/home/eugeneriabinin777/quickjs/cutils.c:
    1|       |/*
    2|       | * C utilities
    3|       | *
    4|       | * Copyright (c) 2017 Fabrice Bellard
    5|       | * Copyright (c) 2018 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |#include <stdlib.h>
   26|       |#include <stdio.h>
   27|       |#include <stdarg.h>
   28|       |#include <string.h>
   29|       |
   30|       |#include "cutils.h"
   31|       |
   32|       |void pstrcpy(char *buf, int buf_size, const char *str)
   33|  1.47k|{
   34|  1.47k|    int c;
   35|  1.47k|    char *q = buf;
   36|       |
   37|  1.47k|    if (buf_size <= 0)
   38|      0|        return;
   39|       |
   40|  53.5k|    for(;;) {
   41|  53.5k|        c = *str++;
   42|  53.5k|        if (c == 0 || q >= buf + buf_size - 1)
   43|  1.47k|            break;
   44|  52.0k|        *q++ = c;
   45|  52.0k|    }
   46|  1.47k|    *q = '\0';
   47|  1.47k|}
   48|       |
   49|       |/* strcat and truncate. */
   50|       |char *pstrcat(char *buf, int buf_size, const char *s)
   51|     52|{
   52|     52|    int len;
   53|     52|    len = strlen(buf);
   54|     52|    if (len < buf_size)
   55|     52|        pstrcpy(buf + len, buf_size - len, s);
   56|     52|    return buf;
   57|     52|}
   58|       |
   59|       |int strstart(const char *str, const char *val, const char **ptr)
   60|  2.29M|{
   61|  2.29M|    const char *p, *q;
   62|  2.29M|    p = str;
   63|  2.29M|    q = val;
   64|  2.44M|    while (*q != '\0') {
   65|  2.43M|        if (*p != *q)
   66|  2.27M|            return 0;
   67|   154k|        p++;
   68|   154k|        q++;
   69|   154k|    }
   70|  18.9k|    if (ptr)
   71|  18.9k|        *ptr = p;
   72|  18.9k|    return 1;
   73|  2.29M|}
   74|       |
   75|       |int has_suffix(const char *str, const char *suffix)
   76|  17.8k|{
   77|  17.8k|    size_t len = strlen(str);
   78|  17.8k|    size_t slen = strlen(suffix);
   79|  17.8k|    return (len >= slen && !memcmp(str + len - slen, suffix, slen));
   80|  17.8k|}
   81|       |
   82|       |/* Dynamic buffer package */
   83|       |
   84|       |static void *dbuf_default_realloc(void *opaque, void *ptr, size_t size)
   85|      0|{
   86|      0|    return realloc(ptr, size);
   87|      0|}
   88|       |
   89|       |void dbuf_init2(DynBuf *s, void *opaque, DynBufReallocFunc *realloc_func)
   90|   842k|{
   91|   842k|    memset(s, 0, sizeof(*s));
   92|   842k|    if (!realloc_func)
   93|      0|        realloc_func = dbuf_default_realloc;
   94|   842k|    s->opaque = opaque;
   95|   842k|    s->realloc_func = realloc_func;
   96|   842k|}
   97|       |
   98|       |void dbuf_init(DynBuf *s)
   99|      0|{
  100|      0|    dbuf_init2(s, NULL, NULL);
  101|      0|}
  102|       |
  103|       |/* return < 0 if error */
  104|       |int dbuf_realloc(DynBuf *s, size_t new_size)
  105|  3.79M|{
  106|  3.79M|    size_t size;
  107|  3.79M|    uint8_t *new_buf;
  108|  3.79M|    if (new_size > s->allocated_size) {
  109|  3.69M|        if (s->error)
  110|      0|            return -1;
  111|  3.69M|        size = s->allocated_size * 3 / 2;
  112|  3.69M|        if (size > new_size)
  113|  1.81M|            new_size = size;
  114|  3.69M|        new_buf = s->realloc_func(s->opaque, s->buf, new_size);
  115|  3.69M|        if (!new_buf) {
  116|      0|            s->error = TRUE;
  117|      0|            return -1;
  118|      0|        }
  119|  3.69M|        s->buf = new_buf;
  120|  3.69M|        s->allocated_size = new_size;
  121|  3.69M|    }
  122|  3.79M|    return 0;
  123|  3.79M|}
  124|       |
  125|       |int dbuf_write(DynBuf *s, size_t offset, const uint8_t *data, size_t len)
  126|      0|{
  127|      0|    size_t end;
  128|      0|    end = offset + len;
  129|      0|    if (dbuf_realloc(s, end))
  130|      0|        return -1;
  131|      0|    memcpy(s->buf + offset, data, len);
  132|      0|    if (end > s->size)
  133|      0|        s->size = end;
  134|      0|    return 0;
  135|      0|}
  136|       |
  137|       |int dbuf_put(DynBuf *s, const uint8_t *data, size_t len)
  138|  42.9M|{
  139|  42.9M|    if (unlikely((s->size + len) > s->allocated_size)) {
  140|  3.68M|        if (dbuf_realloc(s, s->size + len))
  141|      0|            return -1;
  142|  3.68M|    }
  143|  42.9M|    memcpy_no_ub(s->buf + s->size, data, len);
  144|  42.9M|    s->size += len;
  145|  42.9M|    return 0;
  146|  42.9M|}
  147|       |
  148|       |int dbuf_put_self(DynBuf *s, size_t offset, size_t len)
  149|    943|{
  150|    943|    if (unlikely((s->size + len) > s->allocated_size)) {
  151|    210|        if (dbuf_realloc(s, s->size + len))
  152|      0|            return -1;
  153|    210|    }
  154|    943|    memcpy(s->buf + s->size, s->buf + offset, len);
  155|    943|    s->size += len;
  156|    943|    return 0;
  157|    943|}
  158|       |
  159|       |int dbuf_putc(DynBuf *s, uint8_t c)
  160|  13.6M|{
  161|  13.6M|    return dbuf_put(s, &c, 1);
  162|  13.6M|}
  163|       |
  164|       |int dbuf_putstr(DynBuf *s, const char *str)
  165|      0|{
  166|      0|    return dbuf_put(s, (const uint8_t *)str, strlen(str));
  167|      0|}
  168|       |
  169|       |int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
  170|       |                                                      const char *fmt, ...)
  171|   600k|{
  172|   600k|    va_list ap;
  173|   600k|    char buf[128];
  174|   600k|    int len;
  175|       |
  176|   600k|    va_start(ap, fmt);
  177|   600k|    len = vsnprintf(buf, sizeof(buf), fmt, ap);
  178|   600k|    va_end(ap);
  179|   600k|    if (len < 0)
  180|      0|        return -1;
  181|   600k|    if (len < sizeof(buf)) {
  182|       |        /* fast case */
  183|   559k|        return dbuf_put(s, (uint8_t *)buf, len);
  184|   559k|    } else {
  185|  41.3k|        if (dbuf_realloc(s, s->size + len + 1))
  186|      0|            return -1;
  187|  41.3k|        va_start(ap, fmt);
  188|  41.3k|        vsnprintf((char *)(s->buf + s->size), s->allocated_size - s->size,
  189|  41.3k|                  fmt, ap);
  190|  41.3k|        va_end(ap);
  191|  41.3k|        s->size += len;
  192|  41.3k|    }
  193|  41.3k|    return 0;
  194|   600k|}
  195|       |
  196|       |void dbuf_free(DynBuf *s)
  197|   439k|{
  198|       |    /* we test s->buf as a fail safe to avoid crashing if dbuf_free()
  199|       |       is called twice */
  200|   439k|    if (s->buf) {
  201|   368k|        s->realloc_func(s->opaque, s->buf, 0);
  202|   368k|    }
  203|   439k|    memset(s, 0, sizeof(*s));
  204|   439k|}
  205|       |
  206|       |/* Note: at most 31 bits are encoded. At most UTF8_CHAR_LEN_MAX bytes
  207|       |   are output. */
  208|       |int unicode_to_utf8(uint8_t *buf, unsigned int c)
  209|   591k|{
  210|   591k|    uint8_t *q = buf;
  211|       |
  212|   591k|    if (c < 0x80) {
  213|      0|        *q++ = c;
  214|   591k|    } else {
  215|   591k|        if (c < 0x800) {
  216|   522k|            *q++ = (c >> 6) | 0xc0;
  217|   522k|        } else {
  218|  68.7k|            if (c < 0x10000) {
  219|  34.0k|                *q++ = (c >> 12) | 0xe0;
  220|  34.7k|            } else {
  221|  34.7k|                if (c < 0x00200000) {
  222|  34.7k|                    *q++ = (c >> 18) | 0xf0;
  223|  34.7k|                } else {
  224|      0|                    if (c < 0x04000000) {
  225|      0|                        *q++ = (c >> 24) | 0xf8;
  226|      0|                    } else if (c < 0x80000000) {
  227|      0|                        *q++ = (c >> 30) | 0xfc;
  228|      0|                        *q++ = ((c >> 24) & 0x3f) | 0x80;
  229|      0|                    } else {
  230|      0|                        return 0;
  231|      0|                    }
  232|      0|                    *q++ = ((c >> 18) & 0x3f) | 0x80;
  233|      0|                }
  234|  34.7k|                *q++ = ((c >> 12) & 0x3f) | 0x80;
  235|  34.7k|            }
  236|  68.7k|            *q++ = ((c >> 6) & 0x3f) | 0x80;
  237|  68.7k|        }
  238|   591k|        *q++ = (c & 0x3f) | 0x80;
  239|   591k|    }
  240|   591k|    return q - buf;
  241|   591k|}
  242|       |
  243|       |static const unsigned int utf8_min_code[5] = {
  244|       |    0x80, 0x800, 0x10000, 0x00200000, 0x04000000,
  245|       |};
  246|       |
  247|       |static const unsigned char utf8_first_code_mask[5] = {
  248|       |    0x1f, 0xf, 0x7, 0x3, 0x1,
  249|       |};
  250|       |
  251|       |/* return -1 if error. *pp is not updated in this case. max_len must
  252|       |   be >= 1. The maximum length for a UTF8 byte sequence is 6 bytes. */
  253|       |int unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp)
  254|  1.34M|{
  255|  1.34M|    int l, c, b, i;
  256|       |
  257|  1.34M|    c = *p++;
  258|  1.34M|    if (c < 0x80) {
  259|   648k|        *pp = p;
  260|   648k|        return c;
  261|   648k|    }
  262|   700k|    switch(c) {
  263|   127k|    case 0xc0: case 0xc1: case 0xc2: case 0xc3:
  264|   129k|    case 0xc4: case 0xc5: case 0xc6: case 0xc7:
  265|   191k|    case 0xc8: case 0xc9: case 0xca: case 0xcb:
  266|   195k|    case 0xcc: case 0xcd: case 0xce: case 0xcf:
  267|   214k|    case 0xd0: case 0xd1: case 0xd2: case 0xd3:
  268|   216k|    case 0xd4: case 0xd5: case 0xd6: case 0xd7:
  269|   218k|    case 0xd8: case 0xd9: case 0xda: case 0xdb:
  270|   253k|    case 0xdc: case 0xdd: case 0xde: case 0xdf:
  271|   253k|        l = 1;
  272|   253k|        break;
  273|  44.8k|    case 0xe0: case 0xe1: case 0xe2: case 0xe3:
  274|  47.5k|    case 0xe4: case 0xe5: case 0xe6: case 0xe7:
  275|  50.4k|    case 0xe8: case 0xe9: case 0xea: case 0xeb:
  276|  57.2k|    case 0xec: case 0xed: case 0xee: case 0xef:
  277|  57.2k|        l = 2;
  278|  57.2k|        break;
  279|  71.4k|    case 0xf0: case 0xf1: case 0xf2: case 0xf3:
  280|  72.8k|    case 0xf4: case 0xf5: case 0xf6: case 0xf7:
  281|  72.8k|        l = 3;
  282|  72.8k|        break;
  283|  1.19k|    case 0xf8: case 0xf9: case 0xfa: case 0xfb:
  284|  1.19k|        l = 4;
  285|  1.19k|        break;
  286|  4.05k|    case 0xfc: case 0xfd:
  287|  4.05k|        l = 5;
  288|  4.05k|        break;
  289|   310k|    default:
  290|   310k|        return -1;
  291|   700k|    }
  292|       |    /* check that we have enough characters */
  293|   389k|    if (l > (max_len - 1))
  294|      0|        return -1;
  295|   389k|    c &= utf8_first_code_mask[l - 1];
  296|   929k|    for(i = 0; i < l; i++) {
  297|   577k|        b = *p++;
  298|   577k|        if (b < 0x80 || b >= 0xc0)
  299|  36.7k|            return -1;
  300|   540k|        c = (c << 6) | (b & 0x3f);
  301|   540k|    }
  302|   352k|    if (c < utf8_min_code[l - 1])
  303|    300|        return -1;
  304|   352k|    *pp = p;
  305|   352k|    return c;
  306|   352k|}
  307|       |
  308|       |#if 0
  309|       |
  310|       |#if defined(EMSCRIPTEN) || defined(__ANDROID__)
  311|       |
  312|       |static void *rqsort_arg;
  313|       |static int (*rqsort_cmp)(const void *, const void *, void *);
  314|       |
  315|       |static int rqsort_cmp2(const void *p1, const void *p2)
  316|       |{
  317|       |    return rqsort_cmp(p1, p2, rqsort_arg);
  318|       |}
  319|       |
  320|       |/* not reentrant, but not needed with emscripten */
  321|       |void rqsort(void *base, size_t nmemb, size_t size,
  322|       |            int (*cmp)(const void *, const void *, void *),
  323|       |            void *arg)
  324|       |{
  325|       |    rqsort_arg = arg;
  326|       |    rqsort_cmp = cmp;
  327|       |    qsort(base, nmemb, size, rqsort_cmp2);
  328|       |}
  329|       |
  330|       |#endif
  331|       |
  332|       |#else
  333|       |
  334|       |typedef void (*exchange_f)(void *a, void *b, size_t size);
  335|       |typedef int (*cmp_f)(const void *, const void *, void *opaque);
  336|       |
  337|      0|static void exchange_bytes(void *a, void *b, size_t size) {
  338|      0|    uint8_t *ap = (uint8_t *)a;
  339|      0|    uint8_t *bp = (uint8_t *)b;
  340|       |
  341|      0|    while (size-- != 0) {
  342|      0|        uint8_t t = *ap;
  343|      0|        *ap++ = *bp;
  344|      0|        *bp++ = t;
  345|      0|    }
  346|      0|}
  347|       |
  348|      0|static void exchange_one_byte(void *a, void *b, size_t size) {
  349|      0|    uint8_t *ap = (uint8_t *)a;
  350|      0|    uint8_t *bp = (uint8_t *)b;
  351|      0|    uint8_t t = *ap;
  352|      0|    *ap = *bp;
  353|      0|    *bp = t;
  354|      0|}
  355|       |
  356|      0|static void exchange_int16s(void *a, void *b, size_t size) {
  357|      0|    uint16_t *ap = (uint16_t *)a;
  358|      0|    uint16_t *bp = (uint16_t *)b;
  359|       |
  360|      0|    for (size /= sizeof(uint16_t); size-- != 0;) {
  361|      0|        uint16_t t = *ap;
  362|      0|        *ap++ = *bp;
  363|      0|        *bp++ = t;
  364|      0|    }
  365|      0|}
  366|       |
  367|      0|static void exchange_one_int16(void *a, void *b, size_t size) {
  368|      0|    uint16_t *ap = (uint16_t *)a;
  369|      0|    uint16_t *bp = (uint16_t *)b;
  370|      0|    uint16_t t = *ap;
  371|      0|    *ap = *bp;
  372|      0|    *bp = t;
  373|      0|}
  374|       |
  375|      0|static void exchange_int32s(void *a, void *b, size_t size) {
  376|      0|    uint32_t *ap = (uint32_t *)a;
  377|      0|    uint32_t *bp = (uint32_t *)b;
  378|       |
  379|      0|    for (size /= sizeof(uint32_t); size-- != 0;) {
  380|      0|        uint32_t t = *ap;
  381|      0|        *ap++ = *bp;
  382|      0|        *bp++ = t;
  383|      0|    }
  384|      0|}
  385|       |
  386|      0|static void exchange_one_int32(void *a, void *b, size_t size) {
  387|      0|    uint32_t *ap = (uint32_t *)a;
  388|      0|    uint32_t *bp = (uint32_t *)b;
  389|      0|    uint32_t t = *ap;
  390|      0|    *ap = *bp;
  391|      0|    *bp = t;
  392|      0|}
  393|       |
  394|  3.08M|static void exchange_int64s(void *a, void *b, size_t size) {
  395|  3.08M|    uint64_t *ap = (uint64_t *)a;
  396|  3.08M|    uint64_t *bp = (uint64_t *)b;
  397|       |
  398|  4.69M|    for (size /= sizeof(uint64_t); size-- != 0;) {
  399|  1.61M|        uint64_t t = *ap;
  400|  1.61M|        *ap++ = *bp;
  401|  1.61M|        *bp++ = t;
  402|  1.61M|    }
  403|  3.08M|}
  404|       |
  405|  14.0M|static void exchange_one_int64(void *a, void *b, size_t size) {
  406|  14.0M|    uint64_t *ap = (uint64_t *)a;
  407|  14.0M|    uint64_t *bp = (uint64_t *)b;
  408|  14.0M|    uint64_t t = *ap;
  409|  14.0M|    *ap = *bp;
  410|  14.0M|    *bp = t;
  411|  14.0M|}
  412|       |
  413|      0|static void exchange_int128s(void *a, void *b, size_t size) {
  414|      0|    uint64_t *ap = (uint64_t *)a;
  415|      0|    uint64_t *bp = (uint64_t *)b;
  416|       |
  417|      0|    for (size /= sizeof(uint64_t) * 2; size-- != 0; ap += 2, bp += 2) {
  418|      0|        uint64_t t = ap[0];
  419|      0|        uint64_t u = ap[1];
  420|      0|        ap[0] = bp[0];
  421|      0|        ap[1] = bp[1];
  422|      0|        bp[0] = t;
  423|      0|        bp[1] = u;
  424|      0|    }
  425|      0|}
  426|       |
  427|      0|static void exchange_one_int128(void *a, void *b, size_t size) {
  428|      0|    uint64_t *ap = (uint64_t *)a;
  429|      0|    uint64_t *bp = (uint64_t *)b;
  430|      0|    uint64_t t = ap[0];
  431|      0|    uint64_t u = ap[1];
  432|      0|    ap[0] = bp[0];
  433|      0|    ap[1] = bp[1];
  434|      0|    bp[0] = t;
  435|      0|    bp[1] = u;
  436|      0|}
  437|       |
  438|  33.5k|static inline exchange_f exchange_func(const void *base, size_t size) {
  439|  33.5k|    switch (((uintptr_t)base | (uintptr_t)size) & 15) {
  440|      0|    case 0:
  441|      0|        if (size == sizeof(uint64_t) * 2)
  442|      0|            return exchange_one_int128;
  443|      0|        else
  444|      0|            return exchange_int128s;
  445|  33.5k|    case 8:
  446|  33.5k|        if (size == sizeof(uint64_t))
  447|  16.7k|            return exchange_one_int64;
  448|  16.7k|        else
  449|  16.7k|            return exchange_int64s;
  450|      0|    case 4:
  451|      0|    case 12:
  452|      0|        if (size == sizeof(uint32_t))
  453|      0|            return exchange_one_int32;
  454|      0|        else
  455|      0|            return exchange_int32s;
  456|      0|    case 2:
  457|      0|    case 6:
  458|      0|    case 10:
  459|      0|    case 14:
  460|      0|        if (size == sizeof(uint16_t))
  461|      0|            return exchange_one_int16;
  462|      0|        else
  463|      0|            return exchange_int16s;
  464|      0|    default:
  465|      0|        if (size == 1)
  466|      0|            return exchange_one_byte;
  467|      0|        else
  468|      0|            return exchange_bytes;
  469|  33.5k|    }
  470|  33.5k|}
  471|       |
  472|       |static void heapsortx(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)
  473|      0|{
  474|      0|    uint8_t *basep = (uint8_t *)base;
  475|      0|    size_t i, n, c, r;
  476|      0|    exchange_f swap = exchange_func(base, size);
  477|       |
  478|      0|    if (nmemb > 1) {
  479|      0|        i = (nmemb / 2) * size;
  480|      0|        n = nmemb * size;
  481|       |
  482|      0|        while (i > 0) {
  483|      0|            i -= size;
  484|      0|            for (r = i; (c = r * 2 + size) < n; r = c) {
  485|      0|                if (c < n - size && cmp(basep + c, basep + c + size, opaque) <= 0)
  486|      0|                    c += size;
  487|      0|                if (cmp(basep + r, basep + c, opaque) > 0)
  488|      0|                    break;
  489|      0|                swap(basep + r, basep + c, size);
  490|      0|            }
  491|      0|        }
  492|      0|        for (i = n - size; i > 0; i -= size) {
  493|      0|            swap(basep, basep + i, size);
  494|       |
  495|      0|            for (r = 0; (c = r * 2 + size) < i; r = c) {
  496|      0|                if (c < i - size && cmp(basep + c, basep + c + size, opaque) <= 0)
  497|      0|                    c += size;
  498|      0|                if (cmp(basep + r, basep + c, opaque) > 0)
  499|      0|                    break;
  500|      0|                swap(basep + r, basep + c, size);
  501|      0|            }
  502|      0|        }
  503|      0|    }
  504|      0|}
  505|       |
  506|       |static inline void *med3(void *a, void *b, void *c, cmp_f cmp, void *opaque)
  507|  1.54M|{
  508|  1.54M|    return cmp(a, b, opaque) < 0 ?
  509|   920k|        (cmp(b, c, opaque) < 0 ? b : (cmp(a, c, opaque) < 0 ? c : a )) :
  510|  1.54M|        (cmp(b, c, opaque) > 0 ? b : (cmp(a, c, opaque) < 0 ? a : c ));
  511|  1.54M|}
  512|       |
  513|       |/* pointer based version with local stack and insertion sort threshhold */
  514|       |void rqsort(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)
  515|  16.7k|{
  516|  16.7k|    struct { uint8_t *base; size_t count; int depth; } stack[50], *sp = stack;
  517|  16.7k|    uint8_t *ptr, *pi, *pj, *plt, *pgt, *top, *m;
  518|  16.7k|    size_t m4, i, lt, gt, span, span2;
  519|  16.7k|    int c, depth;
  520|  16.7k|    exchange_f swap = exchange_func(base, size);
  521|  16.7k|    exchange_f swap_block = exchange_func(base, size | 128);
  522|       |
  523|  16.7k|    if (nmemb < 2 || size <= 0)
  524|  5.41k|        return;
  525|       |
  526|  11.3k|    sp->base = (uint8_t *)base;
  527|  11.3k|    sp->count = nmemb;
  528|  11.3k|    sp->depth = 0;
  529|  11.3k|    sp++;
  530|       |
  531|  1.56M|    while (sp > stack) {
  532|  1.55M|        sp--;
  533|  1.55M|        ptr = sp->base;
  534|  1.55M|        nmemb = sp->count;
  535|  1.55M|        depth = sp->depth;
  536|       |
  537|  3.09M|        while (nmemb > 6) {
  538|  1.54M|            if (++depth > 50) {
  539|       |                /* depth check to ensure worst case logarithmic time */
  540|      0|                heapsortx(ptr, nmemb, size, cmp, opaque);
  541|      0|                nmemb = 0;
  542|      0|                break;
  543|      0|            }
  544|       |            /* select median of 3 from 1/4, 1/2, 3/4 positions */
  545|       |            /* should use median of 5 or 9? */
  546|  1.54M|            m4 = (nmemb >> 2) * size;
  547|  1.54M|            m = med3(ptr + m4, ptr + 2 * m4, ptr + 3 * m4, cmp, opaque);
  548|  1.54M|            swap(ptr, m, size);  /* move the pivot to the start or the array */
  549|  1.54M|            i = lt = 1;
  550|  1.54M|            pi = plt = ptr + size;
  551|  1.54M|            gt = nmemb;
  552|  1.54M|            pj = pgt = top = ptr + nmemb * size;
  553|  9.58M|            for (;;) {
  554|  29.0M|                while (pi < pj && (c = cmp(ptr, pi, opaque)) >= 0) {
  555|  19.4M|                    if (c == 0) {
  556|  37.9k|                        swap(plt, pi, size);
  557|  37.9k|                        lt++;
  558|  37.9k|                        plt += size;
  559|  37.9k|                    }
  560|  19.4M|                    i++;
  561|  19.4M|                    pi += size;
  562|  19.4M|                }
  563|  27.8M|                while (pi < (pj -= size) && (c = cmp(ptr, pj, opaque)) <= 0) {
  564|  18.2M|                    if (c == 0) {
  565|  33.2k|                        gt--;
  566|  33.2k|                        pgt -= size;
  567|  33.2k|                        swap(pgt, pj, size);
  568|  33.2k|                    }
  569|  18.2M|                }
  570|  9.58M|                if (pi >= pj)
  571|  1.54M|                    break;
  572|  8.04M|                swap(pi, pj, size);
  573|  8.04M|                i++;
  574|  8.04M|                pi += size;
  575|  8.04M|            }
  576|       |            /* array has 4 parts:
  577|       |             * from 0 to lt excluded: elements identical to pivot
  578|       |             * from lt to pi excluded: elements smaller than pivot
  579|       |             * from pi to gt excluded: elements greater than pivot
  580|       |             * from gt to n excluded: elements identical to pivot
  581|       |             */
  582|       |            /* move elements identical to pivot in the middle of the array: */
  583|       |            /* swap values in ranges [0..lt[ and [i-lt..i[
  584|       |               swapping the smallest span between lt and i-lt is sufficient
  585|       |             */
  586|  1.54M|            span = plt - ptr;
  587|  1.54M|            span2 = pi - plt;
  588|  1.54M|            lt = i - lt;
  589|  1.54M|            if (span > span2)
  590|  2.46k|                span = span2;
  591|  1.54M|            swap_block(ptr, pi - span, span);
  592|       |            /* swap values in ranges [gt..top[ and [i..top-(top-gt)[
  593|       |               swapping the smallest span between top-gt and gt-i is sufficient
  594|       |             */
  595|  1.54M|            span = top - pgt;
  596|  1.54M|            span2 = pgt - pi;
  597|  1.54M|            pgt = top - span2;
  598|  1.54M|            gt = nmemb - (gt - i);
  599|  1.54M|            if (span > span2)
  600|      0|                span = span2;
  601|  1.54M|            swap_block(pi, top - span, span);
  602|       |
  603|       |            /* now array has 3 parts:
  604|       |             * from 0 to lt excluded: elements smaller than pivot
  605|       |             * from lt to gt excluded: elements identical to pivot
  606|       |             * from gt to n excluded: elements greater than pivot
  607|       |             */
  608|       |            /* stack the larger segment and keep processing the smaller one
  609|       |               to minimize stack use for pathological distributions */
  610|  1.54M|            if (lt > nmemb - gt) {
  611|   692k|                sp->base = ptr;
  612|   692k|                sp->count = lt;
  613|   692k|                sp->depth = depth;
  614|   692k|                sp++;
  615|   692k|                ptr = pgt;
  616|   692k|                nmemb -= gt;
  617|   850k|            } else {
  618|   850k|                sp->base = pgt;
  619|   850k|                sp->count = nmemb - gt;
  620|   850k|                sp->depth = depth;
  621|   850k|                sp++;
  622|   850k|                nmemb = lt;
  623|   850k|            }
  624|  1.54M|        }
  625|       |        /* Use insertion sort for small fragments */
  626|  6.02M|        for (pi = ptr + size, top = ptr + nmemb * size; pi < top; pi += size) {
  627|  8.87M|            for (pj = pi; pj > ptr && cmp(pj - size, pj, opaque) > 0; pj -= size)
  628|  4.39M|                swap(pj, pj - size, size);
  629|  4.47M|        }
  630|  1.55M|    }
  631|  11.3k|}
  632|       |
  633|       |#endif

/home/eugeneriabinin777/quickjs/cutils.h:
    1|       |/*
    2|       | * C utilities
    3|       | *
    4|       | * Copyright (c) 2017 Fabrice Bellard
    5|       | * Copyright (c) 2018 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |#ifndef CUTILS_H
   26|       |#define CUTILS_H
   27|       |
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |#include <inttypes.h>
   31|       |
   32|   134M|#define likely(x)       __builtin_expect(!!(x), 1)
   33|   632M|#define unlikely(x)     __builtin_expect(!!(x), 0)
   34|       |#define force_inline inline __attribute__((always_inline))
   35|       |#define no_inline __attribute__((noinline))
   36|       |#define __maybe_unused __attribute__((unused))
   37|       |
   38|       |#define xglue(x, y) x ## y
   39|       |#define glue(x, y) xglue(x, y)
   40|       |#define stringify(s)    tostring(s)
   41|       |#define tostring(s)     #s
   42|       |
   43|       |#ifndef offsetof
   44|       |#define offsetof(type, field) ((size_t) &((type *)0)->field)
   45|       |#endif
   46|       |#ifndef countof
   47|  8.87M|#define countof(x) (sizeof(x) / sizeof((x)[0]))
   48|       |#endif
   49|       |#ifndef container_of
   50|       |/* return the pointer of type 'type *' containing 'ptr' as field 'member' */
   51|  31.6M|#define container_of(ptr, type, member) ((type *)((uint8_t *)(ptr) - offsetof(type, member)))
   52|       |#endif
   53|       |
   54|       |#if !defined(_MSC_VER) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
   55|       |#define minimum_length(n)  static n
   56|       |#else
   57|       |#define minimum_length(n)  n
   58|       |#endif
   59|       |
   60|       |typedef int BOOL;
   61|       |
   62|       |#ifndef FALSE
   63|       |enum {
   64|       |    FALSE = 0,
   65|       |    TRUE = 1,
   66|       |};
   67|       |#endif
   68|       |
   69|       |void pstrcpy(char *buf, int buf_size, const char *str);
   70|       |char *pstrcat(char *buf, int buf_size, const char *s);
   71|       |int strstart(const char *str, const char *val, const char **ptr);
   72|       |int has_suffix(const char *str, const char *suffix);
   73|       |
   74|       |/* Prevent UB when n == 0 and (src == NULL or dest == NULL) */
   75|  43.2M|static inline void memcpy_no_ub(void *dest, const void *src, size_t n) {
   76|  43.2M|    if (n)
   77|  43.0M|        memcpy(dest, src, n);
   78|  43.2M|}
  ------------------
  | Unexecuted instantiation: qjs.c:memcpy_no_ub
  ------------------
  | quickjs.c:memcpy_no_ub:
  |   75|   242k|static inline void memcpy_no_ub(void *dest, const void *src, size_t n) {
  |   76|   242k|    if (n)
  |   77|   121k|        memcpy(dest, src, n);
  |   78|   242k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:memcpy_no_ub
  ------------------
  | Unexecuted instantiation: libregexp.c:memcpy_no_ub
  ------------------
  | Unexecuted instantiation: libunicode.c:memcpy_no_ub
  ------------------
  | cutils.c:memcpy_no_ub:
  |   75|  42.9M|static inline void memcpy_no_ub(void *dest, const void *src, size_t n) {
  |   76|  42.9M|    if (n)
  |   77|  42.9M|        memcpy(dest, src, n);
  |   78|  42.9M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:memcpy_no_ub
  ------------------
   79|       |
   80|       |static inline int max_int(int a, int b)
   81|  21.1M|{
   82|  21.1M|    if (a > b)
   83|  5.09M|        return a;
   84|  16.0M|    else
   85|  16.0M|        return b;
   86|  21.1M|}
  ------------------
  | Unexecuted instantiation: qjs.c:max_int
  ------------------
  | quickjs.c:max_int:
  |   81|  15.7M|{
  |   82|  15.7M|    if (a > b)
  |   83|  3.53M|        return a;
  |   84|  12.2M|    else
  |   85|  12.2M|        return b;
  |   86|  15.7M|}
  ------------------
  | dtoa.c:max_int:
  |   81|   443k|{
  |   82|   443k|    if (a > b)
  |   83|   366k|        return a;
  |   84|  77.7k|    else
  |   85|  77.7k|        return b;
  |   86|   443k|}
  ------------------
  | Unexecuted instantiation: libregexp.c:max_int
  ------------------
  | libunicode.c:max_int:
  |   81|  4.93M|{
  |   82|  4.93M|    if (a > b)
  |   83|  1.19M|        return a;
  |   84|  3.73M|    else
  |   85|  3.73M|        return b;
  |   86|  4.93M|}
  ------------------
  | Unexecuted instantiation: cutils.c:max_int
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:max_int
  ------------------
   87|       |
   88|       |static inline int min_int(int a, int b)
   89|  10.0M|{
   90|  10.0M|    if (a < b)
   91|  6.05M|        return a;
   92|  3.94M|    else
   93|  3.94M|        return b;
   94|  10.0M|}
  ------------------
  | Unexecuted instantiation: qjs.c:min_int
  ------------------
  | quickjs.c:min_int:
  |   89|  4.65M|{
  |   90|  4.65M|    if (a < b)
  |   91|  4.44M|        return a;
  |   92|   217k|    else
  |   93|   217k|        return b;
  |   94|  4.65M|}
  ------------------
  | dtoa.c:min_int:
  |   89|  5.34M|{
  |   90|  5.34M|    if (a < b)
  |   91|  1.61M|        return a;
  |   92|  3.72M|    else
  |   93|  3.72M|        return b;
  |   94|  5.34M|}
  ------------------
  | Unexecuted instantiation: libregexp.c:min_int
  ------------------
  | Unexecuted instantiation: libunicode.c:min_int
  ------------------
  | Unexecuted instantiation: cutils.c:min_int
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:min_int
  ------------------
   95|       |
   96|       |static inline uint32_t max_uint32(uint32_t a, uint32_t b)
   97|      0|{
   98|      0|    if (a > b)
   99|      0|        return a;
  100|      0|    else
  101|      0|        return b;
  102|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:max_uint32
  ------------------
  | Unexecuted instantiation: quickjs.c:max_uint32
  ------------------
  | Unexecuted instantiation: dtoa.c:max_uint32
  ------------------
  | Unexecuted instantiation: libregexp.c:max_uint32
  ------------------
  | Unexecuted instantiation: libunicode.c:max_uint32
  ------------------
  | Unexecuted instantiation: cutils.c:max_uint32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:max_uint32
  ------------------
  103|       |
  104|       |static inline uint32_t min_uint32(uint32_t a, uint32_t b)
  105|   300k|{
  106|   300k|    if (a < b)
  107|   117k|        return a;
  108|   183k|    else
  109|   183k|        return b;
  110|   300k|}
  ------------------
  | Unexecuted instantiation: qjs.c:min_uint32
  ------------------
  | quickjs.c:min_uint32:
  |  105|   300k|{
  |  106|   300k|    if (a < b)
  |  107|   117k|        return a;
  |  108|   183k|    else
  |  109|   183k|        return b;
  |  110|   300k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:min_uint32
  ------------------
  | Unexecuted instantiation: libregexp.c:min_uint32
  ------------------
  | Unexecuted instantiation: libunicode.c:min_uint32
  ------------------
  | Unexecuted instantiation: cutils.c:min_uint32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:min_uint32
  ------------------
  111|       |
  112|       |static inline int64_t max_int64(int64_t a, int64_t b)
  113|      0|{
  114|      0|    if (a > b)
  115|      0|        return a;
  116|      0|    else
  117|      0|        return b;
  118|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:max_int64
  ------------------
  | Unexecuted instantiation: quickjs.c:max_int64
  ------------------
  | Unexecuted instantiation: dtoa.c:max_int64
  ------------------
  | Unexecuted instantiation: libregexp.c:max_int64
  ------------------
  | Unexecuted instantiation: libunicode.c:max_int64
  ------------------
  | Unexecuted instantiation: cutils.c:max_int64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:max_int64
  ------------------
  119|       |
  120|       |static inline int64_t min_int64(int64_t a, int64_t b)
  121|      0|{
  122|      0|    if (a < b)
  123|      0|        return a;
  124|      0|    else
  125|      0|        return b;
  126|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:min_int64
  ------------------
  | Unexecuted instantiation: quickjs.c:min_int64
  ------------------
  | Unexecuted instantiation: dtoa.c:min_int64
  ------------------
  | Unexecuted instantiation: libregexp.c:min_int64
  ------------------
  | Unexecuted instantiation: libunicode.c:min_int64
  ------------------
  | Unexecuted instantiation: cutils.c:min_int64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:min_int64
  ------------------
  127|       |
  128|       |/* WARNING: undefined if a = 0 */
  129|       |static inline int clz32(unsigned int a)
  130|  1.68M|{
  131|  1.68M|    return __builtin_clz(a);
  132|  1.68M|}
  ------------------
  | Unexecuted instantiation: qjs.c:clz32
  ------------------
  | quickjs.c:clz32:
  |  130|   275k|{
  |  131|   275k|    return __builtin_clz(a);
  |  132|   275k|}
  ------------------
  | dtoa.c:clz32:
  |  130|  1.41M|{
  |  131|  1.41M|    return __builtin_clz(a);
  |  132|  1.41M|}
  ------------------
  | Unexecuted instantiation: libregexp.c:clz32
  ------------------
  | Unexecuted instantiation: libunicode.c:clz32
  ------------------
  | Unexecuted instantiation: cutils.c:clz32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:clz32
  ------------------
  133|       |
  134|       |/* WARNING: undefined if a = 0 */
  135|       |static inline int clz64(uint64_t a)
  136|  1.02M|{
  137|  1.02M|    return __builtin_clzll(a);
  138|  1.02M|}
  ------------------
  | Unexecuted instantiation: qjs.c:clz64
  ------------------
  | quickjs.c:clz64:
  |  136|  1.01M|{
  |  137|  1.01M|    return __builtin_clzll(a);
  |  138|  1.01M|}
  ------------------
  | dtoa.c:clz64:
  |  136|  8.16k|{
  |  137|  8.16k|    return __builtin_clzll(a);
  |  138|  8.16k|}
  ------------------
  | Unexecuted instantiation: libregexp.c:clz64
  ------------------
  | Unexecuted instantiation: libunicode.c:clz64
  ------------------
  | Unexecuted instantiation: cutils.c:clz64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:clz64
  ------------------
  139|       |
  140|       |/* WARNING: undefined if a = 0 */
  141|       |static inline int ctz32(unsigned int a)
  142|  1.06M|{
  143|  1.06M|    return __builtin_ctz(a);
  144|  1.06M|}
  ------------------
  | Unexecuted instantiation: qjs.c:ctz32
  ------------------
  | Unexecuted instantiation: quickjs.c:ctz32
  ------------------
  | dtoa.c:ctz32:
  |  142|  1.06M|{
  |  143|  1.06M|    return __builtin_ctz(a);
  |  144|  1.06M|}
  ------------------
  | Unexecuted instantiation: libregexp.c:ctz32
  ------------------
  | Unexecuted instantiation: libunicode.c:ctz32
  ------------------
  | Unexecuted instantiation: cutils.c:ctz32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:ctz32
  ------------------
  145|       |
  146|       |/* WARNING: undefined if a = 0 */
  147|       |static inline int ctz64(uint64_t a)
  148|      0|{
  149|      0|    return __builtin_ctzll(a);
  150|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:ctz64
  ------------------
  | Unexecuted instantiation: quickjs.c:ctz64
  ------------------
  | Unexecuted instantiation: dtoa.c:ctz64
  ------------------
  | Unexecuted instantiation: libregexp.c:ctz64
  ------------------
  | Unexecuted instantiation: libunicode.c:ctz64
  ------------------
  | Unexecuted instantiation: cutils.c:ctz64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:ctz64
  ------------------
  151|       |
  152|       |struct __attribute__((packed)) packed_u64 {
  153|       |    uint64_t v;
  154|       |};
  155|       |
  156|       |struct __attribute__((packed)) packed_u32 {
  157|       |    uint32_t v;
  158|       |};
  159|       |
  160|       |struct __attribute__((packed)) packed_u16 {
  161|       |    uint16_t v;
  162|       |};
  163|       |
  164|       |static inline uint64_t get_u64(const uint8_t *tab)
  165|      0|{
  166|      0|    return ((const struct packed_u64 *)tab)->v;
  167|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_u64
  ------------------
  | Unexecuted instantiation: quickjs.c:get_u64
  ------------------
  | Unexecuted instantiation: dtoa.c:get_u64
  ------------------
  | Unexecuted instantiation: libregexp.c:get_u64
  ------------------
  | Unexecuted instantiation: libunicode.c:get_u64
  ------------------
  | Unexecuted instantiation: cutils.c:get_u64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_u64
  ------------------
  168|       |
  169|       |static inline int64_t get_i64(const uint8_t *tab)
  170|      0|{
  171|      0|    return (int64_t)((const struct packed_u64 *)tab)->v;
  172|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_i64
  ------------------
  | Unexecuted instantiation: quickjs.c:get_i64
  ------------------
  | Unexecuted instantiation: dtoa.c:get_i64
  ------------------
  | Unexecuted instantiation: libregexp.c:get_i64
  ------------------
  | Unexecuted instantiation: libunicode.c:get_i64
  ------------------
  | Unexecuted instantiation: cutils.c:get_i64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_i64
  ------------------
  173|       |
  174|       |static inline void put_u64(uint8_t *tab, uint64_t val)
  175|      0|{
  176|      0|    ((struct packed_u64 *)tab)->v = val;
  177|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:put_u64
  ------------------
  | Unexecuted instantiation: quickjs.c:put_u64
  ------------------
  | Unexecuted instantiation: dtoa.c:put_u64
  ------------------
  | Unexecuted instantiation: libregexp.c:put_u64
  ------------------
  | Unexecuted instantiation: libunicode.c:put_u64
  ------------------
  | Unexecuted instantiation: cutils.c:put_u64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:put_u64
  ------------------
  178|       |
  179|       |static inline uint32_t get_u32(const uint8_t *tab)
  180|  21.1M|{
  181|  21.1M|    return ((const struct packed_u32 *)tab)->v;
  182|  21.1M|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_u32
  ------------------
  | quickjs.c:get_u32:
  |  180|  21.1M|{
  |  181|  21.1M|    return ((const struct packed_u32 *)tab)->v;
  |  182|  21.1M|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_u32
  ------------------
  | Unexecuted instantiation: libregexp.c:get_u32
  ------------------
  | Unexecuted instantiation: libunicode.c:get_u32
  ------------------
  | Unexecuted instantiation: cutils.c:get_u32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_u32
  ------------------
  183|       |
  184|       |static inline int32_t get_i32(const uint8_t *tab)
  185|   192k|{
  186|   192k|    return (int32_t)((const struct packed_u32 *)tab)->v;
  187|   192k|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_i32
  ------------------
  | quickjs.c:get_i32:
  |  185|   192k|{
  |  186|   192k|    return (int32_t)((const struct packed_u32 *)tab)->v;
  |  187|   192k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_i32
  ------------------
  | Unexecuted instantiation: libregexp.c:get_i32
  ------------------
  | Unexecuted instantiation: libunicode.c:get_i32
  ------------------
  | Unexecuted instantiation: cutils.c:get_i32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_i32
  ------------------
  188|       |
  189|       |static inline void put_u32(uint8_t *tab, uint32_t val)
  190|   272k|{
  191|   272k|    ((struct packed_u32 *)tab)->v = val;
  192|   272k|}
  ------------------
  | Unexecuted instantiation: qjs.c:put_u32
  ------------------
  | quickjs.c:put_u32:
  |  190|   205k|{
  |  191|   205k|    ((struct packed_u32 *)tab)->v = val;
  |  192|   205k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:put_u32
  ------------------
  | libregexp.c:put_u32:
  |  190|  66.6k|{
  |  191|  66.6k|    ((struct packed_u32 *)tab)->v = val;
  |  192|  66.6k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:put_u32
  ------------------
  | Unexecuted instantiation: cutils.c:put_u32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:put_u32
  ------------------
  193|       |
  194|       |static inline uint32_t get_u16(const uint8_t *tab)
  195|  2.33M|{
  196|  2.33M|    return ((const struct packed_u16 *)tab)->v;
  197|  2.33M|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_u16
  ------------------
  | quickjs.c:get_u16:
  |  195|  2.32M|{
  |  196|  2.32M|    return ((const struct packed_u16 *)tab)->v;
  |  197|  2.32M|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_u16
  ------------------
  | libregexp.c:get_u16:
  |  195|  7.32k|{
  |  196|  7.32k|    return ((const struct packed_u16 *)tab)->v;
  |  197|  7.32k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:get_u16
  ------------------
  | Unexecuted instantiation: cutils.c:get_u16
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_u16
  ------------------
  198|       |
  199|       |static inline int32_t get_i16(const uint8_t *tab)
  200|  3.30M|{
  201|  3.30M|    return (int16_t)((const struct packed_u16 *)tab)->v;
  202|  3.30M|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_i16
  ------------------
  | quickjs.c:get_i16:
  |  200|  3.30M|{
  |  201|  3.30M|    return (int16_t)((const struct packed_u16 *)tab)->v;
  |  202|  3.30M|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_i16
  ------------------
  | Unexecuted instantiation: libregexp.c:get_i16
  ------------------
  | Unexecuted instantiation: libunicode.c:get_i16
  ------------------
  | Unexecuted instantiation: cutils.c:get_i16
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_i16
  ------------------
  203|       |
  204|       |static inline void put_u16(uint8_t *tab, uint16_t val)
  205|   134k|{
  206|   134k|    ((struct packed_u16 *)tab)->v = val;
  207|   134k|}
  ------------------
  | Unexecuted instantiation: qjs.c:put_u16
  ------------------
  | quickjs.c:put_u16:
  |  205|   134k|{
  |  206|   134k|    ((struct packed_u16 *)tab)->v = val;
  |  207|   134k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:put_u16
  ------------------
  | Unexecuted instantiation: libregexp.c:put_u16
  ------------------
  | Unexecuted instantiation: libunicode.c:put_u16
  ------------------
  | Unexecuted instantiation: cutils.c:put_u16
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:put_u16
  ------------------
  208|       |
  209|       |static inline uint32_t get_u8(const uint8_t *tab)
  210|      0|{
  211|      0|    return *tab;
  212|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_u8
  ------------------
  | Unexecuted instantiation: quickjs.c:get_u8
  ------------------
  | Unexecuted instantiation: dtoa.c:get_u8
  ------------------
  | Unexecuted instantiation: libregexp.c:get_u8
  ------------------
  | Unexecuted instantiation: libunicode.c:get_u8
  ------------------
  | Unexecuted instantiation: cutils.c:get_u8
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_u8
  ------------------
  213|       |
  214|       |static inline int32_t get_i8(const uint8_t *tab)
  215|  2.70M|{
  216|  2.70M|    return (int8_t)*tab;
  217|  2.70M|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_i8
  ------------------
  | quickjs.c:get_i8:
  |  215|  2.70M|{
  |  216|  2.70M|    return (int8_t)*tab;
  |  217|  2.70M|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_i8
  ------------------
  | Unexecuted instantiation: libregexp.c:get_i8
  ------------------
  | Unexecuted instantiation: libunicode.c:get_i8
  ------------------
  | Unexecuted instantiation: cutils.c:get_i8
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_i8
  ------------------
  218|       |
  219|       |static inline void put_u8(uint8_t *tab, uint8_t val)
  220|  72.3k|{
  221|  72.3k|    *tab = val;
  222|  72.3k|}
  ------------------
  | Unexecuted instantiation: qjs.c:put_u8
  ------------------
  | quickjs.c:put_u8:
  |  220|  72.3k|{
  |  221|  72.3k|    *tab = val;
  |  222|  72.3k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:put_u8
  ------------------
  | Unexecuted instantiation: libregexp.c:put_u8
  ------------------
  | Unexecuted instantiation: libunicode.c:put_u8
  ------------------
  | Unexecuted instantiation: cutils.c:put_u8
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:put_u8
  ------------------
  223|       |
  224|       |#ifndef bswap16
  225|       |static inline uint16_t bswap16(uint16_t x)
  226|      0|{
  227|      0|    return (x >> 8) | (x << 8);
  228|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:bswap16
  ------------------
  | Unexecuted instantiation: quickjs.c:bswap16
  ------------------
  | Unexecuted instantiation: dtoa.c:bswap16
  ------------------
  | Unexecuted instantiation: libregexp.c:bswap16
  ------------------
  | Unexecuted instantiation: libunicode.c:bswap16
  ------------------
  | Unexecuted instantiation: cutils.c:bswap16
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:bswap16
  ------------------
  229|       |#endif
  230|       |
  231|       |#ifndef bswap32
  232|       |static inline uint32_t bswap32(uint32_t v)
  233|      0|{
  234|      0|    return ((v & 0xff000000) >> 24) | ((v & 0x00ff0000) >>  8) |
  235|      0|        ((v & 0x0000ff00) <<  8) | ((v & 0x000000ff) << 24);
  236|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:bswap32
  ------------------
  | Unexecuted instantiation: quickjs.c:bswap32
  ------------------
  | Unexecuted instantiation: dtoa.c:bswap32
  ------------------
  | Unexecuted instantiation: libregexp.c:bswap32
  ------------------
  | Unexecuted instantiation: libunicode.c:bswap32
  ------------------
  | Unexecuted instantiation: cutils.c:bswap32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:bswap32
  ------------------
  237|       |#endif
  238|       |
  239|       |#ifndef bswap64
  240|       |static inline uint64_t bswap64(uint64_t v)
  241|      0|{
  242|      0|    return ((v & ((uint64_t)0xff << (7 * 8))) >> (7 * 8)) |
  243|      0|        ((v & ((uint64_t)0xff << (6 * 8))) >> (5 * 8)) |
  244|      0|        ((v & ((uint64_t)0xff << (5 * 8))) >> (3 * 8)) |
  245|      0|        ((v & ((uint64_t)0xff << (4 * 8))) >> (1 * 8)) |
  246|      0|        ((v & ((uint64_t)0xff << (3 * 8))) << (1 * 8)) |
  247|      0|        ((v & ((uint64_t)0xff << (2 * 8))) << (3 * 8)) |
  248|      0|        ((v & ((uint64_t)0xff << (1 * 8))) << (5 * 8)) |
  249|      0|        ((v & ((uint64_t)0xff << (0 * 8))) << (7 * 8));
  250|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:bswap64
  ------------------
  | Unexecuted instantiation: quickjs.c:bswap64
  ------------------
  | Unexecuted instantiation: dtoa.c:bswap64
  ------------------
  | Unexecuted instantiation: libregexp.c:bswap64
  ------------------
  | Unexecuted instantiation: libunicode.c:bswap64
  ------------------
  | Unexecuted instantiation: cutils.c:bswap64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:bswap64
  ------------------
  251|       |#endif
  252|       |
  253|       |/* XXX: should take an extra argument to pass slack information to the caller */
  254|       |typedef void *DynBufReallocFunc(void *opaque, void *ptr, size_t size);
  255|       |
  256|       |typedef struct DynBuf {
  257|       |    uint8_t *buf;
  258|       |    size_t size;
  259|       |    size_t allocated_size;
  260|       |    BOOL error; /* true if a memory allocation error occurred */
  261|       |    DynBufReallocFunc *realloc_func;
  262|       |    void *opaque; /* for realloc_func */
  263|       |} DynBuf;
  264|       |
  265|       |void dbuf_init(DynBuf *s);
  266|       |void dbuf_init2(DynBuf *s, void *opaque, DynBufReallocFunc *realloc_func);
  267|       |int dbuf_realloc(DynBuf *s, size_t new_size);
  268|       |int dbuf_write(DynBuf *s, size_t offset, const uint8_t *data, size_t len);
  269|       |int dbuf_put(DynBuf *s, const uint8_t *data, size_t len);
  270|       |int dbuf_put_self(DynBuf *s, size_t offset, size_t len);
  271|       |int dbuf_putc(DynBuf *s, uint8_t c);
  272|       |int dbuf_putstr(DynBuf *s, const char *str);
  273|       |static inline int dbuf_put_u16(DynBuf *s, uint16_t val)
  274|  3.15M|{
  275|  3.15M|    return dbuf_put(s, (uint8_t *)&val, 2);
  276|  3.15M|}
  ------------------
  | Unexecuted instantiation: qjs.c:dbuf_put_u16
  ------------------
  | quickjs.c:dbuf_put_u16:
  |  274|  2.18M|{
  |  275|  2.18M|    return dbuf_put(s, (uint8_t *)&val, 2);
  |  276|  2.18M|}
  ------------------
  | Unexecuted instantiation: dtoa.c:dbuf_put_u16
  ------------------
  | libregexp.c:dbuf_put_u16:
  |  274|   973k|{
  |  275|   973k|    return dbuf_put(s, (uint8_t *)&val, 2);
  |  276|   973k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:dbuf_put_u16
  ------------------
  | Unexecuted instantiation: cutils.c:dbuf_put_u16
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:dbuf_put_u16
  ------------------
  277|       |static inline int dbuf_put_u32(DynBuf *s, uint32_t val)
  278|  18.7M|{
  279|  18.7M|    return dbuf_put(s, (uint8_t *)&val, 4);
  280|  18.7M|}
  ------------------
  | Unexecuted instantiation: qjs.c:dbuf_put_u32
  ------------------
  | quickjs.c:dbuf_put_u32:
  |  278|  5.14M|{
  |  279|  5.14M|    return dbuf_put(s, (uint8_t *)&val, 4);
  |  280|  5.14M|}
  ------------------
  | Unexecuted instantiation: dtoa.c:dbuf_put_u32
  ------------------
  | libregexp.c:dbuf_put_u32:
  |  278|  13.6M|{
  |  279|  13.6M|    return dbuf_put(s, (uint8_t *)&val, 4);
  |  280|  13.6M|}
  ------------------
  | Unexecuted instantiation: libunicode.c:dbuf_put_u32
  ------------------
  | Unexecuted instantiation: cutils.c:dbuf_put_u32
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:dbuf_put_u32
  ------------------
  281|       |static inline int dbuf_put_u64(DynBuf *s, uint64_t val)
  282|      0|{
  283|      0|    return dbuf_put(s, (uint8_t *)&val, 8);
  284|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:dbuf_put_u64
  ------------------
  | Unexecuted instantiation: quickjs.c:dbuf_put_u64
  ------------------
  | Unexecuted instantiation: dtoa.c:dbuf_put_u64
  ------------------
  | Unexecuted instantiation: libregexp.c:dbuf_put_u64
  ------------------
  | Unexecuted instantiation: libunicode.c:dbuf_put_u64
  ------------------
  | Unexecuted instantiation: cutils.c:dbuf_put_u64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:dbuf_put_u64
  ------------------
  285|       |int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
  286|       |                                                      const char *fmt, ...);
  287|       |void dbuf_free(DynBuf *s);
  288|   395k|static inline BOOL dbuf_error(DynBuf *s) {
  289|   395k|    return s->error;
  290|   395k|}
  ------------------
  | Unexecuted instantiation: qjs.c:dbuf_error
  ------------------
  | quickjs.c:dbuf_error:
  |  288|   333k|static inline BOOL dbuf_error(DynBuf *s) {
  |  289|   333k|    return s->error;
  |  290|   333k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:dbuf_error
  ------------------
  | libregexp.c:dbuf_error:
  |  288|  62.0k|static inline BOOL dbuf_error(DynBuf *s) {
  |  289|  62.0k|    return s->error;
  |  290|  62.0k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:dbuf_error
  ------------------
  | Unexecuted instantiation: cutils.c:dbuf_error
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:dbuf_error
  ------------------
  291|       |static inline void dbuf_set_error(DynBuf *s)
  292|      0|{
  293|      0|    s->error = TRUE;
  294|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:dbuf_set_error
  ------------------
  | Unexecuted instantiation: quickjs.c:dbuf_set_error
  ------------------
  | Unexecuted instantiation: dtoa.c:dbuf_set_error
  ------------------
  | Unexecuted instantiation: libregexp.c:dbuf_set_error
  ------------------
  | Unexecuted instantiation: libunicode.c:dbuf_set_error
  ------------------
  | Unexecuted instantiation: cutils.c:dbuf_set_error
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:dbuf_set_error
  ------------------
  295|       |
  296|  1.31M|#define UTF8_CHAR_LEN_MAX 6
  297|       |
  298|       |int unicode_to_utf8(uint8_t *buf, unsigned int c);
  299|       |int unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp);
  300|       |
  301|       |static inline BOOL is_surrogate(uint32_t c)
  302|      0|{
  303|      0|    return (c >> 11) == (0xD800 >> 11); // 0xD800-0xDFFF
  304|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:is_surrogate
  ------------------
  | Unexecuted instantiation: quickjs.c:is_surrogate
  ------------------
  | Unexecuted instantiation: dtoa.c:is_surrogate
  ------------------
  | Unexecuted instantiation: libregexp.c:is_surrogate
  ------------------
  | Unexecuted instantiation: libunicode.c:is_surrogate
  ------------------
  | Unexecuted instantiation: cutils.c:is_surrogate
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:is_surrogate
  ------------------
  305|       |
  306|       |static inline BOOL is_hi_surrogate(uint32_t c)
  307|   573k|{
  308|   573k|    return (c >> 10) == (0xD800 >> 10); // 0xD800-0xDBFF
  309|   573k|}
  ------------------
  | Unexecuted instantiation: qjs.c:is_hi_surrogate
  ------------------
  | quickjs.c:is_hi_surrogate:
  |  307|   570k|{
  |  308|   570k|    return (c >> 10) == (0xD800 >> 10); // 0xD800-0xDBFF
  |  309|   570k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:is_hi_surrogate
  ------------------
  | libregexp.c:is_hi_surrogate:
  |  307|  2.57k|{
  |  308|  2.57k|    return (c >> 10) == (0xD800 >> 10); // 0xD800-0xDBFF
  |  309|  2.57k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:is_hi_surrogate
  ------------------
  | Unexecuted instantiation: cutils.c:is_hi_surrogate
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:is_hi_surrogate
  ------------------
  310|       |
  311|       |static inline BOOL is_lo_surrogate(uint32_t c)
  312|  30.4k|{
  313|  30.4k|    return (c >> 10) == (0xDC00 >> 10); // 0xDC00-0xDFFF
  314|  30.4k|}
  ------------------
  | Unexecuted instantiation: qjs.c:is_lo_surrogate
  ------------------
  | quickjs.c:is_lo_surrogate:
  |  312|  30.4k|{
  |  313|  30.4k|    return (c >> 10) == (0xDC00 >> 10); // 0xDC00-0xDFFF
  |  314|  30.4k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:is_lo_surrogate
  ------------------
  | libregexp.c:is_lo_surrogate:
  |  312|     10|{
  |  313|     10|    return (c >> 10) == (0xDC00 >> 10); // 0xDC00-0xDFFF
  |  314|     10|}
  ------------------
  | Unexecuted instantiation: libunicode.c:is_lo_surrogate
  ------------------
  | Unexecuted instantiation: cutils.c:is_lo_surrogate
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:is_lo_surrogate
  ------------------
  315|       |
  316|       |static inline uint32_t get_hi_surrogate(uint32_t c)
  317|  13.4k|{
  318|  13.4k|    return (c >> 10) - (0x10000 >> 10) + 0xD800;
  319|  13.4k|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_hi_surrogate
  ------------------
  | quickjs.c:get_hi_surrogate:
  |  317|  13.4k|{
  |  318|  13.4k|    return (c >> 10) - (0x10000 >> 10) + 0xD800;
  |  319|  13.4k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_hi_surrogate
  ------------------
  | Unexecuted instantiation: libregexp.c:get_hi_surrogate
  ------------------
  | Unexecuted instantiation: libunicode.c:get_hi_surrogate
  ------------------
  | Unexecuted instantiation: cutils.c:get_hi_surrogate
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_hi_surrogate
  ------------------
  320|       |
  321|       |static inline uint32_t get_lo_surrogate(uint32_t c)
  322|  13.4k|{
  323|  13.4k|    return (c & 0x3FF) | 0xDC00;
  324|  13.4k|}
  ------------------
  | Unexecuted instantiation: qjs.c:get_lo_surrogate
  ------------------
  | quickjs.c:get_lo_surrogate:
  |  322|  13.4k|{
  |  323|  13.4k|    return (c & 0x3FF) | 0xDC00;
  |  324|  13.4k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:get_lo_surrogate
  ------------------
  | Unexecuted instantiation: libregexp.c:get_lo_surrogate
  ------------------
  | Unexecuted instantiation: libunicode.c:get_lo_surrogate
  ------------------
  | Unexecuted instantiation: cutils.c:get_lo_surrogate
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:get_lo_surrogate
  ------------------
  325|       |
  326|       |static inline uint32_t from_surrogate(uint32_t hi, uint32_t lo)
  327|  30.4k|{
  328|  30.4k|    return 0x10000 + 0x400 * (hi - 0xD800) + (lo - 0xDC00);
  329|  30.4k|}
  ------------------
  | Unexecuted instantiation: qjs.c:from_surrogate
  ------------------
  | quickjs.c:from_surrogate:
  |  327|  30.4k|{
  |  328|  30.4k|    return 0x10000 + 0x400 * (hi - 0xD800) + (lo - 0xDC00);
  |  329|  30.4k|}
  ------------------
  | Unexecuted instantiation: dtoa.c:from_surrogate
  ------------------
  | libregexp.c:from_surrogate:
  |  327|     10|{
  |  328|     10|    return 0x10000 + 0x400 * (hi - 0xD800) + (lo - 0xDC00);
  |  329|     10|}
  ------------------
  | Unexecuted instantiation: libunicode.c:from_surrogate
  ------------------
  | Unexecuted instantiation: cutils.c:from_surrogate
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:from_surrogate
  ------------------
  330|       |
  331|       |static inline int from_hex(int c)
  332|  15.2k|{
  333|  15.2k|    if (c >= '0' && c <= '9')
  334|  4.57k|        return c - '0';
  335|  10.6k|    else if (c >= 'A' && c <= 'F')
  336|  3.92k|        return c - 'A' + 10;
  337|  6.76k|    else if (c >= 'a' && c <= 'f')
  338|    693|        return c - 'a' + 10;
  339|  6.06k|    else
  340|  6.06k|        return -1;
  341|  15.2k|}
  ------------------
  | Unexecuted instantiation: qjs.c:from_hex
  ------------------
  | Unexecuted instantiation: quickjs.c:from_hex
  ------------------
  | Unexecuted instantiation: dtoa.c:from_hex
  ------------------
  | libregexp.c:from_hex:
  |  332|  15.2k|{
  |  333|  15.2k|    if (c >= '0' && c <= '9')
  |  334|  4.57k|        return c - '0';
  |  335|  10.6k|    else if (c >= 'A' && c <= 'F')
  |  336|  3.92k|        return c - 'A' + 10;
  |  337|  6.76k|    else if (c >= 'a' && c <= 'f')
  |  338|    693|        return c - 'a' + 10;
  |  339|  6.06k|    else
  |  340|  6.06k|        return -1;
  |  341|  15.2k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:from_hex
  ------------------
  | Unexecuted instantiation: cutils.c:from_hex
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:from_hex
  ------------------
  342|       |
  343|       |void rqsort(void *base, size_t nmemb, size_t size,
  344|       |            int (*cmp)(const void *, const void *, void *),
  345|       |            void *arg);
  346|       |
  347|       |static inline uint64_t float64_as_uint64(double d)
  348|   481k|{
  349|   481k|    union {
  350|   481k|        double d;
  351|   481k|        uint64_t u64;
  352|   481k|    } u;
  353|   481k|    u.d = d;
  354|   481k|    return u.u64;
  355|   481k|}
  ------------------
  | Unexecuted instantiation: qjs.c:float64_as_uint64
  ------------------
  | quickjs.c:float64_as_uint64:
  |  348|   241k|{
  |  349|   241k|    union {
  |  350|   241k|        double d;
  |  351|   241k|        uint64_t u64;
  |  352|   241k|    } u;
  |  353|   241k|    u.d = d;
  |  354|   241k|    return u.u64;
  |  355|   241k|}
  ------------------
  | dtoa.c:float64_as_uint64:
  |  348|   239k|{
  |  349|   239k|    union {
  |  350|   239k|        double d;
  |  351|   239k|        uint64_t u64;
  |  352|   239k|    } u;
  |  353|   239k|    u.d = d;
  |  354|   239k|    return u.u64;
  |  355|   239k|}
  ------------------
  | Unexecuted instantiation: libregexp.c:float64_as_uint64
  ------------------
  | Unexecuted instantiation: libunicode.c:float64_as_uint64
  ------------------
  | Unexecuted instantiation: cutils.c:float64_as_uint64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:float64_as_uint64
  ------------------
  356|       |
  357|       |static inline double uint64_as_float64(uint64_t u64)
  358|   821k|{
  359|   821k|    union {
  360|   821k|        double d;
  361|   821k|        uint64_t u64;
  362|   821k|    } u;
  363|   821k|    u.u64 = u64;
  364|   821k|    return u.d;
  365|   821k|}
  ------------------
  | Unexecuted instantiation: qjs.c:uint64_as_float64
  ------------------
  | Unexecuted instantiation: quickjs.c:uint64_as_float64
  ------------------
  | dtoa.c:uint64_as_float64:
  |  358|   821k|{
  |  359|   821k|    union {
  |  360|   821k|        double d;
  |  361|   821k|        uint64_t u64;
  |  362|   821k|    } u;
  |  363|   821k|    u.u64 = u64;
  |  364|   821k|    return u.d;
  |  365|   821k|}
  ------------------
  | Unexecuted instantiation: libregexp.c:uint64_as_float64
  ------------------
  | Unexecuted instantiation: libunicode.c:uint64_as_float64
  ------------------
  | Unexecuted instantiation: cutils.c:uint64_as_float64
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:uint64_as_float64
  ------------------
  366|       |
  367|       |#endif  /* CUTILS_H */

/home/eugeneriabinin777/quickjs/dtoa.c:
    1|       |/*
    2|       | * Tiny float64 printing and parsing library
    3|       | *
    4|       | * Copyright (c) 2024 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |#include <stdlib.h>
   25|       |#include <stdio.h>
   26|       |#include <stdarg.h>
   27|       |#include <inttypes.h>
   28|       |#include <string.h>
   29|       |#include <assert.h>
   30|       |#include <ctype.h>
   31|       |#include <sys/time.h>
   32|       |#include <math.h>
   33|       |#include <setjmp.h>
   34|       |
   35|       |#include "cutils.h"
   36|       |#include "dtoa.h"
   37|       |
   38|       |/* 
   39|       |   TODO:
   40|       |   - test n_digits=101 instead of 100
   41|       |   - simplify subnormal handling
   42|       |   - reduce max memory usage
   43|       |   - free format: could add shortcut if exact result
   44|       |   - use 64 bit limb_t when possible
   45|       |   - use another algorithm for free format dtoa in base 10 (ryu ?)
   46|       |*/
   47|       |
   48|       |#define USE_POW5_TABLE
   49|       |/* use fast path to print small integers in free format */
   50|       |#define USE_FAST_INT
   51|       |
   52|   176M|#define LIMB_LOG2_BITS 5
   53|       |
   54|   176M|#define LIMB_BITS (1 << LIMB_LOG2_BITS)
   55|       |
   56|       |typedef int32_t slimb_t;
   57|       |typedef uint32_t limb_t;
   58|       |typedef uint64_t dlimb_t;
   59|       |
   60|       |#define LIMB_DIGITS 9
   61|       |
   62|       |#define JS_RADIX_MAX 36
   63|       |
   64|  1.06M|#define DBIGNUM_LEN_MAX 52 /* ~ 2^(1072+53)*36^100 (dtoa) */
   65|   239k|#define MANT_LEN_MAX 18 /* < 36^100 */
   66|       |
   67|       |typedef intptr_t mp_size_t;
   68|       |
   69|       |/* the represented number is sum(i, tab[i]*2^(LIMB_BITS * i)) */
   70|       |typedef struct {
   71|       |    int len; /* >= 1 */
   72|       |    limb_t tab[];
   73|       |} mpb_t;
   74|       |
   75|       |static limb_t mp_add_ui(limb_t *tab, limb_t b, size_t n)
   76|   218k|{
   77|   218k|    size_t i;
   78|   218k|    limb_t k, a;
   79|       |
   80|   218k|    k=b;
   81|   436k|    for(i=0;i<n;i++) {
   82|   405k|        if (k == 0)
   83|   187k|            break;
   84|   218k|        a = tab[i] + k;
   85|   218k|        k = (a < k);
   86|   218k|        tab[i] = a;
   87|   218k|    }
   88|   218k|    return k;
   89|   218k|}
   90|       |
   91|       |/* tabr[] = taba[] * b + l. Return the high carry */
   92|       |static limb_t mp_mul1(limb_t *tabr, const limb_t *taba, limb_t n, 
   93|       |                      limb_t b, limb_t l)
   94|  2.24M|{
   95|  2.24M|    limb_t i;
   96|  2.24M|    dlimb_t t;
   97|       |
   98|  27.3M|    for(i = 0; i < n; i++) {
   99|  25.0M|        t = (dlimb_t)taba[i] * (dlimb_t)b + l;
  100|  25.0M|        tabr[i] = t;
  101|  25.0M|        l = t >> LIMB_BITS;
  102|  25.0M|    }
  103|  2.24M|    return l;
  104|  2.24M|}
  105|       |
  106|       |/* WARNING: d must be >= 2^(LIMB_BITS-1) */
  107|       |static inline limb_t udiv1norm_init(limb_t d)
  108|      0|{
  109|      0|    limb_t a0, a1;
  110|      0|    a1 = -d - 1;
  111|      0|    a0 = -1;
  112|      0|    return (((dlimb_t)a1 << LIMB_BITS) | a0) / d;
  113|      0|}
  114|       |
  115|       |/* return the quotient and the remainder in '*pr'of 'a1*2^LIMB_BITS+a0
  116|       |   / d' with 0 <= a1 < d. */
  117|       |static inline limb_t udiv1norm(limb_t *pr, limb_t a1, limb_t a0,
  118|       |                                limb_t d, limb_t d_inv)
  119|  28.4M|{
  120|  28.4M|    limb_t n1m, n_adj, q, r, ah;
  121|  28.4M|    dlimb_t a;
  122|  28.4M|    n1m = ((slimb_t)a0 >> (LIMB_BITS - 1));
  123|  28.4M|    n_adj = a0 + (n1m & d);
  124|  28.4M|    a = (dlimb_t)d_inv * (a1 - n1m) + n_adj;
  125|  28.4M|    q = (a >> LIMB_BITS) + a1;
  126|       |    /* compute a - q * r and update q so that the remainder is between
  127|       |       0 and d - 1 */
  128|  28.4M|    a = ((dlimb_t)a1 << LIMB_BITS) | a0;
  129|  28.4M|    a = a - (dlimb_t)q * d - d;
  130|  28.4M|    ah = a >> LIMB_BITS;
  131|  28.4M|    q += 1 + ah;
  132|  28.4M|    r = (limb_t)a + (ah & d);
  133|  28.4M|    *pr = r;
  134|  28.4M|    return q;
  135|  28.4M|}
  136|       |
  137|       |static limb_t mp_div1(limb_t *tabr, const limb_t *taba, limb_t n,
  138|       |                      limb_t b, limb_t r)
  139|   119k|{
  140|   119k|    slimb_t i;
  141|   119k|    dlimb_t a1;
  142|   281k|    for(i = n - 1; i >= 0; i--) {
  143|   162k|        a1 = ((dlimb_t)r << LIMB_BITS) | taba[i];
  144|   162k|        tabr[i] = a1 / b;
  145|   162k|        r = a1 % b;
  146|   162k|    }
  147|   119k|    return r;
  148|   119k|}
  149|       |
  150|       |/* r = (a + high*B^n) >> shift. Return the remainder r (0 <= r < 2^shift). 
  151|       |   1 <= shift <= LIMB_BITS - 1 */
  152|       |static limb_t mp_shr(limb_t *tab_r, const limb_t *tab, mp_size_t n, 
  153|       |                     int shift, limb_t high)
  154|   425k|{
  155|   425k|    mp_size_t i;
  156|   425k|    limb_t l, a;
  157|       |
  158|   425k|    assert(shift >= 1 && shift < LIMB_BITS);
  159|   425k|    l = high;
  160|  1.42M|    for(i = n - 1; i >= 0; i--) {
  161|  1.00M|        a = tab[i];
  162|  1.00M|        tab_r[i] = (a >> shift) | (l << (LIMB_BITS - shift));
  163|  1.00M|        l = a;
  164|  1.00M|    }
  165|   425k|    return l & (((limb_t)1 << shift) - 1);
  166|   425k|}
  167|       |
  168|       |/* r = (a << shift) + low. 1 <= shift <= LIMB_BITS - 1, 0 <= low <
  169|       |   2^shift. */
  170|       |static limb_t mp_shl(limb_t *tab_r, const limb_t *tab, mp_size_t n, 
  171|       |              int shift, limb_t low)
  172|  2.86M|{
  173|  2.86M|    mp_size_t i;
  174|  2.86M|    limb_t l, a;
  175|       |
  176|  2.86M|    assert(shift >= 1 && shift < LIMB_BITS);
  177|  2.86M|    l = low;
  178|  32.3M|    for(i = 0; i < n; i++) {
  179|  29.4M|        a = tab[i];
  180|  29.4M|        tab_r[i] = (a << shift) | l;
  181|  29.4M|        l = (a >> (LIMB_BITS - shift)); 
  182|  29.4M|    }
  183|  2.86M|    return l;
  184|  2.86M|}
  185|       |
  186|       |static no_inline limb_t mp_div1norm(limb_t *tabr, const limb_t *taba, limb_t n,
  187|       |                                    limb_t b, limb_t r, limb_t b_inv, int shift)
  188|  1.98M|{
  189|  1.98M|    slimb_t i;
  190|       |
  191|  1.98M|    if (shift != 0) {
  192|  1.98M|        r = (r << shift) | mp_shl(tabr, taba, n, shift, 0);
  193|  1.98M|    }
  194|  30.4M|    for(i = n - 1; i >= 0; i--) {
  195|  28.4M|        tabr[i] = udiv1norm(&r, r, taba[i], b, b_inv);
  196|  28.4M|    }
  197|  1.98M|    r >>= shift;
  198|  1.98M|    return r;
  199|  1.98M|}
  200|       |
  201|       |static __maybe_unused void mpb_dump(const char *str, const mpb_t *a)
  202|      0|{
  203|      0|    int i;
  204|      0|    
  205|      0|    printf("%s= 0x", str);
  206|      0|    for(i = a->len - 1; i >= 0; i--) {
  207|      0|        printf("%08x", a->tab[i]);
  208|      0|        if (i != 0)
  209|      0|            printf("_");
  210|      0|    }
  211|      0|    printf("\n");
  212|      0|}
  213|       |
  214|       |static void mpb_renorm(mpb_t *r)
  215|  3.57M|{
  216|  6.42M|    while (r->len > 1 && r->tab[r->len - 1] == 0)
  217|  2.84M|        r->len--;
  218|  3.57M|}
  219|       |
  220|       |#ifdef USE_POW5_TABLE
  221|       |static const uint32_t pow5_table[17] = {
  222|       |    0x00000005, 0x00000019, 0x0000007d, 0x00000271, 
  223|       |    0x00000c35, 0x00003d09, 0x0001312d, 0x0005f5e1, 
  224|       |    0x001dcd65, 0x009502f9, 0x02e90edd, 0x0e8d4a51, 
  225|       |    0x48c27395, 0x6bcc41e9, 0x1afd498d, 0x86f26fc1, 
  226|       |    0xa2bc2ec5, 
  227|       |};
  228|       |
  229|       |static const uint8_t pow5h_table[4] = {
  230|       |    0x00000001, 0x00000007, 0x00000023, 0x000000b1, 
  231|       |};
  232|       |
  233|       |static const uint32_t pow5_inv_table[13] = {
  234|       |    0x99999999, 0x47ae147a, 0x0624dd2f, 0xa36e2eb1,
  235|       |    0x4f8b588e, 0x0c6f7a0b, 0xad7f29ab, 0x5798ee23,
  236|       |    0x12e0be82, 0xb7cdfd9d, 0x5fd7fe17, 0x19799812,
  237|       |    0xc25c2684,
  238|       |};
  239|       |#endif
  240|       |
  241|       |/* return a^b */
  242|       |static uint64_t pow_ui(uint32_t a, uint32_t b)
  243|  1.40M|{
  244|  1.40M|    int i, n_bits;
  245|  1.40M|    uint64_t r;
  246|  1.40M|    if (b == 0)
  247|      0|        return 1;
  248|  1.40M|    if (b == 1)
  249|   549k|        return a;
  250|   855k|#ifdef USE_POW5_TABLE
  251|   855k|    if ((a == 5 || a == 10) && b <= 17) {
  252|   854k|        r = pow5_table[b - 1];
  253|   854k|        if (b >= 14) {
  254|   175k|            r |= (uint64_t)pow5h_table[b - 14] << 32;
  255|   175k|        }
  256|   854k|        if (a == 10)
  257|   511k|            r <<= b;
  258|   854k|        return r;
  259|   854k|    }
  260|  1.23k|#endif
  261|  1.23k|    r = a;
  262|  1.23k|    n_bits = 32 - clz32(b);
  263|  3.45k|    for(i = n_bits - 2; i >= 0; i--) {
  264|  2.21k|        r *= r;
  265|  2.21k|        if ((b >> i) & 1)
  266|    552|            r *= a;
  267|  2.21k|    }
  268|  1.23k|    return r;
  269|   855k|}
  270|       |
  271|       |static uint32_t pow_ui_inv(uint32_t *pr_inv, int *pshift, uint32_t a, uint32_t b)
  272|   326k|{
  273|   326k|    uint32_t r_inv, r;
  274|   326k|    int shift;
  275|   326k|#ifdef USE_POW5_TABLE
  276|   326k|    if (a == 5 && b >= 1 && b <= 13) {
  277|   326k|        r = pow5_table[b - 1];
  278|   326k|        shift = clz32(r);
  279|   326k|        r <<= shift;
  280|   326k|        r_inv = pow5_inv_table[b - 1];
  281|   326k|    } else
  282|      0|#endif
  283|      0|    {
  284|      0|        r = pow_ui(a, b);
  285|      0|        shift = clz32(r);
  286|      0|        r <<= shift;
  287|      0|        r_inv = udiv1norm_init(r);
  288|      0|    }
  289|   326k|    *pshift = shift;
  290|   326k|    *pr_inv = r_inv;
  291|   326k|    return r;
  292|   326k|}
  293|       |
  294|       |enum {
  295|       |    JS_RNDN, /* round to nearest, ties to even */
  296|       |    JS_RNDNA, /* round to nearest, ties away from zero */
  297|       |    JS_RNDZ,
  298|       |};
  299|       |
  300|       |static int mpb_get_bit(const mpb_t *r, int k)
  301|   435k|{
  302|   435k|    int l;
  303|       |    
  304|   435k|    l = (unsigned)k / LIMB_BITS;
  305|   435k|    k = k & (LIMB_BITS - 1);
  306|   435k|    if (l >= r->len)
  307|      0|        return 0;
  308|   435k|    else
  309|   435k|        return (r->tab[l] >> k) & 1;
  310|   435k|}
  311|       |
  312|       |/* compute round(r / 2^shift). 'shift' can be negative */
  313|       |static void mpb_shr_round(mpb_t *r, int shift, int rnd_mode)
  314|  1.39M|{
  315|  1.39M|    int l, i;
  316|       |
  317|  1.39M|    if (shift == 0)
  318|    690|        return;
  319|  1.39M|    if (shift < 0) {
  320|   957k|        shift = -shift;
  321|   957k|        l = (unsigned)shift / LIMB_BITS;
  322|   957k|        shift = shift & (LIMB_BITS - 1);
  323|   957k|        if (shift != 0) {
  324|   879k|            r->tab[r->len] = mp_shl(r->tab, r->tab, r->len, shift, 0);
  325|   879k|            r->len++;
  326|   879k|            mpb_renorm(r);
  327|   879k|        }
  328|   957k|        if (l > 0) {
  329|  1.92M|            for(i = r->len - 1; i >= 0; i--)
  330|  1.03M|                r->tab[i + l] = r->tab[i];
  331|  3.60M|            for(i = 0; i < l; i++)
  332|  2.72M|                r->tab[i] = 0;
  333|   886k|            r->len += l;
  334|   886k|        }
  335|   957k|    } else {
  336|   433k|        limb_t bit1, bit2;
  337|   433k|        int k, add_one;
  338|       |        
  339|   433k|        switch(rnd_mode) {
  340|      0|        default:
  341|      0|        case JS_RNDZ:
  342|      0|            add_one = 0;
  343|      0|            break;
  344|   433k|        case JS_RNDN:
  345|   433k|        case JS_RNDNA:
  346|   433k|            bit1 = mpb_get_bit(r, shift - 1);
  347|   433k|            if (bit1) {
  348|   218k|                if (rnd_mode == JS_RNDNA) {
  349|      0|                    bit2 = 1;
  350|   218k|                } else {
  351|       |                    /* bit2 = oring of all the bits after bit1 */
  352|   218k|                    bit2 = 0;
  353|   218k|                    if (shift >= 2) {
  354|   218k|                        k = shift - 1;
  355|   218k|                        l = (unsigned)k / LIMB_BITS;
  356|   218k|                        k = k & (LIMB_BITS - 1);
  357|  1.13M|                        for(i = 0; i < min_int(l, r->len); i++)
  358|   920k|                            bit2 |= r->tab[i];
  359|   218k|                        if (l < r->len)
  360|   218k|                            bit2 |= r->tab[l] & (((limb_t)1 << k) - 1);
  361|   218k|                    }
  362|   218k|                }
  363|   218k|                if (bit2) {
  364|   216k|                    add_one = 1;
  365|   216k|                } else {
  366|       |                    /* round to even */
  367|  2.51k|                    add_one = mpb_get_bit(r, shift);
  368|  2.51k|                }
  369|   218k|            } else {
  370|   214k|                add_one = 0;
  371|   214k|            }
  372|   433k|            break;
  373|   433k|        }
  374|       |
  375|   433k|        l = (unsigned)shift / LIMB_BITS;
  376|   433k|        shift = shift & (LIMB_BITS - 1);
  377|   433k|        if (l >= r->len) {
  378|      0|            r->len = 1;
  379|      0|            r->tab[0] = add_one;
  380|   433k|        } else {
  381|   433k|            if (l > 0) {
  382|   295k|                r->len -= l;
  383|   927k|                for(i = 0; i < r->len; i++)
  384|   632k|                    r->tab[i] = r->tab[i + l];
  385|   295k|            }
  386|   433k|            if (shift != 0) {
  387|   425k|                mp_shr(r->tab, r->tab, r->len, shift, 0);
  388|   425k|                mpb_renorm(r);
  389|   425k|            }
  390|   433k|            if (add_one) {
  391|   218k|                limb_t a;
  392|   218k|                a = mp_add_ui(r->tab, 1, r->len);
  393|   218k|                if (a)
  394|      0|                    r->tab[r->len++] = a;
  395|   218k|            }
  396|   433k|        }
  397|   433k|    }
  398|  1.39M|}
  399|       |
  400|       |/* return -1, 0 or 1 */
  401|       |static int mpb_cmp(const mpb_t *a, const mpb_t *b)
  402|      0|{
  403|      0|    mp_size_t i;
  404|      0|    if (a->len < b->len)
  405|      0|        return -1;
  406|      0|    else if (a->len > b->len)
  407|      0|        return 1;
  408|      0|    for(i = a->len - 1; i >= 0; i--) {
  409|      0|        if (a->tab[i] != b->tab[i]) {
  410|      0|            if (a->tab[i] < b->tab[i])
  411|      0|                return -1;
  412|      0|            else
  413|      0|                return 1;
  414|      0|        }
  415|      0|    }
  416|      0|    return 0;
  417|      0|}
  418|       |
  419|       |static void mpb_set_u64(mpb_t *r, uint64_t m)
  420|   462k|{
  421|       |#if LIMB_BITS == 64
  422|       |    r->tab[0] = m;
  423|       |    r->len = 1;
  424|       |#else
  425|   462k|    r->tab[0] = m;
  426|   462k|    r->tab[1] = m >> LIMB_BITS;
  427|   462k|    if (r->tab[1] == 0)
  428|  90.3k|        r->len = 1;
  429|   372k|    else
  430|   372k|        r->len = 2;
  431|   462k|#endif
  432|   462k|}
  433|       |
  434|       |static uint64_t mpb_get_u64(mpb_t *r)
  435|  1.18M|{
  436|       |#if LIMB_BITS == 64
  437|       |    return r->tab[0];
  438|       |#else
  439|  1.18M|    if (r->len == 1) {
  440|  71.8k|        return r->tab[0];
  441|  1.11M|    } else {
  442|  1.11M|        return r->tab[0] | ((uint64_t)r->tab[1] << LIMB_BITS);
  443|  1.11M|    }
  444|  1.18M|#endif
  445|  1.18M|}
  446|       |
  447|       |/* floor_log2() = position of the first non zero bit or -1 if zero. */
  448|       |static int mpb_floor_log2(mpb_t *a)
  449|  1.08M|{
  450|  1.08M|    limb_t v;
  451|  1.08M|    v = a->tab[a->len - 1];
  452|  1.08M|    if (v == 0)
  453|      0|        return -1;
  454|  1.08M|    else
  455|  1.08M|        return a->len * LIMB_BITS - 1 - clz32(v);
  456|  1.08M|}
  457|       |
  458|  72.1k|#define MUL_LOG2_RADIX_BASE_LOG2 24
  459|       |
  460|       |/* round((1 << MUL_LOG2_RADIX_BASE_LOG2)/log2(i + 2)) */
  461|       |static const uint32_t mul_log2_radix_table[JS_RADIX_MAX - 1] = {
  462|       |    0x000000, 0xa1849d, 0x000000, 0x6e40d2, 
  463|       |    0x6308c9, 0x5b3065, 0x000000, 0x50c24e, 
  464|       |    0x4d104d, 0x4a0027, 0x4768ce, 0x452e54, 
  465|       |    0x433d00, 0x418677, 0x000000, 0x3ea16b, 
  466|       |    0x3d645a, 0x3c43c2, 0x3b3b9a, 0x3a4899, 
  467|       |    0x39680b, 0x3897b3, 0x37d5af, 0x372069, 
  468|       |    0x367686, 0x35d6df, 0x354072, 0x34b261, 
  469|       |    0x342bea, 0x33ac62, 0x000000, 0x32bfd9, 
  470|       |    0x3251dd, 0x31e8d6, 0x318465,
  471|       |};
  472|       |
  473|       |/* return floor(a / log2(radix)) for -2048 <= a <= 2047 */
  474|       |static int mul_log2_radix(int a, int radix)
  475|  72.1k|{
  476|  72.1k|    int radix_bits, mult;
  477|       |
  478|  72.1k|    if ((radix & (radix - 1)) == 0) {
  479|       |        /* if the radix is a power of two better to do it exactly */
  480|      0|        radix_bits = 31 - clz32(radix);
  481|      0|        if (a < 0)
  482|      0|            a -= radix_bits - 1;
  483|      0|        return a / radix_bits;
  484|  72.1k|    } else {
  485|  72.1k|        mult = mul_log2_radix_table[radix - 2];
  486|  72.1k|        return ((int64_t)a * mult) >> MUL_LOG2_RADIX_BASE_LOG2;
  487|  72.1k|    }
  488|  72.1k|}
  489|       |
  490|       |#if 0
  491|       |static void build_mul_log2_radix_table(void)
  492|       |{
  493|       |    int base, radix, mult, col, base_log2;
  494|       |
  495|       |    base_log2 = 24;
  496|       |    base = 1 << base_log2;
  497|       |    col = 0;
  498|       |    for(radix = 2; radix <= 36; radix++) {
  499|       |        if ((radix & (radix - 1)) == 0)
  500|       |            mult = 0;
  501|       |        else
  502|       |            mult = lrint((double)base / log2(radix));
  503|       |        printf("0x%06x, ", mult);
  504|       |        if (++col == 4) {
  505|       |            printf("\n");
  506|       |            col = 0;
  507|       |        }
  508|       |    }
  509|       |    printf("\n");
  510|       |}
  511|       |
  512|       |static void mul_log2_radix_test(void)
  513|       |{
  514|       |    int radix, i, ref, r;
  515|       |    
  516|       |    for(radix = 2; radix <= 36; radix++) {
  517|       |        for(i = -2048; i <= 2047; i++) {
  518|       |            ref = (int)floor((double)i / log2(radix));
  519|       |            r = mul_log2_radix(i, radix);
  520|       |            if (ref != r) {
  521|       |                printf("ERROR: radix=%d i=%d r=%d ref=%d\n",
  522|       |                       radix, i, r, ref);
  523|       |                exit(1);
  524|       |            }
  525|       |        }
  526|       |    }
  527|       |    if (0)
  528|       |        build_mul_log2_radix_table();
  529|       |}
  530|       |#endif
  531|       |
  532|       |static void u32toa_len(char *buf, uint32_t n, size_t len)
  533|   201k|{
  534|   201k|    int digit, i;
  535|  1.67M|    for(i = len - 1; i >= 0; i--) {
  536|  1.47M|        digit = n % 10;
  537|  1.47M|        n = n / 10;
  538|  1.47M|        buf[i] = digit + '0';
  539|  1.47M|    }
  540|   201k|}
  541|       |
  542|       |/* for power of 2 radixes. len >= 1 */
  543|       |static void u64toa_bin_len(char *buf, uint64_t n, unsigned int radix_bits, int len)
  544|      0|{
  545|      0|    int digit, i;
  546|      0|    unsigned int mask;
  547|       |
  548|      0|    mask = (1 << radix_bits) - 1;
  549|      0|    for(i = len - 1; i >= 0; i--) {
  550|      0|        digit = n & mask;
  551|      0|        n >>= radix_bits;
  552|      0|        if (digit < 10)
  553|      0|            digit += '0';
  554|      0|        else
  555|      0|            digit += 'a' - 10;
  556|      0|        buf[i] = digit;
  557|      0|    }
  558|      0|}
  559|       |
  560|       |/* len >= 1. 2 <= radix <= 36 */
  561|       |static void limb_to_a(char *buf, limb_t n, unsigned int radix, int len)
  562|   119k|{
  563|   119k|    int digit, i;
  564|       |
  565|   119k|    if (radix == 10) {
  566|       |        /* specific case with constant divisor */
  567|   119k|#if LIMB_BITS == 32
  568|   119k|        u32toa_len(buf, n, len);
  569|       |#else
  570|       |        /* XXX: optimize */
  571|       |        for(i = len - 1; i >= 0; i--) {
  572|       |            digit = (limb_t)n % 10;
  573|       |            n = (limb_t)n / 10;
  574|       |            buf[i] = digit + '0';
  575|       |        }
  576|       |#endif
  577|   119k|    } else {
  578|      0|        for(i = len - 1; i >= 0; i--) {
  579|      0|            digit = (limb_t)n % radix;
  580|      0|            n = (limb_t)n / radix;
  581|      0|            if (digit < 10)
  582|      0|                digit += '0';
  583|      0|            else
  584|      0|                digit += 'a' - 10;
  585|      0|            buf[i] = digit;
  586|      0|        }
  587|      0|    }
  588|   119k|}
  589|       |
  590|       |size_t u32toa(char *buf, uint32_t n)
  591|  7.53M|{
  592|  7.53M|    char buf1[10], *q;
  593|  7.53M|    size_t len;
  594|       |    
  595|  7.53M|    q = buf1 + sizeof(buf1);
  596|  17.2M|    do {
  597|  17.2M|        *--q = n % 10 + '0';
  598|  17.2M|        n /= 10;
  599|  17.2M|    } while (n != 0);
  600|  7.53M|    len = buf1 + sizeof(buf1) - q;
  601|  7.53M|    memcpy(buf, q, len);
  602|  7.53M|    return len;
  603|  7.53M|}
  604|       |
  605|       |size_t i32toa(char *buf, int32_t n)
  606|  1.70M|{
  607|  1.70M|    if (n >= 0) {
  608|  1.68M|        return u32toa(buf, n);
  609|  1.68M|    } else {
  610|  18.6k|        buf[0] = '-';
  611|  18.6k|        return u32toa(buf + 1, -(uint32_t)n) + 1;
  612|  18.6k|    }
  613|  1.70M|}
  614|       |
  615|       |#ifdef USE_FAST_INT
  616|       |size_t u64toa(char *buf, uint64_t n)
  617|   907k|{
  618|   907k|    if (n < 0x100000000) {
  619|   829k|        return u32toa(buf, n);
  620|   829k|    } else {
  621|  78.3k|        uint64_t n1;
  622|  78.3k|        char *q = buf;
  623|  78.3k|        uint32_t n2;
  624|       |        
  625|  78.3k|        n1 = n / 1000000000;
  626|  78.3k|        n %= 1000000000;
  627|  78.3k|        if (n1 >= 0x100000000) {
  628|  3.29k|            n2 = n1 / 1000000000;
  629|  3.29k|            n1 = n1 % 1000000000;
  630|       |            /* at most two digits */
  631|  3.29k|            if (n2 >= 10) {
  632|      0|                *q++ = n2 / 10 + '0';
  633|      0|                n2 %= 10;
  634|      0|            }
  635|  3.29k|            *q++ = n2 + '0';
  636|  3.29k|            u32toa_len(q, n1, 9);
  637|  3.29k|            q += 9;
  638|  75.0k|        } else {
  639|  75.0k|            q += u32toa(q, n1);
  640|  75.0k|        }
  641|  78.3k|        u32toa_len(q, n, 9);
  642|  78.3k|        q += 9;
  643|  78.3k|        return q - buf;
  644|  78.3k|    }
  645|   907k|}
  646|       |
  647|       |size_t i64toa(char *buf, int64_t n)
  648|      0|{
  649|      0|    if (n >= 0) {
  650|      0|        return u64toa(buf, n);
  651|      0|    } else {
  652|      0|        buf[0] = '-';
  653|      0|        return u64toa(buf + 1, -(uint64_t)n) + 1;
  654|      0|    }
  655|      0|}
  656|       |
  657|       |/* XXX: only tested for 1 <= n < 2^53 */
  658|       |size_t u64toa_radix(char *buf, uint64_t n, unsigned int radix)
  659|   907k|{
  660|   907k|    int radix_bits, l;
  661|   907k|    if (likely(radix == 10))
  662|   907k|        return u64toa(buf, n);
  663|      0|    if ((radix & (radix - 1)) == 0) {
  664|      0|        radix_bits = 31 - clz32(radix);
  665|      0|        if (n == 0)
  666|      0|            l = 1;
  667|      0|        else
  668|      0|            l = (64 - clz64(n) + radix_bits - 1) / radix_bits;
  669|      0|        u64toa_bin_len(buf, n, radix_bits, l);
  670|      0|        return l;
  671|      0|    } else {
  672|      0|        char buf1[41], *q; /* maximum length for radix = 3 */
  673|      0|        size_t len;
  674|      0|        int digit;
  675|      0|        q = buf1 + sizeof(buf1);
  676|      0|        do {
  677|      0|            digit = n % radix;
  678|      0|            n /= radix;
  679|      0|            if (digit < 10)
  680|      0|                digit += '0';
  681|      0|            else
  682|      0|                digit += 'a' - 10;
  683|      0|            *--q = digit;
  684|      0|        } while (n != 0);
  685|      0|        len = buf1 + sizeof(buf1) - q;
  686|      0|        memcpy(buf, q, len);
  687|      0|        return len;
  688|      0|    }
  689|      0|}
  690|       |
  691|       |size_t i64toa_radix(char *buf, int64_t n, unsigned int radix)
  692|   835k|{
  693|   835k|    if (n >= 0) {
  694|   821k|        return u64toa_radix(buf, n, radix);
  695|   821k|    } else {
  696|  14.4k|        buf[0] = '-';
  697|  14.4k|        return u64toa_radix(buf + 1, -(uint64_t)n, radix) + 1;
  698|  14.4k|    }
  699|   835k|}
  700|       |#endif /* USE_FAST_INT */
  701|       |
  702|       |static const uint8_t digits_per_limb_table[JS_RADIX_MAX - 1] = {
  703|       |#if LIMB_BITS == 32
  704|       |32,20,16,13,12,11,10,10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  705|       |#else
  706|       |64,40,32,27,24,22,21,20,19,18,17,17,16,16,16,15,15,15,14,14,14,14,13,13,13,13,13,13,13,12,12,12,12,12,12,
  707|       |#endif
  708|       |};
  709|       |
  710|       |static const uint32_t radix_base_table[JS_RADIX_MAX - 1] = {
  711|       | 0x00000000, 0xcfd41b91, 0x00000000, 0x48c27395,
  712|       | 0x81bf1000, 0x75db9c97, 0x40000000, 0xcfd41b91,
  713|       | 0x3b9aca00, 0x8c8b6d2b, 0x19a10000, 0x309f1021,
  714|       | 0x57f6c100, 0x98c29b81, 0x00000000, 0x18754571,
  715|       | 0x247dbc80, 0x3547667b, 0x4c4b4000, 0x6b5a6e1d,
  716|       | 0x94ace180, 0xcaf18367, 0x0b640000, 0x0e8d4a51,
  717|       | 0x1269ae40, 0x17179149, 0x1cb91000, 0x23744899,
  718|       | 0x2b73a840, 0x34e63b41, 0x40000000, 0x4cfa3cc1,
  719|       | 0x5c13d840, 0x6d91b519, 0x81bf1000,
  720|       |};
  721|       |
  722|       |/* XXX: remove the table ? */
  723|       |static uint8_t dtoa_max_digits_table[JS_RADIX_MAX - 1] = {
  724|       |    54, 35, 28, 24, 22, 20, 19, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12,
  725|       |};
  726|       |
  727|       |/* we limit the maximum number of significant digits for atod to about
  728|       |   128 bits of precision for non power of two bases. The only
  729|       |   requirement for Javascript is at least 20 digits in base 10. For
  730|       |   power of two bases, we do an exact rounding in all the cases. */
  731|       |static uint8_t atod_max_digits_table[JS_RADIX_MAX - 1] = {
  732|       |     64, 80, 32, 55, 49, 45, 21, 40, 38, 37, 35, 34, 33, 32, 16, 31, 30, 30, 29, 29, 28, 28, 27, 27, 27, 26, 26, 26, 26, 25, 12, 25, 25, 24, 24,
  733|       |};
  734|       |
  735|       |/* if abs(d) >= B^max_exponent, it is an overflow */
  736|       |static const int16_t max_exponent[JS_RADIX_MAX - 1] = {
  737|       | 1024,   647,   512,   442,   397,   365,   342,   324, 
  738|       |  309,   297,   286,   277,   269,   263,   256,   251, 
  739|       |  246,   242,   237,   234,   230,   227,   224,   221, 
  740|       |  218,   216,   214,   211,   209,   207,   205,   203, 
  741|       |  202,   200,   199, 
  742|       |};
  743|       |
  744|       |/* if abs(d) <= B^min_exponent, it is an underflow */
  745|       |static const int16_t min_exponent[JS_RADIX_MAX - 1] = {
  746|       |-1075,  -679,  -538,  -463,  -416,  -383,  -359,  -340, 
  747|       | -324,  -311,  -300,  -291,  -283,  -276,  -269,  -263, 
  748|       | -258,  -254,  -249,  -245,  -242,  -238,  -235,  -232, 
  749|       | -229,  -227,  -224,  -222,  -220,  -217,  -215,  -214, 
  750|       | -212,  -210,  -208, 
  751|       |};
  752|       |
  753|       |#if 0
  754|       |void build_tables(void)
  755|       |{
  756|       |    int r, j, radix, n, col, i;
  757|       |    
  758|       |    /* radix_base_table */
  759|       |    for(radix = 2; radix <= 36; radix++) {
  760|       |        r = 1;
  761|       |        for(j = 0; j < digits_per_limb_table[radix - 2]; j++) {
  762|       |            r *= radix;
  763|       |        }
  764|       |        printf(" 0x%08x,", r);
  765|       |        if ((radix % 4) == 1)
  766|       |            printf("\n");
  767|       |    }
  768|       |    printf("\n");
  769|       |
  770|       |    /* dtoa_max_digits_table */
  771|       |    for(radix = 2; radix <= 36; radix++) {
  772|       |        /* Note: over estimated when the radix is a power of two */
  773|       |        printf(" %d,", 1 + (int)ceil(53.0 / log2(radix)));
  774|       |    }
  775|       |    printf("\n");
  776|       |
  777|       |    /* atod_max_digits_table */
  778|       |    for(radix = 2; radix <= 36; radix++) {
  779|       |        if ((radix & (radix - 1)) == 0) {
  780|       |            /* 64 bits is more than enough */
  781|       |            n = (int)floor(64.0 / log2(radix));
  782|       |        } else {
  783|       |            n = (int)floor(128.0 / log2(radix));
  784|       |        }
  785|       |        printf(" %d,", n);
  786|       |    }
  787|       |    printf("\n");
  788|       |
  789|       |    printf("static const int16_t max_exponent[JS_RADIX_MAX - 1] = {\n");
  790|       |    col = 0;
  791|       |    for(radix = 2; radix <= 36; radix++) {
  792|       |        printf("%5d, ", (int)ceil(1024 / log2(radix)));
  793|       |        if (++col == 8) {
  794|       |            col = 0;
  795|       |            printf("\n");
  796|       |        }
  797|       |    }
  798|       |    printf("\n};\n\n");
  799|       |
  800|       |    printf("static const int16_t min_exponent[JS_RADIX_MAX - 1] = {\n");
  801|       |    col = 0; 
  802|       |    for(radix = 2; radix <= 36; radix++) {
  803|       |        printf("%5d, ", (int)floor(-1075 / log2(radix)));
  804|       |        if (++col == 8) {
  805|       |            col = 0;
  806|       |            printf("\n");
  807|       |        }
  808|       |    }
  809|       |    printf("\n};\n\n");
  810|       |
  811|       |    printf("static const uint32_t pow5_table[16] = {\n");
  812|       |    col = 0; 
  813|       |    for(i = 2; i <= 17; i++) {
  814|       |        r = 1;
  815|       |        for(j = 0; j < i; j++) {
  816|       |            r *= 5;
  817|       |        }
  818|       |        printf("0x%08x, ", r);
  819|       |        if (++col == 4) {
  820|       |            col = 0;
  821|       |            printf("\n");
  822|       |        }
  823|       |    }
  824|       |    printf("\n};\n\n");
  825|       |
  826|       |    /* high part */
  827|       |    printf("static const uint8_t pow5h_table[4] = {\n");
  828|       |    col = 0; 
  829|       |    for(i = 14; i <= 17; i++) {
  830|       |        uint64_t r1;
  831|       |        r1 = 1;
  832|       |        for(j = 0; j < i; j++) {
  833|       |            r1 *= 5;
  834|       |        }
  835|       |        printf("0x%08x, ", (uint32_t)(r1 >> 32));
  836|       |        if (++col == 4) {
  837|       |            col = 0;
  838|       |            printf("\n");
  839|       |        }
  840|       |    }
  841|       |    printf("\n};\n\n");
  842|       |}
  843|       |#endif
  844|       |
  845|       |/* n_digits >= 1. 0 <= dot_pos <= n_digits. If dot_pos == n_digits,
  846|       |   the dot is not displayed. 'a' is modified. */
  847|       |static int output_digits(char *buf,
  848|       |                         mpb_t *a, int radix, int n_digits1,
  849|       |                         int dot_pos)
  850|  75.3k|{
  851|  75.3k|    int n_digits, digits_per_limb, radix_bits, n, len;
  852|       |
  853|  75.3k|    n_digits = n_digits1;
  854|  75.3k|    if ((radix & (radix - 1)) == 0) {
  855|       |        /* radix = 2^radix_bits */
  856|      0|        radix_bits = 31 - clz32(radix);
  857|  75.3k|    } else {
  858|  75.3k|        radix_bits = 0;
  859|  75.3k|    }
  860|  75.3k|    digits_per_limb = digits_per_limb_table[radix - 2];
  861|  75.3k|    if (radix_bits != 0) {
  862|      0|        for(;;) {
  863|      0|            n = min_int(n_digits, digits_per_limb);
  864|      0|            n_digits -= n;
  865|      0|            u64toa_bin_len(buf + n_digits, a->tab[0], radix_bits, n);
  866|      0|            if (n_digits == 0)
  867|      0|                break;
  868|      0|            mpb_shr_round(a, digits_per_limb * radix_bits, JS_RNDZ);
  869|      0|        }
  870|  75.3k|    } else {
  871|  75.3k|        limb_t r;
  872|   195k|        while (n_digits != 0) {
  873|   119k|            n = min_int(n_digits, digits_per_limb);
  874|   119k|            n_digits -= n;
  875|   119k|            r = mp_div1(a->tab, a->tab, a->len, radix_base_table[radix - 2], 0);
  876|   119k|            mpb_renorm(a);
  877|   119k|            limb_to_a(buf + n_digits, r, radix, n);
  878|   119k|        }
  879|  75.3k|    }
  880|       |
  881|       |    /* add the dot */
  882|  75.3k|    len = n_digits1;
  883|  75.3k|    if (dot_pos != n_digits1) {
  884|  33.5k|        memmove(buf + dot_pos + 1, buf + dot_pos, n_digits1 - dot_pos);
  885|  33.5k|        buf[dot_pos] = '.';
  886|  33.5k|        len++;
  887|  33.5k|    }
  888|  75.3k|    return len;
  889|  75.3k|}
  890|       |
  891|       |/* return (a, e_offset) such that a = a * (radix1*2^radix_shift)^f *
  892|       |   2^-e_offset. 'f' can be negative. */
  893|       |static int mul_pow(mpb_t *a, int radix1, int radix_shift, int f, BOOL is_int, int e)
  894|  1.18M|{
  895|  1.18M|    int e_offset, d, n, n0;
  896|       |
  897|  1.18M|    e_offset = -f * radix_shift;
  898|  1.18M|    if (radix1 != 1) {
  899|  1.18M|        d = digits_per_limb_table[radix1 - 2];
  900|  1.18M|        if (f >= 0) {
  901|   980k|            limb_t h, b;
  902|       |            
  903|   980k|            b = 0;
  904|   980k|            n0 = 0;
  905|  3.06M|            while (f != 0) {
  906|  2.08M|                n = min_int(f, d);
  907|  2.08M|                if (n != n0) {
  908|   375k|                    b = pow_ui(radix1, n);
  909|   375k|                    n0 = n;
  910|   375k|                }
  911|  2.08M|                h = mp_mul1(a->tab, a->tab, a->len, b, 0);
  912|  2.08M|                if (h != 0) {
  913|  1.85M|                    a->tab[a->len++] = h;
  914|  1.85M|                }
  915|  2.08M|                f -= n;
  916|  2.08M|            }
  917|   980k|        } else {
  918|   204k|            int extra_bits, l, shift;
  919|   204k|            limb_t r, rem, b, b_inv;
  920|       |            
  921|   204k|            f = -f;
  922|   204k|            l = (f + d - 1) / d; /* high bound for the number of limbs (XXX: make it better) */
  923|   204k|            e_offset += l * LIMB_BITS;
  924|   204k|            if (!is_int) {
  925|       |                /* at least 'e' bits are needed in the final result for rounding */
  926|   126k|                extra_bits = max_int(e - mpb_floor_log2(a), 0);
  927|   126k|            } else {
  928|       |                /* at least two extra bits are needed in the final result
  929|       |                   for rounding */
  930|  77.4k|                extra_bits = max_int(2 + e - e_offset, 0);
  931|  77.4k|            }
  932|   204k|            e_offset += extra_bits;
  933|   204k|            mpb_shr_round(a, -(l * LIMB_BITS + extra_bits), JS_RNDZ);
  934|       |            
  935|   204k|            b = 0;
  936|   204k|            b_inv = 0;
  937|   204k|            shift = 0;
  938|   204k|            n0 = 0;
  939|   204k|            rem = 0;
  940|  2.19M|            while (f != 0) {
  941|  1.98M|                n = min_int(f, d);
  942|  1.98M|                if (n != n0) {
  943|   326k|                    b = pow_ui_inv(&b_inv, &shift, radix1, n);
  944|   326k|                    n0 = n;
  945|   326k|                }
  946|  1.98M|                r = mp_div1norm(a->tab, a->tab, a->len, b, 0, b_inv, shift);
  947|  1.98M|                rem |= r;
  948|  1.98M|                mpb_renorm(a);
  949|  1.98M|                f -= n;
  950|  1.98M|            }
  951|       |            /* if the remainder is non zero, use it for rounding */
  952|   204k|            a->tab[0] |= (rem != 0);
  953|   204k|        }
  954|  1.18M|    }
  955|  1.18M|    return e_offset;
  956|  1.18M|}
  957|       |
  958|       |/* tmp1 = round(m*2^e*radix^f). 'tmp0' is a temporary storage */
  959|       |static void mul_pow_round(mpb_t *tmp1, uint64_t m, int e, int radix1, int radix_shift, int f,
  960|       |                          int rnd_mode)
  961|   232k|{
  962|   232k|    int e_offset;
  963|       |
  964|   232k|    mpb_set_u64(tmp1, m);
  965|   232k|    e_offset = mul_pow(tmp1, radix1, radix_shift, f, TRUE, e);
  966|   232k|    mpb_shr_round(tmp1, -e + e_offset, rnd_mode);
  967|   232k|}
  968|       |
  969|       |/* return round(a*2^e_offset) rounded as a float64. 'a' is modified */
  970|       |static uint64_t round_to_d(int *pe, mpb_t *a, int e_offset, int rnd_mode)
  971|   955k|{
  972|   955k|    int e;
  973|   955k|    uint64_t m;
  974|       |
  975|   955k|    if (a->tab[0] == 0 && a->len == 1) {
  976|       |        /* zero result */
  977|      0|        m = 0;
  978|      0|        e = 0; /* don't care */
  979|   955k|    } else {
  980|   955k|        int prec, prec1, e_min;
  981|   955k|        e = mpb_floor_log2(a) + 1 - e_offset;
  982|   955k|        prec1 = 53;
  983|   955k|        e_min = -1021;
  984|   955k|        if (e < e_min) {
  985|       |            /* subnormal result or zero */
  986|  63.8k|            prec = prec1 - (e_min - e);
  987|   891k|        } else {
  988|   891k|            prec = prec1;
  989|   891k|        }
  990|   955k|        mpb_shr_round(a, e + e_offset - prec, rnd_mode);
  991|   955k|        m = mpb_get_u64(a);
  992|   955k|        m <<= (53 - prec);
  993|       |        /* mantissa overflow due to rounding */
  994|   955k|        if (m >= (uint64_t)1 << 53) {
  995|    280|            m >>= 1;
  996|    280|            e++;
  997|    280|        }
  998|   955k|    }
  999|   955k|    *pe = e;
 1000|   955k|    return m;
 1001|   955k|}
 1002|       |
 1003|       |/* return (m, e) such that m*2^(e-53) = round(a * radix^f) with 2^52
 1004|       |   <= m < 2^53 or m = 0.
 1005|       |   'a' is modified. */
 1006|       |static uint64_t mul_pow_round_to_d(int *pe, mpb_t *a,
 1007|       |                                   int radix1, int radix_shift, int f, int rnd_mode)
 1008|   952k|{
 1009|   952k|    int e_offset;
 1010|       |
 1011|   952k|    e_offset = mul_pow(a, radix1, radix_shift, f, FALSE, 55);
 1012|   952k|    return round_to_d(pe, a, e_offset, rnd_mode);
 1013|   952k|}
 1014|       |
 1015|       |#ifdef JS_DTOA_DUMP_STATS
 1016|       |static int out_len_count[17];
 1017|       |
 1018|       |void js_dtoa_dump_stats(void)
 1019|       |{
 1020|       |    int i, sum;
 1021|       |    sum = 0;
 1022|       |    for(i = 0; i < 17; i++)
 1023|       |        sum += out_len_count[i];
 1024|       |    for(i = 0; i < 17; i++) {
 1025|       |        printf("%2d %8d %5.2f%%\n",
 1026|       |               i + 1, out_len_count[i], (double)out_len_count[i] / sum * 100);
 1027|       |    }
 1028|       |}
 1029|       |#endif
 1030|       |
 1031|       |/* return a maximum bound of the string length. The bound depends on
 1032|       |   'd' only if format = JS_DTOA_FORMAT_FRAC or if JS_DTOA_EXP_DISABLED
 1033|       |   is enabled. */
 1034|       |int js_dtoa_max_len(double d, int radix, int n_digits, int flags)
 1035|   239k|{
 1036|   239k|    int fmt = flags & JS_DTOA_FORMAT_MASK;
 1037|   239k|    int n, e;
 1038|   239k|    uint64_t a;
 1039|       |
 1040|   239k|    if (fmt != JS_DTOA_FORMAT_FRAC) {
 1041|   239k|        if (fmt == JS_DTOA_FORMAT_FREE) {
 1042|   239k|            n = dtoa_max_digits_table[radix - 2];
 1043|   239k|        } else {
 1044|      0|            n = n_digits;
 1045|      0|        }
 1046|   239k|        if ((flags & JS_DTOA_EXP_MASK) == JS_DTOA_EXP_DISABLED) {
 1047|       |            /* no exponential */
 1048|      0|            a = float64_as_uint64(d);
 1049|      0|            e = (a >> 52) & 0x7ff;
 1050|      0|            if (e == 0x7ff) {
 1051|       |                /* NaN, Infinity */
 1052|      0|                n = 0;
 1053|      0|            } else {
 1054|      0|                e -= 1023;
 1055|       |                /* XXX: adjust */
 1056|      0|                n += 10 + abs(mul_log2_radix(e - 1, radix));
 1057|      0|            }
 1058|   239k|        } else {
 1059|       |            /* extra: sign, 1 dot and exponent "e-1000" */
 1060|   239k|            n += 1 + 1 + 6;
 1061|   239k|        }
 1062|   239k|    } else {
 1063|      0|        a = float64_as_uint64(d);
 1064|      0|        e = (a >> 52) & 0x7ff;
 1065|      0|        if (e == 0x7ff) {
 1066|       |            /* NaN, Infinity */
 1067|      0|            n = 0;
 1068|      0|        } else {
 1069|       |            /* high bound for the integer part */
 1070|      0|            e -= 1023;
 1071|       |            /* x < 2^(e + 1) */
 1072|      0|            if (e < 0) {
 1073|      0|                n = 1;
 1074|      0|            } else {
 1075|      0|                n = 2 + mul_log2_radix(e - 1, radix);
 1076|      0|            }
 1077|       |            /* sign, extra digit, 1 dot */
 1078|      0|            n += 1 + 1 + 1 + n_digits;
 1079|      0|        }
 1080|      0|    }
 1081|   239k|    return max_int(n, 9); /* also include NaN and [-]Infinity */
 1082|   239k|}
 1083|       |
 1084|       |#if defined(__SANITIZE_ADDRESS__) && 0
 1085|       |static void *dtoa_malloc(uint64_t **pptr, size_t size)
 1086|       |{
 1087|       |    return malloc(size);
 1088|       |}
 1089|       |static void dtoa_free(void *ptr)
 1090|       |{
 1091|       |    free(ptr);
 1092|       |}
 1093|       |#else
 1094|       |static void *dtoa_malloc(uint64_t **pptr, size_t size)
 1095|  1.30M|{
 1096|  1.30M|    void *ret;
 1097|  1.30M|    ret = *pptr;
 1098|  1.30M|    *pptr += (size + 7) / 8;
 1099|  1.30M|    return ret;
 1100|  1.30M|}
 1101|       |
 1102|       |static void dtoa_free(void *ptr)
 1103|  1.30M|{
 1104|  1.30M|}
 1105|       |#endif
 1106|       |
 1107|       |/* return the length */
 1108|       |int js_dtoa(char *buf, double d, int radix, int n_digits, int flags,
 1109|       |            JSDTOATempMem *tmp_mem)
 1110|   239k|{
 1111|   239k|    uint64_t a, m, *mptr = tmp_mem->mem;
 1112|   239k|    int e, sgn, l, E, P, i, E_max, radix1, radix_shift;
 1113|   239k|    char *q;
 1114|   239k|    mpb_t *tmp1, *mant_max;
 1115|   239k|    int fmt = flags & JS_DTOA_FORMAT_MASK;
 1116|       |
 1117|   239k|    tmp1 = dtoa_malloc(&mptr, sizeof(mpb_t) + sizeof(limb_t) * DBIGNUM_LEN_MAX);
 1118|   239k|    mant_max = dtoa_malloc(&mptr, sizeof(mpb_t) + sizeof(limb_t) * MANT_LEN_MAX);
 1119|   239k|    assert((mptr - tmp_mem->mem) <= sizeof(JSDTOATempMem) / sizeof(mptr[0]));
 1120|       |
 1121|   239k|    radix_shift = ctz32(radix);
 1122|   239k|    radix1 = radix >> radix_shift;
 1123|   239k|    a = float64_as_uint64(d);
 1124|   239k|    sgn = a >> 63;
 1125|   239k|    e = (a >> 52) & 0x7ff;
 1126|   239k|    m = a & (((uint64_t)1 << 52) - 1);
 1127|   239k|    q = buf;
 1128|   239k|    if (e == 0x7ff) {
 1129|  92.6k|        if (m == 0) {
 1130|  58.3k|            if (sgn)
 1131|  7.42k|                *q++ = '-';
 1132|  58.3k|            memcpy(q, "Infinity", 8);
 1133|  58.3k|            q += 8;
 1134|  58.3k|        } else {
 1135|  34.2k|            memcpy(q, "NaN", 3);
 1136|  34.2k|            q += 3;
 1137|  34.2k|        }
 1138|  92.6k|        goto done;
 1139|   147k|    } else if (e == 0) {
 1140|  11.3k|        if (m == 0) {
 1141|  3.21k|            tmp1->len = 1;
 1142|  3.21k|            tmp1->tab[0] = 0;
 1143|  3.21k|            E = 1;
 1144|  3.21k|            if (fmt == JS_DTOA_FORMAT_FREE)
 1145|  3.21k|                P = 1;
 1146|      0|            else if (fmt == JS_DTOA_FORMAT_FRAC)
 1147|      0|                P = n_digits + 1;
 1148|      0|            else
 1149|      0|                P = n_digits;
 1150|  3.21k|            goto output;
 1151|  3.21k|        }
 1152|       |        /* denormal number: convert to a normal number */
 1153|  8.16k|        l = clz64(m) - 11;
 1154|  8.16k|        e -= l - 1;
 1155|  8.16k|        m <<= l;
 1156|   135k|    } else {
 1157|   135k|        m |= (uint64_t)1 << 52;
 1158|   135k|    }
 1159|       |    /* remove the bias */
 1160|   144k|    e -= 1022;
 1161|       |    /* d = 2^(e-53)*m */
 1162|       |    //    printf("m=0x%016" PRIx64 " e=%d\n", m, e);
 1163|   144k|#ifdef USE_FAST_INT
 1164|   144k|    if (fmt == JS_DTOA_FORMAT_FREE &&
 1165|   144k|        e >= 1 && e <= 53 &&
 1166|   144k|        (m & (((uint64_t)1 << (53 - e)) - 1)) == 0 &&
 1167|   144k|        (flags & JS_DTOA_EXP_MASK) != JS_DTOA_EXP_ENABLED) {
 1168|  71.9k|        m >>= 53 - e;
 1169|       |        /* 'm' is never zero */
 1170|  71.9k|        if (sgn)
 1171|  14.1k|            *q++ = '-';
 1172|  71.9k|        q += u64toa_radix(q, m, radix);
 1173|  71.9k|        goto done;
 1174|  71.9k|    }
 1175|  72.1k|#endif
 1176|       |    
 1177|       |    /* this choice of E implies F=round(x*B^(P-E) is such as: 
 1178|       |       B^(P-1) <= F < 2.B^P. */
 1179|  72.1k|    E = 1 + mul_log2_radix(e - 1, radix);
 1180|       |    
 1181|  72.1k|    if (fmt == JS_DTOA_FORMAT_FREE) {
 1182|  72.1k|        int P_max, E0, e1, E_found, P_found;
 1183|  72.1k|        uint64_t m1, mant_found, mant, mant_max1;
 1184|       |        /* P_max is guarranteed to work by construction */
 1185|  72.1k|        P_max = dtoa_max_digits_table[radix - 2];
 1186|  72.1k|        E0 = E;
 1187|  72.1k|        E_found = 0;
 1188|  72.1k|        P_found = 0;
 1189|  72.1k|        mant_found = 0;
 1190|       |        /* find the minimum number of digits by successive tries */
 1191|  72.1k|        P = P_max; /* P_max is guarateed to work */
 1192|   230k|        for(;;) {
 1193|       |            /* mant_max always fits on 64 bits */
 1194|   230k|            mant_max1 = pow_ui(radix, P);
 1195|       |            /* compute the mantissa in base B */
 1196|   230k|            E = E0;
 1197|   232k|            for(;;) {
 1198|       |                /* XXX: add inexact flag */
 1199|   232k|                mul_pow_round(tmp1, m, e - 53, radix1, radix_shift, P - E, JS_RNDN);
 1200|   232k|                mant = mpb_get_u64(tmp1);
 1201|   232k|                if (mant < mant_max1)
 1202|   230k|                    break;
 1203|  1.31k|                E++; /* at most one iteration is possible */
 1204|  1.31k|            }
 1205|       |            /* remove useless trailing zero digits */
 1206|   657k|            while ((mant % radix) == 0) {
 1207|   427k|                mant /= radix;
 1208|   427k|                P--;
 1209|   427k|            }
 1210|       |            /* garanteed to work for P = P_max */
 1211|   230k|            if (P_found == 0)
 1212|  72.1k|                goto prec_found;
 1213|       |            /* convert back to base 2 */
 1214|   158k|            mpb_set_u64(tmp1, mant);
 1215|   158k|            m1 = mul_pow_round_to_d(&e1, tmp1, radix1, radix_shift, E - P, JS_RNDN);
 1216|       |            //            printf("P=%2d: m=0x%016" PRIx64 " e=%d m1=0x%016" PRIx64 " e1=%d\n", P, m, e, m1, e1);
 1217|       |            /* Note: (m, e) is never zero here, so the exponent for m1
 1218|       |               = 0 does not matter */
 1219|   158k|            if (m1 == m && e1 == e) {
 1220|   163k|            prec_found:
 1221|   163k|                P_found = P;
 1222|   163k|                E_found = E;
 1223|   163k|                mant_found = mant;
 1224|   163k|                if (P == 1)
 1225|  5.32k|                    break;
 1226|   158k|                P--; /* try lower exponent */
 1227|   158k|            } else {
 1228|  66.8k|                break;
 1229|  66.8k|            }
 1230|   158k|        }
 1231|  72.1k|        P = P_found;
 1232|  72.1k|        E = E_found;
 1233|  72.1k|        mpb_set_u64(tmp1, mant_found);
 1234|       |#ifdef JS_DTOA_DUMP_STATS
 1235|       |        if (radix == 10) {
 1236|       |            out_len_count[P - 1]++;
 1237|       |        }
 1238|       |#endif        
 1239|  72.1k|    } else if (fmt == JS_DTOA_FORMAT_FRAC) {
 1240|      0|        int len;
 1241|       |
 1242|      0|        assert(n_digits >= 0 && n_digits <= JS_DTOA_MAX_DIGITS);
 1243|       |        /* P = max_int(E, 1) + n_digits; */
 1244|       |        /* frac is rounded using RNDNA */
 1245|      0|        mul_pow_round(tmp1, m, e - 53, radix1, radix_shift, n_digits, JS_RNDNA);
 1246|       |
 1247|       |        /* "-0" is displayed as "0" */
 1248|      0|        if (sgn && !(tmp1->tab[0] == 0 && tmp1->len == 1)) {
 1249|      0|            *q++ = '-';
 1250|      0|        }
 1251|       |        /* we add one extra digit on the left and remove it if needed
 1252|       |           to avoid testing if the result is < radix^P */
 1253|      0|        len = output_digits(q, tmp1, radix, max_int(E + 1, 1) + n_digits,
 1254|      0|                            max_int(E + 1, 1));
 1255|      0|        if (q[0] == '0' && len >= 2 && q[1] != '.') {
 1256|      0|            len--;
 1257|      0|            memmove(q, q + 1, len);
 1258|      0|        }
 1259|      0|        q += len;
 1260|      0|        goto done;
 1261|      0|    } else {
 1262|      0|        int pow_shift;
 1263|      0|        assert(n_digits >= 1 && n_digits <= JS_DTOA_MAX_DIGITS);
 1264|      0|        P = n_digits;
 1265|       |        /* mant_max = radix^P */
 1266|      0|        mant_max->len = 1;
 1267|      0|        mant_max->tab[0] = 1;
 1268|      0|        pow_shift = mul_pow(mant_max, radix1, radix_shift, P, FALSE, 0);
 1269|      0|        mpb_shr_round(mant_max, pow_shift, JS_RNDZ);
 1270|       |        
 1271|      0|        for(;;) {
 1272|       |            /* fixed and frac are rounded using RNDNA */
 1273|      0|            mul_pow_round(tmp1, m, e - 53, radix1, radix_shift, P - E, JS_RNDNA);
 1274|      0|            if (mpb_cmp(tmp1, mant_max) < 0)
 1275|      0|                break;
 1276|      0|            E++; /* at most one iteration is possible */
 1277|      0|        }
 1278|      0|    }
 1279|  75.3k| output:
 1280|       |    /* "-0" is displayed as "0" if JS_DTOA_MINUS_ZERO is not present */
 1281|  75.3k|    if (sgn && ((flags & JS_DTOA_MINUS_ZERO) ||
 1282|  1.86k|                !(tmp1->tab[0] == 0 && tmp1->len == 1))) {
 1283|  1.07k|        *q++ = '-';
 1284|  1.07k|    }
 1285|  75.3k|    if (fmt == JS_DTOA_FORMAT_FIXED)
 1286|      0|        E_max = n_digits;
 1287|  75.3k|    else
 1288|  75.3k|        E_max = dtoa_max_digits_table[radix - 2] + 4;
 1289|  75.3k|    if ((flags & JS_DTOA_EXP_MASK) == JS_DTOA_EXP_ENABLED ||
 1290|  75.3k|        ((flags & JS_DTOA_EXP_MASK) == JS_DTOA_EXP_AUTO && (E <= -6 || E > E_max))) {
 1291|  35.4k|        q += output_digits(q, tmp1, radix, P, 1);
 1292|  35.4k|        E--;
 1293|  35.4k|        if (radix == 10) {
 1294|  35.4k|            *q++ = 'e';
 1295|  35.4k|        } else if (radix1 == 1 && radix_shift <= 4) {
 1296|      0|            E *= radix_shift;
 1297|      0|            *q++ = 'p';
 1298|      0|        } else {
 1299|      0|            *q++ = '@';
 1300|      0|        }
 1301|  35.4k|        if (E < 0) {
 1302|  10.2k|            *q++ = '-';
 1303|  10.2k|            E = -E;
 1304|  25.1k|        } else {
 1305|  25.1k|            *q++ = '+';
 1306|  25.1k|        }
 1307|  35.4k|        q += u32toa(q, E);
 1308|  39.9k|    } else if (E <= 0) {
 1309|  26.0k|        *q++ = '0';
 1310|  26.0k|        *q++ = '.';
 1311|  31.9k|        for(i = 0; i < -E; i++)
 1312|  5.94k|            *q++ = '0';
 1313|  26.0k|        q += output_digits(q, tmp1, radix, P, P);
 1314|  26.0k|    } else {
 1315|  13.9k|        q += output_digits(q, tmp1, radix, P, min_int(P, E));
 1316|  39.5k|        for(i = 0; i < E - P; i++)
 1317|  25.6k|            *q++ = '0';
 1318|  13.9k|    }
 1319|   239k| done:
 1320|   239k|    *q = '\0';
 1321|   239k|    dtoa_free(mant_max);
 1322|   239k|    dtoa_free(tmp1);
 1323|   239k|    return q - buf;
 1324|  75.3k|}
 1325|       |
 1326|       |static inline int to_digit(int c)
 1327|  10.4M|{
 1328|  10.4M|    if (c >= '0' && c <= '9')
 1329|  9.59M|        return c - '0';
 1330|   850k|    else if (c >= 'A' && c <= 'Z')
 1331|  11.7k|        return c - 'A' + 10;
 1332|   838k|    else if (c >= 'a' && c <= 'z')
 1333|  16.6k|        return c - 'a' + 10;
 1334|   821k|    else
 1335|   821k|        return 36;
 1336|  10.4M|}
 1337|       |
 1338|       |/* r = r * radix_base + a. radix_base = 0 means radix_base = 2^32 */
 1339|       |static void mpb_mul1_base(mpb_t *r, limb_t radix_base, limb_t a)
 1340|   967k|{
 1341|   967k|    int i;
 1342|   967k|    if (r->tab[0] == 0 && r->len == 1) {
 1343|   809k|        r->tab[0] = a;
 1344|   809k|    } else {
 1345|   157k|        if (radix_base == 0) {
 1346|  1.14k|            for(i = r->len; i >= 0; i--) {
 1347|    762|                r->tab[i + 1] = r->tab[i];
 1348|    762|            }
 1349|    381|            r->tab[0] = a;
 1350|   157k|        } else {
 1351|   157k|            r->tab[r->len] = mp_mul1(r->tab, r->tab, r->len,
 1352|   157k|                                     radix_base, a);
 1353|   157k|        }
 1354|   157k|        r->len++;
 1355|   157k|        mpb_renorm(r);
 1356|   157k|    }
 1357|   967k|}
 1358|       |
 1359|       |/* XXX: add fast path for small integers */
 1360|       |double js_atod(const char *str, const char **pnext, int radix, int flags,
 1361|       |               JSATODTempMem *tmp_mem)
 1362|   821k|{
 1363|   821k|    uint64_t *mptr = tmp_mem->mem;
 1364|   821k|    const char *p, *p_start;
 1365|   821k|    limb_t cur_limb, radix_base, extra_digits;
 1366|   821k|    int is_neg, digit_count, limb_digit_count, digits_per_limb, sep, radix1, radix_shift;
 1367|   821k|    int radix_bits, expn, e, max_digits, expn_offset, dot_pos, sig_pos, pos;
 1368|   821k|    mpb_t *tmp0;
 1369|   821k|    double dval;
 1370|   821k|    BOOL is_bin_exp, is_zero, expn_overflow;
 1371|   821k|    uint64_t m, a;
 1372|       |
 1373|   821k|    tmp0 = dtoa_malloc(&mptr, sizeof(mpb_t) + sizeof(limb_t) * DBIGNUM_LEN_MAX);
 1374|   821k|    assert((mptr - tmp_mem->mem) <= sizeof(JSATODTempMem) / sizeof(mptr[0]));
 1375|       |    /* optional separator between digits */
 1376|   821k|    sep = (flags & JS_ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;
 1377|       |
 1378|   821k|    p = str;
 1379|   821k|    is_neg = 0;
 1380|   821k|    if (p[0] == '+') {
 1381|      0|        p++;
 1382|      0|        p_start = p;
 1383|   821k|    } else if (p[0] == '-') {
 1384|  1.01k|        is_neg = 1;
 1385|  1.01k|        p++;
 1386|  1.01k|        p_start = p;
 1387|   820k|    } else {
 1388|   820k|        p_start = p;
 1389|   820k|    }
 1390|       |    
 1391|   821k|    if (p[0] == '0') {
 1392|  13.9k|        if ((p[1] == 'x' || p[1] == 'X') &&
 1393|  13.9k|            (radix == 0 || radix == 16)) {
 1394|      0|            p += 2;
 1395|      0|            radix = 16;
 1396|  13.9k|        } else if ((p[1] == 'o' || p[1] == 'O') &&
 1397|  13.9k|                   radix == 0 && (flags & JS_ATOD_ACCEPT_BIN_OCT)) {
 1398|      0|            p += 2;
 1399|      0|            radix = 8;
 1400|  13.9k|        } else if ((p[1] == 'b' || p[1] == 'B') &&
 1401|  13.9k|                   radix == 0 && (flags & JS_ATOD_ACCEPT_BIN_OCT)) {
 1402|      0|            p += 2;
 1403|      0|            radix = 2;
 1404|  13.9k|        } else if ((p[1] >= '0' && p[1] <= '9') &&
 1405|  13.9k|                   radix == 0 && (flags & JS_ATOD_ACCEPT_LEGACY_OCTAL)) {
 1406|      0|            int i;
 1407|      0|            sep = 256;
 1408|      0|            for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++)
 1409|      0|                continue;
 1410|      0|            if (p[i] == '8' || p[i] == '9')
 1411|      0|                goto no_prefix;
 1412|      0|            p += 1;
 1413|      0|            radix = 8;
 1414|  13.9k|        } else {
 1415|  13.9k|            goto no_prefix;
 1416|  13.9k|        }
 1417|       |        /* there must be a digit after the prefix */
 1418|      0|        if (to_digit((uint8_t)*p) >= radix)
 1419|      0|            goto fail;
 1420|  13.9k|    no_prefix: ;
 1421|   807k|    } else {
 1422|   807k|        if (!(flags & JS_ATOD_INT_ONLY) && strstart(p, "Infinity", &p))
 1423|      0|            goto overflow;
 1424|   807k|    }
 1425|   821k|    if (radix == 0)
 1426|      0|        radix = 10;
 1427|       |
 1428|   821k|    cur_limb = 0;
 1429|   821k|    expn_offset = 0;
 1430|   821k|    digit_count = 0;
 1431|   821k|    limb_digit_count = 0;
 1432|   821k|    max_digits = atod_max_digits_table[radix - 2];
 1433|   821k|    digits_per_limb = digits_per_limb_table[radix - 2];
 1434|   821k|    radix_base = radix_base_table[radix - 2];
 1435|   821k|    radix_shift = ctz32(radix);
 1436|   821k|    radix1 = radix >> radix_shift;
 1437|   821k|    if (radix1 == 1) {
 1438|       |        /* radix = 2^radix_bits */
 1439|  4.01k|        radix_bits = radix_shift;
 1440|   817k|    } else {
 1441|   817k|        radix_bits = 0;
 1442|   817k|    }
 1443|   821k|    tmp0->len = 1;
 1444|   821k|    tmp0->tab[0] = 0;
 1445|   821k|    extra_digits = 0;
 1446|   821k|    pos = 0;
 1447|   821k|    dot_pos = -1;
 1448|       |    /* skip leading zeros */
 1449|   892k|    for(;;) {
 1450|   892k|        if (*p == '.' && (p > p_start || to_digit(p[1]) < radix) &&
 1451|   892k|            !(flags & JS_ATOD_INT_ONLY)) {
 1452|  3.19k|            if (*p == sep)
 1453|      0|                goto fail;
 1454|  3.19k|            if (dot_pos >= 0)
 1455|      0|                break;
 1456|  3.19k|            dot_pos = pos;
 1457|  3.19k|            p++;
 1458|  3.19k|        }
 1459|   892k|        if (*p == sep && p > p_start && p[1] == '0')
 1460|      0|            p++;
 1461|   892k|        if (*p != '0')
 1462|   821k|            break;
 1463|  70.2k|        p++;
 1464|  70.2k|        pos++;
 1465|  70.2k|    }
 1466|       |    
 1467|   821k|    sig_pos = pos;
 1468|  10.3M|    for(;;) {
 1469|  10.3M|        limb_t c;
 1470|  10.3M|        if (*p == '.' && (p > p_start || to_digit(p[1]) < radix) &&
 1471|  10.3M|            !(flags & JS_ATOD_INT_ONLY)) {
 1472|  46.4k|            if (*p == sep)
 1473|      0|                goto fail;
 1474|  46.4k|            if (dot_pos >= 0)
 1475|      0|                break;
 1476|  46.4k|            dot_pos = pos;
 1477|  46.4k|            p++;
 1478|  46.4k|        }
 1479|  10.3M|        if (*p == sep && p > p_start && to_digit(p[1]) < radix)
 1480|      0|            p++;
 1481|  10.3M|        c = to_digit(*p);
 1482|  10.3M|        if (c >= radix)
 1483|   821k|            break;
 1484|  9.50M|        p++;
 1485|  9.50M|        pos++;
 1486|  9.50M|        if (digit_count < max_digits) {
 1487|       |            /* XXX: could be faster when radix_bits != 0 */
 1488|  2.95M|            cur_limb = cur_limb * radix + c;
 1489|  2.95M|            limb_digit_count++;
 1490|  2.95M|            if (limb_digit_count == digits_per_limb) {
 1491|   168k|                mpb_mul1_base(tmp0, radix_base, cur_limb);
 1492|   168k|                cur_limb = 0;
 1493|   168k|                limb_digit_count = 0;
 1494|   168k|            }
 1495|  2.95M|            digit_count++;
 1496|  6.55M|        } else {
 1497|  6.55M|            extra_digits |= c;
 1498|  6.55M|        }
 1499|  9.50M|    }
 1500|   821k|    if (limb_digit_count != 0) {
 1501|   798k|        mpb_mul1_base(tmp0, pow_ui(radix, limb_digit_count), cur_limb);
 1502|   798k|    }
 1503|   821k|    if (digit_count == 0) {
 1504|  12.1k|        is_zero = TRUE;
 1505|  12.1k|        expn_offset = 0;
 1506|   809k|    } else {
 1507|   809k|        is_zero = FALSE;
 1508|   809k|        if (dot_pos < 0)
 1509|   760k|            dot_pos = pos;
 1510|   809k|        expn_offset = sig_pos + digit_count - dot_pos;
 1511|   809k|    }
 1512|       |    
 1513|       |    /* Use the extra digits for rounding if the base is a power of
 1514|       |       two. Otherwise they are just truncated. */
 1515|   821k|    if (radix_bits != 0 && extra_digits != 0) {
 1516|    862|        tmp0->tab[0] |= 1;
 1517|    862|    }
 1518|       |    
 1519|       |    /* parse the exponent, if any */
 1520|   821k|    expn = 0;
 1521|   821k|    expn_overflow = FALSE;
 1522|   821k|    is_bin_exp = FALSE;
 1523|   821k|    if (!(flags & JS_ATOD_INT_ONLY) &&
 1524|   821k|        ((radix == 10 && (*p == 'e' || *p == 'E')) ||
 1525|  65.3k|         (radix != 10 && (*p == '@' ||
 1526|      0|                          (radix_bits >= 1 && radix_bits <= 4 && (*p == 'p' || *p == 'P'))))) &&
 1527|   821k|        p > p_start) {
 1528|  24.0k|        BOOL exp_is_neg;
 1529|  24.0k|        int c;
 1530|  24.0k|        is_bin_exp = (*p == 'p' || *p == 'P');
 1531|  24.0k|        p++;
 1532|  24.0k|        exp_is_neg = 0;
 1533|  24.0k|        if (*p == '+') {
 1534|  2.93k|            p++;
 1535|  21.1k|        } else if (*p == '-') {
 1536|  9.39k|            exp_is_neg = 1;
 1537|  9.39k|            p++;
 1538|  9.39k|        }
 1539|  24.0k|        c = to_digit(*p);
 1540|  24.0k|        if (c >= 10)
 1541|      0|            goto fail; /* XXX: could stop before the exponent part */
 1542|  24.0k|        expn = c;
 1543|  24.0k|        p++;
 1544|  88.8k|        for(;;) {
 1545|  88.8k|            if (*p == sep && to_digit(p[1]) < 10)
 1546|      0|                p++;
 1547|  88.8k|            c = to_digit(*p);
 1548|  88.8k|            if (c >= 10)
 1549|  24.0k|                break;
 1550|  64.8k|            if (!expn_overflow) {
 1551|  51.1k|                if (unlikely(expn > ((INT32_MAX - 2 - 9) / 10))) {
 1552|  1.71k|                    expn_overflow = TRUE;
 1553|  49.4k|                } else {
 1554|  49.4k|                    expn = expn * 10 + c;
 1555|  49.4k|                }
 1556|  51.1k|            }
 1557|  64.8k|            p++;
 1558|  64.8k|        }
 1559|  24.0k|        if (exp_is_neg)
 1560|  9.39k|            expn = -expn;
 1561|       |        /* if zero result, the exponent can be arbitrarily large */
 1562|  24.0k|        if (!is_zero && expn_overflow) {
 1563|  1.71k|            if (exp_is_neg)
 1564|      1|                a = 0;
 1565|  1.71k|            else
 1566|  1.71k|                a = (uint64_t)0x7ff << 52; /* infinity */
 1567|  1.71k|            goto done;
 1568|  1.71k|        }
 1569|  24.0k|    }
 1570|       |
 1571|   820k|    if (p == p_start)
 1572|      0|        goto fail;
 1573|       |
 1574|   820k|    if (is_zero) {
 1575|  12.1k|        a = 0;
 1576|   808k|    } else {
 1577|   808k|        int expn1;
 1578|   808k|        if (radix_bits != 0) {
 1579|  3.09k|            if (!is_bin_exp)
 1580|  3.09k|                expn *= radix_bits;
 1581|  3.09k|            expn -= expn_offset * radix_bits;
 1582|  3.09k|            expn1 = expn + digit_count * radix_bits;
 1583|  3.09k|            if (expn1 >= 1024 + radix_bits)
 1584|    209|                goto overflow;
 1585|  2.88k|            else if (expn1 <= -1075)
 1586|      0|                goto underflow;
 1587|  2.88k|            m = round_to_d(&e, tmp0, -expn, JS_RNDN);
 1588|   804k|        } else {
 1589|   804k|            expn -= expn_offset;
 1590|   804k|            expn1 = expn + digit_count;
 1591|   804k|            if (expn1 >= max_exponent[radix - 2] + 1)
 1592|  10.7k|                goto overflow;
 1593|   794k|            else if (expn1 <= min_exponent[radix - 2])
 1594|    223|                goto underflow;
 1595|   793k|            m = mul_pow_round_to_d(&e, tmp0, radix1, radix_shift, expn, JS_RNDN);
 1596|   793k|        }
 1597|   796k|        if (m == 0) {
 1598|    574|        underflow:
 1599|    574|            a = 0;
 1600|   796k|        } else if (e > 1024) {
 1601|  11.1k|        overflow:
 1602|       |            /* overflow */
 1603|  11.1k|            a = (uint64_t)0x7ff << 52;
 1604|   796k|        } else if (e < -1073) {
 1605|       |            /* underflow */
 1606|       |            /* XXX: check rounding */
 1607|      0|            a = 0;
 1608|   796k|        } else if (e < -1021) {
 1609|       |            /* subnormal */
 1610|  8.16k|            a = m >> (-e - 1021);
 1611|   788k|        } else {
 1612|   788k|            a = ((uint64_t)(e + 1022) << 52) | (m & (((uint64_t)1 << 52) - 1));
 1613|   788k|        }
 1614|   796k|    }
 1615|   821k| done:
 1616|   821k|    a |= (uint64_t)is_neg << 63;
 1617|   821k|    dval = uint64_as_float64(a);
 1618|   821k| done1:
 1619|   821k|    if (pnext)
 1620|      0|        *pnext = p;
 1621|   821k|    dtoa_free(tmp0);
 1622|   821k|    return dval;
 1623|      0| fail:
 1624|      0|    dval = NAN;
 1625|      0|    goto done1;
 1626|   821k|}

/home/eugeneriabinin777/quickjs/dtoa.h:
    1|       |/*
    2|       | * Tiny float64 printing and parsing library
    3|       | *
    4|       | * Copyright (c) 2024 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |
   25|       |//#define JS_DTOA_DUMP_STATS
   26|       |
   27|       |/* maximum number of digits for fixed and frac formats */
   28|       |#define JS_DTOA_MAX_DIGITS 101
   29|       |
   30|       |/* radix != 10 is only supported with flags = JS_DTOA_FORMAT_FREE */
   31|       |/* use as many digits as necessary */
   32|   843k|#define JS_DTOA_FORMAT_FREE  (0 << 0)
   33|       |/* use n_digits significant digits (1 <= n_digits <= JS_DTOA_MAX_DIGITS) */
   34|  75.3k|#define JS_DTOA_FORMAT_FIXED (1 << 0)
   35|       |/* force fractional format: [-]dd.dd with n_digits fractional digits.
   36|       |   0 <= n_digits <= JS_DTOA_MAX_DIGITS */
   37|   239k|#define JS_DTOA_FORMAT_FRAC  (2 << 0)
   38|   479k|#define JS_DTOA_FORMAT_MASK  (3 << 0)
   39|       |
   40|       |/* select exponential notation either in fixed or free format */
   41|   150k|#define JS_DTOA_EXP_AUTO     (0 << 2)
   42|   222k|#define JS_DTOA_EXP_ENABLED  (1 << 2)
   43|   239k|#define JS_DTOA_EXP_DISABLED (2 << 2)
   44|   462k|#define JS_DTOA_EXP_MASK     (3 << 2)
   45|       |
   46|  1.86k|#define JS_DTOA_MINUS_ZERO   (1 << 4) /* show the minus sign for -0 */
   47|       |
   48|       |/* only accepts integers (no dot, no exponent) */
   49|  2.43M|#define JS_ATOD_INT_ONLY       (1 << 0)
   50|       |/* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */
   51|      0|#define JS_ATOD_ACCEPT_BIN_OCT (1 << 1)
   52|       |/* accept O prefix as octal if radix == 0 and properly formed (Annex B) */
   53|      0|#define JS_ATOD_ACCEPT_LEGACY_OCTAL  (1 << 2)
   54|       |/* accept _ between digits as a digit separator */
   55|   821k|#define JS_ATOD_ACCEPT_UNDERSCORES  (1 << 3)
   56|       |
   57|       |typedef struct {
   58|       |    uint64_t mem[37];
   59|       |} JSDTOATempMem;
   60|       |
   61|       |typedef struct {
   62|       |    uint64_t mem[27];
   63|       |} JSATODTempMem;
   64|       |
   65|       |/* return a maximum bound of the string length */
   66|       |int js_dtoa_max_len(double d, int radix, int n_digits, int flags);
   67|       |/* return the string length */
   68|       |int js_dtoa(char *buf, double d, int radix, int n_digits, int flags,
   69|       |            JSDTOATempMem *tmp_mem);
   70|       |double js_atod(const char *str, const char **pnext, int radix, int flags,
   71|       |               JSATODTempMem *tmp_mem);
   72|       |
   73|       |#ifdef JS_DTOA_DUMP_STATS
   74|       |void js_dtoa_dump_stats(void);
   75|       |#endif
   76|       |
   77|       |/* additional exported functions */
   78|       |size_t u32toa(char *buf, uint32_t n);
   79|       |size_t i32toa(char *buf, int32_t n);
   80|       |size_t u64toa(char *buf, uint64_t n);
   81|       |size_t i64toa(char *buf, int64_t n);
   82|       |size_t u64toa_radix(char *buf, uint64_t n, unsigned int radix);
   83|       |size_t i64toa_radix(char *buf, int64_t n, unsigned int radix);

/home/eugeneriabinin777/quickjs/libregexp.c:
    1|       |/*
    2|       | * Regular Expression Engine
    3|       | *
    4|       | * Copyright (c) 2017-2018 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |#include <stdlib.h>
   25|       |#include <stdio.h>
   26|       |#include <stdarg.h>
   27|       |#include <inttypes.h>
   28|       |#include <string.h>
   29|       |#include <assert.h>
   30|       |
   31|       |#include "cutils.h"
   32|       |#include "libregexp.h"
   33|       |#include "libunicode.h"
   34|       |
   35|       |/*
   36|       |  TODO:
   37|       |
   38|       |  - Add a lock step execution mode (=linear time execution guaranteed)
   39|       |    when the regular expression is "simple" i.e. no backreference nor
   40|       |    complicated lookahead. The opcodes are designed for this execution
   41|       |    model.
   42|       |*/
   43|       |
   44|       |#if defined(TEST)
   45|       |#define DUMP_REOP
   46|       |#endif
   47|       |
   48|       |typedef enum {
   49|       |#define DEF(id, size) REOP_ ## id,
   50|       |#include "libregexp-opcode.h"
   51|       |#undef DEF
   52|       |    REOP_COUNT,
   53|       |} REOPCodeEnum;
   54|       |
   55|   175k|#define CAPTURE_COUNT_MAX 255
   56|    167|#define STACK_SIZE_MAX 255
   57|       |/* must be large enough to have a negligible runtime cost and small
   58|       |   enough to call the interrupt callback often. */
   59|      0|#define INTERRUPT_COUNTER_INIT 10000
   60|       |
   61|       |/* unicode code points */
   62|      0|#define CP_LS   0x2028
   63|      0|#define CP_PS   0x2029
   64|       |
   65|       |#define TMP_BUF_SIZE 128
   66|       |
   67|       |typedef struct {
   68|       |    DynBuf byte_code;
   69|       |    const uint8_t *buf_ptr;
   70|       |    const uint8_t *buf_end;
   71|       |    const uint8_t *buf_start;
   72|       |    int re_flags;
   73|       |    BOOL is_unicode;
   74|       |    BOOL ignore_case;
   75|       |    BOOL dotall;
   76|       |    int capture_count;
   77|       |    int total_capture_count; /* -1 = not computed yet */
   78|       |    int has_named_captures; /* -1 = don't know, 0 = no, 1 = yes */
   79|       |    void *opaque;
   80|       |    DynBuf group_names;
   81|       |    union {
   82|       |        char error_msg[TMP_BUF_SIZE];
   83|       |        char tmp_buf[TMP_BUF_SIZE];
   84|       |    } u;
   85|       |} REParseState;
   86|       |
   87|       |typedef struct {
   88|       |#ifdef DUMP_REOP
   89|       |    const char *name;
   90|       |#endif
   91|       |    uint8_t size;
   92|       |} REOpCode;
   93|       |
   94|       |static const REOpCode reopcode_info[REOP_COUNT] = {
   95|       |#ifdef DUMP_REOP
   96|       |#define DEF(id, size) { #id, size },
   97|       |#else
   98|       |#define DEF(id, size) { size },
   99|       |#endif
  100|       |#include "libregexp-opcode.h"
  101|       |#undef DEF
  102|       |};
  103|       |
  104|  5.46M|#define RE_HEADER_FLAGS         0
  105|  38.1k|#define RE_HEADER_CAPTURE_COUNT 1
  106|  38.1k|#define RE_HEADER_STACK_SIZE    2
  107|  38.1k|#define RE_HEADER_BYTECODE_LEN  3
  108|       |
  109|   114k|#define RE_HEADER_LEN 7
  110|       |
  111|  9.86k|static inline int is_digit(int c) {
  112|  9.86k|    return c >= '0' && c <= '9';
  113|  9.86k|}
  114|       |
  115|       |/* insert 'len' bytes at position 'pos'. Return < 0 if error. */
  116|       |static int dbuf_insert(DynBuf *s, int pos, int len)
  117|  16.7k|{
  118|  16.7k|    if (dbuf_realloc(s, s->size + len))
  119|      0|        return -1;
  120|  16.7k|    memmove(s->buf + pos + len, s->buf + pos, s->size - pos);
  121|  16.7k|    s->size += len;
  122|  16.7k|    return 0;
  123|  16.7k|}
  124|       |
  125|       |static const uint16_t char_range_d[] = {
  126|       |    1,
  127|       |    0x0030, 0x0039 + 1,
  128|       |};
  129|       |
  130|       |/* code point ranges for Zs,Zl or Zp property */
  131|       |static const uint16_t char_range_s[] = {
  132|       |    10,
  133|       |    0x0009, 0x000D + 1,
  134|       |    0x0020, 0x0020 + 1,
  135|       |    0x00A0, 0x00A0 + 1,
  136|       |    0x1680, 0x1680 + 1,
  137|       |    0x2000, 0x200A + 1,
  138|       |    /* 2028;LINE SEPARATOR;Zl;0;WS;;;;;N;;;;; */
  139|       |    /* 2029;PARAGRAPH SEPARATOR;Zp;0;B;;;;;N;;;;; */
  140|       |    0x2028, 0x2029 + 1,
  141|       |    0x202F, 0x202F + 1,
  142|       |    0x205F, 0x205F + 1,
  143|       |    0x3000, 0x3000 + 1,
  144|       |    /* FEFF;ZERO WIDTH NO-BREAK SPACE;Cf;0;BN;;;;;N;BYTE ORDER MARK;;;; */
  145|       |    0xFEFF, 0xFEFF + 1,
  146|       |};
  147|       |
  148|       |static const uint16_t char_range_w[] = {
  149|       |    4,
  150|       |    0x0030, 0x0039 + 1,
  151|       |    0x0041, 0x005A + 1,
  152|       |    0x005F, 0x005F + 1,
  153|       |    0x0061, 0x007A + 1,
  154|       |};
  155|       |
  156|  1.43M|#define CLASS_RANGE_BASE 0x40000000
  157|       |
  158|       |typedef enum {
  159|       |    CHAR_RANGE_d,
  160|       |    CHAR_RANGE_D,
  161|       |    CHAR_RANGE_s,
  162|       |    CHAR_RANGE_S,
  163|       |    CHAR_RANGE_w,
  164|       |    CHAR_RANGE_W,
  165|       |} CharRangeEnum;
  166|       |
  167|       |static const uint16_t * const char_range_table[] = {
  168|       |    char_range_d,
  169|       |    char_range_s,
  170|       |    char_range_w,
  171|       |};
  172|       |
  173|       |static int cr_init_char_range(REParseState *s, CharRange *cr, uint32_t c)
  174|  21.3k|{
  175|  21.3k|    BOOL invert;
  176|  21.3k|    const uint16_t *c_pt;
  177|  21.3k|    int len, i;
  178|       |
  179|  21.3k|    invert = c & 1;
  180|  21.3k|    c_pt = char_range_table[c >> 1];
  181|  21.3k|    len = *c_pt++;
  182|  21.3k|    cr_init(cr, s->opaque, lre_realloc);
  183|   185k|    for(i = 0; i < len * 2; i++) {
  184|   164k|        if (cr_add_point(cr, c_pt[i]))
  185|      0|            goto fail;
  186|   164k|    }
  187|  21.3k|    if (invert) {
  188|  19.9k|        if (cr_invert(cr))
  189|      0|            goto fail;
  190|  19.9k|    }
  191|  21.3k|    return 0;
  192|      0| fail:
  193|      0|    cr_free(cr);
  194|      0|    return -1;
  195|  21.3k|}
  196|       |
  197|       |#ifdef DUMP_REOP
  198|       |static __maybe_unused void lre_dump_bytecode(const uint8_t *buf,
  199|       |                                                     int buf_len)
  200|       |{
  201|       |    int pos, len, opcode, bc_len, re_flags, i;
  202|       |    uint32_t val;
  203|       |
  204|       |    assert(buf_len >= RE_HEADER_LEN);
  205|       |
  206|       |    re_flags = lre_get_flags(buf);
  207|       |    bc_len = get_u32(buf + RE_HEADER_BYTECODE_LEN);
  208|       |    assert(bc_len + RE_HEADER_LEN <= buf_len);
  209|       |    printf("flags: 0x%x capture_count=%d stack_size=%d\n",
  210|       |           re_flags, buf[RE_HEADER_CAPTURE_COUNT], buf[RE_HEADER_STACK_SIZE]);
  211|       |    if (re_flags & LRE_FLAG_NAMED_GROUPS) {
  212|       |        const char *p;
  213|       |        p = (char *)buf + RE_HEADER_LEN + bc_len;
  214|       |        printf("named groups: ");
  215|       |        for(i = 1; i < buf[RE_HEADER_CAPTURE_COUNT]; i++) {
  216|       |            if (i != 1)
  217|       |                printf(",");
  218|       |            printf("<%s>", p);
  219|       |            p += strlen(p) + 1;
  220|       |        }
  221|       |        printf("\n");
  222|       |        assert(p == (char *)(buf + buf_len));
  223|       |    }
  224|       |    printf("bytecode_len=%d\n", bc_len);
  225|       |
  226|       |    buf += RE_HEADER_LEN;
  227|       |    pos = 0;
  228|       |    while (pos < bc_len) {
  229|       |        printf("%5u: ", pos);
  230|       |        opcode = buf[pos];
  231|       |        len = reopcode_info[opcode].size;
  232|       |        if (opcode >= REOP_COUNT) {
  233|       |            printf(" invalid opcode=0x%02x\n", opcode);
  234|       |            break;
  235|       |        }
  236|       |        if ((pos + len) > bc_len) {
  237|       |            printf(" buffer overflow (opcode=0x%02x)\n", opcode);
  238|       |            break;
  239|       |        }
  240|       |        printf("%s", reopcode_info[opcode].name);
  241|       |        switch(opcode) {
  242|       |        case REOP_char:
  243|       |            val = get_u16(buf + pos + 1);
  244|       |            if (val >= ' ' && val <= 126)
  245|       |                printf(" '%c'", val);
  246|       |            else
  247|       |                printf(" 0x%04x", val);
  248|       |            break;
  249|       |        case REOP_char32:
  250|       |            val = get_u32(buf + pos + 1);
  251|       |            if (val >= ' ' && val <= 126)
  252|       |                printf(" '%c'", val);
  253|       |            else
  254|       |                printf(" 0x%08x", val);
  255|       |            break;
  256|       |        case REOP_goto:
  257|       |        case REOP_split_goto_first:
  258|       |        case REOP_split_next_first:
  259|       |        case REOP_loop:
  260|       |        case REOP_lookahead:
  261|       |        case REOP_negative_lookahead:
  262|       |            val = get_u32(buf + pos + 1);
  263|       |            val += (pos + 5);
  264|       |            printf(" %u", val);
  265|       |            break;
  266|       |        case REOP_simple_greedy_quant:
  267|       |            printf(" %u %u %u %u",
  268|       |                   get_u32(buf + pos + 1) + (pos + 17),
  269|       |                   get_u32(buf + pos + 1 + 4),
  270|       |                   get_u32(buf + pos + 1 + 8),
  271|       |                   get_u32(buf + pos + 1 + 12));
  272|       |            break;
  273|       |        case REOP_save_start:
  274|       |        case REOP_save_end:
  275|       |        case REOP_back_reference:
  276|       |        case REOP_backward_back_reference:
  277|       |            printf(" %u", buf[pos + 1]);
  278|       |            break;
  279|       |        case REOP_save_reset:
  280|       |            printf(" %u %u", buf[pos + 1], buf[pos + 2]);
  281|       |            break;
  282|       |        case REOP_push_i32:
  283|       |            val = get_u32(buf + pos + 1);
  284|       |            printf(" %d", val);
  285|       |            break;
  286|       |        case REOP_range:
  287|       |            {
  288|       |                int n, i;
  289|       |                n = get_u16(buf + pos + 1);
  290|       |                len += n * 4;
  291|       |                for(i = 0; i < n * 2; i++) {
  292|       |                    val = get_u16(buf + pos + 3 + i * 2);
  293|       |                    printf(" 0x%04x", val);
  294|       |                }
  295|       |            }
  296|       |            break;
  297|       |        case REOP_range32:
  298|       |            {
  299|       |                int n, i;
  300|       |                n = get_u16(buf + pos + 1);
  301|       |                len += n * 8;
  302|       |                for(i = 0; i < n * 2; i++) {
  303|       |                    val = get_u32(buf + pos + 3 + i * 4);
  304|       |                    printf(" 0x%08x", val);
  305|       |                }
  306|       |            }
  307|       |            break;
  308|       |        default:
  309|       |            break;
  310|       |        }
  311|       |        printf("\n");
  312|       |        pos += len;
  313|       |    }
  314|       |}
  315|       |#endif
  316|       |
  317|       |static void re_emit_op(REParseState *s, int op)
  318|   185k|{
  319|   185k|    dbuf_putc(&s->byte_code, op);
  320|   185k|}
  321|       |
  322|       |/* return the offset of the u32 value */
  323|       |static int re_emit_op_u32(REParseState *s, int op, uint32_t val)
  324|  86.1k|{
  325|  86.1k|    int pos;
  326|  86.1k|    dbuf_putc(&s->byte_code, op);
  327|  86.1k|    pos = s->byte_code.size;
  328|  86.1k|    dbuf_put_u32(&s->byte_code, val);
  329|  86.1k|    return pos;
  330|  86.1k|}
  331|       |
  332|       |static int re_emit_goto(REParseState *s, int op, uint32_t val)
  333|  9.22k|{
  334|  9.22k|    int pos;
  335|  9.22k|    dbuf_putc(&s->byte_code, op);
  336|  9.22k|    pos = s->byte_code.size;
  337|  9.22k|    dbuf_put_u32(&s->byte_code, val - (pos + 4));
  338|  9.22k|    return pos;
  339|  9.22k|}
  340|       |
  341|       |static void re_emit_op_u8(REParseState *s, int op, uint32_t val)
  342|   125k|{
  343|   125k|    dbuf_putc(&s->byte_code, op);
  344|   125k|    dbuf_putc(&s->byte_code, val);
  345|   125k|}
  346|       |
  347|       |static void re_emit_op_u16(REParseState *s, int op, uint32_t val)
  348|   898k|{
  349|   898k|    dbuf_putc(&s->byte_code, op);
  350|   898k|    dbuf_put_u16(&s->byte_code, val);
  351|   898k|}
  352|       |
  353|       |static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)
  354|  1.05k|{
  355|  1.05k|    va_list ap;
  356|  1.05k|    va_start(ap, fmt);
  357|  1.05k|    vsnprintf(s->u.error_msg, sizeof(s->u.error_msg), fmt, ap);
  358|  1.05k|    va_end(ap);
  359|  1.05k|    return -1;
  360|  1.05k|}
  361|       |
  362|       |static int re_parse_out_of_memory(REParseState *s)
  363|      0|{
  364|      0|    return re_parse_error(s, "out of memory");
  365|      0|}
  366|       |
  367|       |/* If allow_overflow is false, return -1 in case of
  368|       |   overflow. Otherwise return INT32_MAX. */
  369|       |static int parse_digits(const uint8_t **pp, BOOL allow_overflow)
  370|  12.3k|{
  371|  12.3k|    const uint8_t *p;
  372|  12.3k|    uint64_t v;
  373|  12.3k|    int c;
  374|       |
  375|  12.3k|    p = *pp;
  376|  12.3k|    v = 0;
  377|  42.9k|    for(;;) {
  378|  42.9k|        c = *p;
  379|  42.9k|        if (c < '0' || c > '9')
  380|  12.2k|            break;
  381|  30.7k|        v = v * 10 + c - '0';
  382|  30.7k|        if (v >= INT32_MAX) {
  383|  2.66k|            if (allow_overflow)
  384|  2.59k|                v = INT32_MAX;
  385|     71|            else
  386|     71|                return -1;
  387|  2.66k|        }
  388|  30.6k|        p++;
  389|  30.6k|    }
  390|  12.2k|    *pp = p;
  391|  12.2k|    return v;
  392|  12.3k|}
  393|       |
  394|       |static int re_parse_expect(REParseState *s, const uint8_t **pp, int c)
  395|  13.1k|{
  396|  13.1k|    const uint8_t *p;
  397|  13.1k|    p = *pp;
  398|  13.1k|    if (*p != c)
  399|    518|        return re_parse_error(s, "expecting '%c'", c);
  400|  12.6k|    p++;
  401|  12.6k|    *pp = p;
  402|  12.6k|    return 0;
  403|  13.1k|}
  404|       |
  405|       |/* Parse an escape sequence, *pp points after the '\':
  406|       |   allow_utf16 value:
  407|       |   0 : no UTF-16 escapes allowed
  408|       |   1 : UTF-16 escapes allowed
  409|       |   2 : UTF-16 escapes allowed and escapes of surrogate pairs are
  410|       |   converted to a unicode character (unicode regexp case).
  411|       |
  412|       |   Return the unicode char and update *pp if recognized,
  413|       |   return -1 if malformed escape,
  414|       |   return -2 otherwise. */
  415|       |int lre_parse_escape(const uint8_t **pp, int allow_utf16)
  416|  80.8k|{
  417|  80.8k|    const uint8_t *p;
  418|  80.8k|    uint32_t c;
  419|       |
  420|  80.8k|    p = *pp;
  421|  80.8k|    c = *p++;
  422|  80.8k|    switch(c) {
  423|    449|    case 'b':
  424|    449|        c = '\b';
  425|    449|        break;
  426|    259|    case 'f':
  427|    259|        c = '\f';
  428|    259|        break;
  429|    279|    case 'n':
  430|    279|        c = '\n';
  431|    279|        break;
  432|    494|    case 'r':
  433|    494|        c = '\r';
  434|    494|        break;
  435|    659|    case 't':
  436|    659|        c = '\t';
  437|    659|        break;
  438|    215|    case 'v':
  439|    215|        c = '\v';
  440|    215|        break;
  441|    286|    case 'x':
  442|  7.76k|    case 'u':
  443|  7.76k|        {
  444|  7.76k|            int h, n, i;
  445|  7.76k|            uint32_t c1;
  446|       |
  447|  7.76k|            if (*p == '{' && allow_utf16) {
  448|  1.89k|                p++;
  449|  1.89k|                c = 0;
  450|  4.58k|                for(;;) {
  451|  4.58k|                    h = from_hex(*p++);
  452|  4.58k|                    if (h < 0)
  453|    950|                        return -1;
  454|  3.63k|                    c = (c << 4) | h;
  455|  3.63k|                    if (c > 0x10FFFF)
  456|    261|                        return -1;
  457|  3.37k|                    if (*p == '}')
  458|    684|                        break;
  459|  3.37k|                }
  460|    684|                p++;
  461|  5.86k|            } else {
  462|  5.86k|                if (c == 'x') {
  463|    286|                    n = 2;
  464|  5.57k|                } else {
  465|  5.57k|                    n = 4;
  466|  5.57k|                }
  467|       |
  468|  5.86k|                c = 0;
  469|  11.4k|                for(i = 0; i < n; i++) {
  470|  10.6k|                    h = from_hex(*p++);
  471|  10.6k|                    if (h < 0) {
  472|  5.11k|                        return -1;
  473|  5.11k|                    }
  474|  5.56k|                    c = (c << 4) | h;
  475|  5.56k|                }
  476|    747|                if (is_hi_surrogate(c) &&
  477|    747|                    allow_utf16 == 2 && p[0] == '\\' && p[1] == 'u') {
  478|       |                    /* convert an escaped surrogate pair into a
  479|       |                       unicode char */
  480|      0|                    c1 = 0;
  481|      0|                    for(i = 0; i < 4; i++) {
  482|      0|                        h = from_hex(p[2 + i]);
  483|      0|                        if (h < 0)
  484|      0|                            break;
  485|      0|                        c1 = (c1 << 4) | h;
  486|      0|                    }
  487|      0|                    if (i == 4 && is_lo_surrogate(c1)) {
  488|      0|                        p += 6;
  489|      0|                        c = from_surrogate(c, c1);
  490|      0|                    }
  491|      0|                }
  492|    747|            }
  493|  7.76k|        }
  494|  1.43k|        break;
  495|  11.6k|    case '0': case '1': case '2': case '3':
  496|  13.0k|    case '4': case '5': case '6': case '7':
  497|  13.0k|        c -= '0';
  498|  13.0k|        if (allow_utf16 == 2) {
  499|       |            /* only accept \0 not followed by digit */
  500|    152|            if (c != 0 || is_digit(*p))
  501|      2|                return -1;
  502|  12.9k|        } else {
  503|       |            /* parse a legacy octal sequence */
  504|  12.9k|            uint32_t v;
  505|  12.9k|            v = *p - '0';
  506|  12.9k|            if (v > 7)
  507|  4.23k|                break;
  508|  8.67k|            c = (c << 3) | v;
  509|  8.67k|            p++;
  510|  8.67k|            if (c >= 32)
  511|  1.09k|                break;
  512|  7.57k|            v = *p - '0';
  513|  7.57k|            if (v > 7)
  514|  1.29k|                break;
  515|  6.28k|            c = (c << 3) | v;
  516|  6.28k|            p++;
  517|  6.28k|        }
  518|  6.43k|        break;
  519|  57.6k|    default:
  520|  57.6k|        return -2;
  521|  80.8k|    }
  522|  16.8k|    *pp = p;
  523|  16.8k|    return c;
  524|  80.8k|}
  525|       |
  526|       |#ifdef CONFIG_ALL_UNICODE
  527|       |/* XXX: we use the same chars for name and value */
  528|       |static BOOL is_unicode_char(int c)
  529|    710|{
  530|    710|    return ((c >= '0' && c <= '9') ||
  531|    710|            (c >= 'A' && c <= 'Z') ||
  532|    710|            (c >= 'a' && c <= 'z') ||
  533|    710|            (c == '_'));
  534|    710|}
  535|       |
  536|       |static int parse_unicode_property(REParseState *s, CharRange *cr,
  537|       |                                  const uint8_t **pp, BOOL is_inv)
  538|    120|{
  539|    120|    const uint8_t *p;
  540|    120|    char name[64], value[64];
  541|    120|    char *q;
  542|    120|    BOOL script_ext;
  543|    120|    int ret;
  544|       |
  545|    120|    p = *pp;
  546|    120|    if (*p != '{')
  547|     78|        return re_parse_error(s, "expecting '{' after \\p");
  548|     42|    p++;
  549|     42|    q = name;
  550|    552|    while (is_unicode_char(*p)) {
  551|    511|        if ((q - name) >= sizeof(name) - 1)
  552|      1|            goto unknown_property_name;
  553|    510|        *q++ = *p++;
  554|    510|    }
  555|     41|    *q = '\0';
  556|     41|    q = value;
  557|     41|    if (*p == '=') {
  558|     10|        p++;
  559|    158|        while (is_unicode_char(*p)) {
  560|    149|            if ((q - value) >= sizeof(value) - 1)
  561|      1|                return re_parse_error(s, "unknown unicode property value");
  562|    148|            *q++ = *p++;
  563|    148|        }
  564|     10|    }
  565|     40|    *q = '\0';
  566|     40|    if (*p != '}')
  567|     15|        return re_parse_error(s, "expecting '}'");
  568|     25|    p++;
  569|       |    //    printf("name=%s value=%s\n", name, value);
  570|       |
  571|     25|    if (!strcmp(name, "Script") || !strcmp(name, "sc")) {
  572|      0|        script_ext = FALSE;
  573|      0|        goto do_script;
  574|     25|    } else if (!strcmp(name, "Script_Extensions") || !strcmp(name, "scx")) {
  575|      0|        script_ext = TRUE;
  576|      0|    do_script:
  577|      0|        cr_init(cr, s->opaque, lre_realloc);
  578|      0|        ret = unicode_script(cr, value, script_ext);
  579|      0|        if (ret) {
  580|      0|            cr_free(cr);
  581|      0|            if (ret == -2)
  582|      0|                return re_parse_error(s, "unknown unicode script");
  583|      0|            else
  584|      0|                goto out_of_memory;
  585|      0|        }
  586|     25|    } else if (!strcmp(name, "General_Category") || !strcmp(name, "gc")) {
  587|      0|        cr_init(cr, s->opaque, lre_realloc);
  588|      0|        ret = unicode_general_category(cr, value);
  589|      0|        if (ret) {
  590|      0|            cr_free(cr);
  591|      0|            if (ret == -2)
  592|      0|                return re_parse_error(s, "unknown unicode general category");
  593|      0|            else
  594|      0|                goto out_of_memory;
  595|      0|        }
  596|     25|    } else if (value[0] == '\0') {
  597|     24|        cr_init(cr, s->opaque, lre_realloc);
  598|     24|        ret = unicode_general_category(cr, name);
  599|     24|        if (ret == -1) {
  600|      0|            cr_free(cr);
  601|      0|            goto out_of_memory;
  602|      0|        }
  603|     24|        if (ret < 0) {
  604|      9|            ret = unicode_prop(cr, name);
  605|      9|            if (ret) {
  606|      9|                cr_free(cr);
  607|      9|                if (ret == -2)
  608|      9|                    goto unknown_property_name;
  609|      0|                else
  610|      0|                    goto out_of_memory;
  611|      9|            }
  612|      9|        }
  613|     24|    } else {
  614|     11|    unknown_property_name:
  615|     11|        return re_parse_error(s, "unknown unicode property name");
  616|      1|    }
  617|       |
  618|     15|    if (is_inv) {
  619|     15|        if (cr_invert(cr)) {
  620|      0|            cr_free(cr);
  621|      0|            return -1;
  622|      0|        }
  623|     15|    }
  624|     15|    *pp = p;
  625|     15|    return 0;
  626|      0| out_of_memory:
  627|      0|    return re_parse_out_of_memory(s);
  628|     15|}
  629|       |#endif /* CONFIG_ALL_UNICODE */
  630|       |
  631|       |/* return -1 if error otherwise the character or a class range
  632|       |   (CLASS_RANGE_BASE). In case of class range, 'cr' is
  633|       |   initialized. Otherwise, it is ignored. */
  634|       |static int get_class_atom(REParseState *s, CharRange *cr,
  635|       |                          const uint8_t **pp, BOOL inclass)
  636|  1.40M|{
  637|  1.40M|    const uint8_t *p;
  638|  1.40M|    uint32_t c;
  639|  1.40M|    int ret;
  640|       |
  641|  1.40M|    p = *pp;
  642|       |
  643|  1.40M|    c = *p;
  644|  1.40M|    switch(c) {
  645|  47.7k|    case '\\':
  646|  47.7k|        p++;
  647|  47.7k|        if (p >= s->buf_end)
  648|      0|            goto unexpected_end;
  649|  47.7k|        c = *p++;
  650|  47.7k|        switch(c) {
  651|  1.23k|        case 'd':
  652|  1.23k|            c = CHAR_RANGE_d;
  653|  1.23k|            goto class_range;
  654|     35|        case 'D':
  655|     35|            c = CHAR_RANGE_D;
  656|     35|            goto class_range;
  657|     89|        case 's':
  658|     89|            c = CHAR_RANGE_s;
  659|     89|            goto class_range;
  660|     36|        case 'S':
  661|     36|            c = CHAR_RANGE_S;
  662|     36|            goto class_range;
  663|     40|        case 'w':
  664|     40|            c = CHAR_RANGE_w;
  665|     40|            goto class_range;
  666|  19.9k|        case 'W':
  667|  19.9k|            c = CHAR_RANGE_W;
  668|  21.3k|        class_range:
  669|  21.3k|            if (cr_init_char_range(s, cr, c))
  670|      0|                return -1;
  671|  21.3k|            c = CLASS_RANGE_BASE;
  672|  21.3k|            break;
  673|    235|        case 'c':
  674|    235|            c = *p;
  675|    235|            if ((c >= 'a' && c <= 'z') ||
  676|    235|                (c >= 'A' && c <= 'Z') ||
  677|    235|                (((c >= '0' && c <= '9') || c == '_') &&
  678|    189|                 inclass && !s->is_unicode)) {   /* Annex B.1.4 */
  679|    189|                c &= 0x1f;
  680|    189|                p++;
  681|    189|            } else if (s->is_unicode) {
  682|      2|                goto invalid_escape;
  683|     44|            } else {
  684|       |                /* otherwise return '\' and 'c' */
  685|     44|                p--;
  686|     44|                c = '\\';
  687|     44|            }
  688|    233|            break;
  689|    233|        case '-':
  690|    162|            if (!inclass && s->is_unicode)
  691|      1|                goto invalid_escape;
  692|    161|            break;
  693|    161|#ifdef CONFIG_ALL_UNICODE
  694|    161|        case 'p':
  695|    242|        case 'P':
  696|    242|            if (s->is_unicode) {
  697|    120|                if (parse_unicode_property(s, cr, &p, (c == 'P')))
  698|    105|                    return -1;
  699|     15|                c = CLASS_RANGE_BASE;
  700|     15|                break;
  701|    120|            }
  702|       |            /* fall thru */
  703|    122|#endif
  704|  25.9k|        default:
  705|  25.9k|            p--;
  706|  25.9k|            ret = lre_parse_escape(&p, s->is_unicode * 2);
  707|  25.9k|            if (ret >= 0) {
  708|    685|                c = ret;
  709|  25.2k|            } else {
  710|  25.2k|                if (ret == -2 && *p != '\0' && strchr("^$\\.*+?()[]{}|/", *p)) {
  711|       |                    /* always valid to escape these characters */
  712|  18.0k|                    goto normal_char;
  713|  18.0k|                } else if (s->is_unicode) {
  714|     19|                invalid_escape:
  715|     19|                    return re_parse_error(s, "invalid escape sequence in regular expression");
  716|  7.13k|                } else {
  717|       |                    /* just ignore the '\' */
  718|  7.13k|                    goto normal_char;
  719|  7.13k|                }
  720|  25.2k|            }
  721|    685|            break;
  722|  47.7k|        }
  723|  22.4k|        break;
  724|  37.3k|    case '\0':
  725|  37.3k|        if (p >= s->buf_end) {
  726|      0|        unexpected_end:
  727|      0|            return re_parse_error(s, "unexpected end");
  728|      0|        }
  729|       |        /* fall thru */
  730|  1.35M|    default:
  731|  1.38M|    normal_char:
  732|       |        /* normal char */
  733|  1.38M|        if (c >= 128) {
  734|  21.1k|            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
  735|  21.1k|            if ((unsigned)c > 0xffff && !s->is_unicode) {
  736|       |                /* XXX: should handle non BMP-1 code points */
  737|      0|                return re_parse_error(s, "malformed unicode char");
  738|      0|            }
  739|  1.36M|        } else {
  740|  1.36M|            p++;
  741|  1.36M|        }
  742|  1.38M|        break;
  743|  1.40M|    }
  744|  1.40M|    *pp = p;
  745|  1.40M|    return c;
  746|  1.40M|}
  747|       |
  748|       |static int re_emit_range(REParseState *s, const CharRange *cr)
  749|  22.0k|{
  750|  22.0k|    int len, i;
  751|  22.0k|    uint32_t high;
  752|       |
  753|  22.0k|    len = (unsigned)cr->len / 2;
  754|  22.0k|    if (len >= 65535)
  755|      0|        return re_parse_error(s, "too many ranges");
  756|  22.0k|    if (len == 0) {
  757|       |        /* not sure it can really happen. Emit a match that is always
  758|       |           false */
  759|  4.58k|        re_emit_op_u32(s, REOP_char32, -1);
  760|  17.4k|    } else {
  761|  17.4k|        high = cr->points[cr->len - 1];
  762|  17.4k|        if (high == UINT32_MAX)
  763|  11.5k|            high = cr->points[cr->len - 2];
  764|  17.4k|        if (high <= 0xffff) {
  765|       |            /* can use 16 bit ranges with the conversion that 0xffff =
  766|       |               infinity */
  767|  6.78k|            re_emit_op_u16(s, REOP_range, len);
  768|  44.3k|            for(i = 0; i < cr->len; i += 2) {
  769|  37.5k|                dbuf_put_u16(&s->byte_code, cr->points[i]);
  770|  37.5k|                high = cr->points[i + 1] - 1;
  771|  37.5k|                if (high == UINT32_MAX - 1)
  772|    896|                    high = 0xffff;
  773|  37.5k|                dbuf_put_u16(&s->byte_code, high);
  774|  37.5k|            }
  775|  10.6k|        } else {
  776|  10.6k|            re_emit_op_u16(s, REOP_range32, len);
  777|  6.75M|            for(i = 0; i < cr->len; i += 2) {
  778|  6.74M|                dbuf_put_u32(&s->byte_code, cr->points[i]);
  779|  6.74M|                dbuf_put_u32(&s->byte_code, cr->points[i + 1] - 1);
  780|  6.74M|            }
  781|  10.6k|        }
  782|  17.4k|    }
  783|  22.0k|    return 0;
  784|  22.0k|}
  785|       |
  786|       |static int re_parse_char_class(REParseState *s, const uint8_t **pp)
  787|  21.4k|{
  788|  21.4k|    const uint8_t *p;
  789|  21.4k|    uint32_t c1, c2;
  790|  21.4k|    CharRange cr_s, *cr = &cr_s;
  791|  21.4k|    CharRange cr1_s, *cr1 = &cr1_s;
  792|  21.4k|    BOOL invert;
  793|       |
  794|  21.4k|    cr_init(cr, s->opaque, lre_realloc);
  795|  21.4k|    p = *pp;
  796|  21.4k|    p++;    /* skip '[' */
  797|       |
  798|  21.4k|    invert = FALSE;
  799|  21.4k|    if (*p == '^') {
  800|    131|        p++;
  801|    131|        invert = TRUE;
  802|    131|    }
  803|       |
  804|   543k|    for(;;) {
  805|   543k|        if (*p == ']')
  806|  21.3k|            break;
  807|   521k|        c1 = get_class_atom(s, cr1, &p, TRUE);
  808|   521k|        if ((int)c1 < 0)
  809|     90|            goto fail;
  810|   521k|        if (*p == '-' && p[1] != ']') {
  811|  4.82k|            const uint8_t *p0 = p + 1;
  812|  4.82k|            if (c1 >= CLASS_RANGE_BASE) {
  813|     26|                if (s->is_unicode) {
  814|      1|                    cr_free(cr1);
  815|      1|                    goto invalid_class_range;
  816|      1|                }
  817|       |                /* Annex B: match '-' character */
  818|     25|                goto class_atom;
  819|     26|            }
  820|  4.79k|            c2 = get_class_atom(s, cr1, &p0, TRUE);
  821|  4.79k|            if ((int)c2 < 0)
  822|     28|                goto fail;
  823|  4.76k|            if (c2 >= CLASS_RANGE_BASE) {
  824|    364|                cr_free(cr1);
  825|    364|                if (s->is_unicode) {
  826|      7|                    goto invalid_class_range;
  827|      7|                }
  828|       |                /* Annex B: match '-' character */
  829|    357|                goto class_atom;
  830|    364|            }
  831|  4.40k|            p = p0;
  832|  4.40k|            if (c2 < c1) {
  833|     29|            invalid_class_range:
  834|     29|                re_parse_error(s, "invalid class range");
  835|     29|                goto fail;
  836|     21|            }
  837|  4.38k|            if (cr_union_interval(cr, c1, c2))
  838|      0|                goto memory_error;
  839|   516k|        } else {
  840|   517k|        class_atom:
  841|   517k|            if (c1 >= CLASS_RANGE_BASE) {
  842|  20.2k|                int ret;
  843|  20.2k|                ret = cr_union1(cr, cr1->points, cr1->len);
  844|  20.2k|                cr_free(cr1);
  845|  20.2k|                if (ret)
  846|      0|                    goto memory_error;
  847|   496k|            } else {
  848|   496k|                if (cr_union_interval(cr, c1, c1))
  849|      0|                    goto memory_error;
  850|   496k|            }
  851|   517k|        }
  852|   521k|    }
  853|  21.3k|    if (s->ignore_case) {
  854|  16.7k|        if (cr_regexp_canonicalize(cr, s->is_unicode))
  855|      0|            goto memory_error;
  856|  16.7k|    }
  857|  21.3k|    if (invert) {
  858|    124|        if (cr_invert(cr))
  859|      0|            goto memory_error;
  860|    124|    }
  861|  21.3k|    if (re_emit_range(s, cr))
  862|      0|        goto fail;
  863|  21.3k|    cr_free(cr);
  864|  21.3k|    p++;    /* skip ']' */
  865|  21.3k|    *pp = p;
  866|  21.3k|    return 0;
  867|      0| memory_error:
  868|      0|    re_parse_out_of_memory(s);
  869|    147| fail:
  870|    147|    cr_free(cr);
  871|    147|    return -1;
  872|      0|}
  873|       |
  874|       |/* Return:
  875|       |   - true if the opcodes may not advance the char pointer
  876|       |   - false if the opcodes always advance the char pointer
  877|       |*/
  878|       |static BOOL re_need_check_advance(const uint8_t *bc_buf, int bc_buf_len)
  879|  11.5k|{
  880|  11.5k|    int pos, opcode, len;
  881|  11.5k|    uint32_t val;
  882|  11.5k|    BOOL ret;
  883|       |
  884|  11.5k|    ret = TRUE;
  885|  11.5k|    pos = 0;
  886|  69.2k|    while (pos < bc_buf_len) {
  887|  59.6k|        opcode = bc_buf[pos];
  888|  59.6k|        len = reopcode_info[opcode].size;
  889|  59.6k|        switch(opcode) {
  890|    364|        case REOP_range:
  891|    364|            val = get_u16(bc_buf + pos + 1);
  892|    364|            len += val * 4;
  893|    364|            goto simple_char;
  894|     73|        case REOP_range32:
  895|     73|            val = get_u16(bc_buf + pos + 1);
  896|     73|            len += val * 8;
  897|     73|            goto simple_char;
  898|  26.0k|        case REOP_char:
  899|  26.7k|        case REOP_char32:
  900|  27.8k|        case REOP_dot:
  901|  28.1k|        case REOP_any:
  902|  28.5k|        simple_char:
  903|  28.5k|            ret = FALSE;
  904|  28.5k|            break;
  905|  1.11k|        case REOP_line_start:
  906|  3.38k|        case REOP_line_end:
  907|  3.90k|        case REOP_push_i32:
  908|  3.90k|        case REOP_push_char_pos:
  909|  3.90k|        case REOP_drop:
  910|  4.35k|        case REOP_word_boundary:
  911|  4.80k|        case REOP_not_word_boundary:
  912|  15.2k|        case REOP_prev:
  913|       |            /* no effect */
  914|  15.2k|            break;
  915|  6.91k|        case REOP_save_start:
  916|  10.9k|        case REOP_save_end:
  917|  11.6k|        case REOP_save_reset:
  918|  13.4k|        case REOP_back_reference:
  919|  13.9k|        case REOP_backward_back_reference:
  920|  13.9k|            break;
  921|  1.97k|        default:
  922|       |            /* safe behavior: we cannot predict the outcome */
  923|  1.97k|            return TRUE;
  924|  59.6k|        }
  925|  57.6k|        pos += len;
  926|  57.6k|    }
  927|  9.55k|    return ret;
  928|  11.5k|}
  929|       |
  930|       |/* return -1 if a simple quantifier cannot be used. Otherwise return
  931|       |   the number of characters in the atom. */
  932|       |static int re_is_simple_quantifier(const uint8_t *bc_buf, int bc_buf_len)
  933|  13.5k|{
  934|  13.5k|    int pos, opcode, len, count;
  935|  13.5k|    uint32_t val;
  936|       |
  937|  13.5k|    count = 0;
  938|  13.5k|    pos = 0;
  939|  25.8k|    while (pos < bc_buf_len) {
  940|  19.7k|        opcode = bc_buf[pos];
  941|  19.7k|        len = reopcode_info[opcode].size;
  942|  19.7k|        switch(opcode) {
  943|    143|        case REOP_range:
  944|    143|            val = get_u16(bc_buf + pos + 1);
  945|    143|            len += val * 4;
  946|    143|            goto simple_char;
  947|     10|        case REOP_range32:
  948|     10|            val = get_u16(bc_buf + pos + 1);
  949|     10|            len += val * 8;
  950|     10|            goto simple_char;
  951|  7.61k|        case REOP_char:
  952|  7.68k|        case REOP_char32:
  953|  9.63k|        case REOP_dot:
  954|  10.1k|        case REOP_any:
  955|  10.3k|        simple_char:
  956|  10.3k|            count++;
  957|  10.3k|            break;
  958|  1.33k|        case REOP_line_start:
  959|  1.84k|        case REOP_line_end:
  960|  1.92k|        case REOP_word_boundary:
  961|  1.95k|        case REOP_not_word_boundary:
  962|  1.95k|            break;
  963|  7.52k|        default:
  964|  7.52k|            return -1;
  965|  19.7k|        }
  966|  12.2k|        pos += len;
  967|  12.2k|    }
  968|  6.03k|    return count;
  969|  13.5k|}
  970|       |
  971|       |/* '*pp' is the first char after '<' */
  972|       |static int re_parse_group_name(char *buf, int buf_size, const uint8_t **pp)
  973|  2.89k|{
  974|  2.89k|    const uint8_t *p, *p1;
  975|  2.89k|    uint32_t c, d;
  976|  2.89k|    char *q;
  977|       |
  978|  2.89k|    p = *pp;
  979|  2.89k|    q = buf;
  980|  12.7k|    for(;;) {
  981|  12.7k|        c = *p;
  982|  12.7k|        if (c == '\\') {
  983|     88|            p++;
  984|     88|            if (*p != 'u')
  985|     78|                return -1;
  986|     10|            c = lre_parse_escape(&p, 2); // accept surrogate pairs
  987|  12.6k|        } else if (c == '>') {
  988|  1.89k|            break;
  989|  10.7k|        } else if (c >= 128) {
  990|  1.82k|            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
  991|  1.82k|            if (is_hi_surrogate(c)) {
  992|     10|                d = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
  993|     10|                if (is_lo_surrogate(d)) {
  994|     10|                    c = from_surrogate(c, d);
  995|     10|                    p = p1;
  996|     10|                }
  997|     10|            }
  998|  8.91k|        } else {
  999|  8.91k|            p++;
 1000|  8.91k|        }
 1001|  10.7k|        if (c > 0x10FFFF)
 1002|     10|            return -1;
 1003|  10.7k|        if (q == buf) {
 1004|  2.40k|            if (!lre_js_is_ident_first(c))
 1005|    554|                return -1;
 1006|  8.33k|        } else {
 1007|  8.33k|            if (!lre_js_is_ident_next(c))
 1008|    308|                return -1;
 1009|  8.33k|        }
 1010|  9.88k|        if ((q - buf + UTF8_CHAR_LEN_MAX + 1) > buf_size)
 1011|     44|            return -1;
 1012|  9.83k|        if (c < 128) {
 1013|  8.02k|            *q++ = c;
 1014|  8.02k|        } else {
 1015|  1.81k|            q += unicode_to_utf8((uint8_t*)q, c);
 1016|  1.81k|        }
 1017|  9.83k|    }
 1018|  1.89k|    if (q == buf)
 1019|    413|        return -1;
 1020|  1.48k|    *q = '\0';
 1021|  1.48k|    p++;
 1022|  1.48k|    *pp = p;
 1023|  1.48k|    return 0;
 1024|  1.89k|}
 1025|       |
 1026|       |/* if capture_name = NULL: return the number of captures + 1.
 1027|       |   Otherwise, return the capture index corresponding to capture_name
 1028|       |   or -1 if none */
 1029|       |static int re_parse_captures(REParseState *s, int *phas_named_captures,
 1030|       |                             const char *capture_name)
 1031|  1.62k|{
 1032|  1.62k|    const uint8_t *p;
 1033|  1.62k|    int capture_index;
 1034|  1.62k|    char name[TMP_BUF_SIZE];
 1035|       |
 1036|  1.62k|    capture_index = 1;
 1037|  1.62k|    *phas_named_captures = 0;
 1038|  2.56M|    for (p = s->buf_start; p < s->buf_end; p++) {
 1039|  2.56M|        switch (*p) {
 1040|   164k|        case '(':
 1041|   164k|            if (p[1] == '?') {
 1042|  25.6k|                if (p[2] == '<' && p[3] != '=' && p[3] != '!') {
 1043|    751|                    *phas_named_captures = 1;
 1044|       |                    /* potential named capture */
 1045|    751|                    if (capture_name) {
 1046|    576|                        p += 3;
 1047|    576|                        if (re_parse_group_name(name, sizeof(name), &p) == 0) {
 1048|    536|                            if (!strcmp(name, capture_name))
 1049|    204|                                return capture_index;
 1050|    536|                        }
 1051|    576|                    }
 1052|    547|                    capture_index++;
 1053|    547|                    if (capture_index >= CAPTURE_COUNT_MAX)
 1054|      4|                        goto done;
 1055|    547|                }
 1056|   139k|            } else {
 1057|   139k|                capture_index++;
 1058|   139k|                if (capture_index >= CAPTURE_COUNT_MAX)
 1059|    127|                    goto done;
 1060|   139k|            }
 1061|   164k|            break;
 1062|   164k|        case '\\':
 1063|   102k|            p++;
 1064|   102k|            break;
 1065|  2.44k|        case '[':
 1066|  46.6k|            for (p += 1 + (*p == ']'); p < s->buf_end && *p != ']'; p++) {
 1067|  44.1k|                if (*p == '\\')
 1068|  2.73k|                    p++;
 1069|  44.1k|            }
 1070|  2.44k|            break;
 1071|  2.56M|        }
 1072|  2.56M|    }
 1073|  1.41k| done:
 1074|  1.41k|    if (capture_name)
 1075|    589|        return -1;
 1076|    829|    else
 1077|    829|        return capture_index;
 1078|  1.41k|}
 1079|       |
 1080|       |static int re_count_captures(REParseState *s)
 1081|  5.64k|{
 1082|  5.64k|    if (s->total_capture_count < 0) {
 1083|    829|        s->total_capture_count = re_parse_captures(s, &s->has_named_captures,
 1084|    829|                                                   NULL);
 1085|    829|    }
 1086|  5.64k|    return s->total_capture_count;
 1087|  5.64k|}
 1088|       |
 1089|       |static BOOL re_has_named_captures(REParseState *s)
 1090|  2.40k|{
 1091|  2.40k|    if (s->has_named_captures < 0)
 1092|    339|        re_count_captures(s);
 1093|  2.40k|    return s->has_named_captures;
 1094|  2.40k|}
 1095|       |
 1096|       |static int find_group_name(REParseState *s, const char *name)
 1097|    948|{
 1098|    948|    const char *p, *buf_end;
 1099|    948|    size_t len, name_len;
 1100|    948|    int capture_index;
 1101|       |
 1102|    948|    p = (char *)s->group_names.buf;
 1103|    948|    if (!p) return -1;
 1104|    859|    buf_end = (char *)s->group_names.buf + s->group_names.size;
 1105|    859|    name_len = strlen(name);
 1106|    859|    capture_index = 1;
 1107|  64.2k|    while (p < buf_end) {
 1108|  63.4k|        len = strlen(p);
 1109|  63.4k|        if (len == name_len && memcmp(name, p, name_len) == 0)
 1110|     73|            return capture_index;
 1111|  63.3k|        p += len + 1;
 1112|  63.3k|        capture_index++;
 1113|  63.3k|    }
 1114|    786|    return -1;
 1115|    859|}
 1116|       |
 1117|       |static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir);
 1118|       |
 1119|       |static int re_parse_term(REParseState *s, BOOL is_backward_dir)
 1120|   971k|{
 1121|   971k|    const uint8_t *p;
 1122|   971k|    int c, last_atom_start, quant_min, quant_max, last_capture_count;
 1123|   971k|    BOOL greedy, add_zero_advance_check, is_neg, is_backward_lookahead;
 1124|   971k|    CharRange cr_s, *cr = &cr_s;
 1125|       |
 1126|   971k|    last_atom_start = -1;
 1127|   971k|    last_capture_count = 0;
 1128|   971k|    p = s->buf_ptr;
 1129|   971k|    c = *p;
 1130|   971k|    switch(c) {
 1131|  7.03k|    case '^':
 1132|  7.03k|        p++;
 1133|  7.03k|        re_emit_op(s, REOP_line_start);
 1134|  7.03k|        break;
 1135|  6.30k|    case '$':
 1136|  6.30k|        p++;
 1137|  6.30k|        re_emit_op(s, REOP_line_end);
 1138|  6.30k|        break;
 1139|  9.53k|    case '.':
 1140|  9.53k|        p++;
 1141|  9.53k|        last_atom_start = s->byte_code.size;
 1142|  9.53k|        last_capture_count = s->capture_count;
 1143|  9.53k|        if (is_backward_dir)
 1144|  1.32k|            re_emit_op(s, REOP_prev);
 1145|  9.53k|        re_emit_op(s, s->dotall ? REOP_any : REOP_dot);
 1146|  9.53k|        if (is_backward_dir)
 1147|  1.32k|            re_emit_op(s, REOP_prev);
 1148|  9.53k|        break;
 1149|  3.54k|    case '{':
 1150|  3.54k|        if (s->is_unicode) {
 1151|      1|            return re_parse_error(s, "syntax error");
 1152|  3.54k|        } else if (!is_digit(p[1])) {
 1153|       |            /* Annex B: we accept '{' not followed by digits as a
 1154|       |               normal atom */
 1155|  2.13k|            goto parse_class_atom;
 1156|  2.13k|        } else {
 1157|  1.40k|            const uint8_t *p1 = p + 1;
 1158|       |            /* Annex B: error if it is like a repetition count */
 1159|  1.40k|            parse_digits(&p1, TRUE);
 1160|  1.40k|            if (*p1 == ',') {
 1161|    914|                p1++;
 1162|    914|                if (is_digit(*p1)) {
 1163|     53|                    parse_digits(&p1, TRUE);
 1164|     53|                }
 1165|    914|            }
 1166|  1.40k|            if (*p1 != '}') {
 1167|  1.40k|                goto parse_class_atom;
 1168|  1.40k|            }
 1169|  1.40k|        }
 1170|       |        /* fall thru */
 1171|     15|    case '*':
 1172|     53|    case '+':
 1173|    112|    case '?':
 1174|    112|        return re_parse_error(s, "nothing to repeat");
 1175|  39.0k|    case '(':
 1176|  39.0k|        if (p[1] == '?') {
 1177|  3.42k|            if (p[2] == ':') {
 1178|  2.54k|                p += 3;
 1179|  2.54k|                last_atom_start = s->byte_code.size;
 1180|  2.54k|                last_capture_count = s->capture_count;
 1181|  2.54k|                s->buf_ptr = p;
 1182|  2.54k|                if (re_parse_disjunction(s, is_backward_dir))
 1183|    388|                    return -1;
 1184|  2.15k|                p = s->buf_ptr;
 1185|  2.15k|                if (re_parse_expect(s, &p, ')'))
 1186|      1|                    return -1;
 1187|  2.15k|            } else if ((p[2] == '=' || p[2] == '!')) {
 1188|    201|                is_neg = (p[2] == '!');
 1189|    201|                is_backward_lookahead = FALSE;
 1190|    201|                p += 3;
 1191|    201|                goto lookahead;
 1192|    676|            } else if (p[2] == '<' &&
 1193|    676|                       (p[3] == '=' || p[3] == '!')) {
 1194|    453|                int pos;
 1195|    453|                is_neg = (p[3] == '!');
 1196|    453|                is_backward_lookahead = TRUE;
 1197|    453|                p += 4;
 1198|       |                /* lookahead */
 1199|    654|            lookahead:
 1200|       |                /* Annex B allows lookahead to be used as an atom for
 1201|       |                   the quantifiers */
 1202|    654|                if (!s->is_unicode && !is_backward_lookahead)  {
 1203|    135|                    last_atom_start = s->byte_code.size;
 1204|    135|                    last_capture_count = s->capture_count;
 1205|    135|                }
 1206|    654|                pos = re_emit_op_u32(s, REOP_lookahead + is_neg, 0);
 1207|    654|                s->buf_ptr = p;
 1208|    654|                if (re_parse_disjunction(s, is_backward_lookahead))
 1209|    583|                    return -1;
 1210|     71|                p = s->buf_ptr;
 1211|     71|                if (re_parse_expect(s, &p, ')'))
 1212|     16|                    return -1;
 1213|     55|                re_emit_op(s, REOP_match);
 1214|       |                /* jump after the 'match' after the lookahead is successful */
 1215|     55|                if (dbuf_error(&s->byte_code))
 1216|      0|                    return -1;
 1217|     55|                put_u32(s->byte_code.buf + pos, s->byte_code.size - (pos + 4));
 1218|    223|            } else if (p[2] == '<') {
 1219|    107|                p += 3;
 1220|    107|                if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),
 1221|    107|                                        &p)) {
 1222|      7|                    return re_parse_error(s, "invalid group name");
 1223|      7|                }
 1224|    100|                if (find_group_name(s, s->u.tmp_buf) > 0) {
 1225|     18|                    return re_parse_error(s, "duplicate group name");
 1226|     18|                }
 1227|       |                /* group name with a trailing zero */
 1228|     82|                dbuf_put(&s->group_names, (uint8_t *)s->u.tmp_buf,
 1229|     82|                         strlen(s->u.tmp_buf) + 1);
 1230|     82|                s->has_named_captures = 1;
 1231|     82|                goto parse_capture;
 1232|    116|            } else {
 1233|    116|                return re_parse_error(s, "invalid group");
 1234|    116|            }
 1235|  35.6k|        } else {
 1236|  35.6k|            int capture_index;
 1237|  35.6k|            p++;
 1238|       |            /* capture without group name */
 1239|  35.6k|            dbuf_putc(&s->group_names, 0);
 1240|  35.7k|        parse_capture:
 1241|  35.7k|            if (s->capture_count >= CAPTURE_COUNT_MAX)
 1242|     27|                return re_parse_error(s, "too many captures");
 1243|  35.7k|            last_atom_start = s->byte_code.size;
 1244|  35.7k|            last_capture_count = s->capture_count;
 1245|  35.7k|            capture_index = s->capture_count++;
 1246|  35.7k|            re_emit_op_u8(s, REOP_save_start + is_backward_dir,
 1247|  35.7k|                          capture_index);
 1248|       |
 1249|  35.7k|            s->buf_ptr = p;
 1250|  35.7k|            if (re_parse_disjunction(s, is_backward_dir))
 1251|  27.1k|                return -1;
 1252|  8.57k|            p = s->buf_ptr;
 1253|       |
 1254|  8.57k|            re_emit_op_u8(s, REOP_save_start + 1 - is_backward_dir,
 1255|  8.57k|                          capture_index);
 1256|       |
 1257|  8.57k|            if (re_parse_expect(s, &p, ')'))
 1258|    500|                return -1;
 1259|  8.57k|        }
 1260|  10.2k|        break;
 1261|  33.6k|    case '\\':
 1262|  33.6k|        switch(p[1]) {
 1263|  1.06k|        case 'b':
 1264|  1.75k|        case 'B':
 1265|  1.75k|            re_emit_op(s, REOP_word_boundary + (p[1] != 'b'));
 1266|  1.75k|            p += 2;
 1267|  1.75k|            break;
 1268|  2.66k|        case 'k':
 1269|  2.66k|            {
 1270|  2.66k|                const uint8_t *p1;
 1271|  2.66k|                int dummy_res;
 1272|       |
 1273|  2.66k|                p1 = p;
 1274|  2.66k|                if (p1[2] != '<') {
 1275|       |                    /* annex B: we tolerate invalid group names in non
 1276|       |                       unicode mode if there is no named capture
 1277|       |                       definition */
 1278|    460|                    if (s->is_unicode || re_has_named_captures(s))
 1279|      4|                        return re_parse_error(s, "expecting group name");
 1280|    456|                    else
 1281|    456|                        goto parse_class_atom;
 1282|    460|                }
 1283|  2.20k|                p1 += 3;
 1284|  2.20k|                if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),
 1285|  2.20k|                                        &p1)) {
 1286|  1.36k|                    if (s->is_unicode || re_has_named_captures(s))
 1287|      8|                        return re_parse_error(s, "invalid group name");
 1288|  1.35k|                    else
 1289|  1.35k|                        goto parse_class_atom;
 1290|  1.36k|                }
 1291|    848|                c = find_group_name(s, s->u.tmp_buf);
 1292|    848|                if (c < 0) {
 1293|       |                    /* no capture name parsed before, try to look
 1294|       |                       after (inefficient, but hopefully not common */
 1295|    793|                    c = re_parse_captures(s, &dummy_res, s->u.tmp_buf);
 1296|    793|                    if (c < 0) {
 1297|    589|                        if (s->is_unicode || re_has_named_captures(s))
 1298|     17|                            return re_parse_error(s, "group name not defined");
 1299|    572|                        else
 1300|    572|                            goto parse_class_atom;
 1301|    589|                    }
 1302|    793|                }
 1303|    259|                p = p1;
 1304|    259|            }
 1305|      0|            goto emit_back_reference;
 1306|    476|        case '0':
 1307|    476|            p += 2;
 1308|    476|            c = 0;
 1309|    476|            if (s->is_unicode) {
 1310|     19|                if (is_digit(*p)) {
 1311|      1|                    return re_parse_error(s, "invalid decimal escape in regular expression");
 1312|      1|                }
 1313|    457|            } else {
 1314|       |                /* Annex B.1.4: accept legacy octal */
 1315|    457|                if (*p >= '0' && *p <= '7') {
 1316|    172|                    c = *p++ - '0';
 1317|    172|                    if (*p >= '0' && *p <= '7') {
 1318|    104|                        c = (c << 3) + *p++ - '0';
 1319|    104|                    }
 1320|    172|                }
 1321|    457|            }
 1322|    475|            goto normal_char;
 1323|  7.39k|        case '1': case '2': case '3': case '4':
 1324|  7.77k|        case '5': case '6': case '7': case '8':
 1325|  7.81k|        case '9':
 1326|  7.81k|            {
 1327|  7.81k|                const uint8_t *q = ++p;
 1328|       |
 1329|  7.81k|                c = parse_digits(&p, FALSE);
 1330|  7.81k|                if (c < 0 || (c >= s->capture_count && c >= re_count_captures(s))) {
 1331|  4.48k|                    if (!s->is_unicode) {
 1332|       |                        /* Annex B.1.4: accept legacy octal */
 1333|  4.46k|                        p = q;
 1334|  4.46k|                        if (*p <= '7') {
 1335|  4.28k|                            c = 0;
 1336|  4.28k|                            if (*p <= '3')
 1337|  4.01k|                                c = *p++ - '0';
 1338|  4.28k|                            if (*p >= '0' && *p <= '7') {
 1339|  3.51k|                                c = (c << 3) + *p++ - '0';
 1340|  3.51k|                                if (*p >= '0' && *p <= '7') {
 1341|  2.55k|                                    c = (c << 3) + *p++ - '0';
 1342|  2.55k|                                }
 1343|  3.51k|                            }
 1344|  4.28k|                        } else {
 1345|    179|                            c = *p++;
 1346|    179|                        }
 1347|  4.46k|                        goto normal_char;
 1348|  4.46k|                    }
 1349|     19|                    return re_parse_error(s, "back reference out of range in regular expression");
 1350|  4.48k|                }
 1351|  3.59k|            emit_back_reference:
 1352|  3.59k|                last_atom_start = s->byte_code.size;
 1353|  3.59k|                last_capture_count = s->capture_count;
 1354|  3.59k|                re_emit_op_u8(s, REOP_back_reference + is_backward_dir, c);
 1355|  3.59k|            }
 1356|      0|            break;
 1357|  20.9k|        default:
 1358|  20.9k|            goto parse_class_atom;
 1359|  33.6k|        }
 1360|  5.34k|        break;
 1361|  21.4k|    case '[':
 1362|  21.4k|        last_atom_start = s->byte_code.size;
 1363|  21.4k|        last_capture_count = s->capture_count;
 1364|  21.4k|        if (is_backward_dir)
 1365|  1.05k|            re_emit_op(s, REOP_prev);
 1366|  21.4k|        if (re_parse_char_class(s, &p))
 1367|    147|            return -1;
 1368|  21.3k|        if (is_backward_dir)
 1369|  1.05k|            re_emit_op(s, REOP_prev);
 1370|  21.3k|        break;
 1371|  7.80k|    case ']':
 1372|  8.57k|    case '}':
 1373|  8.57k|        if (s->is_unicode)
 1374|     21|            return re_parse_error(s, "syntax error");
 1375|  8.55k|        goto parse_class_atom;
 1376|   841k|    default:
 1377|   877k|    parse_class_atom:
 1378|   877k|        c = get_class_atom(s, cr, &p, FALSE);
 1379|   877k|        if ((int)c < 0)
 1380|      6|            return -1;
 1381|   882k|    normal_char:
 1382|   882k|        last_atom_start = s->byte_code.size;
 1383|   882k|        last_capture_count = s->capture_count;
 1384|   882k|        if (is_backward_dir)
 1385|  33.0k|            re_emit_op(s, REOP_prev);
 1386|   882k|        if (c >= CLASS_RANGE_BASE) {
 1387|    692|            int ret;
 1388|       |            /* Note: canonicalization is not needed */
 1389|    692|            ret = re_emit_range(s, cr);
 1390|    692|            cr_free(cr);
 1391|    692|            if (ret)
 1392|      0|                return -1;
 1393|   881k|        } else {
 1394|   881k|            if (s->ignore_case)
 1395|  44.8k|                c = lre_canonicalize(c, s->is_unicode);
 1396|   881k|            if (c <= 0xffff)
 1397|   881k|                re_emit_op_u16(s, REOP_char, c);
 1398|     40|            else
 1399|     40|                re_emit_op_u32(s, REOP_char32, c);
 1400|   881k|        }
 1401|   882k|        if (is_backward_dir)
 1402|  33.0k|            re_emit_op(s, REOP_prev);
 1403|   882k|        break;
 1404|   971k|    }
 1405|       |
 1406|       |    /* quantifier */
 1407|   941k|    if (last_atom_start >= 0) {
 1408|   926k|        c = *p;
 1409|   926k|        switch(c) {
 1410|  7.66k|        case '*':
 1411|  7.66k|            p++;
 1412|  7.66k|            quant_min = 0;
 1413|  7.66k|            quant_max = INT32_MAX;
 1414|  7.66k|            goto quantifier;
 1415|  3.20k|        case '+':
 1416|  3.20k|            p++;
 1417|  3.20k|            quant_min = 1;
 1418|  3.20k|            quant_max = INT32_MAX;
 1419|  3.20k|            goto quantifier;
 1420|  2.48k|        case '?':
 1421|  2.48k|            p++;
 1422|  2.48k|            quant_min = 0;
 1423|  2.48k|            quant_max = 1;
 1424|  2.48k|            goto quantifier;
 1425|  5.10k|        case '{':
 1426|  5.10k|            {
 1427|  5.10k|                const uint8_t *p1 = p;
 1428|       |                /* As an extension (see ES6 annex B), we accept '{' not
 1429|       |                   followed by digits as a normal atom */
 1430|  5.10k|                if (!is_digit(p[1])) {
 1431|  2.10k|                    if (s->is_unicode)
 1432|      1|                        goto invalid_quant_count;
 1433|  2.10k|                    break;
 1434|  2.10k|                }
 1435|  3.00k|                p++;
 1436|  3.00k|                quant_min = parse_digits(&p, TRUE);
 1437|  3.00k|                quant_max = quant_min;
 1438|  3.00k|                if (*p == ',') {
 1439|    134|                    p++;
 1440|    134|                    if (is_digit(*p)) {
 1441|     58|                        quant_max = parse_digits(&p, TRUE);
 1442|     58|                        if (quant_max < quant_min) {
 1443|      6|                        invalid_quant_count:
 1444|      6|                            return re_parse_error(s, "invalid repetition count");
 1445|      5|                        }
 1446|     76|                    } else {
 1447|     76|                        quant_max = INT32_MAX; /* infinity */
 1448|     76|                    }
 1449|    134|                }
 1450|  2.99k|                if (*p != '}' && !s->is_unicode) {
 1451|       |                    /* Annex B: normal atom if invalid '{' syntax */
 1452|    614|                    p = p1;
 1453|    614|                    break;
 1454|    614|                }
 1455|  2.38k|                if (re_parse_expect(s, &p, '}'))
 1456|      1|                    return -1;
 1457|  2.38k|            }
 1458|  15.7k|        quantifier:
 1459|  15.7k|            greedy = TRUE;
 1460|  15.7k|            if (*p == '?') {
 1461|  1.28k|                p++;
 1462|  1.28k|                greedy = FALSE;
 1463|  1.28k|            }
 1464|  15.7k|            if (last_atom_start < 0) {
 1465|      0|                return re_parse_error(s, "nothing to repeat");
 1466|      0|            }
 1467|  15.7k|            if (greedy) {
 1468|  14.4k|                int len, pos;
 1469|       |
 1470|  14.4k|                if (quant_max > 0) {
 1471|       |                    /* specific optimization for simple quantifiers */
 1472|  13.5k|                    if (dbuf_error(&s->byte_code))
 1473|      0|                        goto out_of_memory;
 1474|  13.5k|                    len = re_is_simple_quantifier(s->byte_code.buf + last_atom_start,
 1475|  13.5k|                                                 s->byte_code.size - last_atom_start);
 1476|  13.5k|                    if (len > 0) {
 1477|  4.19k|                        re_emit_op(s, REOP_match);
 1478|       |
 1479|  4.19k|                        if (dbuf_insert(&s->byte_code, last_atom_start, 17))
 1480|      0|                            goto out_of_memory;
 1481|  4.19k|                        pos = last_atom_start;
 1482|  4.19k|                        s->byte_code.buf[pos++] = REOP_simple_greedy_quant;
 1483|  4.19k|                        put_u32(&s->byte_code.buf[pos],
 1484|  4.19k|                                s->byte_code.size - last_atom_start - 17);
 1485|  4.19k|                        pos += 4;
 1486|  4.19k|                        put_u32(&s->byte_code.buf[pos], quant_min);
 1487|  4.19k|                        pos += 4;
 1488|  4.19k|                        put_u32(&s->byte_code.buf[pos], quant_max);
 1489|  4.19k|                        pos += 4;
 1490|  4.19k|                        put_u32(&s->byte_code.buf[pos], len);
 1491|  4.19k|                        pos += 4;
 1492|  4.19k|                        goto done;
 1493|  4.19k|                    }
 1494|  13.5k|                }
 1495|       |
 1496|  10.2k|                if (dbuf_error(&s->byte_code))
 1497|      0|                    goto out_of_memory;
 1498|  10.2k|            }
 1499|       |            /* the spec tells that if there is no advance when
 1500|       |               running the atom after the first quant_min times,
 1501|       |               then there is no match. We remove this test when we
 1502|       |               are sure the atom always advances the position. */
 1503|  11.5k|            add_zero_advance_check = re_need_check_advance(s->byte_code.buf + last_atom_start,
 1504|  11.5k|                                                           s->byte_code.size - last_atom_start);
 1505|       |
 1506|  11.5k|            {
 1507|  11.5k|                int len, pos;
 1508|  11.5k|                len = s->byte_code.size - last_atom_start;
 1509|  11.5k|                if (quant_min == 0) {
 1510|       |                    /* need to reset the capture in case the atom is
 1511|       |                       not executed */
 1512|  8.12k|                    if (last_capture_count != s->capture_count) {
 1513|  2.32k|                        if (dbuf_insert(&s->byte_code, last_atom_start, 3))
 1514|      0|                            goto out_of_memory;
 1515|  2.32k|                        s->byte_code.buf[last_atom_start++] = REOP_save_reset;
 1516|  2.32k|                        s->byte_code.buf[last_atom_start++] = last_capture_count;
 1517|  2.32k|                        s->byte_code.buf[last_atom_start++] = s->capture_count - 1;
 1518|  2.32k|                    }
 1519|  8.12k|                    if (quant_max == 0) {
 1520|    881|                        s->byte_code.size = last_atom_start;
 1521|  7.24k|                    } else if (quant_max == 1 || quant_max == INT32_MAX) {
 1522|  7.24k|                        BOOL has_goto = (quant_max == INT32_MAX);
 1523|  7.24k|                        if (dbuf_insert(&s->byte_code, last_atom_start, 5 + add_zero_advance_check))
 1524|      0|                            goto out_of_memory;
 1525|  7.24k|                        s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
 1526|  7.24k|                            greedy;
 1527|  7.24k|                        put_u32(s->byte_code.buf + last_atom_start + 1,
 1528|  7.24k|                                len + 5 * has_goto + add_zero_advance_check * 2);
 1529|  7.24k|                        if (add_zero_advance_check) {
 1530|  5.45k|                            s->byte_code.buf[last_atom_start + 1 + 4] = REOP_push_char_pos;
 1531|  5.45k|                            re_emit_op(s, REOP_check_advance);
 1532|  5.45k|                        }
 1533|  7.24k|                        if (has_goto)
 1534|  5.81k|                            re_emit_goto(s, REOP_goto, last_atom_start);
 1535|  7.24k|                    } else {
 1536|      0|                        if (dbuf_insert(&s->byte_code, last_atom_start, 10 + add_zero_advance_check))
 1537|      0|                            goto out_of_memory;
 1538|      0|                        pos = last_atom_start;
 1539|      0|                        s->byte_code.buf[pos++] = REOP_push_i32;
 1540|      0|                        put_u32(s->byte_code.buf + pos, quant_max);
 1541|      0|                        pos += 4;
 1542|      0|                        s->byte_code.buf[pos++] = REOP_split_goto_first + greedy;
 1543|      0|                        put_u32(s->byte_code.buf + pos, len + 5 + add_zero_advance_check * 2);
 1544|      0|                        pos += 4;
 1545|      0|                        if (add_zero_advance_check) {
 1546|      0|                            s->byte_code.buf[pos++] = REOP_push_char_pos;
 1547|      0|                            re_emit_op(s, REOP_check_advance);
 1548|      0|                        }
 1549|      0|                        re_emit_goto(s, REOP_loop, last_atom_start + 5);
 1550|      0|                        re_emit_op(s, REOP_drop);
 1551|      0|                    }
 1552|  8.12k|                } else if (quant_min == 1 && quant_max == INT32_MAX &&
 1553|  3.39k|                           !add_zero_advance_check) {
 1554|  1.03k|                    re_emit_goto(s, REOP_split_next_first - greedy,
 1555|  1.03k|                                 last_atom_start);
 1556|  2.36k|                } else {
 1557|  2.36k|                    if (quant_min == 1) {
 1558|       |                        /* nothing to add */
 1559|  1.42k|                    } else {
 1560|  1.42k|                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))
 1561|      0|                            goto out_of_memory;
 1562|  1.42k|                        s->byte_code.buf[last_atom_start] = REOP_push_i32;
 1563|  1.42k|                        put_u32(s->byte_code.buf + last_atom_start + 1,
 1564|  1.42k|                                quant_min);
 1565|  1.42k|                        last_atom_start += 5;
 1566|  1.42k|                        re_emit_goto(s, REOP_loop, last_atom_start);
 1567|  1.42k|                        re_emit_op(s, REOP_drop);
 1568|  1.42k|                    }
 1569|  2.36k|                    if (quant_max == INT32_MAX) {
 1570|    943|                        pos = s->byte_code.size;
 1571|    943|                        re_emit_op_u32(s, REOP_split_goto_first + greedy,
 1572|    943|                                       len + 5 + add_zero_advance_check * 2);
 1573|    943|                        if (add_zero_advance_check)
 1574|    932|                            re_emit_op(s, REOP_push_char_pos);
 1575|       |                        /* copy the atom */
 1576|    943|                        dbuf_put_self(&s->byte_code, last_atom_start, len);
 1577|    943|                        if (add_zero_advance_check)
 1578|    932|                            re_emit_op(s, REOP_check_advance);
 1579|    943|                        re_emit_goto(s, REOP_goto, pos);
 1580|  1.41k|                    } else if (quant_max > quant_min) {
 1581|      0|                        re_emit_op_u32(s, REOP_push_i32, quant_max - quant_min);
 1582|      0|                        pos = s->byte_code.size;
 1583|      0|                        re_emit_op_u32(s, REOP_split_goto_first + greedy,
 1584|      0|                                       len + 5 + add_zero_advance_check * 2);
 1585|      0|                        if (add_zero_advance_check)
 1586|      0|                            re_emit_op(s, REOP_push_char_pos);
 1587|       |                        /* copy the atom */
 1588|      0|                        dbuf_put_self(&s->byte_code, last_atom_start, len);
 1589|      0|                        if (add_zero_advance_check)
 1590|      0|                            re_emit_op(s, REOP_check_advance);
 1591|      0|                        re_emit_goto(s, REOP_loop, pos);
 1592|      0|                        re_emit_op(s, REOP_drop);
 1593|      0|                    }
 1594|  2.36k|                }
 1595|  11.5k|                last_atom_start = -1;
 1596|  11.5k|            }
 1597|      0|            break;
 1598|   908k|        default:
 1599|   908k|            break;
 1600|   926k|        }
 1601|   926k|    }
 1602|   941k| done:
 1603|   941k|    s->buf_ptr = p;
 1604|   941k|    return 0;
 1605|      0| out_of_memory:
 1606|      0|    return re_parse_out_of_memory(s);
 1607|   941k|}
 1608|       |
 1609|       |static int re_parse_alternative(REParseState *s, BOOL is_backward_dir)
 1610|  79.6k|{
 1611|  79.6k|    const uint8_t *p;
 1612|  79.6k|    int ret;
 1613|  79.6k|    size_t start, term_start, end, term_size;
 1614|       |
 1615|  79.6k|    start = s->byte_code.size;
 1616|  1.02M|    for(;;) {
 1617|  1.02M|        p = s->buf_ptr;
 1618|  1.02M|        if (p >= s->buf_end)
 1619|  38.6k|            break;
 1620|   982k|        if (*p == '|' || *p == ')')
 1621|  11.8k|            break;
 1622|   971k|        term_start = s->byte_code.size;
 1623|   971k|        ret = re_parse_term(s, is_backward_dir);
 1624|   971k|        if (ret)
 1625|  29.1k|            return ret;
 1626|   941k|        if (is_backward_dir) {
 1627|       |            /* reverse the order of the terms (XXX: inefficient, but
 1628|       |               speed is not really critical here) */
 1629|  37.1k|            end = s->byte_code.size;
 1630|  37.1k|            term_size = end - term_start;
 1631|  37.1k|            if (dbuf_realloc(&s->byte_code, end + term_size))
 1632|      0|                return -1;
 1633|  37.1k|            memmove(s->byte_code.buf + start + term_size,
 1634|  37.1k|                    s->byte_code.buf + start,
 1635|  37.1k|                    end - start);
 1636|  37.1k|            memcpy(s->byte_code.buf + start, s->byte_code.buf + end,
 1637|  37.1k|                   term_size);
 1638|  37.1k|        }
 1639|   941k|    }
 1640|  50.5k|    return 0;
 1641|  79.6k|}
 1642|       |
 1643|       |static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir)
 1644|  78.1k|{
 1645|  78.1k|    int start, len, pos;
 1646|       |
 1647|  78.1k|    if (lre_check_stack_overflow(s->opaque, 0))
 1648|      0|        return re_parse_error(s, "stack overflow");
 1649|       |
 1650|  78.1k|    start = s->byte_code.size;
 1651|  78.1k|    if (re_parse_alternative(s, is_backward_dir))
 1652|  29.0k|        return -1;
 1653|  50.5k|    while (*s->buf_ptr == '|') {
 1654|  1.52k|        s->buf_ptr++;
 1655|       |
 1656|  1.52k|        len = s->byte_code.size - start;
 1657|       |
 1658|       |        /* insert a split before the first alternative */
 1659|  1.52k|        if (dbuf_insert(&s->byte_code, start, 5)) {
 1660|      0|            return re_parse_out_of_memory(s);
 1661|      0|        }
 1662|  1.52k|        s->byte_code.buf[start] = REOP_split_next_first;
 1663|  1.52k|        put_u32(s->byte_code.buf + start + 1, len + 5);
 1664|       |
 1665|  1.52k|        pos = re_emit_op_u32(s, REOP_goto, 0);
 1666|       |
 1667|  1.52k|        if (re_parse_alternative(s, is_backward_dir))
 1668|     97|            return -1;
 1669|       |
 1670|       |        /* patch the goto */
 1671|  1.42k|        len = s->byte_code.size - (pos + 4);
 1672|  1.42k|        put_u32(s->byte_code.buf + pos, len);
 1673|  1.42k|    }
 1674|  48.9k|    return 0;
 1675|  49.0k|}
 1676|       |
 1677|       |/* the control flow is recursive so the analysis can be linear */
 1678|       |static int compute_stack_size(const uint8_t *bc_buf, int bc_buf_len)
 1679|  38.1k|{
 1680|  38.1k|    int stack_size, stack_size_max, pos, opcode, len;
 1681|  38.1k|    uint32_t val;
 1682|       |
 1683|  38.1k|    stack_size = 0;
 1684|  38.1k|    stack_size_max = 0;
 1685|  38.1k|    bc_buf += RE_HEADER_LEN;
 1686|  38.1k|    bc_buf_len -= RE_HEADER_LEN;
 1687|  38.1k|    pos = 0;
 1688|   944k|    while (pos < bc_buf_len) {
 1689|   906k|        opcode = bc_buf[pos];
 1690|   906k|        len = reopcode_info[opcode].size;
 1691|   906k|        assert(opcode < REOP_COUNT);
 1692|   906k|        assert((pos + len) <= bc_buf_len);
 1693|   906k|        switch(opcode) {
 1694|    117|        case REOP_push_i32:
 1695|  1.08k|        case REOP_push_char_pos:
 1696|  1.08k|            stack_size++;
 1697|  1.08k|            if (stack_size > stack_size_max) {
 1698|    167|                if (stack_size > STACK_SIZE_MAX)
 1699|      0|                    return -1;
 1700|    167|                stack_size_max = stack_size;
 1701|    167|            }
 1702|  1.08k|            break;
 1703|  1.08k|        case REOP_drop:
 1704|  1.08k|        case REOP_check_advance:
 1705|  1.08k|            assert(stack_size > 0);
 1706|  1.08k|            stack_size--;
 1707|  1.08k|            break;
 1708|  5.01k|        case REOP_range:
 1709|  5.01k|            val = get_u16(bc_buf + pos + 1);
 1710|  5.01k|            len += val * 4;
 1711|  5.01k|            break;
 1712|  1.72k|        case REOP_range32:
 1713|  1.72k|            val = get_u16(bc_buf + pos + 1);
 1714|  1.72k|            len += val * 8;
 1715|  1.72k|            break;
 1716|   906k|        }
 1717|   906k|        pos += len;
 1718|   906k|    }
 1719|  38.1k|    return stack_size_max;
 1720|  38.1k|}
 1721|       |
 1722|       |/* 'buf' must be a zero terminated UTF-8 string of length buf_len.
 1723|       |   Return NULL if error and allocate an error message in *perror_msg,
 1724|       |   otherwise the compiled bytecode and its length in plen.
 1725|       |*/
 1726|       |uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
 1727|       |                     const char *buf, size_t buf_len, int re_flags,
 1728|       |                     void *opaque)
 1729|  39.2k|{
 1730|  39.2k|    REParseState s_s, *s = &s_s;
 1731|  39.2k|    int stack_size;
 1732|  39.2k|    BOOL is_sticky;
 1733|       |
 1734|  39.2k|    memset(s, 0, sizeof(*s));
 1735|  39.2k|    s->opaque = opaque;
 1736|  39.2k|    s->buf_ptr = (const uint8_t *)buf;
 1737|  39.2k|    s->buf_end = s->buf_ptr + buf_len;
 1738|  39.2k|    s->buf_start = s->buf_ptr;
 1739|  39.2k|    s->re_flags = re_flags;
 1740|  39.2k|    s->is_unicode = ((re_flags & LRE_FLAG_UNICODE) != 0);
 1741|  39.2k|    is_sticky = ((re_flags & LRE_FLAG_STICKY) != 0);
 1742|  39.2k|    s->ignore_case = ((re_flags & LRE_FLAG_IGNORECASE) != 0);
 1743|  39.2k|    s->dotall = ((re_flags & LRE_FLAG_DOTALL) != 0);
 1744|  39.2k|    s->capture_count = 1;
 1745|  39.2k|    s->total_capture_count = -1;
 1746|  39.2k|    s->has_named_captures = -1;
 1747|       |
 1748|  39.2k|    dbuf_init2(&s->byte_code, opaque, lre_realloc);
 1749|  39.2k|    dbuf_init2(&s->group_names, opaque, lre_realloc);
 1750|       |
 1751|  39.2k|    dbuf_putc(&s->byte_code, re_flags); /* first element is the flags */
 1752|  39.2k|    dbuf_putc(&s->byte_code, 0); /* second element is the number of captures */
 1753|  39.2k|    dbuf_putc(&s->byte_code, 0); /* stack size */
 1754|  39.2k|    dbuf_put_u32(&s->byte_code, 0); /* bytecode length */
 1755|       |
 1756|  39.2k|    if (!is_sticky) {
 1757|       |        /* iterate thru all positions (about the same as .*?( ... ) )
 1758|       |           .  We do it without an explicit loop so that lock step
 1759|       |           thread execution will be possible in an optimized
 1760|       |           implementation */
 1761|  39.1k|        re_emit_op_u32(s, REOP_split_goto_first, 1 + 5);
 1762|  39.1k|        re_emit_op(s, REOP_any);
 1763|  39.1k|        re_emit_op_u32(s, REOP_goto, -(5 + 1 + 5));
 1764|  39.1k|    }
 1765|  39.2k|    re_emit_op_u8(s, REOP_save_start, 0);
 1766|       |
 1767|  39.2k|    if (re_parse_disjunction(s, FALSE)) {
 1768|  1.05k|    error:
 1769|  1.05k|        dbuf_free(&s->byte_code);
 1770|  1.05k|        dbuf_free(&s->group_names);
 1771|  1.05k|        pstrcpy(error_msg, error_msg_size, s->u.error_msg);
 1772|  1.05k|        *plen = 0;
 1773|  1.05k|        return NULL;
 1774|  1.02k|    }
 1775|       |
 1776|  38.1k|    re_emit_op_u8(s, REOP_save_end, 0);
 1777|       |
 1778|  38.1k|    re_emit_op(s, REOP_match);
 1779|       |
 1780|  38.1k|    if (*s->buf_ptr != '\0') {
 1781|     25|        re_parse_error(s, "extraneous characters at the end");
 1782|     25|        goto error;
 1783|     25|    }
 1784|       |
 1785|  38.1k|    if (dbuf_error(&s->byte_code)) {
 1786|      0|        re_parse_out_of_memory(s);
 1787|      0|        goto error;
 1788|      0|    }
 1789|       |
 1790|  38.1k|    stack_size = compute_stack_size(s->byte_code.buf, s->byte_code.size);
 1791|  38.1k|    if (stack_size < 0) {
 1792|      0|        re_parse_error(s, "too many imbricated quantifiers");
 1793|      0|        goto error;
 1794|      0|    }
 1795|       |
 1796|  38.1k|    s->byte_code.buf[RE_HEADER_CAPTURE_COUNT] = s->capture_count;
 1797|  38.1k|    s->byte_code.buf[RE_HEADER_STACK_SIZE] = stack_size;
 1798|  38.1k|    put_u32(s->byte_code.buf + RE_HEADER_BYTECODE_LEN,
 1799|  38.1k|            s->byte_code.size - RE_HEADER_LEN);
 1800|       |
 1801|       |    /* add the named groups if needed */
 1802|  38.1k|    if (s->group_names.size > (s->capture_count - 1)) {
 1803|      0|        dbuf_put(&s->byte_code, s->group_names.buf, s->group_names.size);
 1804|      0|        s->byte_code.buf[RE_HEADER_FLAGS] |= LRE_FLAG_NAMED_GROUPS;
 1805|      0|    }
 1806|  38.1k|    dbuf_free(&s->group_names);
 1807|       |
 1808|       |#ifdef DUMP_REOP
 1809|       |    lre_dump_bytecode(s->byte_code.buf, s->byte_code.size);
 1810|       |#endif
 1811|       |
 1812|  38.1k|    error_msg[0] = '\0';
 1813|  38.1k|    *plen = s->byte_code.size;
 1814|  38.1k|    return s->byte_code.buf;
 1815|  38.1k|}
 1816|       |
 1817|       |static BOOL is_line_terminator(uint32_t c)
 1818|      0|{
 1819|      0|    return (c == '\n' || c == '\r' || c == CP_LS || c == CP_PS);
 1820|      0|}
 1821|       |
 1822|       |static BOOL is_word_char(uint32_t c)
 1823|      0|{
 1824|      0|    return ((c >= '0' && c <= '9') ||
 1825|      0|            (c >= 'a' && c <= 'z') ||
 1826|      0|            (c >= 'A' && c <= 'Z') ||
 1827|      0|            (c == '_'));
 1828|      0|}
 1829|       |
 1830|       |#define GET_CHAR(c, cptr, cbuf_end, cbuf_type)                          \
 1831|      0|    do {                                                                \
 1832|      0|        if (cbuf_type == 0) {                                           \
 1833|      0|            c = *cptr++;                                                \
 1834|      0|        } else {                                                        \
 1835|      0|            const uint16_t *_p = (const uint16_t *)cptr;                \
 1836|      0|            const uint16_t *_end = (const uint16_t *)cbuf_end;          \
 1837|      0|            c = *_p++;                                                  \
 1838|      0|            if (is_hi_surrogate(c) && cbuf_type == 2) {                 \
 1839|      0|                if (_p < _end && is_lo_surrogate(*_p)) {                \
 1840|      0|                    c = from_surrogate(c, *_p++);                       \
 1841|      0|                }                                                       \
 1842|      0|            }                                                           \
 1843|      0|            cptr = (const void *)_p;                                    \
 1844|      0|        }                                                               \
 1845|      0|    } while (0)
 1846|       |
 1847|       |#define PEEK_CHAR(c, cptr, cbuf_end, cbuf_type)                         \
 1848|      0|    do {                                                                \
 1849|      0|        if (cbuf_type == 0) {                                           \
 1850|      0|            c = cptr[0];                                                \
 1851|      0|        } else {                                                        \
 1852|      0|            const uint16_t *_p = (const uint16_t *)cptr;                \
 1853|      0|            const uint16_t *_end = (const uint16_t *)cbuf_end;          \
 1854|      0|            c = *_p++;                                                  \
 1855|      0|            if (is_hi_surrogate(c) && cbuf_type == 2) {                 \
 1856|      0|                if (_p < _end && is_lo_surrogate(*_p)) {                \
 1857|      0|                    c = from_surrogate(c, *_p);                         \
 1858|      0|                }                                                       \
 1859|      0|            }                                                           \
 1860|      0|        }                                                               \
 1861|      0|    } while (0)
 1862|       |
 1863|       |#define PEEK_PREV_CHAR(c, cptr, cbuf_start, cbuf_type)                  \
 1864|      0|    do {                                                                \
 1865|      0|        if (cbuf_type == 0) {                                           \
 1866|      0|            c = cptr[-1];                                               \
 1867|      0|        } else {                                                        \
 1868|      0|            const uint16_t *_p = (const uint16_t *)cptr - 1;            \
 1869|      0|            const uint16_t *_start = (const uint16_t *)cbuf_start;      \
 1870|      0|            c = *_p;                                                    \
 1871|      0|            if (is_lo_surrogate(c) && cbuf_type == 2) {                 \
 1872|      0|                if (_p > _start && is_hi_surrogate(_p[-1])) {           \
 1873|      0|                    c = from_surrogate(*--_p, c);                       \
 1874|      0|                }                                                       \
 1875|      0|            }                                                           \
 1876|      0|        }                                                               \
 1877|      0|    } while (0)
 1878|       |
 1879|       |#define GET_PREV_CHAR(c, cptr, cbuf_start, cbuf_type)                   \
 1880|      0|    do {                                                                \
 1881|      0|        if (cbuf_type == 0) {                                           \
 1882|      0|            cptr--;                                                     \
 1883|      0|            c = cptr[0];                                                \
 1884|      0|        } else {                                                        \
 1885|      0|            const uint16_t *_p = (const uint16_t *)cptr - 1;            \
 1886|      0|            const uint16_t *_start = (const uint16_t *)cbuf_start;      \
 1887|      0|            c = *_p;                                                    \
 1888|      0|            if (is_lo_surrogate(c) && cbuf_type == 2) {                 \
 1889|      0|                if (_p > _start && is_hi_surrogate(_p[-1])) {           \
 1890|      0|                    c = from_surrogate(*--_p, c);                       \
 1891|      0|                }                                                       \
 1892|      0|            }                                                           \
 1893|      0|            cptr = (const void *)_p;                                    \
 1894|      0|        }                                                               \
 1895|      0|    } while (0)
 1896|       |
 1897|       |#define PREV_CHAR(cptr, cbuf_start, cbuf_type)                          \
 1898|      0|    do {                                                                \
 1899|      0|        if (cbuf_type == 0) {                                           \
 1900|      0|            cptr--;                                                     \
 1901|      0|        } else {                                                        \
 1902|      0|            const uint16_t *_p = (const uint16_t *)cptr - 1;            \
 1903|      0|            const uint16_t *_start = (const uint16_t *)cbuf_start;      \
 1904|      0|            if (is_lo_surrogate(*_p) && cbuf_type == 2) {               \
 1905|      0|                if (_p > _start && is_hi_surrogate(_p[-1])) {           \
 1906|      0|                    --_p;                                               \
 1907|      0|                }                                                       \
 1908|      0|            }                                                           \
 1909|      0|            cptr = (const void *)_p;                                    \
 1910|      0|        }                                                               \
 1911|      0|    } while (0)
 1912|       |
 1913|       |typedef uintptr_t StackInt;
 1914|       |
 1915|       |typedef enum {
 1916|       |    RE_EXEC_STATE_SPLIT,
 1917|       |    RE_EXEC_STATE_LOOKAHEAD,
 1918|       |    RE_EXEC_STATE_NEGATIVE_LOOKAHEAD,
 1919|       |    RE_EXEC_STATE_GREEDY_QUANT,
 1920|       |} REExecStateEnum;
 1921|       |
 1922|       |typedef struct REExecState {
 1923|       |    REExecStateEnum type : 8;
 1924|       |    uint8_t stack_len;
 1925|       |    size_t count; /* only used for RE_EXEC_STATE_GREEDY_QUANT */
 1926|       |    const uint8_t *cptr;
 1927|       |    const uint8_t *pc;
 1928|       |    void *buf[0];
 1929|       |} REExecState;
 1930|       |
 1931|       |typedef struct {
 1932|       |    const uint8_t *cbuf;
 1933|       |    const uint8_t *cbuf_end;
 1934|       |    /* 0 = 8 bit chars, 1 = 16 bit chars, 2 = 16 bit chars, UTF-16 */
 1935|       |    int cbuf_type;
 1936|       |    int capture_count;
 1937|       |    int stack_size_max;
 1938|       |    BOOL multi_line;
 1939|       |    BOOL ignore_case;
 1940|       |    BOOL is_unicode;
 1941|       |    int interrupt_counter;
 1942|       |    void *opaque; /* used for stack overflow check */
 1943|       |
 1944|       |    size_t state_size;
 1945|       |    uint8_t *state_stack;
 1946|       |    size_t state_stack_size;
 1947|       |    size_t state_stack_len;
 1948|       |} REExecContext;
 1949|       |
 1950|       |static int push_state(REExecContext *s,
 1951|       |                      uint8_t **capture,
 1952|       |                      StackInt *stack, size_t stack_len,
 1953|       |                      const uint8_t *pc, const uint8_t *cptr,
 1954|       |                      REExecStateEnum type, size_t count)
 1955|      0|{
 1956|      0|    REExecState *rs;
 1957|      0|    uint8_t *new_stack;
 1958|      0|    size_t new_size, i, n;
 1959|      0|    StackInt *stack_buf;
 1960|       |
 1961|      0|    if (unlikely((s->state_stack_len + 1) > s->state_stack_size)) {
 1962|       |        /* reallocate the stack */
 1963|      0|        new_size = s->state_stack_size * 3 / 2;
 1964|      0|        if (new_size < 8)
 1965|      0|            new_size = 8;
 1966|      0|        new_stack = lre_realloc(s->opaque, s->state_stack, new_size * s->state_size);
 1967|      0|        if (!new_stack)
 1968|      0|            return -1;
 1969|      0|        s->state_stack_size = new_size;
 1970|      0|        s->state_stack = new_stack;
 1971|      0|    }
 1972|      0|    rs = (REExecState *)(s->state_stack + s->state_stack_len * s->state_size);
 1973|      0|    s->state_stack_len++;
 1974|      0|    rs->type = type;
 1975|      0|    rs->count = count;
 1976|      0|    rs->stack_len = stack_len;
 1977|      0|    rs->cptr = cptr;
 1978|      0|    rs->pc = pc;
 1979|      0|    n = 2 * s->capture_count;
 1980|      0|    for(i = 0; i < n; i++)
 1981|      0|        rs->buf[i] = capture[i];
 1982|      0|    stack_buf = (StackInt *)(rs->buf + n);
 1983|      0|    for(i = 0; i < stack_len; i++)
 1984|      0|        stack_buf[i] = stack[i];
 1985|      0|    return 0;
 1986|      0|}
 1987|       |
 1988|       |static int lre_poll_timeout(REExecContext *s)
 1989|      0|{
 1990|      0|    if (unlikely(--s->interrupt_counter <= 0)) {
 1991|      0|        s->interrupt_counter = INTERRUPT_COUNTER_INIT;
 1992|      0|        if (lre_check_timeout(s->opaque))
 1993|      0|            return LRE_RET_TIMEOUT;
 1994|      0|    }
 1995|      0|    return 0;
 1996|      0|}
 1997|       |
 1998|       |/* return 1 if match, 0 if not match or < 0 if error. */
 1999|       |static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
 2000|       |                                   StackInt *stack, int stack_len,
 2001|       |                                   const uint8_t *pc, const uint8_t *cptr,
 2002|       |                                   BOOL no_recurse)
 2003|      0|{
 2004|      0|    int opcode, ret;
 2005|      0|    int cbuf_type;
 2006|      0|    uint32_t val, c;
 2007|      0|    const uint8_t *cbuf_end;
 2008|       |
 2009|      0|    cbuf_type = s->cbuf_type;
 2010|      0|    cbuf_end = s->cbuf_end;
 2011|       |
 2012|      0|    for(;;) {
 2013|       |        //        printf("top=%p: pc=%d\n", th_list.top, (int)(pc - (bc_buf + RE_HEADER_LEN)));
 2014|      0|        opcode = *pc++;
 2015|      0|        switch(opcode) {
 2016|      0|        case REOP_match:
 2017|      0|            {
 2018|      0|                REExecState *rs;
 2019|      0|                if (no_recurse)
 2020|      0|                    return (intptr_t)cptr;
 2021|      0|                ret = 1;
 2022|      0|                goto recurse;
 2023|      0|            no_match:
 2024|      0|                if (no_recurse)
 2025|      0|                    return 0;
 2026|      0|                ret = 0;
 2027|      0|            recurse:
 2028|      0|                for(;;) {
 2029|      0|                    if (lre_poll_timeout(s))
 2030|      0|                        return LRE_RET_TIMEOUT;
 2031|      0|                    if (s->state_stack_len == 0)
 2032|      0|                        return ret;
 2033|      0|                    rs = (REExecState *)(s->state_stack +
 2034|      0|                                         (s->state_stack_len - 1) * s->state_size);
 2035|      0|                    if (rs->type == RE_EXEC_STATE_SPLIT) {
 2036|      0|                        if (!ret) {
 2037|      0|                        pop_state:
 2038|      0|                            memcpy(capture, rs->buf,
 2039|      0|                                   sizeof(capture[0]) * 2 * s->capture_count);
 2040|      0|                        pop_state1:
 2041|      0|                            pc = rs->pc;
 2042|      0|                            cptr = rs->cptr;
 2043|      0|                            stack_len = rs->stack_len;
 2044|      0|                            memcpy(stack, rs->buf + 2 * s->capture_count,
 2045|      0|                                   stack_len * sizeof(stack[0]));
 2046|      0|                            s->state_stack_len--;
 2047|      0|                            break;
 2048|      0|                        }
 2049|      0|                    } else if (rs->type == RE_EXEC_STATE_GREEDY_QUANT) {
 2050|      0|                        if (!ret) {
 2051|      0|                            uint32_t char_count, i;
 2052|      0|                            memcpy(capture, rs->buf,
 2053|      0|                                   sizeof(capture[0]) * 2 * s->capture_count);
 2054|      0|                            stack_len = rs->stack_len;
 2055|      0|                            memcpy(stack, rs->buf + 2 * s->capture_count,
 2056|      0|                                   stack_len * sizeof(stack[0]));
 2057|      0|                            pc = rs->pc;
 2058|      0|                            cptr = rs->cptr;
 2059|       |                            /* go backward */
 2060|      0|                            char_count = get_u32(pc + 12);
 2061|      0|                            for(i = 0; i < char_count; i++) {
 2062|      0|                                PREV_CHAR(cptr, s->cbuf, cbuf_type);
 2063|      0|                            }
 2064|      0|                            pc = (pc + 16) + (int)get_u32(pc);
 2065|      0|                            rs->cptr = cptr;
 2066|      0|                            rs->count--;
 2067|      0|                            if (rs->count == 0) {
 2068|      0|                                s->state_stack_len--;
 2069|      0|                            }
 2070|      0|                            break;
 2071|      0|                        }
 2072|      0|                    } else {
 2073|      0|                        ret = ((rs->type == RE_EXEC_STATE_LOOKAHEAD && ret) ||
 2074|      0|                               (rs->type == RE_EXEC_STATE_NEGATIVE_LOOKAHEAD && !ret));
 2075|      0|                        if (ret) {
 2076|       |                            /* keep the capture in case of positive lookahead */
 2077|      0|                            if (rs->type == RE_EXEC_STATE_LOOKAHEAD)
 2078|      0|                                goto pop_state1;
 2079|      0|                            else
 2080|      0|                                goto pop_state;
 2081|      0|                        }
 2082|      0|                    }
 2083|      0|                    s->state_stack_len--;
 2084|      0|                }
 2085|      0|            }
 2086|      0|            break;
 2087|      0|        case REOP_char32:
 2088|      0|            val = get_u32(pc);
 2089|      0|            pc += 4;
 2090|      0|            goto test_char;
 2091|      0|        case REOP_char:
 2092|      0|            val = get_u16(pc);
 2093|      0|            pc += 2;
 2094|      0|        test_char:
 2095|      0|            if (cptr >= cbuf_end)
 2096|      0|                goto no_match;
 2097|      0|            GET_CHAR(c, cptr, cbuf_end, cbuf_type);
 2098|      0|            if (s->ignore_case) {
 2099|      0|                c = lre_canonicalize(c, s->is_unicode);
 2100|      0|            }
 2101|      0|            if (val != c)
 2102|      0|                goto no_match;
 2103|      0|            break;
 2104|      0|        case REOP_split_goto_first:
 2105|      0|        case REOP_split_next_first:
 2106|      0|            {
 2107|      0|                const uint8_t *pc1;
 2108|       |
 2109|      0|                val = get_u32(pc);
 2110|      0|                pc += 4;
 2111|      0|                if (opcode == REOP_split_next_first) {
 2112|      0|                    pc1 = pc + (int)val;
 2113|      0|                } else {
 2114|      0|                    pc1 = pc;
 2115|      0|                    pc = pc + (int)val;
 2116|      0|                }
 2117|      0|                ret = push_state(s, capture, stack, stack_len,
 2118|      0|                                 pc1, cptr, RE_EXEC_STATE_SPLIT, 0);
 2119|      0|                if (ret < 0)
 2120|      0|                    return LRE_RET_MEMORY_ERROR;
 2121|      0|                break;
 2122|      0|            }
 2123|      0|        case REOP_lookahead:
 2124|      0|        case REOP_negative_lookahead:
 2125|      0|            val = get_u32(pc);
 2126|      0|            pc += 4;
 2127|      0|            ret = push_state(s, capture, stack, stack_len,
 2128|      0|                             pc + (int)val, cptr,
 2129|      0|                             RE_EXEC_STATE_LOOKAHEAD + opcode - REOP_lookahead,
 2130|      0|                             0);
 2131|      0|            if (ret < 0)
 2132|      0|                return LRE_RET_MEMORY_ERROR;
 2133|      0|            break;
 2134|       |
 2135|      0|        case REOP_goto:
 2136|      0|            val = get_u32(pc);
 2137|      0|            pc += 4 + (int)val;
 2138|      0|            if (lre_poll_timeout(s))
 2139|      0|                return LRE_RET_TIMEOUT;
 2140|      0|            break;
 2141|      0|        case REOP_line_start:
 2142|      0|            if (cptr == s->cbuf)
 2143|      0|                break;
 2144|      0|            if (!s->multi_line)
 2145|      0|                goto no_match;
 2146|      0|            PEEK_PREV_CHAR(c, cptr, s->cbuf, cbuf_type);
 2147|      0|            if (!is_line_terminator(c))
 2148|      0|                goto no_match;
 2149|      0|            break;
 2150|      0|        case REOP_line_end:
 2151|      0|            if (cptr == cbuf_end)
 2152|      0|                break;
 2153|      0|            if (!s->multi_line)
 2154|      0|                goto no_match;
 2155|      0|            PEEK_CHAR(c, cptr, cbuf_end, cbuf_type);
 2156|      0|            if (!is_line_terminator(c))
 2157|      0|                goto no_match;
 2158|      0|            break;
 2159|      0|        case REOP_dot:
 2160|      0|            if (cptr == cbuf_end)
 2161|      0|                goto no_match;
 2162|      0|            GET_CHAR(c, cptr, cbuf_end, cbuf_type);
 2163|      0|            if (is_line_terminator(c))
 2164|      0|                goto no_match;
 2165|      0|            break;
 2166|      0|        case REOP_any:
 2167|      0|            if (cptr == cbuf_end)
 2168|      0|                goto no_match;
 2169|      0|            GET_CHAR(c, cptr, cbuf_end, cbuf_type);
 2170|      0|            break;
 2171|      0|        case REOP_save_start:
 2172|      0|        case REOP_save_end:
 2173|      0|            val = *pc++;
 2174|      0|            assert(val < s->capture_count);
 2175|      0|            capture[2 * val + opcode - REOP_save_start] = (uint8_t *)cptr;
 2176|      0|            break;
 2177|      0|        case REOP_save_reset:
 2178|      0|            {
 2179|      0|                uint32_t val2;
 2180|      0|                val = pc[0];
 2181|      0|                val2 = pc[1];
 2182|      0|                pc += 2;
 2183|      0|                assert(val2 < s->capture_count);
 2184|      0|                while (val <= val2) {
 2185|      0|                    capture[2 * val] = NULL;
 2186|      0|                    capture[2 * val + 1] = NULL;
 2187|      0|                    val++;
 2188|      0|                }
 2189|      0|            }
 2190|      0|            break;
 2191|      0|        case REOP_push_i32:
 2192|      0|            val = get_u32(pc);
 2193|      0|            pc += 4;
 2194|      0|            stack[stack_len++] = val;
 2195|      0|            break;
 2196|      0|        case REOP_drop:
 2197|      0|            stack_len--;
 2198|      0|            break;
 2199|      0|        case REOP_loop:
 2200|      0|            val = get_u32(pc);
 2201|      0|            pc += 4;
 2202|      0|            if (--stack[stack_len - 1] != 0) {
 2203|      0|                pc += (int)val;
 2204|      0|                if (lre_poll_timeout(s))
 2205|      0|                    return LRE_RET_TIMEOUT;
 2206|      0|            }
 2207|      0|            break;
 2208|      0|        case REOP_push_char_pos:
 2209|      0|            stack[stack_len++] = (uintptr_t)cptr;
 2210|      0|            break;
 2211|      0|        case REOP_check_advance:
 2212|      0|            if (stack[--stack_len] == (uintptr_t)cptr)
 2213|      0|                goto no_match;
 2214|      0|            break;
 2215|      0|        case REOP_word_boundary:
 2216|      0|        case REOP_not_word_boundary:
 2217|      0|            {
 2218|      0|                BOOL v1, v2;
 2219|       |                /* char before */
 2220|      0|                if (cptr == s->cbuf) {
 2221|      0|                    v1 = FALSE;
 2222|      0|                } else {
 2223|      0|                    PEEK_PREV_CHAR(c, cptr, s->cbuf, cbuf_type);
 2224|      0|                    v1 = is_word_char(c);
 2225|      0|                }
 2226|       |                /* current char */
 2227|      0|                if (cptr >= cbuf_end) {
 2228|      0|                    v2 = FALSE;
 2229|      0|                } else {
 2230|      0|                    PEEK_CHAR(c, cptr, cbuf_end, cbuf_type);
 2231|      0|                    v2 = is_word_char(c);
 2232|      0|                }
 2233|      0|                if (v1 ^ v2 ^ (REOP_not_word_boundary - opcode))
 2234|      0|                    goto no_match;
 2235|      0|            }
 2236|      0|            break;
 2237|      0|        case REOP_back_reference:
 2238|      0|        case REOP_backward_back_reference:
 2239|      0|            {
 2240|      0|                const uint8_t *cptr1, *cptr1_end, *cptr1_start;
 2241|      0|                uint32_t c1, c2;
 2242|       |
 2243|      0|                val = *pc++;
 2244|      0|                if (val >= s->capture_count)
 2245|      0|                    goto no_match;
 2246|      0|                cptr1_start = capture[2 * val];
 2247|      0|                cptr1_end = capture[2 * val + 1];
 2248|      0|                if (!cptr1_start || !cptr1_end)
 2249|      0|                    break;
 2250|      0|                if (opcode == REOP_back_reference) {
 2251|      0|                    cptr1 = cptr1_start;
 2252|      0|                    while (cptr1 < cptr1_end) {
 2253|      0|                        if (cptr >= cbuf_end)
 2254|      0|                            goto no_match;
 2255|      0|                        GET_CHAR(c1, cptr1, cptr1_end, cbuf_type);
 2256|      0|                        GET_CHAR(c2, cptr, cbuf_end, cbuf_type);
 2257|      0|                        if (s->ignore_case) {
 2258|      0|                            c1 = lre_canonicalize(c1, s->is_unicode);
 2259|      0|                            c2 = lre_canonicalize(c2, s->is_unicode);
 2260|      0|                        }
 2261|      0|                        if (c1 != c2)
 2262|      0|                            goto no_match;
 2263|      0|                    }
 2264|      0|                } else {
 2265|      0|                    cptr1 = cptr1_end;
 2266|      0|                    while (cptr1 > cptr1_start) {
 2267|      0|                        if (cptr == s->cbuf)
 2268|      0|                            goto no_match;
 2269|      0|                        GET_PREV_CHAR(c1, cptr1, cptr1_start, cbuf_type);
 2270|      0|                        GET_PREV_CHAR(c2, cptr, s->cbuf, cbuf_type);
 2271|      0|                        if (s->ignore_case) {
 2272|      0|                            c1 = lre_canonicalize(c1, s->is_unicode);
 2273|      0|                            c2 = lre_canonicalize(c2, s->is_unicode);
 2274|      0|                        }
 2275|      0|                        if (c1 != c2)
 2276|      0|                            goto no_match;
 2277|      0|                    }
 2278|      0|                }
 2279|      0|            }
 2280|      0|            break;
 2281|      0|        case REOP_range:
 2282|      0|            {
 2283|      0|                int n;
 2284|      0|                uint32_t low, high, idx_min, idx_max, idx;
 2285|       |
 2286|      0|                n = get_u16(pc); /* n must be >= 1 */
 2287|      0|                pc += 2;
 2288|      0|                if (cptr >= cbuf_end)
 2289|      0|                    goto no_match;
 2290|      0|                GET_CHAR(c, cptr, cbuf_end, cbuf_type);
 2291|      0|                if (s->ignore_case) {
 2292|      0|                    c = lre_canonicalize(c, s->is_unicode);
 2293|      0|                }
 2294|      0|                idx_min = 0;
 2295|      0|                low = get_u16(pc + 0 * 4);
 2296|      0|                if (c < low)
 2297|      0|                    goto no_match;
 2298|      0|                idx_max = n - 1;
 2299|      0|                high = get_u16(pc + idx_max * 4 + 2);
 2300|       |                /* 0xffff in for last value means +infinity */
 2301|      0|                if (unlikely(c >= 0xffff) && high == 0xffff)
 2302|      0|                    goto range_match;
 2303|      0|                if (c > high)
 2304|      0|                    goto no_match;
 2305|      0|                while (idx_min <= idx_max) {
 2306|      0|                    idx = (idx_min + idx_max) / 2;
 2307|      0|                    low = get_u16(pc + idx * 4);
 2308|      0|                    high = get_u16(pc + idx * 4 + 2);
 2309|      0|                    if (c < low)
 2310|      0|                        idx_max = idx - 1;
 2311|      0|                    else if (c > high)
 2312|      0|                        idx_min = idx + 1;
 2313|      0|                    else
 2314|      0|                        goto range_match;
 2315|      0|                }
 2316|      0|                goto no_match;
 2317|      0|            range_match:
 2318|      0|                pc += 4 * n;
 2319|      0|            }
 2320|      0|            break;
 2321|      0|        case REOP_range32:
 2322|      0|            {
 2323|      0|                int n;
 2324|      0|                uint32_t low, high, idx_min, idx_max, idx;
 2325|       |
 2326|      0|                n = get_u16(pc); /* n must be >= 1 */
 2327|      0|                pc += 2;
 2328|      0|                if (cptr >= cbuf_end)
 2329|      0|                    goto no_match;
 2330|      0|                GET_CHAR(c, cptr, cbuf_end, cbuf_type);
 2331|      0|                if (s->ignore_case) {
 2332|      0|                    c = lre_canonicalize(c, s->is_unicode);
 2333|      0|                }
 2334|      0|                idx_min = 0;
 2335|      0|                low = get_u32(pc + 0 * 8);
 2336|      0|                if (c < low)
 2337|      0|                    goto no_match;
 2338|      0|                idx_max = n - 1;
 2339|      0|                high = get_u32(pc + idx_max * 8 + 4);
 2340|      0|                if (c > high)
 2341|      0|                    goto no_match;
 2342|      0|                while (idx_min <= idx_max) {
 2343|      0|                    idx = (idx_min + idx_max) / 2;
 2344|      0|                    low = get_u32(pc + idx * 8);
 2345|      0|                    high = get_u32(pc + idx * 8 + 4);
 2346|      0|                    if (c < low)
 2347|      0|                        idx_max = idx - 1;
 2348|      0|                    else if (c > high)
 2349|      0|                        idx_min = idx + 1;
 2350|      0|                    else
 2351|      0|                        goto range32_match;
 2352|      0|                }
 2353|      0|                goto no_match;
 2354|      0|            range32_match:
 2355|      0|                pc += 8 * n;
 2356|      0|            }
 2357|      0|            break;
 2358|      0|        case REOP_prev:
 2359|       |            /* go to the previous char */
 2360|      0|            if (cptr == s->cbuf)
 2361|      0|                goto no_match;
 2362|      0|            PREV_CHAR(cptr, s->cbuf, cbuf_type);
 2363|      0|            break;
 2364|      0|        case REOP_simple_greedy_quant:
 2365|      0|            {
 2366|      0|                uint32_t next_pos, quant_min, quant_max;
 2367|      0|                size_t q;
 2368|      0|                intptr_t res;
 2369|      0|                const uint8_t *pc1;
 2370|       |
 2371|      0|                next_pos = get_u32(pc);
 2372|      0|                quant_min = get_u32(pc + 4);
 2373|      0|                quant_max = get_u32(pc + 8);
 2374|      0|                pc += 16;
 2375|      0|                pc1 = pc;
 2376|      0|                pc += (int)next_pos;
 2377|       |
 2378|      0|                q = 0;
 2379|      0|                for(;;) {
 2380|      0|                    if (lre_poll_timeout(s))
 2381|      0|                        return LRE_RET_TIMEOUT;
 2382|      0|                    res = lre_exec_backtrack(s, capture, stack, stack_len,
 2383|      0|                                             pc1, cptr, TRUE);
 2384|      0|                    if (res == LRE_RET_MEMORY_ERROR ||
 2385|      0|                        res == LRE_RET_TIMEOUT)
 2386|      0|                        return res;
 2387|      0|                    if (!res)
 2388|      0|                        break;
 2389|      0|                    cptr = (uint8_t *)res;
 2390|      0|                    q++;
 2391|      0|                    if (q >= quant_max && quant_max != INT32_MAX)
 2392|      0|                        break;
 2393|      0|                }
 2394|      0|                if (q < quant_min)
 2395|      0|                    goto no_match;
 2396|      0|                if (q > quant_min) {
 2397|       |                    /* will examine all matches down to quant_min */
 2398|      0|                    ret = push_state(s, capture, stack, stack_len,
 2399|      0|                                     pc1 - 16, cptr,
 2400|      0|                                     RE_EXEC_STATE_GREEDY_QUANT,
 2401|      0|                                     q - quant_min);
 2402|      0|                    if (ret < 0)
 2403|      0|                        return LRE_RET_MEMORY_ERROR;
 2404|      0|                }
 2405|      0|            }
 2406|      0|            break;
 2407|      0|        default:
 2408|      0|            abort();
 2409|      0|        }
 2410|      0|    }
 2411|      0|}
 2412|       |
 2413|       |/* Return 1 if match, 0 if not match or < 0 if error (see LRE_RET_x). cindex is the
 2414|       |   starting position of the match and must be such as 0 <= cindex <=
 2415|       |   clen. */
 2416|       |int lre_exec(uint8_t **capture,
 2417|       |             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,
 2418|       |             int cbuf_type, void *opaque)
 2419|      0|{
 2420|      0|    REExecContext s_s, *s = &s_s;
 2421|      0|    int re_flags, i, alloca_size, ret;
 2422|      0|    StackInt *stack_buf;
 2423|       |
 2424|      0|    re_flags = lre_get_flags(bc_buf);
 2425|      0|    s->multi_line = (re_flags & LRE_FLAG_MULTILINE) != 0;
 2426|      0|    s->ignore_case = (re_flags & LRE_FLAG_IGNORECASE) != 0;
 2427|      0|    s->is_unicode = (re_flags & LRE_FLAG_UNICODE) != 0;
 2428|      0|    s->capture_count = bc_buf[RE_HEADER_CAPTURE_COUNT];
 2429|      0|    s->stack_size_max = bc_buf[RE_HEADER_STACK_SIZE];
 2430|      0|    s->cbuf = cbuf;
 2431|      0|    s->cbuf_end = cbuf + (clen << cbuf_type);
 2432|      0|    s->cbuf_type = cbuf_type;
 2433|      0|    if (s->cbuf_type == 1 && s->is_unicode)
 2434|      0|        s->cbuf_type = 2;
 2435|      0|    s->interrupt_counter = INTERRUPT_COUNTER_INIT;
 2436|      0|    s->opaque = opaque;
 2437|       |
 2438|      0|    s->state_size = sizeof(REExecState) +
 2439|      0|        s->capture_count * sizeof(capture[0]) * 2 +
 2440|      0|        s->stack_size_max * sizeof(stack_buf[0]);
 2441|      0|    s->state_stack = NULL;
 2442|      0|    s->state_stack_len = 0;
 2443|      0|    s->state_stack_size = 0;
 2444|       |
 2445|      0|    for(i = 0; i < s->capture_count * 2; i++)
 2446|      0|        capture[i] = NULL;
 2447|      0|    alloca_size = s->stack_size_max * sizeof(stack_buf[0]);
 2448|      0|    stack_buf = alloca(alloca_size);
 2449|      0|    ret = lre_exec_backtrack(s, capture, stack_buf, 0, bc_buf + RE_HEADER_LEN,
 2450|      0|                             cbuf + (cindex << cbuf_type), FALSE);
 2451|      0|    lre_realloc(s->opaque, s->state_stack, 0);
 2452|      0|    return ret;
 2453|      0|}
 2454|       |
 2455|       |int lre_get_capture_count(const uint8_t *bc_buf)
 2456|      0|{
 2457|      0|    return bc_buf[RE_HEADER_CAPTURE_COUNT];
 2458|      0|}
 2459|       |
 2460|       |int lre_get_flags(const uint8_t *bc_buf)
 2461|  5.46M|{
 2462|  5.46M|    return bc_buf[RE_HEADER_FLAGS];
 2463|  5.46M|}
 2464|       |
 2465|       |/* Return NULL if no group names. Otherwise, return a pointer to
 2466|       |   'capture_count - 1' zero terminated UTF-8 strings. */
 2467|       |const char *lre_get_groupnames(const uint8_t *bc_buf)
 2468|      0|{
 2469|      0|    uint32_t re_bytecode_len;
 2470|      0|    if ((lre_get_flags(bc_buf) & LRE_FLAG_NAMED_GROUPS) == 0)
 2471|      0|        return NULL;
 2472|      0|    re_bytecode_len = get_u32(bc_buf + RE_HEADER_BYTECODE_LEN);
 2473|      0|    return (const char *)(bc_buf + RE_HEADER_LEN + re_bytecode_len);
 2474|      0|}
 2475|       |
 2476|       |#ifdef TEST
 2477|       |
 2478|       |BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size)
 2479|       |{
 2480|       |    return FALSE;
 2481|       |}
 2482|       |
 2483|       |void *lre_realloc(void *opaque, void *ptr, size_t size)
 2484|       |{
 2485|       |    return realloc(ptr, size);
 2486|       |}
 2487|       |
 2488|       |int main(int argc, char **argv)
 2489|       |{
 2490|       |    int len, flags, ret, i;
 2491|       |    uint8_t *bc;
 2492|       |    char error_msg[64];
 2493|       |    uint8_t *capture[CAPTURE_COUNT_MAX * 2];
 2494|       |    const char *input;
 2495|       |    int input_len, capture_count;
 2496|       |
 2497|       |    if (argc < 4) {
 2498|       |        printf("usage: %s regexp flags input\n", argv[0]);
 2499|       |        return 1;
 2500|       |    }
 2501|       |    flags = atoi(argv[2]);
 2502|       |    bc = lre_compile(&len, error_msg, sizeof(error_msg), argv[1],
 2503|       |                     strlen(argv[1]), flags, NULL);
 2504|       |    if (!bc) {
 2505|       |        fprintf(stderr, "error: %s\n", error_msg);
 2506|       |        exit(1);
 2507|       |    }
 2508|       |
 2509|       |    input = argv[3];
 2510|       |    input_len = strlen(input);
 2511|       |
 2512|       |    ret = lre_exec(capture, bc, (uint8_t *)input, 0, input_len, 0, NULL);
 2513|       |    printf("ret=%d\n", ret);
 2514|       |    if (ret == 1) {
 2515|       |        capture_count = lre_get_capture_count(bc);
 2516|       |        for(i = 0; i < 2 * capture_count; i++) {
 2517|       |            uint8_t *ptr;
 2518|       |            ptr = capture[i];
 2519|       |            printf("%d: ", i);
 2520|       |            if (!ptr)
 2521|       |                printf("<nil>");
 2522|       |            else
 2523|       |                printf("%u", (int)(ptr - (uint8_t *)input));
 2524|       |            printf("\n");
 2525|       |        }
 2526|       |    }
 2527|       |    return 0;
 2528|       |}
 2529|       |#endif

/home/eugeneriabinin777/quickjs/libregexp.h:
    1|       |/*
    2|       | * Regular Expression Engine
    3|       | *
    4|       | * Copyright (c) 2017-2018 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |#ifndef LIBREGEXP_H
   25|       |#define LIBREGEXP_H
   26|       |
   27|       |#include <stddef.h>
   28|       |#include <stdint.h>
   29|       |
   30|  1.81k|#define LRE_FLAG_GLOBAL     (1 << 0)
   31|  39.8k|#define LRE_FLAG_IGNORECASE (1 << 1)
   32|    264|#define LRE_FLAG_MULTILINE  (1 << 2)
   33|  39.6k|#define LRE_FLAG_DOTALL     (1 << 3)
   34|  78.7k|#define LRE_FLAG_UNICODE    (1 << 4)
   35|  39.2k|#define LRE_FLAG_STICKY     (1 << 5)
   36|     35|#define LRE_FLAG_INDICES    (1 << 6) /* Unused by libregexp, just recorded. */
   37|      0|#define LRE_FLAG_NAMED_GROUPS (1 << 7) /* named groups are present in the regexp */
   38|       |
   39|      0|#define LRE_RET_MEMORY_ERROR (-1)
   40|      0|#define LRE_RET_TIMEOUT      (-2)
   41|       |
   42|       |uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
   43|       |                     const char *buf, size_t buf_len, int re_flags,
   44|       |                     void *opaque);
   45|       |int lre_get_capture_count(const uint8_t *bc_buf);
   46|       |int lre_get_flags(const uint8_t *bc_buf);
   47|       |const char *lre_get_groupnames(const uint8_t *bc_buf);
   48|       |int lre_exec(uint8_t **capture,
   49|       |             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,
   50|       |             int cbuf_type, void *opaque);
   51|       |
   52|       |int lre_parse_escape(const uint8_t **pp, int allow_utf16);
   53|       |
   54|       |/* must be provided by the user, return non zero if overflow */
   55|       |int lre_check_stack_overflow(void *opaque, size_t alloca_size);
   56|       |/* must be provided by the user, return non zero if time out */
   57|       |int lre_check_timeout(void *opaque);
   58|       |void *lre_realloc(void *opaque, void *ptr, size_t size);
   59|       |
   60|       |#endif /* LIBREGEXP_H */

/home/eugeneriabinin777/quickjs/libunicode.c:
    1|       |/*
    2|       | * Unicode utilities
    3|       | *
    4|       | * Copyright (c) 2017-2018 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |#include <stdlib.h>
   25|       |#include <stdio.h>
   26|       |#include <stdarg.h>
   27|       |#include <string.h>
   28|       |#include <assert.h>
   29|       |
   30|       |#include "cutils.h"
   31|       |#include "libunicode.h"
   32|       |#include "libunicode-table.h"
   33|       |
   34|       |enum {
   35|       |    RUN_TYPE_U,
   36|       |    RUN_TYPE_L,
   37|       |    RUN_TYPE_UF,
   38|       |    RUN_TYPE_LF,
   39|       |    RUN_TYPE_UL,
   40|       |    RUN_TYPE_LSU,
   41|       |    RUN_TYPE_U2L_399_EXT2,
   42|       |    RUN_TYPE_UF_D20,
   43|       |    RUN_TYPE_UF_D1_EXT,
   44|       |    RUN_TYPE_U_EXT,
   45|       |    RUN_TYPE_LF_EXT,
   46|       |    RUN_TYPE_UF_EXT2,
   47|       |    RUN_TYPE_LF_EXT2,
   48|       |    RUN_TYPE_UF_EXT3,
   49|       |};
   50|       |
   51|       |static int lre_case_conv1(uint32_t c, int conv_type)
   52|  1.46M|{
   53|  1.46M|    uint32_t res[LRE_CC_RES_LEN_MAX];
   54|  1.46M|    lre_case_conv(res, c, conv_type);
   55|  1.46M|    return res[0];
   56|  1.46M|}
   57|       |
   58|       |/* case conversion using the table entry 'idx' with value 'v' */
   59|       |static int lre_case_conv_entry(uint32_t *res, uint32_t c, int conv_type, uint32_t idx, uint32_t v)
   60|  17.2M|{
   61|  17.2M|    uint32_t code, data, type, a, is_lower;
   62|  17.2M|    is_lower = (conv_type != 0);
   63|  17.2M|    type = (v >> (32 - 17 - 7 - 4)) & 0xf;
   64|  17.2M|    data = ((v & 0xf) << 8) | case_conv_table2[idx];
   65|  17.2M|    code = v >> (32 - 17);
   66|  17.2M|    switch(type) {
   67|  1.40M|    case RUN_TYPE_U:
   68|  1.40M|    case RUN_TYPE_L:
   69|  2.32M|    case RUN_TYPE_UF:
   70|  9.99M|    case RUN_TYPE_LF:
   71|  9.99M|        if (conv_type == (type & 1) ||
   72|  9.99M|            (type >= RUN_TYPE_UF && conv_type == 2)) {
   73|  9.99M|            c = c - code + (case_conv_table1[data] >> (32 - 17));
   74|  9.99M|        }
   75|  9.99M|        break;
   76|  5.78M|    case RUN_TYPE_UL:
   77|  5.78M|        a = c - code;
   78|  5.78M|        if ((a & 1) != (1 - is_lower))
   79|    258|            break;
   80|  5.78M|        c = (a ^ 1) + code;
   81|  5.78M|        break;
   82|  85.8k|    case RUN_TYPE_LSU:
   83|  85.8k|        a = c - code;
   84|  85.8k|        if (a == 1) {
   85|  42.8k|            c += 2 * is_lower - 1;
   86|  43.0k|        } else if (a == (1 - is_lower) * 2) {
   87|  42.8k|            c += (2 * is_lower - 1) * 2;
   88|  42.8k|        }
   89|  85.8k|        break;
   90|   287k|    case RUN_TYPE_U2L_399_EXT2:
   91|   287k|        if (!is_lower) {
   92|  49.4k|            res[0] = c - code + case_conv_ext[data >> 6];
   93|  49.4k|            res[1] = 0x399;
   94|  49.4k|            return 2;
   95|   238k|        } else {
   96|   238k|            c = c - code + case_conv_ext[data & 0x3f];
   97|   238k|        }
   98|   238k|        break;
   99|   238k|    case RUN_TYPE_UF_D20:
  100|   202k|        if (conv_type == 1)
  101|      0|            break;
  102|   202k|        c = data + (conv_type == 2) * 0x20;
  103|   202k|        break;
  104|  31.9k|    case RUN_TYPE_UF_D1_EXT:
  105|  31.9k|        if (conv_type == 1)
  106|      0|            break;
  107|  31.9k|        c = case_conv_ext[data] + (conv_type == 2);
  108|  31.9k|        break;
  109|  1.87k|    case RUN_TYPE_U_EXT:
  110|  37.1k|    case RUN_TYPE_LF_EXT:
  111|  37.1k|        if (is_lower != (type - RUN_TYPE_U_EXT))
  112|      0|            break;
  113|  37.1k|        c = case_conv_ext[data];
  114|  37.1k|        break;
  115|  8.84k|    case RUN_TYPE_LF_EXT2:
  116|  8.84k|        if (!is_lower)
  117|      0|            break;
  118|  8.84k|        res[0] = c - code + case_conv_ext[data >> 6];
  119|  8.84k|        res[1] = case_conv_ext[data & 0x3f];
  120|  8.84k|        return 2;
  121|   629k|    case RUN_TYPE_UF_EXT2:
  122|   629k|        if (conv_type == 1)
  123|      0|            break;
  124|   629k|        res[0] = c - code + case_conv_ext[data >> 6];
  125|   629k|        res[1] = case_conv_ext[data & 0x3f];
  126|   629k|        if (conv_type == 2) {
  127|       |            /* convert to lower */
  128|   520k|            res[0] = lre_case_conv1(res[0], 1);
  129|   520k|            res[1] = lre_case_conv1(res[1], 1);
  130|   520k|        }
  131|   629k|        return 2;
  132|      0|    default:
  133|   170k|    case RUN_TYPE_UF_EXT3:
  134|   170k|        if (conv_type == 1)
  135|      0|            break;
  136|   170k|        res[0] = case_conv_ext[data >> 8];
  137|   170k|        res[1] = case_conv_ext[(data >> 4) & 0xf];
  138|   170k|        res[2] = case_conv_ext[data & 0xf];
  139|   170k|        if (conv_type == 2) {
  140|       |            /* convert to lower */
  141|   141k|            res[0] = lre_case_conv1(res[0], 1);
  142|   141k|            res[1] = lre_case_conv1(res[1], 1);
  143|   141k|            res[2] = lre_case_conv1(res[2], 1);
  144|   141k|        }
  145|   170k|        return 3;
  146|  17.2M|    }
  147|  16.3M|    res[0] = c;
  148|  16.3M|    return 1;
  149|  17.2M|}
  150|       |
  151|       |/* conv_type:
  152|       |   0 = to upper
  153|       |   1 = to lower
  154|       |   2 = case folding (= to lower with modifications)
  155|       |*/
  156|       |int lre_case_conv(uint32_t *res, uint32_t c, int conv_type)
  157|  1.46M|{
  158|  1.46M|    if (c < 128) {
  159|   220k|        if (conv_type) {
  160|   220k|            if (c >= 'A' && c <= 'Z') {
  161|   220k|                c = c - 'A' + 'a';
  162|   220k|            }
  163|   220k|        } else {
  164|      0|            if (c >= 'a' && c <= 'z') {
  165|      0|                c = c - 'a' + 'A';
  166|      0|            }
  167|      0|        }
  168|  1.24M|    } else {
  169|  1.24M|        uint32_t v, code, len;
  170|  1.24M|        int idx, idx_min, idx_max;
  171|       |
  172|  1.24M|        idx_min = 0;
  173|  1.24M|        idx_max = countof(case_conv_table1) - 1;
  174|  10.0M|        while (idx_min <= idx_max) {
  175|  9.65M|            idx = (unsigned)(idx_max + idx_min) / 2;
  176|  9.65M|            v = case_conv_table1[idx];
  177|  9.65M|            code = v >> (32 - 17);
  178|  9.65M|            len = (v >> (32 - 17 - 7)) & 0x7f;
  179|  9.65M|            if (c < code) {
  180|  4.06M|                idx_max = idx - 1;
  181|  5.58M|            } else if (c >= code + len) {
  182|  4.68M|                idx_min = idx + 1;
  183|  4.68M|            } else {
  184|   900k|                return lre_case_conv_entry(res, c, conv_type, idx, v);
  185|   900k|            }
  186|  9.65M|        }
  187|  1.24M|    }
  188|   565k|    res[0] = c;
  189|   565k|    return 1;
  190|  1.46M|}
  191|       |
  192|       |static int lre_case_folding_entry(uint32_t c, uint32_t idx, uint32_t v, BOOL is_unicode)
  193|  16.3M|{
  194|  16.3M|    uint32_t res[LRE_CC_RES_LEN_MAX];
  195|  16.3M|    int len;
  196|       |
  197|  16.3M|    if (is_unicode) {
  198|  13.5M|        len = lre_case_conv_entry(res, c, 2, idx, v);
  199|  13.5M|        if (len == 1) {
  200|  12.8M|            c = res[0];
  201|  12.8M|        } else {
  202|       |            /* handle the few specific multi-character cases (see
  203|       |               unicode_gen.c:dump_case_folding_special_cases()) */
  204|   670k|            if (c == 0xfb06) {
  205|  8.82k|                c = 0xfb05;
  206|   662k|            } else if (c == 0x01fd3) {
  207|  8.82k|                c = 0x390;
  208|   653k|            } else if (c == 0x01fe3) {
  209|  8.82k|                c = 0x3b0;
  210|  8.82k|            }
  211|   670k|        }
  212|  13.5M|    } else {
  213|  2.82M|        if (likely(c < 128)) {
  214|  12.9k|            if (c >= 'a' && c <= 'z')
  215|  12.9k|                c = c - 'a' + 'A';
  216|  2.80M|        } else {
  217|       |            /* legacy regexp: to upper case if single char >= 128 */
  218|  2.80M|            len = lre_case_conv_entry(res, c, FALSE, idx, v);
  219|  2.80M|            if (len == 1 && res[0] >= 128)
  220|  2.61M|                c = res[0];
  221|  2.80M|        }
  222|  2.82M|    }
  223|  16.3M|    return c;
  224|  16.3M|}
  225|       |
  226|       |/* JS regexp specific rules for case folding */
  227|       |int lre_canonicalize(uint32_t c, BOOL is_unicode)
  228|  44.8k|{
  229|  44.8k|    if (c < 128) {
  230|       |        /* fast case */
  231|  43.4k|        if (is_unicode) {
  232|  1.76k|            if (c >= 'A' && c <= 'Z') {
  233|    297|                c = c - 'A' + 'a';
  234|    297|            }
  235|  41.6k|        } else {
  236|  41.6k|            if (c >= 'a' && c <= 'z') {
  237|  15.6k|                c = c - 'a' + 'A';
  238|  15.6k|            }
  239|  41.6k|        }
  240|  43.4k|    } else {
  241|  1.47k|        uint32_t v, code, len;
  242|  1.47k|        int idx, idx_min, idx_max;
  243|       |
  244|  1.47k|        idx_min = 0;
  245|  1.47k|        idx_max = countof(case_conv_table1) - 1;
  246|  11.7k|        while (idx_min <= idx_max) {
  247|  11.4k|            idx = (unsigned)(idx_max + idx_min) / 2;
  248|  11.4k|            v = case_conv_table1[idx];
  249|  11.4k|            code = v >> (32 - 17);
  250|  11.4k|            len = (v >> (32 - 17 - 7)) & 0x7f;
  251|  11.4k|            if (c < code) {
  252|  5.74k|                idx_max = idx - 1;
  253|  5.74k|            } else if (c >= code + len) {
  254|  4.48k|                idx_min = idx + 1;
  255|  4.48k|            } else {
  256|  1.19k|                return lre_case_folding_entry(c, idx, v, is_unicode);
  257|  1.19k|            }
  258|  11.4k|        }
  259|  1.47k|    }
  260|  43.6k|    return c;
  261|  44.8k|}
  262|       |
  263|       |static uint32_t get_le24(const uint8_t *ptr)
  264|   329k|{
  265|   329k|    return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16);
  266|   329k|}
  267|       |
  268|  25.9k|#define UNICODE_INDEX_BLOCK_LEN 32
  269|       |
  270|       |/* return -1 if not in table, otherwise the offset in the block */
  271|       |static int get_index_pos(uint32_t *pcode, uint32_t c,
  272|       |                         const uint8_t *index_table, int index_table_len)
  273|  90.2k|{
  274|  90.2k|    uint32_t code, v;
  275|  90.2k|    int idx_min, idx_max, idx;
  276|       |
  277|  90.2k|    idx_min = 0;
  278|  90.2k|    v = get_le24(index_table);
  279|  90.2k|    code = v & ((1 << 21) - 1);
  280|  90.2k|    if (c < code) {
  281|  6.29k|        *pcode = 0;
  282|  6.29k|        return 0;
  283|  6.29k|    }
  284|  83.9k|    idx_max = index_table_len - 1;
  285|  83.9k|    code = get_le24(index_table + idx_max * 3);
  286|  83.9k|    if (c >= code)
  287|  58.0k|        return -1;
  288|       |    /* invariant: tab[idx_min] <= c < tab2[idx_max] */
  289|   155k|    while ((idx_max - idx_min) > 1) {
  290|   129k|        idx = (idx_max + idx_min) / 2;
  291|   129k|        v = get_le24(index_table + idx * 3);
  292|   129k|        code = v & ((1 << 21) - 1);
  293|   129k|        if (c < code) {
  294|  84.2k|            idx_max = idx;
  295|  84.2k|        } else {
  296|  45.2k|            idx_min = idx;
  297|  45.2k|        }
  298|   129k|    }
  299|  25.9k|    v = get_le24(index_table + idx_min * 3);
  300|  25.9k|    *pcode = v & ((1 << 21) - 1);
  301|  25.9k|    return (idx_min + 1) * UNICODE_INDEX_BLOCK_LEN + (v >> 21);
  302|  83.9k|}
  303|       |
  304|       |static BOOL lre_is_in_table(uint32_t c, const uint8_t *table,
  305|       |                            const uint8_t *index_table, int index_table_len)
  306|  90.2k|{
  307|  90.2k|    uint32_t code, b, bit;
  308|  90.2k|    int pos;
  309|  90.2k|    const uint8_t *p;
  310|       |
  311|  90.2k|    pos = get_index_pos(&code, c, index_table, index_table_len);
  312|  90.2k|    if (pos < 0)
  313|  58.0k|        return FALSE; /* outside the table */
  314|  32.2k|    p = table + pos;
  315|  32.2k|    bit = 0;
  316|       |    /* Compressed run length encoding:
  317|       |       00..3F: 2 packed lengths: 3-bit + 3-bit
  318|       |       40..5F: 5-bits plus extra byte for length
  319|       |       60..7F: 5-bits plus 2 extra bytes for length
  320|       |       80..FF: 7-bit length
  321|       |       lengths must be incremented to get character count
  322|       |       Ranges alternate between false and true return value.
  323|       |     */
  324|   330k|    for(;;) {
  325|   330k|        b = *p++;
  326|   330k|        if (b < 64) {
  327|  86.3k|            code += (b >> 3) + 1;
  328|  86.3k|            if (c < code)
  329|    442|                return bit;
  330|  85.8k|            bit ^= 1;
  331|  85.8k|            code += (b & 7) + 1;
  332|   244k|        } else if (b >= 0x80) {
  333|   219k|            code += b - 0x80 + 1;
  334|   219k|        } else if (b < 0x60) {
  335|  24.3k|            code += (((b - 0x40) << 8) | p[0]) + 1;
  336|  24.3k|            p++;
  337|  24.3k|        } else {
  338|    470|            code += (((b - 0x60) << 16) | (p[0] << 8) | p[1]) + 1;
  339|    470|            p += 2;
  340|    470|        }
  341|   330k|        if (c < code)
  342|  31.8k|            return bit;
  343|   298k|        bit ^= 1;
  344|   298k|    }
  345|  32.2k|}
  346|       |
  347|       |BOOL lre_is_cased(uint32_t c)
  348|      0|{
  349|      0|    uint32_t v, code, len;
  350|      0|    int idx, idx_min, idx_max;
  351|       |
  352|      0|    idx_min = 0;
  353|      0|    idx_max = countof(case_conv_table1) - 1;
  354|      0|    while (idx_min <= idx_max) {
  355|      0|        idx = (unsigned)(idx_max + idx_min) / 2;
  356|      0|        v = case_conv_table1[idx];
  357|      0|        code = v >> (32 - 17);
  358|      0|        len = (v >> (32 - 17 - 7)) & 0x7f;
  359|      0|        if (c < code) {
  360|      0|            idx_max = idx - 1;
  361|      0|        } else if (c >= code + len) {
  362|      0|            idx_min = idx + 1;
  363|      0|        } else {
  364|      0|            return TRUE;
  365|      0|        }
  366|      0|    }
  367|      0|    return lre_is_in_table(c, unicode_prop_Cased1_table,
  368|      0|                           unicode_prop_Cased1_index,
  369|      0|                           sizeof(unicode_prop_Cased1_index) / 3);
  370|      0|}
  371|       |
  372|       |BOOL lre_is_case_ignorable(uint32_t c)
  373|      0|{
  374|      0|    return lre_is_in_table(c, unicode_prop_Case_Ignorable_table,
  375|      0|                           unicode_prop_Case_Ignorable_index,
  376|      0|                           sizeof(unicode_prop_Case_Ignorable_index) / 3);
  377|      0|}
  378|       |
  379|       |/* character range */
  380|       |
  381|       |static __maybe_unused void cr_dump(CharRange *cr)
  382|      0|{
  383|      0|    int i;
  384|      0|    for(i = 0; i < cr->len; i++)
  385|      0|        printf("%d: 0x%04x\n", i, cr->points[i]);
  386|      0|}
  387|       |
  388|       |static void *cr_default_realloc(void *opaque, void *ptr, size_t size)
  389|      0|{
  390|      0|    return realloc(ptr, size);
  391|      0|}
  392|       |
  393|       |void cr_init(CharRange *cr, void *mem_opaque, DynBufReallocFunc *realloc_func)
  394|   110k|{
  395|   110k|    cr->len = cr->size = 0;
  396|   110k|    cr->points = NULL;
  397|   110k|    cr->mem_opaque = mem_opaque;
  398|   110k|    cr->realloc_func = realloc_func ? realloc_func : cr_default_realloc;
  399|   110k|}
  400|       |
  401|       |void cr_free(CharRange *cr)
  402|   631k|{
  403|   631k|    cr->realloc_func(cr->mem_opaque, cr->points, 0);
  404|   631k|}
  405|       |
  406|       |int cr_realloc(CharRange *cr, int size)
  407|  4.95M|{
  408|  4.95M|    int new_size;
  409|  4.95M|    uint32_t *new_buf;
  410|       |
  411|  4.95M|    if (size > cr->size) {
  412|  4.93M|        new_size = max_int(size, cr->size * 3 / 2);
  413|  4.93M|        new_buf = cr->realloc_func(cr->mem_opaque, cr->points,
  414|  4.93M|                                   new_size * sizeof(cr->points[0]));
  415|  4.93M|        if (!new_buf)
  416|      0|            return -1;
  417|  4.93M|        cr->points = new_buf;
  418|  4.93M|        cr->size = new_size;
  419|  4.93M|    }
  420|  4.95M|    return 0;
  421|  4.95M|}
  422|       |
  423|       |int cr_copy(CharRange *cr, const CharRange *cr1)
  424|      0|{
  425|      0|    if (cr_realloc(cr, cr1->len))
  426|      0|        return -1;
  427|      0|    memcpy(cr->points, cr1->points, sizeof(cr->points[0]) * cr1->len);
  428|      0|    cr->len = cr1->len;
  429|      0|    return 0;
  430|      0|}
  431|       |
  432|       |/* merge consecutive intervals and remove empty intervals */
  433|       |static void cr_compress(CharRange *cr)
  434|   608k|{
  435|   608k|    int i, j, k, len;
  436|   608k|    uint32_t *pt;
  437|       |
  438|   608k|    pt = cr->points;
  439|   608k|    len = cr->len;
  440|   608k|    i = 0;
  441|   608k|    j = 0;
  442|   608k|    k = 0;
  443|  37.5M|    while ((i + 1) < len) {
  444|  36.9M|        if (pt[i] == pt[i + 1]) {
  445|       |            /* empty interval */
  446|  1.95M|            i += 2;
  447|  34.9M|        } else {
  448|  34.9M|            j = i;
  449|  36.2M|            while ((j + 3) < len && pt[j + 1] == pt[j + 2])
  450|  1.24M|                j += 2;
  451|       |            /* just copy */
  452|  34.9M|            pt[k] = pt[i];
  453|  34.9M|            pt[k + 1] = pt[j + 1];
  454|  34.9M|            k += 2;
  455|  34.9M|            i = j + 2;
  456|  34.9M|        }
  457|  36.9M|    }
  458|   608k|    cr->len = k;
  459|   608k|}
  460|       |
  461|       |/* union or intersection */
  462|       |int cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,
  463|       |          const uint32_t *b_pt, int b_len, int op)
  464|   572k|{
  465|   572k|    int a_idx, b_idx, is_in;
  466|   572k|    uint32_t v;
  467|       |
  468|   572k|    a_idx = 0;
  469|   572k|    b_idx = 0;
  470|  70.6M|    for(;;) {
  471|       |        /* get one more point from a or b in increasing order */
  472|  70.6M|        if (a_idx < a_len && b_idx < b_len) {
  473|  49.0M|            if (a_pt[a_idx] < b_pt[b_idx]) {
  474|  33.9M|                goto a_add;
  475|  33.9M|            } else if (a_pt[a_idx] == b_pt[b_idx]) {
  476|  12.5M|                v = a_pt[a_idx];
  477|  12.5M|                a_idx++;
  478|  12.5M|                b_idx++;
  479|  12.5M|            } else {
  480|  2.59M|                goto b_add;
  481|  2.59M|            }
  482|  49.0M|        } else if (a_idx < a_len) {
  483|  54.7M|        a_add:
  484|  54.7M|            v = a_pt[a_idx++];
  485|  54.7M|        } else if (b_idx < b_len) {
  486|  2.76M|        b_add:
  487|  2.76M|            v = b_pt[b_idx++];
  488|  2.76M|        } else {
  489|   572k|            break;
  490|   572k|        }
  491|       |        /* add the point if the in/out status changes */
  492|  70.0M|        switch(op) {
  493|  23.3M|        case CR_OP_UNION:
  494|  23.3M|            is_in = (a_idx & 1) | (b_idx & 1);
  495|  23.3M|            break;
  496|  46.7M|        case CR_OP_INTER:
  497|  46.7M|            is_in = (a_idx & 1) & (b_idx & 1);
  498|  46.7M|            break;
  499|      0|        case CR_OP_XOR:
  500|      0|            is_in = (a_idx & 1) ^ (b_idx & 1);
  501|      0|            break;
  502|      0|        default:
  503|      0|            abort();
  504|  70.0M|        }
  505|  70.0M|        if (is_in != (cr->len & 1)) {
  506|  51.0M|            if (cr_add_point(cr, v))
  507|      0|                return -1;
  508|  51.0M|        }
  509|  70.0M|    }
  510|   572k|    cr_compress(cr);
  511|   572k|    return 0;
  512|   572k|}
  513|       |
  514|       |int cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len)
  515|   521k|{
  516|   521k|    CharRange a = *cr;
  517|   521k|    int ret;
  518|   521k|    cr->len = 0;
  519|   521k|    cr->size = 0;
  520|   521k|    cr->points = NULL;
  521|   521k|    ret = cr_op(cr, a.points, a.len, b_pt, b_len, CR_OP_UNION);
  522|   521k|    cr_free(&a);
  523|   521k|    return ret;
  524|   521k|}
  525|       |
  526|       |int cr_invert(CharRange *cr)
  527|  36.9k|{
  528|  36.9k|    int len;
  529|  36.9k|    len = cr->len;
  530|  36.9k|    if (cr_realloc(cr, len + 2))
  531|      0|        return -1;
  532|  36.9k|    memmove(cr->points + 1, cr->points, len * sizeof(cr->points[0]));
  533|  36.9k|    cr->points[0] = 0;
  534|  36.9k|    cr->points[len + 1] = UINT32_MAX;
  535|  36.9k|    cr->len = len + 2;
  536|  36.9k|    cr_compress(cr);
  537|  36.9k|    return 0;
  538|  36.9k|}
  539|       |
  540|  2.25M|#define CASE_U (1 << 0)
  541|   498k|#define CASE_L (1 << 1)
  542|   507k|#define CASE_F (1 << 2)
  543|       |
  544|       |/* use the case conversion table to generate range of characters.
  545|       |   CASE_U: set char if modified by uppercasing,
  546|       |   CASE_L: set char if modified by lowercasing,
  547|       |   CASE_F: set char if modified by case folding,
  548|       | */
  549|       |static int unicode_case1(CharRange *cr, int case_mask)
  550|  16.7k|{
  551|   487k|#define MR(x) (1 << RUN_TYPE_ ## x)
  552|  16.7k|    const uint32_t tab_run_mask[3] = {
  553|  16.7k|        MR(U) | MR(UF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(UF_D20) |
  554|  16.7k|        MR(UF_D1_EXT) | MR(U_EXT) | MR(UF_EXT2) | MR(UF_EXT3),
  555|       |
  556|  16.7k|        MR(L) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(LF_EXT2),
  557|       |
  558|  16.7k|        MR(UF) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(LF_EXT2) | MR(UF_D20) | MR(UF_D1_EXT) | MR(LF_EXT) | MR(UF_EXT2) | MR(UF_EXT3),
  559|  16.7k|    };
  560|  16.7k|#undef MR
  561|  16.7k|    uint32_t mask, v, code, type, len, i, idx;
  562|       |
  563|  16.7k|    if (case_mask == 0)
  564|      0|        return 0;
  565|  16.7k|    mask = 0;
  566|  67.1k|    for(i = 0; i < 3; i++) {
  567|  50.3k|        if ((case_mask >> i) & 1)
  568|  16.7k|            mask |= tab_run_mask[i];
  569|  50.3k|    }
  570|  6.36M|    for(idx = 0; idx < countof(case_conv_table1); idx++) {
  571|  6.34M|        v = case_conv_table1[idx];
  572|  6.34M|        type = (v >> (32 - 17 - 7 - 4)) & 0xf;
  573|  6.34M|        code = v >> (32 - 17);
  574|  6.34M|        len = (v >> (32 - 17 - 7)) & 0x7f;
  575|  6.34M|        if ((mask >> type) & 1) {
  576|       |            //            printf("%d: type=%d %04x %04x\n", idx, type, code, code + len - 1);
  577|  4.41M|            switch(type) {
  578|  1.02M|            case RUN_TYPE_UL:
  579|  1.02M|                if ((case_mask & CASE_U) && (case_mask & (CASE_L | CASE_F)))
  580|      0|                    goto def_case;
  581|  1.02M|                code += ((case_mask & CASE_U) != 0);
  582|  10.1M|                for(i = 0; i < len; i += 2) {
  583|  9.10M|                    if (cr_add_interval(cr, code + i, code + i + 1))
  584|      0|                        return -1;
  585|  9.10M|                }
  586|  1.02M|                break;
  587|  1.02M|            case RUN_TYPE_LSU:
  588|  67.1k|                if ((case_mask & CASE_U) && (case_mask & (CASE_L | CASE_F)))
  589|      0|                    goto def_case;
  590|  67.1k|                if (!(case_mask & CASE_U)) {
  591|  36.5k|                    if (cr_add_interval(cr, code, code + 1))
  592|      0|                        return -1;
  593|  36.5k|                }
  594|  67.1k|                if (cr_add_interval(cr, code + 1, code + 2))
  595|      0|                    return -1;
  596|  67.1k|                if (case_mask & CASE_U) {
  597|  30.6k|                    if (cr_add_interval(cr, code + 2, code + 3))
  598|      0|                        return -1;
  599|  30.6k|                }
  600|  67.1k|                break;
  601|  3.32M|            default:
  602|  3.32M|            def_case:
  603|  3.32M|                if (cr_add_interval(cr, code, code + len))
  604|      0|                    return -1;
  605|  3.32M|                break;
  606|  4.41M|            }
  607|  4.41M|        }
  608|  6.34M|    }
  609|  16.7k|    return 0;
  610|  16.7k|}
  611|       |
  612|       |static int point_cmp(const void *p1, const void *p2, void *arg)
  613|  65.8M|{
  614|  65.8M|    uint32_t v1 = *(uint32_t *)p1;
  615|  65.8M|    uint32_t v2 = *(uint32_t *)p2;
  616|  65.8M|    return (v1 > v2) - (v1 < v2);
  617|  65.8M|}
  618|       |
  619|       |static void cr_sort_and_remove_overlap(CharRange *cr)
  620|  16.7k|{
  621|  16.7k|    uint32_t start, end, start1, end1, i, j;
  622|       |
  623|       |    /* the resulting ranges are not necessarily sorted and may overlap */
  624|  16.7k|    rqsort(cr->points, cr->len / 2, sizeof(cr->points[0]) * 2, point_cmp, NULL);
  625|  16.7k|    j = 0;
  626|  6.70M|    for(i = 0; i < cr->len; ) {
  627|  6.69M|        start = cr->points[i];
  628|  6.69M|        end = cr->points[i + 1];
  629|  6.69M|        i += 2;
  630|  7.63M|        while (i < cr->len) {
  631|  7.62M|            start1 = cr->points[i];
  632|  7.62M|            end1 = cr->points[i + 1];
  633|  7.62M|            if (start1 > end) {
  634|       |                /* |------|
  635|       |                 *           |-------| */
  636|  6.67M|                break;
  637|  6.67M|            } else if (end1 <= end) {
  638|       |                /* |------|
  639|       |                 *    |--| */
  640|   365k|                i += 2;
  641|   582k|            } else {
  642|       |                /* |------|
  643|       |                 *     |-------| */
  644|   582k|                end = end1;
  645|   582k|                i += 2;
  646|   582k|            }
  647|  7.62M|        }
  648|  6.69M|        cr->points[j] = start;
  649|  6.69M|        cr->points[j + 1] = end;
  650|  6.69M|        j += 2;
  651|  6.69M|    }
  652|  16.7k|    cr->len = j;
  653|  16.7k|}
  654|       |
  655|       |/* canonicalize a character set using the JS regex case folding rules
  656|       |   (see lre_canonicalize()) */
  657|       |int cr_regexp_canonicalize(CharRange *cr, BOOL is_unicode)
  658|  16.7k|{
  659|  16.7k|    CharRange cr_inter, cr_mask, cr_result, cr_sub;
  660|  16.7k|    uint32_t v, code, len, i, idx, start, end, c, d_start, d_end, d;
  661|       |
  662|  16.7k|    cr_init(&cr_mask, cr->mem_opaque, cr->realloc_func);
  663|  16.7k|    cr_init(&cr_inter, cr->mem_opaque, cr->realloc_func);
  664|  16.7k|    cr_init(&cr_result, cr->mem_opaque, cr->realloc_func);
  665|  16.7k|    cr_init(&cr_sub, cr->mem_opaque, cr->realloc_func);
  666|       |
  667|  16.7k|    if (unicode_case1(&cr_mask, is_unicode ? CASE_F : CASE_U))
  668|      0|        goto fail;
  669|  16.7k|    if (cr_op(&cr_inter, cr_mask.points, cr_mask.len, cr->points, cr->len, CR_OP_INTER))
  670|      0|        goto fail;
  671|       |
  672|  16.7k|    if (cr_invert(&cr_mask))
  673|      0|        goto fail;
  674|  16.7k|    if (cr_op(&cr_sub, cr_mask.points, cr_mask.len, cr->points, cr->len, CR_OP_INTER))
  675|      0|        goto fail;
  676|       |
  677|       |    /* cr_inter = cr & cr_mask */
  678|       |    /* cr_sub = cr & ~cr_mask */
  679|       |
  680|       |    /* use the case conversion table to compute the result */
  681|  16.7k|    d_start = -1;
  682|  16.7k|    d_end = -1;
  683|  16.7k|    idx = 0;
  684|  16.7k|    v = case_conv_table1[idx];
  685|  16.7k|    code = v >> (32 - 17);
  686|  16.7k|    len = (v >> (32 - 17 - 7)) & 0x7f;
  687|  6.77M|    for(i = 0; i < cr_inter.len; i += 2) {
  688|  6.75M|        start = cr_inter.points[i];
  689|  6.75M|        end = cr_inter.points[i + 1];
  690|       |
  691|  23.0M|        for(c = start; c < end; c++) {
  692|  20.3M|            for(;;) {
  693|  20.3M|                if (c >= code && c < code + len)
  694|  16.3M|                    break;
  695|  4.02M|                idx++;
  696|  4.02M|                assert(idx < countof(case_conv_table1));
  697|  4.02M|                v = case_conv_table1[idx];
  698|  4.02M|                code = v >> (32 - 17);
  699|  4.02M|                len = (v >> (32 - 17 - 7)) & 0x7f;
  700|  4.02M|            }
  701|  16.3M|            d = lre_case_folding_entry(c, idx, v, is_unicode);
  702|       |            /* try to merge with the current interval */
  703|  16.3M|            if (d_start == -1) {
  704|  12.1k|                d_start = d;
  705|  12.1k|                d_end = d + 1;
  706|  16.3M|            } else if (d_end == d) {
  707|  8.70M|                d_end++;
  708|  8.70M|            } else {
  709|  7.62M|                cr_add_interval(&cr_result, d_start, d_end);
  710|  7.62M|                d_start = d;
  711|  7.62M|                d_end = d + 1;
  712|  7.62M|            }
  713|  16.3M|        }
  714|  6.75M|    }
  715|  16.7k|    if (d_start != -1) {
  716|  12.1k|        if (cr_add_interval(&cr_result, d_start, d_end))
  717|      0|            goto fail;
  718|  12.1k|    }
  719|       |
  720|       |    /* the resulting ranges are not necessarily sorted and may overlap */
  721|  16.7k|    cr_sort_and_remove_overlap(&cr_result);
  722|       |
  723|       |    /* or with the character not affected by the case folding */
  724|  16.7k|    cr->len = 0;
  725|  16.7k|    if (cr_op(cr, cr_result.points, cr_result.len, cr_sub.points, cr_sub.len, CR_OP_UNION))
  726|      0|        goto fail;
  727|       |
  728|  16.7k|    cr_free(&cr_inter);
  729|  16.7k|    cr_free(&cr_mask);
  730|  16.7k|    cr_free(&cr_result);
  731|  16.7k|    cr_free(&cr_sub);
  732|  16.7k|    return 0;
  733|      0| fail:
  734|      0|    cr_free(&cr_inter);
  735|      0|    cr_free(&cr_mask);
  736|      0|    cr_free(&cr_result);
  737|      0|    cr_free(&cr_sub);
  738|      0|    return -1;
  739|  16.7k|}
  740|       |
  741|       |#ifdef CONFIG_ALL_UNICODE
  742|       |
  743|       |BOOL lre_is_id_start(uint32_t c)
  744|  71.6k|{
  745|  71.6k|    return lre_is_in_table(c, unicode_prop_ID_Start_table,
  746|  71.6k|                           unicode_prop_ID_Start_index,
  747|  71.6k|                           sizeof(unicode_prop_ID_Start_index) / 3);
  748|  71.6k|}
  749|       |
  750|       |BOOL lre_is_id_continue(uint32_t c)
  751|  36.1k|{
  752|  36.1k|    return lre_is_id_start(c) ||
  753|  36.1k|        lre_is_in_table(c, unicode_prop_ID_Continue1_table,
  754|  18.6k|                        unicode_prop_ID_Continue1_index,
  755|  18.6k|                        sizeof(unicode_prop_ID_Continue1_index) / 3);
  756|  36.1k|}
  757|       |
  758|       |#define UNICODE_DECOMP_LEN_MAX 18
  759|       |
  760|       |typedef enum {
  761|       |    DECOMP_TYPE_C1, /* 16 bit char */
  762|       |    DECOMP_TYPE_L1, /* 16 bit char table */
  763|       |    DECOMP_TYPE_L2,
  764|       |    DECOMP_TYPE_L3,
  765|       |    DECOMP_TYPE_L4,
  766|       |    DECOMP_TYPE_L5, /* XXX: not used */
  767|       |    DECOMP_TYPE_L6, /* XXX: could remove */
  768|       |    DECOMP_TYPE_L7, /* XXX: could remove */
  769|       |    DECOMP_TYPE_LL1, /* 18 bit char table */
  770|       |    DECOMP_TYPE_LL2,
  771|       |    DECOMP_TYPE_S1, /* 8 bit char table */
  772|       |    DECOMP_TYPE_S2,
  773|       |    DECOMP_TYPE_S3,
  774|       |    DECOMP_TYPE_S4,
  775|       |    DECOMP_TYPE_S5,
  776|       |    DECOMP_TYPE_I1, /* increment 16 bit char value */
  777|       |    DECOMP_TYPE_I2_0,
  778|       |    DECOMP_TYPE_I2_1,
  779|       |    DECOMP_TYPE_I3_1,
  780|       |    DECOMP_TYPE_I3_2,
  781|       |    DECOMP_TYPE_I4_1,
  782|       |    DECOMP_TYPE_I4_2,
  783|       |    DECOMP_TYPE_B1, /* 16 bit base + 8 bit offset */
  784|       |    DECOMP_TYPE_B2,
  785|       |    DECOMP_TYPE_B3,
  786|       |    DECOMP_TYPE_B4,
  787|       |    DECOMP_TYPE_B5,
  788|       |    DECOMP_TYPE_B6,
  789|       |    DECOMP_TYPE_B7,
  790|       |    DECOMP_TYPE_B8,
  791|       |    DECOMP_TYPE_B18,
  792|       |    DECOMP_TYPE_LS2,
  793|       |    DECOMP_TYPE_PAT3,
  794|       |    DECOMP_TYPE_S2_UL,
  795|       |    DECOMP_TYPE_LS2_UL,
  796|       |} DecompTypeEnum;
  797|       |
  798|       |static uint32_t unicode_get_short_code(uint32_t c)
  799|      0|{
  800|      0|    static const uint16_t unicode_short_table[2] = { 0x2044, 0x2215 };
  801|       |
  802|      0|    if (c < 0x80)
  803|      0|        return c;
  804|      0|    else if (c < 0x80 + 0x50)
  805|      0|        return c - 0x80 + 0x300;
  806|      0|    else
  807|      0|        return unicode_short_table[c - 0x80 - 0x50];
  808|      0|}
  809|       |
  810|       |static uint32_t unicode_get_lower_simple(uint32_t c)
  811|      0|{
  812|      0|    if (c < 0x100 || (c >= 0x410 && c <= 0x42f))
  813|      0|        c += 0x20;
  814|      0|    else
  815|      0|        c++;
  816|      0|    return c;
  817|      0|}
  818|       |
  819|       |static uint16_t unicode_get16(const uint8_t *p)
  820|      0|{
  821|      0|    return p[0] | (p[1] << 8);
  822|      0|}
  823|       |
  824|       |static int unicode_decomp_entry(uint32_t *res, uint32_t c,
  825|       |                                int idx, uint32_t code, uint32_t len,
  826|       |                                uint32_t type)
  827|      0|{
  828|      0|    uint32_t c1;
  829|      0|    int l, i, p;
  830|      0|    const uint8_t *d;
  831|       |
  832|      0|    if (type == DECOMP_TYPE_C1) {
  833|      0|        res[0] = unicode_decomp_table2[idx];
  834|      0|        return 1;
  835|      0|    } else {
  836|      0|        d = unicode_decomp_data + unicode_decomp_table2[idx];
  837|      0|        switch(type) {
  838|      0|        case DECOMP_TYPE_L1:
  839|      0|        case DECOMP_TYPE_L2:
  840|      0|        case DECOMP_TYPE_L3:
  841|      0|        case DECOMP_TYPE_L4:
  842|      0|        case DECOMP_TYPE_L5:
  843|      0|        case DECOMP_TYPE_L6:
  844|      0|        case DECOMP_TYPE_L7:
  845|      0|            l = type - DECOMP_TYPE_L1 + 1;
  846|      0|            d += (c - code) * l * 2;
  847|      0|            for(i = 0; i < l; i++) {
  848|      0|                if ((res[i] = unicode_get16(d + 2 * i)) == 0)
  849|      0|                    return 0;
  850|      0|            }
  851|      0|            return l;
  852|      0|        case DECOMP_TYPE_LL1:
  853|      0|        case DECOMP_TYPE_LL2:
  854|      0|            {
  855|      0|                uint32_t k, p;
  856|      0|                l = type - DECOMP_TYPE_LL1 + 1;
  857|      0|                k = (c - code) * l;
  858|      0|                p = len * l * 2;
  859|      0|                for(i = 0; i < l; i++) {
  860|      0|                    c1 = unicode_get16(d + 2 * k) |
  861|      0|                        (((d[p + (k / 4)] >> ((k % 4) * 2)) & 3) << 16);
  862|      0|                    if (!c1)
  863|      0|                        return 0;
  864|      0|                    res[i] = c1;
  865|      0|                    k++;
  866|      0|                }
  867|      0|            }
  868|      0|            return l;
  869|      0|        case DECOMP_TYPE_S1:
  870|      0|        case DECOMP_TYPE_S2:
  871|      0|        case DECOMP_TYPE_S3:
  872|      0|        case DECOMP_TYPE_S4:
  873|      0|        case DECOMP_TYPE_S5:
  874|      0|            l = type - DECOMP_TYPE_S1 + 1;
  875|      0|            d += (c - code) * l;
  876|      0|            for(i = 0; i < l; i++) {
  877|      0|                if ((res[i] = unicode_get_short_code(d[i])) == 0)
  878|      0|                    return 0;
  879|      0|            }
  880|      0|            return l;
  881|      0|        case DECOMP_TYPE_I1:
  882|      0|            l = 1;
  883|      0|            p = 0;
  884|      0|            goto decomp_type_i;
  885|      0|        case DECOMP_TYPE_I2_0:
  886|      0|        case DECOMP_TYPE_I2_1:
  887|      0|        case DECOMP_TYPE_I3_1:
  888|      0|        case DECOMP_TYPE_I3_2:
  889|      0|        case DECOMP_TYPE_I4_1:
  890|      0|        case DECOMP_TYPE_I4_2:
  891|      0|            l = 2 + ((type - DECOMP_TYPE_I2_0) >> 1);
  892|      0|            p = ((type - DECOMP_TYPE_I2_0) & 1) + (l > 2);
  893|      0|        decomp_type_i:
  894|      0|            for(i = 0; i < l; i++) {
  895|      0|                c1 = unicode_get16(d + 2 * i);
  896|      0|                if (i == p)
  897|      0|                    c1 += c - code;
  898|      0|                res[i] = c1;
  899|      0|            }
  900|      0|            return l;
  901|      0|        case DECOMP_TYPE_B18:
  902|      0|            l = 18;
  903|      0|            goto decomp_type_b;
  904|      0|        case DECOMP_TYPE_B1:
  905|      0|        case DECOMP_TYPE_B2:
  906|      0|        case DECOMP_TYPE_B3:
  907|      0|        case DECOMP_TYPE_B4:
  908|      0|        case DECOMP_TYPE_B5:
  909|      0|        case DECOMP_TYPE_B6:
  910|      0|        case DECOMP_TYPE_B7:
  911|      0|        case DECOMP_TYPE_B8:
  912|      0|            l = type - DECOMP_TYPE_B1 + 1;
  913|      0|        decomp_type_b:
  914|      0|            {
  915|      0|                uint32_t c_min;
  916|      0|                c_min = unicode_get16(d);
  917|      0|                d += 2 + (c - code) * l;
  918|      0|                for(i = 0; i < l; i++) {
  919|      0|                    c1 = d[i];
  920|      0|                    if (c1 == 0xff)
  921|      0|                        c1 = 0x20;
  922|      0|                    else
  923|      0|                        c1 += c_min;
  924|      0|                    res[i] = c1;
  925|      0|                }
  926|      0|            }
  927|      0|            return l;
  928|      0|        case DECOMP_TYPE_LS2:
  929|      0|            d += (c - code) * 3;
  930|      0|            if (!(res[0] = unicode_get16(d)))
  931|      0|                return 0;
  932|      0|            res[1] = unicode_get_short_code(d[2]);
  933|      0|            return 2;
  934|      0|        case DECOMP_TYPE_PAT3:
  935|      0|            res[0] = unicode_get16(d);
  936|      0|            res[2] = unicode_get16(d + 2);
  937|      0|            d += 4 + (c - code) * 2;
  938|      0|            res[1] = unicode_get16(d);
  939|      0|            return 3;
  940|      0|        case DECOMP_TYPE_S2_UL:
  941|      0|        case DECOMP_TYPE_LS2_UL:
  942|      0|            c1 = c - code;
  943|      0|            if (type == DECOMP_TYPE_S2_UL) {
  944|      0|                d += c1 & ~1;
  945|      0|                c = unicode_get_short_code(*d);
  946|      0|                d++;
  947|      0|            } else {
  948|      0|                d += (c1 >> 1) * 3;
  949|      0|                c = unicode_get16(d);
  950|      0|                d += 2;
  951|      0|            }
  952|      0|            if (c1 & 1)
  953|      0|                c = unicode_get_lower_simple(c);
  954|      0|            res[0] = c;
  955|      0|            res[1] = unicode_get_short_code(*d);
  956|      0|            return 2;
  957|      0|        }
  958|      0|    }
  959|      0|    return 0;
  960|      0|}
  961|       |
  962|       |
  963|       |/* return the length of the decomposition (length <=
  964|       |   UNICODE_DECOMP_LEN_MAX) or 0 if no decomposition */
  965|       |static int unicode_decomp_char(uint32_t *res, uint32_t c, BOOL is_compat1)
  966|      0|{
  967|      0|    uint32_t v, type, is_compat, code, len;
  968|      0|    int idx_min, idx_max, idx;
  969|       |
  970|      0|    idx_min = 0;
  971|      0|    idx_max = countof(unicode_decomp_table1) - 1;
  972|      0|    while (idx_min <= idx_max) {
  973|      0|        idx = (idx_max + idx_min) / 2;
  974|      0|        v = unicode_decomp_table1[idx];
  975|      0|        code = v >> (32 - 18);
  976|      0|        len = (v >> (32 - 18 - 7)) & 0x7f;
  977|       |        //        printf("idx=%d code=%05x len=%d\n", idx, code, len);
  978|      0|        if (c < code) {
  979|      0|            idx_max = idx - 1;
  980|      0|        } else if (c >= code + len) {
  981|      0|            idx_min = idx + 1;
  982|      0|        } else {
  983|      0|            is_compat = v & 1;
  984|      0|            if (is_compat1 < is_compat)
  985|      0|                break;
  986|      0|            type = (v >> (32 - 18 - 7 - 6)) & 0x3f;
  987|      0|            return unicode_decomp_entry(res, c, idx, code, len, type);
  988|      0|        }
  989|      0|    }
  990|      0|    return 0;
  991|      0|}
  992|       |
  993|       |/* return 0 if no pair found */
  994|       |static int unicode_compose_pair(uint32_t c0, uint32_t c1)
  995|      0|{
  996|      0|    uint32_t code, len, type, v, idx1, d_idx, d_offset, ch;
  997|      0|    int idx_min, idx_max, idx, d;
  998|      0|    uint32_t pair[2];
  999|       |
 1000|      0|    idx_min = 0;
 1001|      0|    idx_max = countof(unicode_comp_table) - 1;
 1002|      0|    while (idx_min <= idx_max) {
 1003|      0|        idx = (idx_max + idx_min) / 2;
 1004|      0|        idx1 = unicode_comp_table[idx];
 1005|       |
 1006|       |        /* idx1 represent an entry of the decomposition table */
 1007|      0|        d_idx = idx1 >> 6;
 1008|      0|        d_offset = idx1 & 0x3f;
 1009|      0|        v = unicode_decomp_table1[d_idx];
 1010|      0|        code = v >> (32 - 18);
 1011|      0|        len = (v >> (32 - 18 - 7)) & 0x7f;
 1012|      0|        type = (v >> (32 - 18 - 7 - 6)) & 0x3f;
 1013|      0|        ch = code + d_offset;
 1014|      0|        unicode_decomp_entry(pair, ch, d_idx, code, len, type);
 1015|      0|        d = c0 - pair[0];
 1016|      0|        if (d == 0)
 1017|      0|            d = c1 - pair[1];
 1018|      0|        if (d < 0) {
 1019|      0|            idx_max = idx - 1;
 1020|      0|        } else if (d > 0) {
 1021|      0|            idx_min = idx + 1;
 1022|      0|        } else {
 1023|      0|            return ch;
 1024|      0|        }
 1025|      0|    }
 1026|      0|    return 0;
 1027|      0|}
 1028|       |
 1029|       |/* return the combining class of character c (between 0 and 255) */
 1030|       |static int unicode_get_cc(uint32_t c)
 1031|      0|{
 1032|      0|    uint32_t code, n, type, cc, c1, b;
 1033|      0|    int pos;
 1034|      0|    const uint8_t *p;
 1035|       |
 1036|      0|    pos = get_index_pos(&code, c,
 1037|      0|                        unicode_cc_index, sizeof(unicode_cc_index) / 3);
 1038|      0|    if (pos < 0)
 1039|      0|        return 0;
 1040|      0|    p = unicode_cc_table + pos;
 1041|       |    /* Compressed run length encoding:
 1042|       |       - 2 high order bits are combining class type
 1043|       |       -         0:0, 1:230, 2:extra byte linear progression, 3:extra byte
 1044|       |       - 00..2F: range length (add 1)
 1045|       |       - 30..37: 3-bit range-length + 1 extra byte
 1046|       |       - 38..3F: 3-bit range-length + 2 extra byte
 1047|       |     */
 1048|      0|    for(;;) {
 1049|      0|        b = *p++;
 1050|      0|        type = b >> 6;
 1051|      0|        n = b & 0x3f;
 1052|      0|        if (n < 48) {
 1053|      0|        } else if (n < 56) {
 1054|      0|            n = (n - 48) << 8;
 1055|      0|            n |= *p++;
 1056|      0|            n += 48;
 1057|      0|        } else {
 1058|      0|            n = (n - 56) << 8;
 1059|      0|            n |= *p++ << 8;
 1060|      0|            n |= *p++;
 1061|      0|            n += 48 + (1 << 11);
 1062|      0|        }
 1063|      0|        if (type <= 1)
 1064|      0|            p++;
 1065|      0|        c1 = code + n + 1;
 1066|      0|        if (c < c1) {
 1067|      0|            switch(type) {
 1068|      0|            case 0:
 1069|      0|                cc = p[-1];
 1070|      0|                break;
 1071|      0|            case 1:
 1072|      0|                cc = p[-1] + c - code;
 1073|      0|                break;
 1074|      0|            case 2:
 1075|      0|                cc = 0;
 1076|      0|                break;
 1077|      0|            default:
 1078|      0|            case 3:
 1079|      0|                cc = 230;
 1080|      0|                break;
 1081|      0|            }
 1082|      0|            return cc;
 1083|      0|        }
 1084|      0|        code = c1;
 1085|      0|    }
 1086|      0|}
 1087|       |
 1088|       |static void sort_cc(int *buf, int len)
 1089|      0|{
 1090|      0|    int i, j, k, cc, cc1, start, ch1;
 1091|       |
 1092|      0|    for(i = 0; i < len; i++) {
 1093|      0|        cc = unicode_get_cc(buf[i]);
 1094|      0|        if (cc != 0) {
 1095|      0|            start = i;
 1096|      0|            j = i + 1;
 1097|      0|            while (j < len) {
 1098|      0|                ch1 = buf[j];
 1099|      0|                cc1 = unicode_get_cc(ch1);
 1100|      0|                if (cc1 == 0)
 1101|      0|                    break;
 1102|      0|                k = j - 1;
 1103|      0|                while (k >= start) {
 1104|      0|                    if (unicode_get_cc(buf[k]) <= cc1)
 1105|      0|                        break;
 1106|      0|                    buf[k + 1] = buf[k];
 1107|      0|                    k--;
 1108|      0|                }
 1109|      0|                buf[k + 1] = ch1;
 1110|      0|                j++;
 1111|      0|            }
 1112|       |#if 0
 1113|       |            printf("cc:");
 1114|       |            for(k = start; k < j; k++) {
 1115|       |                printf(" %3d", unicode_get_cc(buf[k]));
 1116|       |            }
 1117|       |            printf("\n");
 1118|       |#endif
 1119|      0|            i = j;
 1120|      0|        }
 1121|      0|    }
 1122|      0|}
 1123|       |
 1124|       |static void to_nfd_rec(DynBuf *dbuf,
 1125|       |                       const int *src, int src_len, int is_compat)
 1126|      0|{
 1127|      0|    uint32_t c, v;
 1128|      0|    int i, l;
 1129|      0|    uint32_t res[UNICODE_DECOMP_LEN_MAX];
 1130|       |
 1131|      0|    for(i = 0; i < src_len; i++) {
 1132|      0|        c = src[i];
 1133|      0|        if (c >= 0xac00 && c < 0xd7a4) {
 1134|       |            /* Hangul decomposition */
 1135|      0|            c -= 0xac00;
 1136|      0|            dbuf_put_u32(dbuf, 0x1100 + c / 588);
 1137|      0|            dbuf_put_u32(dbuf, 0x1161 + (c % 588) / 28);
 1138|      0|            v = c % 28;
 1139|      0|            if (v != 0)
 1140|      0|                dbuf_put_u32(dbuf, 0x11a7 + v);
 1141|      0|        } else {
 1142|      0|            l = unicode_decomp_char(res, c, is_compat);
 1143|      0|            if (l) {
 1144|      0|                to_nfd_rec(dbuf, (int *)res, l, is_compat);
 1145|      0|            } else {
 1146|      0|                dbuf_put_u32(dbuf, c);
 1147|      0|            }
 1148|      0|        }
 1149|      0|    }
 1150|      0|}
 1151|       |
 1152|       |/* return 0 if not found */
 1153|       |static int compose_pair(uint32_t c0, uint32_t c1)
 1154|      0|{
 1155|       |    /* Hangul composition */
 1156|      0|    if (c0 >= 0x1100 && c0 < 0x1100 + 19 &&
 1157|      0|        c1 >= 0x1161 && c1 < 0x1161 + 21) {
 1158|      0|        return 0xac00 + (c0 - 0x1100) * 588 + (c1 - 0x1161) * 28;
 1159|      0|    } else if (c0 >= 0xac00 && c0 < 0xac00 + 11172 &&
 1160|      0|               (c0 - 0xac00) % 28 == 0 &&
 1161|      0|               c1 >= 0x11a7 && c1 < 0x11a7 + 28) {
 1162|      0|        return c0 + c1 - 0x11a7;
 1163|      0|    } else {
 1164|      0|        return unicode_compose_pair(c0, c1);
 1165|      0|    }
 1166|      0|}
 1167|       |
 1168|       |int unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,
 1169|       |                      UnicodeNormalizationEnum n_type,
 1170|       |                      void *opaque, DynBufReallocFunc *realloc_func)
 1171|      0|{
 1172|      0|    int *buf, buf_len, i, p, starter_pos, cc, last_cc, out_len;
 1173|      0|    BOOL is_compat;
 1174|      0|    DynBuf dbuf_s, *dbuf = &dbuf_s;
 1175|       |
 1176|      0|    is_compat = n_type >> 1;
 1177|       |
 1178|      0|    dbuf_init2(dbuf, opaque, realloc_func);
 1179|      0|    if (dbuf_realloc(dbuf, sizeof(int) * src_len))
 1180|      0|        goto fail;
 1181|       |
 1182|       |    /* common case: latin1 is unaffected by NFC */
 1183|      0|    if (n_type == UNICODE_NFC) {
 1184|      0|        for(i = 0; i < src_len; i++) {
 1185|      0|            if (src[i] >= 0x100)
 1186|      0|                goto not_latin1;
 1187|      0|        }
 1188|      0|        buf = (int *)dbuf->buf;
 1189|      0|        memcpy(buf, src, src_len * sizeof(int));
 1190|      0|        *pdst = (uint32_t *)buf;
 1191|      0|        return src_len;
 1192|      0|    not_latin1: ;
 1193|      0|    }
 1194|       |
 1195|      0|    to_nfd_rec(dbuf, (const int *)src, src_len, is_compat);
 1196|      0|    if (dbuf_error(dbuf)) {
 1197|      0|    fail:
 1198|      0|        *pdst = NULL;
 1199|      0|        return -1;
 1200|      0|    }
 1201|      0|    buf = (int *)dbuf->buf;
 1202|      0|    buf_len = dbuf->size / sizeof(int);
 1203|       |
 1204|      0|    sort_cc(buf, buf_len);
 1205|       |
 1206|      0|    if (buf_len <= 1 || (n_type & 1) != 0) {
 1207|       |        /* NFD / NFKD */
 1208|      0|        *pdst = (uint32_t *)buf;
 1209|      0|        return buf_len;
 1210|      0|    }
 1211|       |
 1212|      0|    i = 1;
 1213|      0|    out_len = 1;
 1214|      0|    while (i < buf_len) {
 1215|       |        /* find the starter character and test if it is blocked from
 1216|       |           the character at 'i' */
 1217|      0|        last_cc = unicode_get_cc(buf[i]);
 1218|      0|        starter_pos = out_len - 1;
 1219|      0|        while (starter_pos >= 0) {
 1220|      0|            cc = unicode_get_cc(buf[starter_pos]);
 1221|      0|            if (cc == 0)
 1222|      0|                break;
 1223|      0|            if (cc >= last_cc)
 1224|      0|                goto next;
 1225|      0|            last_cc = 256;
 1226|      0|            starter_pos--;
 1227|      0|        }
 1228|      0|        if (starter_pos >= 0 &&
 1229|      0|            (p = compose_pair(buf[starter_pos], buf[i])) != 0) {
 1230|      0|            buf[starter_pos] = p;
 1231|      0|            i++;
 1232|      0|        } else {
 1233|      0|        next:
 1234|      0|            buf[out_len++] = buf[i++];
 1235|      0|        }
 1236|      0|    }
 1237|      0|    *pdst = (uint32_t *)buf;
 1238|      0|    return out_len;
 1239|      0|}
 1240|       |
 1241|       |/* char ranges for various unicode properties */
 1242|       |
 1243|       |static int unicode_find_name(const char *name_table, const char *name)
 1244|     33|{
 1245|     33|    const char *p, *r;
 1246|     33|    int pos;
 1247|     33|    size_t name_len, len;
 1248|       |
 1249|     33|    p = name_table;
 1250|     33|    pos = 0;
 1251|     33|    name_len = strlen(name);
 1252|  1.43k|    while (*p) {
 1253|  2.80k|        for(;;) {
 1254|  2.80k|            r = strchr(p, ',');
 1255|  2.80k|            if (!r)
 1256|  1.39k|                len = strlen(p);
 1257|  1.40k|            else
 1258|  1.40k|                len = r - p;
 1259|  2.80k|            if (len == name_len && !memcmp(p, name, name_len))
 1260|     15|                return pos;
 1261|  2.78k|            p += len + 1;
 1262|  2.78k|            if (!r)
 1263|  1.39k|                break;
 1264|  2.78k|        }
 1265|  1.39k|        pos++;
 1266|  1.39k|    }
 1267|     18|    return -1;
 1268|     33|}
 1269|       |
 1270|       |/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2
 1271|       |   if not found */
 1272|       |int unicode_script(CharRange *cr,
 1273|       |                   const char *script_name, BOOL is_ext)
 1274|      0|{
 1275|      0|    int script_idx;
 1276|      0|    const uint8_t *p, *p_end;
 1277|      0|    uint32_t c, c1, b, n, v, v_len, i, type;
 1278|      0|    CharRange cr1_s, *cr1;
 1279|      0|    CharRange cr2_s, *cr2 = &cr2_s;
 1280|      0|    BOOL is_common;
 1281|       |
 1282|      0|    script_idx = unicode_find_name(unicode_script_name_table, script_name);
 1283|      0|    if (script_idx < 0)
 1284|      0|        return -2;
 1285|       |    /* Note: we remove the "Unknown" Script */
 1286|      0|    script_idx += UNICODE_SCRIPT_Unknown + 1;
 1287|       |
 1288|      0|    is_common = (script_idx == UNICODE_SCRIPT_Common ||
 1289|      0|                 script_idx == UNICODE_SCRIPT_Inherited);
 1290|      0|    if (is_ext) {
 1291|      0|        cr1 = &cr1_s;
 1292|      0|        cr_init(cr1, cr->mem_opaque, cr->realloc_func);
 1293|      0|        cr_init(cr2, cr->mem_opaque, cr->realloc_func);
 1294|      0|    } else {
 1295|      0|        cr1 = cr;
 1296|      0|    }
 1297|       |
 1298|      0|    p = unicode_script_table;
 1299|      0|    p_end = unicode_script_table + countof(unicode_script_table);
 1300|      0|    c = 0;
 1301|      0|    while (p < p_end) {
 1302|      0|        b = *p++;
 1303|      0|        type = b >> 7;
 1304|      0|        n = b & 0x7f;
 1305|      0|        if (n < 96) {
 1306|      0|        } else if (n < 112) {
 1307|      0|            n = (n - 96) << 8;
 1308|      0|            n |= *p++;
 1309|      0|            n += 96;
 1310|      0|        } else {
 1311|      0|            n = (n - 112) << 16;
 1312|      0|            n |= *p++ << 8;
 1313|      0|            n |= *p++;
 1314|      0|            n += 96 + (1 << 12);
 1315|      0|        }
 1316|      0|        if (type == 0)
 1317|      0|            v = 0;
 1318|      0|        else
 1319|      0|            v = *p++;
 1320|      0|        c1 = c + n + 1;
 1321|      0|        if (v == script_idx) {
 1322|      0|            if (cr_add_interval(cr1, c, c1))
 1323|      0|                goto fail;
 1324|      0|        }
 1325|      0|        c = c1;
 1326|      0|    }
 1327|       |
 1328|      0|    if (is_ext) {
 1329|       |        /* add the script extensions */
 1330|      0|        p = unicode_script_ext_table;
 1331|      0|        p_end = unicode_script_ext_table + countof(unicode_script_ext_table);
 1332|      0|        c = 0;
 1333|      0|        while (p < p_end) {
 1334|      0|            b = *p++;
 1335|      0|            if (b < 128) {
 1336|      0|                n = b;
 1337|      0|            } else if (b < 128 + 64) {
 1338|      0|                n = (b - 128) << 8;
 1339|      0|                n |= *p++;
 1340|      0|                n += 128;
 1341|      0|            } else {
 1342|      0|                n = (b - 128 - 64) << 16;
 1343|      0|                n |= *p++ << 8;
 1344|      0|                n |= *p++;
 1345|      0|                n += 128 + (1 << 14);
 1346|      0|            }
 1347|      0|            c1 = c + n + 1;
 1348|      0|            v_len = *p++;
 1349|      0|            if (is_common) {
 1350|      0|                if (v_len != 0) {
 1351|      0|                    if (cr_add_interval(cr2, c, c1))
 1352|      0|                        goto fail;
 1353|      0|                }
 1354|      0|            } else {
 1355|      0|                for(i = 0; i < v_len; i++) {
 1356|      0|                    if (p[i] == script_idx) {
 1357|      0|                        if (cr_add_interval(cr2, c, c1))
 1358|      0|                            goto fail;
 1359|      0|                        break;
 1360|      0|                    }
 1361|      0|                }
 1362|      0|            }
 1363|      0|            p += v_len;
 1364|      0|            c = c1;
 1365|      0|        }
 1366|      0|        if (is_common) {
 1367|       |            /* remove all the characters with script extensions */
 1368|      0|            if (cr_invert(cr2))
 1369|      0|                goto fail;
 1370|      0|            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,
 1371|      0|                      CR_OP_INTER))
 1372|      0|                goto fail;
 1373|      0|        } else {
 1374|      0|            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,
 1375|      0|                      CR_OP_UNION))
 1376|      0|                goto fail;
 1377|      0|        }
 1378|      0|        cr_free(cr1);
 1379|      0|        cr_free(cr2);
 1380|      0|    }
 1381|      0|    return 0;
 1382|      0| fail:
 1383|      0|    if (is_ext) {
 1384|      0|        cr_free(cr1);
 1385|      0|        cr_free(cr2);
 1386|      0|    }
 1387|      0|    goto fail;
 1388|      0|}
 1389|       |
 1390|  1.77k|#define M(id) (1U << UNICODE_GC_ ## id)
 1391|       |
 1392|       |static int unicode_general_category1(CharRange *cr, uint32_t gc_mask)
 1393|     15|{
 1394|     15|    const uint8_t *p, *p_end;
 1395|     15|    uint32_t c, c0, b, n, v;
 1396|       |
 1397|     15|    p = unicode_gc_table;
 1398|     15|    p_end = unicode_gc_table + countof(unicode_gc_table);
 1399|     15|    c = 0;
 1400|       |    /* Compressed range encoding:
 1401|       |       initial byte:
 1402|       |       bits 0..4: category number (special case 31)
 1403|       |       bits 5..7: range length (add 1)
 1404|       |       special case bits 5..7 == 7: read an extra byte
 1405|       |       - 00..7F: range length (add 7 + 1)
 1406|       |       - 80..BF: 6-bits plus extra byte for range length (add 7 + 128)
 1407|       |       - C0..FF: 6-bits plus 2 extra bytes for range length (add 7 + 128 + 16384)
 1408|       |     */
 1409|  46.5k|    while (p < p_end) {
 1410|  46.5k|        b = *p++;
 1411|  46.5k|        n = b >> 5;
 1412|  46.5k|        v = b & 0x1f;
 1413|  46.5k|        if (n == 7) {
 1414|  13.2k|            n = *p++;
 1415|  13.2k|            if (n < 128) {
 1416|  12.0k|                n += 7;
 1417|  12.0k|            } else if (n < 128 + 64) {
 1418|  1.11k|                n = (n - 128) << 8;
 1419|  1.11k|                n |= *p++;
 1420|  1.11k|                n += 7 + 128;
 1421|  1.11k|            } else {
 1422|     90|                n = (n - 128 - 64) << 16;
 1423|     90|                n |= *p++ << 8;
 1424|     90|                n |= *p++;
 1425|     90|                n += 7 + 128 + (1 << 14);
 1426|     90|            }
 1427|  13.2k|        }
 1428|  46.5k|        c0 = c;
 1429|  46.5k|        c += n + 1;
 1430|  46.5k|        if (v == 31) {
 1431|       |            /* run of Lu / Ll */
 1432|    885|            b = gc_mask & (M(Lu) | M(Ll));
 1433|    885|            if (b != 0) {
 1434|      0|                if (b == (M(Lu) | M(Ll))) {
 1435|      0|                    goto add_range;
 1436|      0|                } else {
 1437|      0|                    c0 += ((gc_mask & M(Ll)) != 0);
 1438|      0|                    for(; c0 < c; c0 += 2) {
 1439|      0|                        if (cr_add_interval(cr, c0, c0 + 1))
 1440|      0|                            return -1;
 1441|      0|                    }
 1442|      0|                }
 1443|      0|            }
 1444|  45.6k|        } else if ((gc_mask >> v) & 1) {
 1445|  2.45k|        add_range:
 1446|  2.45k|            if (cr_add_interval(cr, c0, c))
 1447|      0|                return -1;
 1448|  2.45k|        }
 1449|  46.5k|    }
 1450|     15|    return 0;
 1451|     15|}
 1452|       |
 1453|       |static int unicode_prop1(CharRange *cr, int prop_idx)
 1454|      0|{
 1455|      0|    const uint8_t *p, *p_end;
 1456|      0|    uint32_t c, c0, b, bit;
 1457|       |
 1458|      0|    p = unicode_prop_table[prop_idx];
 1459|      0|    p_end = p + unicode_prop_len_table[prop_idx];
 1460|      0|    c = 0;
 1461|      0|    bit = 0;
 1462|       |    /* Compressed range encoding:
 1463|       |       00..3F: 2 packed lengths: 3-bit + 3-bit
 1464|       |       40..5F: 5-bits plus extra byte for length
 1465|       |       60..7F: 5-bits plus 2 extra bytes for length
 1466|       |       80..FF: 7-bit length
 1467|       |       lengths must be incremented to get character count
 1468|       |       Ranges alternate between false and true return value.
 1469|       |     */
 1470|      0|    while (p < p_end) {
 1471|      0|        c0 = c;
 1472|      0|        b = *p++;
 1473|      0|        if (b < 64) {
 1474|      0|            c += (b >> 3) + 1;
 1475|      0|            if (bit)  {
 1476|      0|                if (cr_add_interval(cr, c0, c))
 1477|      0|                    return -1;
 1478|      0|            }
 1479|      0|            bit ^= 1;
 1480|      0|            c0 = c;
 1481|      0|            c += (b & 7) + 1;
 1482|      0|        } else if (b >= 0x80) {
 1483|      0|            c += b - 0x80 + 1;
 1484|      0|        } else if (b < 0x60) {
 1485|      0|            c += (((b - 0x40) << 8) | p[0]) + 1;
 1486|      0|            p++;
 1487|      0|        } else {
 1488|      0|            c += (((b - 0x60) << 16) | (p[0] << 8) | p[1]) + 1;
 1489|      0|            p += 2;
 1490|      0|        }
 1491|      0|        if (bit)  {
 1492|      0|            if (cr_add_interval(cr, c0, c))
 1493|      0|                return -1;
 1494|      0|        }
 1495|      0|        bit ^= 1;
 1496|      0|    }
 1497|      0|    return 0;
 1498|      0|}
 1499|       |
 1500|       |typedef enum {
 1501|       |    POP_GC,
 1502|       |    POP_PROP,
 1503|       |    POP_CASE,
 1504|       |    POP_UNION,
 1505|       |    POP_INTER,
 1506|       |    POP_XOR,
 1507|       |    POP_INVERT,
 1508|       |    POP_END,
 1509|       |} PropOPEnum;
 1510|       |
 1511|       |#define POP_STACK_LEN_MAX 4
 1512|       |
 1513|       |static int unicode_prop_ops(CharRange *cr, ...)
 1514|      0|{
 1515|      0|    va_list ap;
 1516|      0|    CharRange stack[POP_STACK_LEN_MAX];
 1517|      0|    int stack_len, op, ret, i;
 1518|      0|    uint32_t a;
 1519|       |
 1520|      0|    va_start(ap, cr);
 1521|      0|    stack_len = 0;
 1522|      0|    for(;;) {
 1523|      0|        op = va_arg(ap, int);
 1524|      0|        switch(op) {
 1525|      0|        case POP_GC:
 1526|      0|            assert(stack_len < POP_STACK_LEN_MAX);
 1527|      0|            a = va_arg(ap, int);
 1528|      0|            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);
 1529|      0|            if (unicode_general_category1(&stack[stack_len - 1], a))
 1530|      0|                goto fail;
 1531|      0|            break;
 1532|      0|        case POP_PROP:
 1533|      0|            assert(stack_len < POP_STACK_LEN_MAX);
 1534|      0|            a = va_arg(ap, int);
 1535|      0|            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);
 1536|      0|            if (unicode_prop1(&stack[stack_len - 1], a))
 1537|      0|                goto fail;
 1538|      0|            break;
 1539|      0|        case POP_CASE:
 1540|      0|            assert(stack_len < POP_STACK_LEN_MAX);
 1541|      0|            a = va_arg(ap, int);
 1542|      0|            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);
 1543|      0|            if (unicode_case1(&stack[stack_len - 1], a))
 1544|      0|                goto fail;
 1545|      0|            break;
 1546|      0|        case POP_UNION:
 1547|      0|        case POP_INTER:
 1548|      0|        case POP_XOR:
 1549|      0|            {
 1550|      0|                CharRange *cr1, *cr2, *cr3;
 1551|      0|                assert(stack_len >= 2);
 1552|      0|                assert(stack_len < POP_STACK_LEN_MAX);
 1553|      0|                cr1 = &stack[stack_len - 2];
 1554|      0|                cr2 = &stack[stack_len - 1];
 1555|      0|                cr3 = &stack[stack_len++];
 1556|      0|                cr_init(cr3, cr->mem_opaque, cr->realloc_func);
 1557|      0|                if (cr_op(cr3, cr1->points, cr1->len,
 1558|      0|                          cr2->points, cr2->len, op - POP_UNION + CR_OP_UNION))
 1559|      0|                    goto fail;
 1560|      0|                cr_free(cr1);
 1561|      0|                cr_free(cr2);
 1562|      0|                *cr1 = *cr3;
 1563|      0|                stack_len -= 2;
 1564|      0|            }
 1565|      0|            break;
 1566|      0|        case POP_INVERT:
 1567|      0|            assert(stack_len >= 1);
 1568|      0|            if (cr_invert(&stack[stack_len - 1]))
 1569|      0|                goto fail;
 1570|      0|            break;
 1571|      0|        case POP_END:
 1572|      0|            goto done;
 1573|      0|        default:
 1574|      0|            abort();
 1575|      0|        }
 1576|      0|    }
 1577|      0| done:
 1578|      0|    assert(stack_len == 1);
 1579|      0|    ret = cr_copy(cr, &stack[0]);
 1580|      0|    cr_free(&stack[0]);
 1581|      0|    return ret;
 1582|      0| fail:
 1583|      0|    for(i = 0; i < stack_len; i++)
 1584|      0|        cr_free(&stack[i]);
 1585|      0|    return -1;
 1586|      0|}
 1587|       |
 1588|       |static const uint32_t unicode_gc_mask_table[] = {
 1589|       |    M(Lu) | M(Ll) | M(Lt), /* LC */
 1590|       |    M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo), /* L */
 1591|       |    M(Mn) | M(Mc) | M(Me), /* M */
 1592|       |    M(Nd) | M(Nl) | M(No), /* N */
 1593|       |    M(Sm) | M(Sc) | M(Sk) | M(So), /* S */
 1594|       |    M(Pc) | M(Pd) | M(Ps) | M(Pe) | M(Pi) | M(Pf) | M(Po), /* P */
 1595|       |    M(Zs) | M(Zl) | M(Zp), /* Z */
 1596|       |    M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn), /* C */
 1597|       |};
 1598|       |
 1599|       |/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2
 1600|       |   if not found */
 1601|       |int unicode_general_category(CharRange *cr, const char *gc_name)
 1602|     24|{
 1603|     24|    int gc_idx;
 1604|     24|    uint32_t gc_mask;
 1605|       |
 1606|     24|    gc_idx = unicode_find_name(unicode_gc_name_table, gc_name);
 1607|     24|    if (gc_idx < 0)
 1608|      9|        return -2;
 1609|     15|    if (gc_idx <= UNICODE_GC_Co) {
 1610|      0|        gc_mask = (uint64_t)1 << gc_idx;
 1611|     15|    } else {
 1612|     15|        gc_mask = unicode_gc_mask_table[gc_idx - UNICODE_GC_LC];
 1613|     15|    }
 1614|     15|    return unicode_general_category1(cr, gc_mask);
 1615|     24|}
 1616|       |
 1617|       |
 1618|       |/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2
 1619|       |   if not found */
 1620|       |int unicode_prop(CharRange *cr, const char *prop_name)
 1621|      9|{
 1622|      9|    int prop_idx, ret;
 1623|       |
 1624|      9|    prop_idx = unicode_find_name(unicode_prop_name_table, prop_name);
 1625|      9|    if (prop_idx < 0)
 1626|      9|        return -2;
 1627|      0|    prop_idx += UNICODE_PROP_ASCII_Hex_Digit;
 1628|       |
 1629|      0|    ret = 0;
 1630|      0|    switch(prop_idx) {
 1631|      0|    case UNICODE_PROP_ASCII:
 1632|      0|        if (cr_add_interval(cr, 0x00, 0x7f + 1))
 1633|      0|            return -1;
 1634|      0|        break;
 1635|      0|    case UNICODE_PROP_Any:
 1636|      0|        if (cr_add_interval(cr, 0x00000, 0x10ffff + 1))
 1637|      0|            return -1;
 1638|      0|        break;
 1639|      0|    case UNICODE_PROP_Assigned:
 1640|      0|        ret = unicode_prop_ops(cr,
 1641|      0|                               POP_GC, M(Cn),
 1642|      0|                               POP_INVERT,
 1643|      0|                               POP_END);
 1644|      0|        break;
 1645|      0|    case UNICODE_PROP_Math:
 1646|      0|        ret = unicode_prop_ops(cr,
 1647|      0|                               POP_GC, M(Sm),
 1648|      0|                               POP_PROP, UNICODE_PROP_Other_Math,
 1649|      0|                               POP_UNION,
 1650|      0|                               POP_END);
 1651|      0|        break;
 1652|      0|    case UNICODE_PROP_Lowercase:
 1653|      0|        ret = unicode_prop_ops(cr,
 1654|      0|                               POP_GC, M(Ll),
 1655|      0|                               POP_PROP, UNICODE_PROP_Other_Lowercase,
 1656|      0|                               POP_UNION,
 1657|      0|                               POP_END);
 1658|      0|        break;
 1659|      0|    case UNICODE_PROP_Uppercase:
 1660|      0|        ret = unicode_prop_ops(cr,
 1661|      0|                               POP_GC, M(Lu),
 1662|      0|                               POP_PROP, UNICODE_PROP_Other_Uppercase,
 1663|      0|                               POP_UNION,
 1664|      0|                               POP_END);
 1665|      0|        break;
 1666|      0|    case UNICODE_PROP_Cased:
 1667|      0|        ret = unicode_prop_ops(cr,
 1668|      0|                               POP_GC, M(Lu) | M(Ll) | M(Lt),
 1669|      0|                               POP_PROP, UNICODE_PROP_Other_Uppercase,
 1670|      0|                               POP_UNION,
 1671|      0|                               POP_PROP, UNICODE_PROP_Other_Lowercase,
 1672|      0|                               POP_UNION,
 1673|      0|                               POP_END);
 1674|      0|        break;
 1675|      0|    case UNICODE_PROP_Alphabetic:
 1676|      0|        ret = unicode_prop_ops(cr,
 1677|      0|                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),
 1678|      0|                               POP_PROP, UNICODE_PROP_Other_Uppercase,
 1679|      0|                               POP_UNION,
 1680|      0|                               POP_PROP, UNICODE_PROP_Other_Lowercase,
 1681|      0|                               POP_UNION,
 1682|      0|                               POP_PROP, UNICODE_PROP_Other_Alphabetic,
 1683|      0|                               POP_UNION,
 1684|      0|                               POP_END);
 1685|      0|        break;
 1686|      0|    case UNICODE_PROP_Grapheme_Base:
 1687|      0|        ret = unicode_prop_ops(cr,
 1688|      0|                               POP_GC, M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn) | M(Zl) | M(Zp) | M(Me) | M(Mn),
 1689|      0|                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,
 1690|      0|                               POP_UNION,
 1691|      0|                               POP_INVERT,
 1692|      0|                               POP_END);
 1693|      0|        break;
 1694|      0|    case UNICODE_PROP_Grapheme_Extend:
 1695|      0|        ret = unicode_prop_ops(cr,
 1696|      0|                               POP_GC, M(Me) | M(Mn),
 1697|      0|                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,
 1698|      0|                               POP_UNION,
 1699|      0|                               POP_END);
 1700|      0|        break;
 1701|      0|    case UNICODE_PROP_XID_Start:
 1702|      0|        ret = unicode_prop_ops(cr,
 1703|      0|                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),
 1704|      0|                               POP_PROP, UNICODE_PROP_Other_ID_Start,
 1705|      0|                               POP_UNION,
 1706|      0|                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
 1707|      0|                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
 1708|      0|                               POP_UNION,
 1709|      0|                               POP_PROP, UNICODE_PROP_XID_Start1,
 1710|      0|                               POP_UNION,
 1711|      0|                               POP_INVERT,
 1712|      0|                               POP_INTER,
 1713|      0|                               POP_END);
 1714|      0|        break;
 1715|      0|    case UNICODE_PROP_XID_Continue:
 1716|      0|        ret = unicode_prop_ops(cr,
 1717|      0|                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |
 1718|      0|                               M(Mn) | M(Mc) | M(Nd) | M(Pc),
 1719|      0|                               POP_PROP, UNICODE_PROP_Other_ID_Start,
 1720|      0|                               POP_UNION,
 1721|      0|                               POP_PROP, UNICODE_PROP_Other_ID_Continue,
 1722|      0|                               POP_UNION,
 1723|      0|                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
 1724|      0|                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
 1725|      0|                               POP_UNION,
 1726|      0|                               POP_PROP, UNICODE_PROP_XID_Continue1,
 1727|      0|                               POP_UNION,
 1728|      0|                               POP_INVERT,
 1729|      0|                               POP_INTER,
 1730|      0|                               POP_END);
 1731|      0|        break;
 1732|      0|    case UNICODE_PROP_Changes_When_Uppercased:
 1733|      0|        ret = unicode_case1(cr, CASE_U);
 1734|      0|        break;
 1735|      0|    case UNICODE_PROP_Changes_When_Lowercased:
 1736|      0|        ret = unicode_case1(cr, CASE_L);
 1737|      0|        break;
 1738|      0|    case UNICODE_PROP_Changes_When_Casemapped:
 1739|      0|        ret = unicode_case1(cr, CASE_U | CASE_L | CASE_F);
 1740|      0|        break;
 1741|      0|    case UNICODE_PROP_Changes_When_Titlecased:
 1742|      0|        ret = unicode_prop_ops(cr,
 1743|      0|                               POP_CASE, CASE_U,
 1744|      0|                               POP_PROP, UNICODE_PROP_Changes_When_Titlecased1,
 1745|      0|                               POP_XOR,
 1746|      0|                               POP_END);
 1747|      0|        break;
 1748|      0|    case UNICODE_PROP_Changes_When_Casefolded:
 1749|      0|        ret = unicode_prop_ops(cr,
 1750|      0|                               POP_CASE, CASE_F,
 1751|      0|                               POP_PROP, UNICODE_PROP_Changes_When_Casefolded1,
 1752|      0|                               POP_XOR,
 1753|      0|                               POP_END);
 1754|      0|        break;
 1755|      0|    case UNICODE_PROP_Changes_When_NFKC_Casefolded:
 1756|      0|        ret = unicode_prop_ops(cr,
 1757|      0|                               POP_CASE, CASE_F,
 1758|      0|                               POP_PROP, UNICODE_PROP_Changes_When_NFKC_Casefolded1,
 1759|      0|                               POP_XOR,
 1760|      0|                               POP_END);
 1761|      0|        break;
 1762|       |#if 0
 1763|       |    case UNICODE_PROP_ID_Start:
 1764|       |        ret = unicode_prop_ops(cr,
 1765|       |                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),
 1766|       |                               POP_PROP, UNICODE_PROP_Other_ID_Start,
 1767|       |                               POP_UNION,
 1768|       |                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
 1769|       |                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
 1770|       |                               POP_UNION,
 1771|       |                               POP_INVERT,
 1772|       |                               POP_INTER,
 1773|       |                               POP_END);
 1774|       |        break;
 1775|       |    case UNICODE_PROP_ID_Continue:
 1776|       |        ret = unicode_prop_ops(cr,
 1777|       |                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |
 1778|       |                               M(Mn) | M(Mc) | M(Nd) | M(Pc),
 1779|       |                               POP_PROP, UNICODE_PROP_Other_ID_Start,
 1780|       |                               POP_UNION,
 1781|       |                               POP_PROP, UNICODE_PROP_Other_ID_Continue,
 1782|       |                               POP_UNION,
 1783|       |                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
 1784|       |                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
 1785|       |                               POP_UNION,
 1786|       |                               POP_INVERT,
 1787|       |                               POP_INTER,
 1788|       |                               POP_END);
 1789|       |        break;
 1790|       |    case UNICODE_PROP_Case_Ignorable:
 1791|       |        ret = unicode_prop_ops(cr,
 1792|       |                               POP_GC, M(Mn) | M(Cf) | M(Lm) | M(Sk),
 1793|       |                               POP_PROP, UNICODE_PROP_Case_Ignorable1,
 1794|       |                               POP_XOR,
 1795|       |                               POP_END);
 1796|       |        break;
 1797|       |#else
 1798|       |        /* we use the existing tables */
 1799|      0|    case UNICODE_PROP_ID_Continue:
 1800|      0|        ret = unicode_prop_ops(cr,
 1801|      0|                               POP_PROP, UNICODE_PROP_ID_Start,
 1802|      0|                               POP_PROP, UNICODE_PROP_ID_Continue1,
 1803|      0|                               POP_XOR,
 1804|      0|                               POP_END);
 1805|      0|        break;
 1806|      0|#endif
 1807|      0|    default:
 1808|      0|        if (prop_idx >= countof(unicode_prop_table))
 1809|      0|            return -2;
 1810|      0|        ret = unicode_prop1(cr, prop_idx);
 1811|      0|        break;
 1812|      0|    }
 1813|      0|    return ret;
 1814|      0|}
 1815|       |
 1816|       |#endif /* CONFIG_ALL_UNICODE */
 1817|       |
 1818|       |/*---- lre codepoint categorizing functions ----*/
 1819|       |
 1820|       |#define S  UNICODE_C_SPACE
 1821|       |#define D  UNICODE_C_DIGIT
 1822|       |#define X  UNICODE_C_XDIGIT
 1823|       |#define U  UNICODE_C_UPPER
 1824|       |#define L  UNICODE_C_LOWER
 1825|       |#define _  UNICODE_C_UNDER
 1826|       |#define d  UNICODE_C_DOLLAR
 1827|       |
 1828|       |uint8_t const lre_ctype_bits[256] = {
 1829|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1830|       |    0, S, S, S, S, S, 0, 0,
 1831|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1832|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1833|       |
 1834|       |    S, 0, 0, 0, d, 0, 0, 0,
 1835|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1836|       |    X|D, X|D, X|D, X|D, X|D, X|D, X|D, X|D,
 1837|       |    X|D, X|D, 0, 0, 0, 0, 0, 0,
 1838|       |
 1839|       |    0, X|U, X|U, X|U, X|U, X|U, X|U, U,
 1840|       |    U, U, U, U, U, U, U, U,
 1841|       |    U, U, U, U, U, U, U, U,
 1842|       |    U, U, U, 0, 0, 0, 0, _,
 1843|       |
 1844|       |    0, X|L, X|L, X|L, X|L, X|L, X|L, L,
 1845|       |    L, L, L, L, L, L, L, L,
 1846|       |    L, L, L, L, L, L, L, L,
 1847|       |    L, L, L, 0, 0, 0, 0, 0,
 1848|       |
 1849|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1850|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1851|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1852|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1853|       |
 1854|       |    S, 0, 0, 0, 0, 0, 0, 0,
 1855|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1856|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1857|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1858|       |
 1859|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1860|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1861|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1862|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1863|       |
 1864|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1865|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1866|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1867|       |    0, 0, 0, 0, 0, 0, 0, 0,
 1868|       |};
 1869|       |
 1870|       |#undef S
 1871|       |#undef D
 1872|       |#undef X
 1873|       |#undef U
 1874|       |#undef L
 1875|       |#undef _
 1876|       |#undef d
 1877|       |
 1878|       |/* code point ranges for Zs,Zl or Zp property */
 1879|       |static const uint16_t char_range_s[] = {
 1880|       |    10,
 1881|       |    0x0009, 0x000D + 1,
 1882|       |    0x0020, 0x0020 + 1,
 1883|       |    0x00A0, 0x00A0 + 1,
 1884|       |    0x1680, 0x1680 + 1,
 1885|       |    0x2000, 0x200A + 1,
 1886|       |    /* 2028;LINE SEPARATOR;Zl;0;WS;;;;;N;;;;; */
 1887|       |    /* 2029;PARAGRAPH SEPARATOR;Zp;0;B;;;;;N;;;;; */
 1888|       |    0x2028, 0x2029 + 1,
 1889|       |    0x202F, 0x202F + 1,
 1890|       |    0x205F, 0x205F + 1,
 1891|       |    0x3000, 0x3000 + 1,
 1892|       |    /* FEFF;ZERO WIDTH NO-BREAK SPACE;Cf;0;BN;;;;;N;BYTE ORDER MARK;;;; */
 1893|       |    0xFEFF, 0xFEFF + 1,
 1894|       |};
 1895|       |
 1896|       |BOOL lre_is_space_non_ascii(uint32_t c)
 1897|  90.9k|{
 1898|  90.9k|    size_t i, n;
 1899|       |
 1900|  90.9k|    n = countof(char_range_s);
 1901|   737k|    for(i = 5; i < n; i += 2) {
 1902|   663k|        uint32_t low = char_range_s[i];
 1903|   663k|        uint32_t high = char_range_s[i + 1];
 1904|   663k|        if (c < low)
 1905|  3.26k|            return FALSE;
 1906|   660k|        if (c < high)
 1907|  13.8k|            return TRUE;
 1908|   660k|    }
 1909|  73.8k|    return FALSE;
 1910|  90.9k|}

/home/eugeneriabinin777/quickjs/libunicode.h:
    1|       |/*
    2|       | * Unicode utilities
    3|       | *
    4|       | * Copyright (c) 2017-2018 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |#ifndef LIBUNICODE_H
   25|       |#define LIBUNICODE_H
   26|       |
   27|       |#include <stdint.h>
   28|       |
   29|       |/* define it to include all the unicode tables (40KB larger) */
   30|       |#define CONFIG_ALL_UNICODE
   31|       |
   32|       |#define LRE_CC_RES_LEN_MAX 3
   33|       |
   34|       |/* char ranges */
   35|       |
   36|       |typedef struct {
   37|       |    int len; /* in points, always even */
   38|       |    int size;
   39|       |    uint32_t *points; /* points sorted by increasing value */
   40|       |    void *mem_opaque;
   41|       |    void *(*realloc_func)(void *opaque, void *ptr, size_t size);
   42|       |} CharRange;
   43|       |
   44|       |typedef enum {
   45|       |    CR_OP_UNION,
   46|       |    CR_OP_INTER,
   47|       |    CR_OP_XOR,
   48|       |} CharRangeOpEnum;
   49|       |
   50|       |void cr_init(CharRange *cr, void *mem_opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));
   51|       |void cr_free(CharRange *cr);
   52|       |int cr_realloc(CharRange *cr, int size);
   53|       |int cr_copy(CharRange *cr, const CharRange *cr1);
   54|       |
   55|       |static inline int cr_add_point(CharRange *cr, uint32_t v)
   56|  51.1M|{
   57|  51.1M|    if (cr->len >= cr->size) {
   58|  4.44M|        if (cr_realloc(cr, cr->len + 1))
   59|      0|            return -1;
   60|  4.44M|    }
   61|  51.1M|    cr->points[cr->len++] = v;
   62|  51.1M|    return 0;
   63|  51.1M|}
  ------------------
  | Unexecuted instantiation: quickjs.c:cr_add_point
  ------------------
  | libregexp.c:cr_add_point:
  |   56|   164k|{
  |   57|   164k|    if (cr->len >= cr->size) {
  |   58|   123k|        if (cr_realloc(cr, cr->len + 1))
  |   59|      0|            return -1;
  |   60|   123k|    }
  |   61|   164k|    cr->points[cr->len++] = v;
  |   62|   164k|    return 0;
  |   63|   164k|}
  ------------------
  | libunicode.c:cr_add_point:
  |   56|  51.0M|{
  |   57|  51.0M|    if (cr->len >= cr->size) {
  |   58|  4.32M|        if (cr_realloc(cr, cr->len + 1))
  |   59|      0|            return -1;
  |   60|  4.32M|    }
  |   61|  51.0M|    cr->points[cr->len++] = v;
  |   62|  51.0M|    return 0;
  |   63|  51.0M|}
  ------------------
   64|       |
   65|       |static inline int cr_add_interval(CharRange *cr, uint32_t c1, uint32_t c2)
   66|  20.1M|{
   67|  20.1M|    if ((cr->len + 2) > cr->size) {
   68|   470k|        if (cr_realloc(cr, cr->len + 2))
   69|      0|            return -1;
   70|   470k|    }
   71|  20.1M|    cr->points[cr->len++] = c1;
   72|  20.1M|    cr->points[cr->len++] = c2;
   73|  20.1M|    return 0;
   74|  20.1M|}
  ------------------
  | Unexecuted instantiation: quickjs.c:cr_add_interval
  ------------------
  | Unexecuted instantiation: libregexp.c:cr_add_interval
  ------------------
  | libunicode.c:cr_add_interval:
  |   66|  20.1M|{
  |   67|  20.1M|    if ((cr->len + 2) > cr->size) {
  |   68|   470k|        if (cr_realloc(cr, cr->len + 2))
  |   69|      0|            return -1;
  |   70|   470k|    }
  |   71|  20.1M|    cr->points[cr->len++] = c1;
  |   72|  20.1M|    cr->points[cr->len++] = c2;
  |   73|  20.1M|    return 0;
  |   74|  20.1M|}
  ------------------
   75|       |
   76|       |int cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len);
   77|       |
   78|       |static inline int cr_union_interval(CharRange *cr, uint32_t c1, uint32_t c2)
   79|   501k|{
   80|   501k|    uint32_t b_pt[2];
   81|   501k|    b_pt[0] = c1;
   82|   501k|    b_pt[1] = c2 + 1;
   83|   501k|    return cr_union1(cr, b_pt, 2);
   84|   501k|}
  ------------------
  | Unexecuted instantiation: quickjs.c:cr_union_interval
  ------------------
  | libregexp.c:cr_union_interval:
  |   79|   501k|{
  |   80|   501k|    uint32_t b_pt[2];
  |   81|   501k|    b_pt[0] = c1;
  |   82|   501k|    b_pt[1] = c2 + 1;
  |   83|   501k|    return cr_union1(cr, b_pt, 2);
  |   84|   501k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:cr_union_interval
  ------------------
   85|       |
   86|       |int cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,
   87|       |          const uint32_t *b_pt, int b_len, int op);
   88|       |
   89|       |int cr_invert(CharRange *cr);
   90|       |
   91|       |int cr_regexp_canonicalize(CharRange *cr, int is_unicode);
   92|       |
   93|       |typedef enum {
   94|       |    UNICODE_NFC,
   95|       |    UNICODE_NFD,
   96|       |    UNICODE_NFKC,
   97|       |    UNICODE_NFKD,
   98|       |} UnicodeNormalizationEnum;
   99|       |
  100|       |int unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,
  101|       |                      UnicodeNormalizationEnum n_type,
  102|       |                      void *opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));
  103|       |
  104|       |/* Unicode character range functions */
  105|       |
  106|       |int unicode_script(CharRange *cr, const char *script_name, int is_ext);
  107|       |int unicode_general_category(CharRange *cr, const char *gc_name);
  108|       |int unicode_prop(CharRange *cr, const char *prop_name);
  109|       |
  110|       |int lre_case_conv(uint32_t *res, uint32_t c, int conv_type);
  111|       |int lre_canonicalize(uint32_t c, int is_unicode);
  112|       |
  113|       |/* Code point type categories */
  114|       |enum {
  115|       |    UNICODE_C_SPACE  = (1 << 0),
  116|       |    UNICODE_C_DIGIT  = (1 << 1),
  117|       |    UNICODE_C_UPPER  = (1 << 2),
  118|       |    UNICODE_C_LOWER  = (1 << 3),
  119|       |    UNICODE_C_UNDER  = (1 << 4),
  120|       |    UNICODE_C_DOLLAR = (1 << 5),
  121|       |    UNICODE_C_XDIGIT = (1 << 6),
  122|       |};
  123|       |extern uint8_t const lre_ctype_bits[256];
  124|       |
  125|       |/* zero or non-zero return value */
  126|       |int lre_is_cased(uint32_t c);
  127|       |int lre_is_case_ignorable(uint32_t c);
  128|       |int lre_is_id_start(uint32_t c);
  129|       |int lre_is_id_continue(uint32_t c);
  130|       |
  131|   422k|static inline int lre_is_space_byte(uint8_t c) {
  132|   422k|    return lre_ctype_bits[c] & UNICODE_C_SPACE;
  133|   422k|}
  ------------------
  | quickjs.c:lre_is_space_byte:
  |  131|   422k|static inline int lre_is_space_byte(uint8_t c) {
  |  132|   422k|    return lre_ctype_bits[c] & UNICODE_C_SPACE;
  |  133|   422k|}
  ------------------
  | Unexecuted instantiation: libregexp.c:lre_is_space_byte
  ------------------
  | Unexecuted instantiation: libunicode.c:lre_is_space_byte
  ------------------
  134|       |
  135|   313k|static inline int lre_is_id_start_byte(uint8_t c) {
  136|   313k|    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |
  137|   313k|                                UNICODE_C_UNDER | UNICODE_C_DOLLAR);
  138|   313k|}
  ------------------
  | quickjs.c:lre_is_id_start_byte:
  |  135|   313k|static inline int lre_is_id_start_byte(uint8_t c) {
  |  136|   313k|    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |
  |  137|   313k|                                UNICODE_C_UNDER | UNICODE_C_DOLLAR);
  |  138|   313k|}
  ------------------
  | libregexp.c:lre_is_id_start_byte:
  |  135|    629|static inline int lre_is_id_start_byte(uint8_t c) {
  |  136|    629|    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |
  |  137|    629|                                UNICODE_C_UNDER | UNICODE_C_DOLLAR);
  |  138|    629|}
  ------------------
  | Unexecuted instantiation: libunicode.c:lre_is_id_start_byte
  ------------------
  139|       |
  140|  12.3M|static inline int lre_is_id_continue_byte(uint8_t c) {
  141|  12.3M|    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |
  142|  12.3M|                                UNICODE_C_UNDER | UNICODE_C_DOLLAR |
  143|  12.3M|                                UNICODE_C_DIGIT);
  144|  12.3M|}
  ------------------
  | quickjs.c:lre_is_id_continue_byte:
  |  140|  12.3M|static inline int lre_is_id_continue_byte(uint8_t c) {
  |  141|  12.3M|    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |
  |  142|  12.3M|                                UNICODE_C_UNDER | UNICODE_C_DOLLAR |
  |  143|  12.3M|                                UNICODE_C_DIGIT);
  |  144|  12.3M|}
  ------------------
  | libregexp.c:lre_is_id_continue_byte:
  |  140|  8.29k|static inline int lre_is_id_continue_byte(uint8_t c) {
  |  141|  8.29k|    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |
  |  142|  8.29k|                                UNICODE_C_UNDER | UNICODE_C_DOLLAR |
  |  143|  8.29k|                                UNICODE_C_DIGIT);
  |  144|  8.29k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:lre_is_id_continue_byte
  ------------------
  145|       |
  146|       |int lre_is_space_non_ascii(uint32_t c);
  147|       |
  148|   513k|static inline int lre_is_space(uint32_t c) {
  149|   513k|    if (c < 256)
  150|   422k|        return lre_is_space_byte(c);
  151|  90.9k|    else
  152|  90.9k|        return lre_is_space_non_ascii(c);
  153|   513k|}
  ------------------
  | quickjs.c:lre_is_space:
  |  148|   513k|static inline int lre_is_space(uint32_t c) {
  |  149|   513k|    if (c < 256)
  |  150|   422k|        return lre_is_space_byte(c);
  |  151|  90.9k|    else
  |  152|  90.9k|        return lre_is_space_non_ascii(c);
  |  153|   513k|}
  ------------------
  | Unexecuted instantiation: libregexp.c:lre_is_space
  ------------------
  | Unexecuted instantiation: libunicode.c:lre_is_space
  ------------------
  154|       |
  155|   349k|static inline int lre_js_is_ident_first(uint32_t c) {
  156|   349k|    if (c < 128) {
  157|   313k|        return lre_is_id_start_byte(c);
  158|   313k|    } else {
  159|  35.4k|#ifdef CONFIG_ALL_UNICODE
  160|  35.4k|        return lre_is_id_start(c);
  161|       |#else
  162|       |        return !lre_is_space_non_ascii(c);
  163|       |#endif
  164|  35.4k|    }
  165|   349k|}
  ------------------
  | quickjs.c:lre_js_is_ident_first:
  |  155|   346k|static inline int lre_js_is_ident_first(uint32_t c) {
  |  156|   346k|    if (c < 128) {
  |  157|   313k|        return lre_is_id_start_byte(c);
  |  158|   313k|    } else {
  |  159|  33.6k|#ifdef CONFIG_ALL_UNICODE
  |  160|  33.6k|        return lre_is_id_start(c);
  |  161|       |#else
  |  162|       |        return !lre_is_space_non_ascii(c);
  |  163|       |#endif
  |  164|  33.6k|    }
  |  165|   346k|}
  ------------------
  | libregexp.c:lre_js_is_ident_first:
  |  155|  2.40k|static inline int lre_js_is_ident_first(uint32_t c) {
  |  156|  2.40k|    if (c < 128) {
  |  157|    629|        return lre_is_id_start_byte(c);
  |  158|  1.78k|    } else {
  |  159|  1.78k|#ifdef CONFIG_ALL_UNICODE
  |  160|  1.78k|        return lre_is_id_start(c);
  |  161|       |#else
  |  162|       |        return !lre_is_space_non_ascii(c);
  |  163|       |#endif
  |  164|  1.78k|    }
  |  165|  2.40k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:lre_js_is_ident_first
  ------------------
  166|       |
  167|  12.3M|static inline int lre_js_is_ident_next(uint32_t c) {
  168|  12.3M|    if (c < 128) {
  169|  12.3M|        return lre_is_id_continue_byte(c);
  170|  12.3M|    } else {
  171|       |        /* ZWNJ and ZWJ are accepted in identifiers */
  172|  42.9k|        if (c >= 0x200C && c <= 0x200D)
  173|  6.74k|            return TRUE;
  174|  36.1k|#ifdef CONFIG_ALL_UNICODE
  175|  36.1k|        return lre_is_id_continue(c);
  176|       |#else
  177|       |        return !lre_is_space_non_ascii(c);
  178|       |#endif
  179|  42.9k|    }
  180|  12.3M|}
  ------------------
  | quickjs.c:lre_js_is_ident_next:
  |  167|  12.3M|static inline int lre_js_is_ident_next(uint32_t c) {
  |  168|  12.3M|    if (c < 128) {
  |  169|  12.3M|        return lre_is_id_continue_byte(c);
  |  170|  12.3M|    } else {
  |  171|       |        /* ZWNJ and ZWJ are accepted in identifiers */
  |  172|  42.8k|        if (c >= 0x200C && c <= 0x200D)
  |  173|  6.74k|            return TRUE;
  |  174|  36.1k|#ifdef CONFIG_ALL_UNICODE
  |  175|  36.1k|        return lre_is_id_continue(c);
  |  176|       |#else
  |  177|       |        return !lre_is_space_non_ascii(c);
  |  178|       |#endif
  |  179|  42.8k|    }
  |  180|  12.3M|}
  ------------------
  | libregexp.c:lre_js_is_ident_next:
  |  167|  8.33k|static inline int lre_js_is_ident_next(uint32_t c) {
  |  168|  8.33k|    if (c < 128) {
  |  169|  8.29k|        return lre_is_id_continue_byte(c);
  |  170|  8.29k|    } else {
  |  171|       |        /* ZWNJ and ZWJ are accepted in identifiers */
  |  172|     45|        if (c >= 0x200C && c <= 0x200D)
  |  173|      0|            return TRUE;
  |  174|     45|#ifdef CONFIG_ALL_UNICODE
  |  175|     45|        return lre_is_id_continue(c);
  |  176|       |#else
  |  177|       |        return !lre_is_space_non_ascii(c);
  |  178|       |#endif
  |  179|     45|    }
  |  180|  8.33k|}
  ------------------
  | Unexecuted instantiation: libunicode.c:lre_js_is_ident_next
  ------------------
  181|       |
  182|       |#endif /* LIBUNICODE_H */

/home/eugeneriabinin777/quickjs/list.h:
    1|       |/*
    2|       | * Linux klist like system
    3|       | *
    4|       | * Copyright (c) 2016-2017 Fabrice Bellard
    5|       | *
    6|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       | * of this software and associated documentation files (the "Software"), to deal
    8|       | * in the Software without restriction, including without limitation the rights
    9|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       | * copies of the Software, and to permit persons to whom the Software is
   11|       | * furnished to do so, subject to the following conditions:
   12|       | *
   13|       | * The above copyright notice and this permission notice shall be included in
   14|       | * all copies or substantial portions of the Software.
   15|       | *
   16|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   19|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       | * THE SOFTWARE.
   23|       | */
   24|       |#ifndef LIST_H
   25|       |#define LIST_H
   26|       |
   27|       |#ifndef NULL
   28|       |#include <stddef.h>
   29|       |#endif
   30|       |
   31|       |struct list_head {
   32|       |    struct list_head *prev;
   33|       |    struct list_head *next;
   34|       |};
   35|       |
   36|       |#define LIST_HEAD_INIT(el) { &(el), &(el) }
   37|       |
   38|       |/* return the pointer of type 'type *' containing 'el' as field 'member' */
   39|  29.0M|#define list_entry(el, type, member) container_of(el, type, member)
   40|       |
   41|       |static inline void init_list_head(struct list_head *head)
   42|   635k|{
   43|   635k|    head->prev = head;
   44|   635k|    head->next = head;
   45|   635k|}
  ------------------
  | quickjs.c:init_list_head:
  |   42|   564k|{
  |   43|   564k|    head->prev = head;
  |   44|   564k|    head->next = head;
  |   45|   564k|}
  ------------------
  | quickjs-libc.c:init_list_head:
  |   42|  71.0k|{
  |   43|  71.0k|    head->prev = head;
  |   44|  71.0k|    head->next = head;
  |   45|  71.0k|}
  ------------------
   46|       |
   47|       |/* insert 'el' between 'prev' and 'next' */
   48|       |static inline void __list_add(struct list_head *el,
   49|       |                              struct list_head *prev, struct list_head *next)
   50|  42.6M|{
   51|  42.6M|    prev->next = el;
   52|  42.6M|    el->prev = prev;
   53|  42.6M|    el->next = next;
   54|  42.6M|    next->prev = el;
   55|  42.6M|}
  ------------------
  | quickjs.c:__list_add:
  |   50|  42.6M|{
  |   51|  42.6M|    prev->next = el;
  |   52|  42.6M|    el->prev = prev;
  |   53|  42.6M|    el->next = next;
  |   54|  42.6M|    next->prev = el;
  |   55|  42.6M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:__list_add
  ------------------
   56|       |
   57|       |/* add 'el' at the head of the list 'head' (= after element head) */
   58|       |static inline void list_add(struct list_head *el, struct list_head *head)
   59|  6.32M|{
   60|  6.32M|    __list_add(el, head, head->next);
   61|  6.32M|}
  ------------------
  | quickjs.c:list_add:
  |   59|  6.32M|{
  |   60|  6.32M|    __list_add(el, head, head->next);
  |   61|  6.32M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:list_add
  ------------------
   62|       |
   63|       |/* add 'el' at the end of the list 'head' (= before element head) */
   64|       |static inline void list_add_tail(struct list_head *el, struct list_head *head)
   65|  36.3M|{
   66|  36.3M|    __list_add(el, head->prev, head);
   67|  36.3M|}
  ------------------
  | quickjs.c:list_add_tail:
  |   65|  36.3M|{
  |   66|  36.3M|    __list_add(el, head->prev, head);
  |   67|  36.3M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:list_add_tail
  ------------------
   68|       |
   69|       |static inline void list_del(struct list_head *el)
   70|  40.7M|{
   71|  40.7M|    struct list_head *prev, *next;
   72|  40.7M|    prev = el->prev;
   73|  40.7M|    next = el->next;
   74|  40.7M|    prev->next = next;
   75|  40.7M|    next->prev = prev;
   76|  40.7M|    el->prev = NULL; /* fail safe */
   77|  40.7M|    el->next = NULL; /* fail safe */
   78|  40.7M|}
  ------------------
  | quickjs.c:list_del:
  |   70|  40.7M|{
  |   71|  40.7M|    struct list_head *prev, *next;
  |   72|  40.7M|    prev = el->prev;
  |   73|  40.7M|    next = el->next;
  |   74|  40.7M|    prev->next = next;
  |   75|  40.7M|    next->prev = prev;
  |   76|  40.7M|    el->prev = NULL; /* fail safe */
  |   77|  40.7M|    el->next = NULL; /* fail safe */
  |   78|  40.7M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:list_del
  ------------------
   79|       |
   80|       |static inline int list_empty(struct list_head *el)
   81|   285k|{
   82|   285k|    return el->next == el;
   83|   285k|}
  ------------------
  | quickjs.c:list_empty:
  |   81|   285k|{
  |   82|   285k|    return el->next == el;
  |   83|   285k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:list_empty
  ------------------
   84|       |
   85|       |#define list_for_each(el, head) \
   86|  8.89M|  for(el = (head)->next; el != (head); el = el->next)
   87|       |
   88|       |#define list_for_each_safe(el, el1, head)                \
   89|  10.8M|    for(el = (head)->next, el1 = el->next; el != (head); \
   90|  10.5M|        el = el1, el1 = el->next)
   91|       |
   92|       |#define list_for_each_prev(el, head) \
   93|       |  for(el = (head)->prev; el != (head); el = el->prev)
   94|       |
   95|       |#define list_for_each_prev_safe(el, el1, head)           \
   96|       |    for(el = (head)->prev, el1 = el->prev; el != (head); \
   97|       |        el = el1, el1 = el->prev)
   98|       |
   99|       |#endif /* LIST_H */

/home/eugeneriabinin777/quickjs/qjs.c:
    1|       |/*
    2|       | * QuickJS stand alone interpreter
    3|       | *
    4|       | * Copyright (c) 2017-2021 Fabrice Bellard
    5|       | * Copyright (c) 2017-2021 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |#include <stdlib.h>
   26|       |#include <stdio.h>
   27|       |#include <stdarg.h>
   28|       |#include <inttypes.h>
   29|       |#include <string.h>
   30|       |#include <assert.h>
   31|       |#include <unistd.h>
   32|       |#include <errno.h>
   33|       |#include <fcntl.h>
   34|       |#include <time.h>
   35|       |#if defined(__APPLE__)
   36|       |#include <malloc/malloc.h>
   37|       |#elif defined(__linux__) || defined(__GLIBC__)
   38|       |#include <malloc.h>
   39|       |#elif defined(__FreeBSD__)
   40|       |#include <malloc_np.h>
   41|       |#endif
   42|       |
   43|       |#include "cutils.h"
   44|       |#include "quickjs-libc.h"
   45|       |
   46|       |extern const uint8_t qjsc_repl[];
   47|       |extern const uint32_t qjsc_repl_size;
   48|       |
   49|       |static int eval_buf(JSContext *ctx, const void *buf, int buf_len,
   50|       |                    const char *filename, int eval_flags)
   51|  17.7k|{
   52|  17.7k|    JSValue val;
   53|  17.7k|    int ret;
   54|       |
   55|  17.7k|    if ((eval_flags & JS_EVAL_TYPE_MASK) == JS_EVAL_TYPE_MODULE) {
   56|       |        /* for the modules, we compile then run to be able to set
   57|       |           import.meta */
   58|    885|        val = JS_Eval(ctx, buf, buf_len, filename,
   59|    885|                      eval_flags | JS_EVAL_FLAG_COMPILE_ONLY);
   60|    885|        if (!JS_IsException(val)) {
   61|    367|            js_module_set_import_meta(ctx, val, TRUE, TRUE);
   62|    367|            val = JS_EvalFunction(ctx, val);
   63|    367|        }
   64|    885|        val = js_std_await(ctx, val);
   65|  16.8k|    } else {
   66|  16.8k|        val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);
   67|  16.8k|    }
   68|  17.7k|    if (JS_IsException(val)) {
   69|  13.9k|        js_std_dump_error(ctx);
   70|  13.9k|        ret = -1;
   71|  13.9k|    } else {
   72|  3.81k|        ret = 0;
   73|  3.81k|    }
   74|  17.7k|    JS_FreeValue(ctx, val);
   75|  17.7k|    return ret;
   76|  17.7k|}
   77|       |
   78|       |static int eval_file(JSContext *ctx, const char *filename, int module)
   79|  17.7k|{
   80|  17.7k|    uint8_t *buf;
   81|  17.7k|    int ret, eval_flags;
   82|  17.7k|    size_t buf_len;
   83|       |
   84|  17.7k|    buf = js_load_file(ctx, &buf_len, filename);
   85|  17.7k|    if (!buf) {
   86|      0|        perror(filename);
   87|      0|        exit(1);
   88|      0|    }
   89|       |
   90|  17.7k|    if (module < 0) {
   91|  17.7k|        module = (has_suffix(filename, ".mjs") ||
   92|  17.7k|                  JS_DetectModule((const char *)buf, buf_len));
   93|  17.7k|    }
   94|  17.7k|    if (module)
   95|    885|        eval_flags = JS_EVAL_TYPE_MODULE;
   96|  16.8k|    else
   97|  16.8k|        eval_flags = JS_EVAL_TYPE_GLOBAL;
   98|  17.7k|    ret = eval_buf(ctx, buf, buf_len, filename, eval_flags);
   99|  17.7k|    js_free(ctx, buf);
  100|  17.7k|    return ret;
  101|  17.7k|}
  102|       |
  103|       |/* also used to initialize the worker context */
  104|       |static JSContext *JS_NewCustomContext(JSRuntime *rt)
  105|  17.7k|{
  106|  17.7k|    JSContext *ctx;
  107|  17.7k|    ctx = JS_NewContext(rt);
  108|  17.7k|    if (!ctx)
  109|      0|        return NULL;
  110|       |    /* system modules */
  111|  17.7k|    js_init_module_std(ctx, "std");
  112|  17.7k|    js_init_module_os(ctx, "os");
  113|  17.7k|    return ctx;
  114|  17.7k|}
  115|       |
  116|       |#if defined(__APPLE__)
  117|       |#define MALLOC_OVERHEAD  0
  118|       |#else
  119|      0|#define MALLOC_OVERHEAD  8
  120|       |#endif
  121|       |
  122|       |struct trace_malloc_data {
  123|       |    uint8_t *base;
  124|       |};
  125|       |
  126|       |static inline unsigned long long js_trace_malloc_ptr_offset(uint8_t *ptr,
  127|       |                                                struct trace_malloc_data *dp)
  128|      0|{
  129|      0|    return ptr - dp->base;
  130|      0|}
  131|       |
  132|       |/* default memory allocation functions with memory limitation */
  133|       |static size_t js_trace_malloc_usable_size(const void *ptr)
  134|      0|{
  135|       |#if defined(__APPLE__)
  136|       |    return malloc_size(ptr);
  137|       |#elif defined(_WIN32)
  138|       |    return _msize((void *)ptr);
  139|       |#elif defined(EMSCRIPTEN)
  140|       |    return 0;
  141|       |#elif defined(__linux__) || defined(__GLIBC__)
  142|      0|    return malloc_usable_size((void *)ptr);
  143|       |#else
  144|       |    /* change this to `return 0;` if compilation fails */
  145|       |    return malloc_usable_size((void *)ptr);
  146|       |#endif
  147|      0|}
  148|       |
  149|       |static void
  150|       |#ifdef _WIN32
  151|       |/* mingw printf is used */
  152|       |__attribute__((format(gnu_printf, 2, 3)))
  153|       |#else
  154|       |__attribute__((format(printf, 2, 3)))
  155|       |#endif
  156|       |    js_trace_malloc_printf(JSMallocState *s, const char *fmt, ...)
  157|      0|{
  158|      0|    va_list ap;
  159|      0|    int c;
  160|       |
  161|      0|    va_start(ap, fmt);
  162|      0|    while ((c = *fmt++) != '\0') {
  163|      0|        if (c == '%') {
  164|       |            /* only handle %p and %zd */
  165|      0|            if (*fmt == 'p') {
  166|      0|                uint8_t *ptr = va_arg(ap, void *);
  167|      0|                if (ptr == NULL) {
  168|      0|                    printf("NULL");
  169|      0|                } else {
  170|      0|                    printf("H%+06lld.%zd",
  171|      0|                           js_trace_malloc_ptr_offset(ptr, s->opaque),
  172|      0|                           js_trace_malloc_usable_size(ptr));
  173|      0|                }
  174|      0|                fmt++;
  175|      0|                continue;
  176|      0|            }
  177|      0|            if (fmt[0] == 'z' && fmt[1] == 'd') {
  178|      0|                size_t sz = va_arg(ap, size_t);
  179|      0|                printf("%zd", sz);
  180|      0|                fmt += 2;
  181|      0|                continue;
  182|      0|            }
  183|      0|        }
  184|      0|        putc(c, stdout);
  185|      0|    }
  186|      0|    va_end(ap);
  187|      0|}
  188|       |
  189|       |static void js_trace_malloc_init(struct trace_malloc_data *s)
  190|      0|{
  191|      0|    free(s->base = malloc(8));
  192|      0|}
  193|       |
  194|       |static void *js_trace_malloc(JSMallocState *s, size_t size)
  195|      0|{
  196|      0|    void *ptr;
  197|       |
  198|       |    /* Do not allocate zero bytes: behavior is platform dependent */
  199|      0|    assert(size != 0);
  200|       |
  201|      0|    if (unlikely(s->malloc_size + size > s->malloc_limit))
  202|      0|        return NULL;
  203|      0|    ptr = malloc(size);
  204|      0|    js_trace_malloc_printf(s, "A %zd -> %p\n", size, ptr);
  205|      0|    if (ptr) {
  206|      0|        s->malloc_count++;
  207|      0|        s->malloc_size += js_trace_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
  208|      0|    }
  209|      0|    return ptr;
  210|      0|}
  211|       |
  212|       |static void js_trace_free(JSMallocState *s, void *ptr)
  213|      0|{
  214|      0|    if (!ptr)
  215|      0|        return;
  216|       |
  217|      0|    js_trace_malloc_printf(s, "F %p\n", ptr);
  218|      0|    s->malloc_count--;
  219|      0|    s->malloc_size -= js_trace_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
  220|      0|    free(ptr);
  221|      0|}
  222|       |
  223|       |static void *js_trace_realloc(JSMallocState *s, void *ptr, size_t size)
  224|      0|{
  225|      0|    size_t old_size;
  226|       |
  227|      0|    if (!ptr) {
  228|      0|        if (size == 0)
  229|      0|            return NULL;
  230|      0|        return js_trace_malloc(s, size);
  231|      0|    }
  232|      0|    old_size = js_trace_malloc_usable_size(ptr);
  233|      0|    if (size == 0) {
  234|      0|        js_trace_malloc_printf(s, "R %zd %p\n", size, ptr);
  235|      0|        s->malloc_count--;
  236|      0|        s->malloc_size -= old_size + MALLOC_OVERHEAD;
  237|      0|        free(ptr);
  238|      0|        return NULL;
  239|      0|    }
  240|      0|    if (s->malloc_size + size - old_size > s->malloc_limit)
  241|      0|        return NULL;
  242|       |
  243|      0|    js_trace_malloc_printf(s, "R %zd %p", size, ptr);
  244|       |
  245|      0|    ptr = realloc(ptr, size);
  246|      0|    js_trace_malloc_printf(s, " -> %p\n", ptr);
  247|      0|    if (ptr) {
  248|      0|        s->malloc_size += js_trace_malloc_usable_size(ptr) - old_size;
  249|      0|    }
  250|      0|    return ptr;
  251|      0|}
  252|       |
  253|       |static const JSMallocFunctions trace_mf = {
  254|       |    js_trace_malloc,
  255|       |    js_trace_free,
  256|       |    js_trace_realloc,
  257|       |    js_trace_malloc_usable_size,
  258|       |};
  259|       |
  260|       |static size_t get_suffixed_size(const char *str)
  261|      0|{
  262|      0|    char *p;
  263|      0|    size_t v;
  264|      0|    v = (size_t)strtod(str, &p);
  265|      0|    switch(*p) {
  266|      0|    case 'G':
  267|      0|        v <<= 30;
  268|      0|        break;
  269|      0|    case 'M':
  270|      0|        v <<= 20;
  271|      0|        break;
  272|      0|    case 'k':
  273|      0|    case 'K':
  274|      0|        v <<= 10;
  275|      0|        break;
  276|      0|    default:
  277|      0|        if (*p != '\0') {
  278|      0|            fprintf(stderr, "qjs: invalid suffix: %s\n", p);
  279|      0|            exit(1);
  280|      0|        }
  281|      0|        break;
  282|      0|    }
  283|      0|    return v;
  284|      0|}
  285|       |
  286|       |#define PROG_NAME "qjs"
  287|       |
  288|       |void help(void)
  289|      0|{
  290|      0|    printf("QuickJS version " CONFIG_VERSION "\n"
  291|      0|           "usage: " PROG_NAME " [options] [file [args]]\n"
  292|      0|           "-h  --help         list options\n"
  293|      0|           "-e  --eval EXPR    evaluate EXPR\n"
  294|      0|           "-i  --interactive  go to interactive mode\n"
  295|      0|           "-m  --module       load as ES6 module (default=autodetect)\n"
  296|      0|           "    --script       load as ES6 script (default=autodetect)\n"
  297|      0|           "-I  --include file include an additional file\n"
  298|      0|           "    --std          make 'std' and 'os' available to the loaded script\n"
  299|      0|           "-T  --trace        trace memory allocation\n"
  300|      0|           "-d  --dump         dump the memory usage stats\n"
  301|      0|           "    --memory-limit n  limit the memory usage to 'n' bytes (SI suffixes allowed)\n"
  302|      0|           "    --stack-size n    limit the stack size to 'n' bytes (SI suffixes allowed)\n"
  303|      0|           "    --no-unhandled-rejection  ignore unhandled promise rejections\n"
  304|      0|           "-s                    strip all the debug info\n"
  305|      0|           "    --strip-source    strip the source code\n"
  306|      0|           "-q  --quit         just instantiate the interpreter and quit\n");
  307|      0|    exit(1);
  308|      0|}
  309|       |
  310|       |int main(int argc, char **argv)
  311|  17.7k|{
  312|  17.7k|    JSRuntime *rt;
  313|  17.7k|    JSContext *ctx;
  314|  17.7k|    struct trace_malloc_data trace_data = { NULL };
  315|  17.7k|    int optind;
  316|  17.7k|    char *expr = NULL;
  317|  17.7k|    int interactive = 0;
  318|  17.7k|    int dump_memory = 0;
  319|  17.7k|    int trace_memory = 0;
  320|  17.7k|    int empty_run = 0;
  321|  17.7k|    int module = -1;
  322|  17.7k|    int load_std = 0;
  323|  17.7k|    int dump_unhandled_promise_rejection = 1;
  324|  17.7k|    size_t memory_limit = 0;
  325|  17.7k|    char *include_list[32];
  326|  17.7k|    int i, include_count = 0;
  327|  17.7k|    int strip_flags = 0;
  328|  17.7k|    size_t stack_size = 0;
  329|       |
  330|       |    /* cannot use getopt because we want to pass the command line to
  331|       |       the script */
  332|  17.7k|    optind = 1;
  333|  17.7k|    while (optind < argc && *argv[optind] == '-') {
  334|      0|        char *arg = argv[optind] + 1;
  335|      0|        const char *longopt = "";
  336|       |        /* a single - is not an option, it also stops argument scanning */
  337|      0|        if (!*arg)
  338|      0|            break;
  339|      0|        optind++;
  340|      0|        if (*arg == '-') {
  341|      0|            longopt = arg + 1;
  342|      0|            arg += strlen(arg);
  343|       |            /* -- stops argument scanning */
  344|      0|            if (!*longopt)
  345|      0|                break;
  346|      0|        }
  347|      0|        for (; *arg || *longopt; longopt = "") {
  348|      0|            char opt = *arg;
  349|      0|            if (opt)
  350|      0|                arg++;
  351|      0|            if (opt == 'h' || opt == '?' || !strcmp(longopt, "help")) {
  352|      0|                help();
  353|      0|                continue;
  354|      0|            }
  355|      0|            if (opt == 'e' || !strcmp(longopt, "eval")) {
  356|      0|                if (*arg) {
  357|      0|                    expr = arg;
  358|      0|                    break;
  359|      0|                }
  360|      0|                if (optind < argc) {
  361|      0|                    expr = argv[optind++];
  362|      0|                    break;
  363|      0|                }
  364|      0|                fprintf(stderr, "qjs: missing expression for -e\n");
  365|      0|                exit(2);
  366|      0|            }
  367|      0|            if (opt == 'I' || !strcmp(longopt, "include")) {
  368|      0|                if (optind >= argc) {
  369|      0|                    fprintf(stderr, "expecting filename");
  370|      0|                    exit(1);
  371|      0|                }
  372|      0|                if (include_count >= countof(include_list)) {
  373|      0|                    fprintf(stderr, "too many included files");
  374|      0|                    exit(1);
  375|      0|                }
  376|      0|                include_list[include_count++] = argv[optind++];
  377|      0|                continue;
  378|      0|            }
  379|      0|            if (opt == 'i' || !strcmp(longopt, "interactive")) {
  380|      0|                interactive++;
  381|      0|                continue;
  382|      0|            }
  383|      0|            if (opt == 'm' || !strcmp(longopt, "module")) {
  384|      0|                module = 1;
  385|      0|                continue;
  386|      0|            }
  387|      0|            if (!strcmp(longopt, "script")) {
  388|      0|                module = 0;
  389|      0|                continue;
  390|      0|            }
  391|      0|            if (opt == 'd' || !strcmp(longopt, "dump")) {
  392|      0|                dump_memory++;
  393|      0|                continue;
  394|      0|            }
  395|      0|            if (opt == 'T' || !strcmp(longopt, "trace")) {
  396|      0|                trace_memory++;
  397|      0|                continue;
  398|      0|            }
  399|      0|            if (!strcmp(longopt, "std")) {
  400|      0|                load_std = 1;
  401|      0|                continue;
  402|      0|            }
  403|      0|            if (!strcmp(longopt, "no-unhandled-rejection")) {
  404|      0|                dump_unhandled_promise_rejection = 0;
  405|      0|                continue;
  406|      0|            }
  407|      0|            if (opt == 'q' || !strcmp(longopt, "quit")) {
  408|      0|                empty_run++;
  409|      0|                continue;
  410|      0|            }
  411|      0|            if (!strcmp(longopt, "memory-limit")) {
  412|      0|                if (optind >= argc) {
  413|      0|                    fprintf(stderr, "expecting memory limit");
  414|      0|                    exit(1);
  415|      0|                }
  416|      0|                memory_limit = get_suffixed_size(argv[optind++]);
  417|      0|                continue;
  418|      0|            }
  419|      0|            if (!strcmp(longopt, "stack-size")) {
  420|      0|                if (optind >= argc) {
  421|      0|                    fprintf(stderr, "expecting stack size");
  422|      0|                    exit(1);
  423|      0|                }
  424|      0|                stack_size = get_suffixed_size(argv[optind++]);
  425|      0|                continue;
  426|      0|            }
  427|      0|            if (opt == 's') {
  428|      0|                strip_flags = JS_STRIP_DEBUG;
  429|      0|                continue;
  430|      0|            }
  431|      0|            if (!strcmp(longopt, "strip-source")) {
  432|      0|                strip_flags = JS_STRIP_SOURCE;
  433|      0|                continue;
  434|      0|            }
  435|      0|            if (opt) {
  436|      0|                fprintf(stderr, "qjs: unknown option '-%c'\n", opt);
  437|      0|            } else {
  438|      0|                fprintf(stderr, "qjs: unknown option '--%s'\n", longopt);
  439|      0|            }
  440|      0|            help();
  441|      0|        }
  442|      0|    }
  443|       |
  444|  17.7k|    if (trace_memory) {
  445|      0|        js_trace_malloc_init(&trace_data);
  446|      0|        rt = JS_NewRuntime2(&trace_mf, &trace_data);
  447|  17.7k|    } else {
  448|  17.7k|        rt = JS_NewRuntime();
  449|  17.7k|    }
  450|  17.7k|    if (!rt) {
  451|      0|        fprintf(stderr, "qjs: cannot allocate JS runtime\n");
  452|      0|        exit(2);
  453|      0|    }
  454|  17.7k|    if (memory_limit != 0)
  455|      0|        JS_SetMemoryLimit(rt, memory_limit);
  456|  17.7k|    if (stack_size != 0)
  457|      0|        JS_SetMaxStackSize(rt, stack_size);
  458|  17.7k|    JS_SetStripInfo(rt, strip_flags);
  459|  17.7k|    js_std_set_worker_new_context_func(JS_NewCustomContext);
  460|  17.7k|    js_std_init_handlers(rt);
  461|  17.7k|    ctx = JS_NewCustomContext(rt);
  462|  17.7k|    if (!ctx) {
  463|      0|        fprintf(stderr, "qjs: cannot allocate JS context\n");
  464|      0|        exit(2);
  465|      0|    }
  466|       |
  467|       |    /* loader for ES6 modules */
  468|  17.7k|    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);
  469|       |
  470|  17.7k|    if (dump_unhandled_promise_rejection) {
  471|  17.7k|        JS_SetHostPromiseRejectionTracker(rt, js_std_promise_rejection_tracker,
  472|  17.7k|                                          NULL);
  473|  17.7k|    }
  474|       |
  475|  17.7k|    if (!empty_run) {
  476|  17.7k|        js_std_add_helpers(ctx, argc - optind, argv + optind);
  477|       |
  478|       |        /* make 'std' and 'os' visible to non module code */
  479|  17.7k|        if (load_std) {
  480|      0|            const char *str = "import * as std from 'std';\n"
  481|      0|                "import * as os from 'os';\n"
  482|      0|                "globalThis.std = std;\n"
  483|      0|                "globalThis.os = os;\n";
  484|      0|            eval_buf(ctx, str, strlen(str), "<input>", JS_EVAL_TYPE_MODULE);
  485|      0|        }
  486|       |
  487|  17.7k|        for(i = 0; i < include_count; i++) {
  488|      0|            if (eval_file(ctx, include_list[i], module))
  489|      0|                goto fail;
  490|      0|        }
  491|       |
  492|  17.7k|        if (expr) {
  493|      0|            if (eval_buf(ctx, expr, strlen(expr), "<cmdline>", 0))
  494|      0|                goto fail;
  495|      0|        } else
  496|  17.7k|        if (optind >= argc) {
  497|       |            /* interactive mode */
  498|      0|            interactive = 1;
  499|  17.7k|        } else {
  500|  17.7k|            const char *filename;
  501|  17.7k|            filename = argv[optind];
  502|  17.7k|            if (eval_file(ctx, filename, module))
  503|  13.9k|                goto fail;
  504|  17.7k|        }
  505|  3.81k|        if (interactive) {
  506|      0|            JS_SetHostPromiseRejectionTracker(rt, NULL, NULL);
  507|      0|            js_std_eval_binary(ctx, qjsc_repl, qjsc_repl_size, 0);
  508|      0|        }
  509|  3.81k|        js_std_loop(ctx);
  510|  3.81k|    }
  511|       |
  512|  3.81k|    if (dump_memory) {
  513|      0|        JSMemoryUsage stats;
  514|      0|        JS_ComputeMemoryUsage(rt, &stats);
  515|      0|        JS_DumpMemoryUsage(stdout, &stats, rt);
  516|      0|    }
  517|  3.81k|    js_std_free_handlers(rt);
  518|  3.81k|    JS_FreeContext(ctx);
  519|  3.81k|    JS_FreeRuntime(rt);
  520|       |
  521|  3.81k|    if (empty_run && dump_memory) {
  522|      0|        clock_t t[5];
  523|      0|        double best[5];
  524|      0|        int i, j;
  525|      0|        for (i = 0; i < 100; i++) {
  526|      0|            t[0] = clock();
  527|      0|            rt = JS_NewRuntime();
  528|      0|            t[1] = clock();
  529|      0|            ctx = JS_NewContext(rt);
  530|      0|            t[2] = clock();
  531|      0|            JS_FreeContext(ctx);
  532|      0|            t[3] = clock();
  533|      0|            JS_FreeRuntime(rt);
  534|      0|            t[4] = clock();
  535|      0|            for (j = 4; j > 0; j--) {
  536|      0|                double ms = 1000.0 * (t[j] - t[j - 1]) / CLOCKS_PER_SEC;
  537|      0|                if (i == 0 || best[j] > ms)
  538|      0|                    best[j] = ms;
  539|      0|            }
  540|      0|        }
  541|      0|        printf("\nInstantiation times (ms): %.3f = %.3f+%.3f+%.3f+%.3f\n",
  542|      0|               best[1] + best[2] + best[3] + best[4],
  543|      0|               best[1], best[2], best[3], best[4]);
  544|      0|    }
  545|  3.81k|    return 0;
  546|  13.9k| fail:
  547|  13.9k|    js_std_free_handlers(rt);
  548|  13.9k|    JS_FreeContext(ctx);
  549|  13.9k|    JS_FreeRuntime(rt);
  550|  13.9k|    return 1;
  551|  17.7k|}

/home/eugeneriabinin777/quickjs/quickjs-libc.c:
    1|       |/*
    2|       | * QuickJS C library
    3|       | *
    4|       | * Copyright (c) 2017-2021 Fabrice Bellard
    5|       | * Copyright (c) 2017-2021 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |#include <stdlib.h>
   26|       |#include <stdio.h>
   27|       |#include <stdarg.h>
   28|       |#include <inttypes.h>
   29|       |#include <string.h>
   30|       |#include <assert.h>
   31|       |#include <unistd.h>
   32|       |#include <errno.h>
   33|       |#include <fcntl.h>
   34|       |#include <sys/time.h>
   35|       |#include <time.h>
   36|       |#include <signal.h>
   37|       |#include <limits.h>
   38|       |#include <sys/stat.h>
   39|       |#include <dirent.h>
   40|       |#if defined(_WIN32)
   41|       |#include <windows.h>
   42|       |#include <conio.h>
   43|       |#include <utime.h>
   44|       |#else
   45|       |#include <dlfcn.h>
   46|       |#include <termios.h>
   47|       |#include <sys/ioctl.h>
   48|       |#include <sys/wait.h>
   49|       |
   50|       |#if defined(__FreeBSD__)
   51|       |extern char **environ;
   52|       |#endif
   53|       |
   54|       |#if defined(__APPLE__) || defined(__FreeBSD__)
   55|       |typedef sig_t sighandler_t;
   56|       |#endif
   57|       |
   58|       |#if defined(__APPLE__)
   59|       |#if !defined(environ)
   60|       |#include <crt_externs.h>
   61|       |#define environ (*_NSGetEnviron())
   62|       |#endif
   63|       |#endif /* __APPLE__ */
   64|       |
   65|       |#endif
   66|       |
   67|       |/* enable the os.Worker API. It relies on POSIX threads */
   68|       |#define USE_WORKER
   69|       |
   70|       |#ifdef USE_WORKER
   71|       |#include <pthread.h>
   72|       |#include <stdatomic.h>
   73|       |#endif
   74|       |
   75|       |#include "cutils.h"
   76|       |#include "list.h"
   77|       |#include "quickjs-libc.h"
   78|       |
   79|       |#if !defined(PATH_MAX)
   80|       |#define PATH_MAX 4096
   81|       |#endif
   82|       |
   83|       |/* TODO:
   84|       |   - add socket calls
   85|       |*/
   86|       |
   87|       |typedef struct {
   88|       |    struct list_head link;
   89|       |    int fd;
   90|       |    JSValue rw_func[2];
   91|       |} JSOSRWHandler;
   92|       |
   93|       |typedef struct {
   94|       |    struct list_head link;
   95|       |    int sig_num;
   96|       |    JSValue func;
   97|       |} JSOSSignalHandler;
   98|       |
   99|       |typedef struct {
  100|       |    struct list_head link;
  101|       |    int timer_id;
  102|       |    int64_t timeout;
  103|       |    JSValue func;
  104|       |} JSOSTimer;
  105|       |
  106|       |typedef struct {
  107|       |    struct list_head link;
  108|       |    uint8_t *data;
  109|       |    size_t data_len;
  110|       |    /* list of SharedArrayBuffers, necessary to free the message */
  111|       |    uint8_t **sab_tab;
  112|       |    size_t sab_tab_len;
  113|       |} JSWorkerMessage;
  114|       |
  115|       |typedef struct JSWaker {
  116|       |#ifdef _WIN32
  117|       |    HANDLE handle;
  118|       |#else
  119|       |    int read_fd;
  120|       |    int write_fd;
  121|       |#endif
  122|       |} JSWaker;
  123|       |
  124|       |typedef struct {
  125|       |    int ref_count;
  126|       |#ifdef USE_WORKER
  127|       |    pthread_mutex_t mutex;
  128|       |#endif
  129|       |    struct list_head msg_queue; /* list of JSWorkerMessage.link */
  130|       |    JSWaker waker;
  131|       |} JSWorkerMessagePipe;
  132|       |
  133|       |typedef struct {
  134|       |    struct list_head link;
  135|       |    JSWorkerMessagePipe *recv_pipe;
  136|       |    JSValue on_message_func;
  137|       |} JSWorkerMessageHandler;
  138|       |
  139|       |typedef struct JSThreadState {
  140|       |    struct list_head os_rw_handlers; /* list of JSOSRWHandler.link */
  141|       |    struct list_head os_signal_handlers; /* list JSOSSignalHandler.link */
  142|       |    struct list_head os_timers; /* list of JSOSTimer.link */
  143|       |    struct list_head port_list; /* list of JSWorkerMessageHandler.link */
  144|       |    int eval_script_recurse; /* only used in the main thread */
  145|       |    int next_timer_id; /* for setTimeout() */
  146|       |    /* not used in the main thread */
  147|       |    JSWorkerMessagePipe *recv_pipe, *send_pipe;
  148|       |} JSThreadState;
  149|       |
  150|       |static uint64_t os_pending_signals;
  151|       |static int (*os_poll_func)(JSContext *ctx);
  152|       |
  153|       |static void js_std_dbuf_init(JSContext *ctx, DynBuf *s)
  154|      0|{
  155|      0|    dbuf_init2(s, JS_GetRuntime(ctx), (DynBufReallocFunc *)js_realloc_rt);
  156|      0|}
  157|       |
  158|       |static BOOL my_isdigit(int c)
  159|      0|{
  160|      0|    return (c >= '0' && c <= '9');
  161|      0|}
  162|       |
  163|       |static JSValue js_printf_internal(JSContext *ctx,
  164|       |                                  int argc, JSValueConst *argv, FILE *fp)
  165|      0|{
  166|      0|    char fmtbuf[32];
  167|      0|    uint8_t cbuf[UTF8_CHAR_LEN_MAX+1];
  168|      0|    JSValue res;
  169|      0|    DynBuf dbuf;
  170|      0|    const char *fmt_str = NULL;
  171|      0|    const uint8_t *fmt, *fmt_end;
  172|      0|    const uint8_t *p;
  173|      0|    char *q;
  174|      0|    int i, c, len, mod;
  175|      0|    size_t fmt_len;
  176|      0|    int32_t int32_arg;
  177|      0|    int64_t int64_arg;
  178|      0|    double double_arg;
  179|      0|    const char *string_arg;
  180|       |    /* Use indirect call to dbuf_printf to prevent gcc warning */
  181|      0|    int (*dbuf_printf_fun)(DynBuf *s, const char *fmt, ...) = (void*)dbuf_printf;
  182|       |
  183|      0|    js_std_dbuf_init(ctx, &dbuf);
  184|       |
  185|      0|    if (argc > 0) {
  186|      0|        fmt_str = JS_ToCStringLen(ctx, &fmt_len, argv[0]);
  187|      0|        if (!fmt_str)
  188|      0|            goto fail;
  189|       |
  190|      0|        i = 1;
  191|      0|        fmt = (const uint8_t *)fmt_str;
  192|      0|        fmt_end = fmt + fmt_len;
  193|      0|        while (fmt < fmt_end) {
  194|      0|            for (p = fmt; fmt < fmt_end && *fmt != '%'; fmt++)
  195|      0|                continue;
  196|      0|            dbuf_put(&dbuf, p, fmt - p);
  197|      0|            if (fmt >= fmt_end)
  198|      0|                break;
  199|      0|            q = fmtbuf;
  200|      0|            *q++ = *fmt++;  /* copy '%' */
  201|       |
  202|       |            /* flags */
  203|      0|            for(;;) {
  204|      0|                c = *fmt;
  205|      0|                if (c == '0' || c == '#' || c == '+' || c == '-' || c == ' ' ||
  206|      0|                    c == '\'') {
  207|      0|                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)
  208|      0|                        goto invalid;
  209|      0|                    *q++ = c;
  210|      0|                    fmt++;
  211|      0|                } else {
  212|      0|                    break;
  213|      0|                }
  214|      0|            }
  215|       |            /* width */
  216|      0|            if (*fmt == '*') {
  217|      0|                if (i >= argc)
  218|      0|                    goto missing;
  219|      0|                if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
  220|      0|                    goto fail;
  221|      0|                q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, "%d", int32_arg);
  222|      0|                fmt++;
  223|      0|            } else {
  224|      0|                while (my_isdigit(*fmt)) {
  225|      0|                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)
  226|      0|                        goto invalid;
  227|      0|                    *q++ = *fmt++;
  228|      0|                }
  229|      0|            }
  230|      0|            if (*fmt == '.') {
  231|      0|                if (q >= fmtbuf + sizeof(fmtbuf) - 1)
  232|      0|                    goto invalid;
  233|      0|                *q++ = *fmt++;
  234|      0|                if (*fmt == '*') {
  235|      0|                    if (i >= argc)
  236|      0|                        goto missing;
  237|      0|                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
  238|      0|                        goto fail;
  239|      0|                    q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, "%d", int32_arg);
  240|      0|                    fmt++;
  241|      0|                } else {
  242|      0|                    while (my_isdigit(*fmt)) {
  243|      0|                        if (q >= fmtbuf + sizeof(fmtbuf) - 1)
  244|      0|                            goto invalid;
  245|      0|                        *q++ = *fmt++;
  246|      0|                    }
  247|      0|                }
  248|      0|            }
  249|       |
  250|       |            /* we only support the "l" modifier for 64 bit numbers */
  251|      0|            mod = ' ';
  252|      0|            if (*fmt == 'l') {
  253|      0|                mod = *fmt++;
  254|      0|            }
  255|       |
  256|       |            /* type */
  257|      0|            c = *fmt++;
  258|      0|            if (q >= fmtbuf + sizeof(fmtbuf) - 1)
  259|      0|                goto invalid;
  260|      0|            *q++ = c;
  261|      0|            *q = '\0';
  262|       |
  263|      0|            switch (c) {
  264|      0|            case 'c':
  265|      0|                if (i >= argc)
  266|      0|                    goto missing;
  267|      0|                if (JS_IsString(argv[i])) {
  268|      0|                    string_arg = JS_ToCString(ctx, argv[i++]);
  269|      0|                    if (!string_arg)
  270|      0|                        goto fail;
  271|      0|                    int32_arg = unicode_from_utf8((const uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);
  272|      0|                    JS_FreeCString(ctx, string_arg);
  273|      0|                } else {
  274|      0|                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
  275|      0|                        goto fail;
  276|      0|                }
  277|       |                /* handle utf-8 encoding explicitly */
  278|      0|                if ((unsigned)int32_arg > 0x10FFFF)
  279|      0|                    int32_arg = 0xFFFD;
  280|       |                /* ignore conversion flags, width and precision */
  281|      0|                len = unicode_to_utf8(cbuf, int32_arg);
  282|      0|                dbuf_put(&dbuf, cbuf, len);
  283|      0|                break;
  284|       |
  285|      0|            case 'd':
  286|      0|            case 'i':
  287|      0|            case 'o':
  288|      0|            case 'u':
  289|      0|            case 'x':
  290|      0|            case 'X':
  291|      0|                if (i >= argc)
  292|      0|                    goto missing;
  293|      0|                if (JS_ToInt64Ext(ctx, &int64_arg, argv[i++]))
  294|      0|                    goto fail;
  295|      0|                if (mod == 'l') {
  296|       |                    /* 64 bit number */
  297|       |#if defined(_WIN32)
  298|       |                    if (q >= fmtbuf + sizeof(fmtbuf) - 3)
  299|       |                        goto invalid;
  300|       |                    q[2] = q[-1];
  301|       |                    q[-1] = 'I';
  302|       |                    q[0] = '6';
  303|       |                    q[1] = '4';
  304|       |                    q[3] = '\0';
  305|       |                    dbuf_printf_fun(&dbuf, fmtbuf, (int64_t)int64_arg);
  306|       |#else
  307|      0|                    if (q >= fmtbuf + sizeof(fmtbuf) - 2)
  308|      0|                        goto invalid;
  309|      0|                    q[1] = q[-1];
  310|      0|                    q[-1] = q[0] = 'l';
  311|      0|                    q[2] = '\0';
  312|      0|                    dbuf_printf_fun(&dbuf, fmtbuf, (long long)int64_arg);
  313|      0|#endif
  314|      0|                } else {
  315|      0|                    dbuf_printf_fun(&dbuf, fmtbuf, (int)int64_arg);
  316|      0|                }
  317|      0|                break;
  318|       |
  319|      0|            case 's':
  320|      0|                if (i >= argc)
  321|      0|                    goto missing;
  322|       |                /* XXX: handle strings containing null characters */
  323|      0|                string_arg = JS_ToCString(ctx, argv[i++]);
  324|      0|                if (!string_arg)
  325|      0|                    goto fail;
  326|      0|                dbuf_printf_fun(&dbuf, fmtbuf, string_arg);
  327|      0|                JS_FreeCString(ctx, string_arg);
  328|      0|                break;
  329|       |
  330|      0|            case 'e':
  331|      0|            case 'f':
  332|      0|            case 'g':
  333|      0|            case 'a':
  334|      0|            case 'E':
  335|      0|            case 'F':
  336|      0|            case 'G':
  337|      0|            case 'A':
  338|      0|                if (i >= argc)
  339|      0|                    goto missing;
  340|      0|                if (JS_ToFloat64(ctx, &double_arg, argv[i++]))
  341|      0|                    goto fail;
  342|      0|                dbuf_printf_fun(&dbuf, fmtbuf, double_arg);
  343|      0|                break;
  344|       |
  345|      0|            case '%':
  346|      0|                dbuf_putc(&dbuf, '%');
  347|      0|                break;
  348|       |
  349|      0|            default:
  350|       |                /* XXX: should support an extension mechanism */
  351|      0|            invalid:
  352|      0|                JS_ThrowTypeError(ctx, "invalid conversion specifier in format string");
  353|      0|                goto fail;
  354|      0|            missing:
  355|      0|                JS_ThrowReferenceError(ctx, "missing argument for conversion specifier");
  356|      0|                goto fail;
  357|      0|            }
  358|      0|        }
  359|      0|        JS_FreeCString(ctx, fmt_str);
  360|      0|    }
  361|      0|    if (dbuf.error) {
  362|      0|        res = JS_ThrowOutOfMemory(ctx);
  363|      0|    } else {
  364|      0|        if (fp) {
  365|      0|            len = fwrite(dbuf.buf, 1, dbuf.size, fp);
  366|      0|            res = JS_NewInt32(ctx, len);
  367|      0|        } else {
  368|      0|            res = JS_NewStringLen(ctx, (char *)dbuf.buf, dbuf.size);
  369|      0|        }
  370|      0|    }
  371|      0|    dbuf_free(&dbuf);
  372|      0|    return res;
  373|       |
  374|      0|fail:
  375|      0|    JS_FreeCString(ctx, fmt_str);
  376|      0|    dbuf_free(&dbuf);
  377|      0|    return JS_EXCEPTION;
  378|      0|}
  379|       |
  380|       |uint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename)
  381|  17.8k|{
  382|  17.8k|    FILE *f;
  383|  17.8k|    uint8_t *buf;
  384|  17.8k|    size_t buf_len;
  385|  17.8k|    long lret;
  386|       |
  387|  17.8k|    f = fopen(filename, "rb");
  388|  17.8k|    if (!f)
  389|    116|        return NULL;
  390|  17.7k|    if (fseek(f, 0, SEEK_END) < 0)
  391|      0|        goto fail;
  392|  17.7k|    lret = ftell(f);
  393|  17.7k|    if (lret < 0)
  394|      0|        goto fail;
  395|       |    /* XXX: on Linux, ftell() return LONG_MAX for directories */
  396|  17.7k|    if (lret == LONG_MAX) {
  397|      2|        errno = EISDIR;
  398|      2|        goto fail;
  399|      2|    }
  400|  17.7k|    buf_len = lret;
  401|  17.7k|    if (fseek(f, 0, SEEK_SET) < 0)
  402|      0|        goto fail;
  403|  17.7k|    if (ctx)
  404|  17.7k|        buf = js_malloc(ctx, buf_len + 1);
  405|      0|    else
  406|      0|        buf = malloc(buf_len + 1);
  407|  17.7k|    if (!buf)
  408|      0|        goto fail;
  409|  17.7k|    if (fread(buf, 1, buf_len, f) != buf_len) {
  410|      0|        errno = EIO;
  411|      0|        if (ctx)
  412|      0|            js_free(ctx, buf);
  413|      0|        else
  414|      0|            free(buf);
  415|      2|    fail:
  416|      2|        fclose(f);
  417|      2|        return NULL;
  418|      0|    }
  419|  17.7k|    buf[buf_len] = '\0';
  420|  17.7k|    fclose(f);
  421|  17.7k|    *pbuf_len = buf_len;
  422|  17.7k|    return buf;
  423|  17.7k|}
  424|       |
  425|       |/* load and evaluate a file */
  426|       |static JSValue js_loadScript(JSContext *ctx, JSValueConst this_val,
  427|       |                             int argc, JSValueConst *argv)
  428|      0|{
  429|      0|    uint8_t *buf;
  430|      0|    const char *filename;
  431|      0|    JSValue ret;
  432|      0|    size_t buf_len;
  433|       |
  434|      0|    filename = JS_ToCString(ctx, argv[0]);
  435|      0|    if (!filename)
  436|      0|        return JS_EXCEPTION;
  437|      0|    buf = js_load_file(ctx, &buf_len, filename);
  438|      0|    if (!buf) {
  439|      0|        JS_ThrowReferenceError(ctx, "could not load '%s'", filename);
  440|      0|        JS_FreeCString(ctx, filename);
  441|      0|        return JS_EXCEPTION;
  442|      0|    }
  443|      0|    ret = JS_Eval(ctx, (char *)buf, buf_len, filename,
  444|      0|                  JS_EVAL_TYPE_GLOBAL);
  445|      0|    js_free(ctx, buf);
  446|      0|    JS_FreeCString(ctx, filename);
  447|      0|    return ret;
  448|      0|}
  449|       |
  450|       |/* load a file as a UTF-8 encoded string */
  451|       |static JSValue js_std_loadFile(JSContext *ctx, JSValueConst this_val,
  452|       |                               int argc, JSValueConst *argv)
  453|      0|{
  454|      0|    uint8_t *buf;
  455|      0|    const char *filename;
  456|      0|    JSValue ret;
  457|      0|    size_t buf_len;
  458|       |
  459|      0|    filename = JS_ToCString(ctx, argv[0]);
  460|      0|    if (!filename)
  461|      0|        return JS_EXCEPTION;
  462|      0|    buf = js_load_file(ctx, &buf_len, filename);
  463|      0|    JS_FreeCString(ctx, filename);
  464|      0|    if (!buf)
  465|      0|        return JS_NULL;
  466|      0|    ret = JS_NewStringLen(ctx, (char *)buf, buf_len);
  467|      0|    js_free(ctx, buf);
  468|      0|    return ret;
  469|      0|}
  470|       |
  471|       |typedef JSModuleDef *(JSInitModuleFunc)(JSContext *ctx,
  472|       |                                        const char *module_name);
  473|       |
  474|       |
  475|       |#if defined(_WIN32)
  476|       |static JSModuleDef *js_module_loader_so(JSContext *ctx,
  477|       |                                        const char *module_name)
  478|       |{
  479|       |    JS_ThrowReferenceError(ctx, "shared library modules are not supported yet");
  480|       |    return NULL;
  481|       |}
  482|       |#else
  483|       |static JSModuleDef *js_module_loader_so(JSContext *ctx,
  484|       |                                        const char *module_name)
  485|      0|{
  486|      0|    JSModuleDef *m;
  487|      0|    void *hd;
  488|      0|    JSInitModuleFunc *init;
  489|      0|    char *filename;
  490|       |
  491|      0|    if (!strchr(module_name, '/')) {
  492|       |        /* must add a '/' so that the DLL is not searched in the
  493|       |           system library paths */
  494|      0|        filename = js_malloc(ctx, strlen(module_name) + 2 + 1);
  495|      0|        if (!filename)
  496|      0|            return NULL;
  497|      0|        strcpy(filename, "./");
  498|      0|        strcpy(filename + 2, module_name);
  499|      0|    } else {
  500|      0|        filename = (char *)module_name;
  501|      0|    }
  502|       |
  503|       |    /* C module */
  504|      0|    hd = dlopen(filename, RTLD_NOW | RTLD_LOCAL);
  505|      0|    if (filename != module_name)
  506|      0|        js_free(ctx, filename);
  507|      0|    if (!hd) {
  508|      0|        JS_ThrowReferenceError(ctx, "could not load module filename '%s' as shared library",
  509|      0|                               module_name);
  510|      0|        goto fail;
  511|      0|    }
  512|       |
  513|      0|    init = dlsym(hd, "js_init_module");
  514|      0|    if (!init) {
  515|      0|        JS_ThrowReferenceError(ctx, "could not load module filename '%s': js_init_module not found",
  516|      0|                               module_name);
  517|      0|        goto fail;
  518|      0|    }
  519|       |
  520|      0|    m = init(ctx, module_name);
  521|      0|    if (!m) {
  522|      0|        JS_ThrowReferenceError(ctx, "could not load module filename '%s': initialization error",
  523|      0|                               module_name);
  524|      0|    fail:
  525|      0|        if (hd)
  526|      0|            dlclose(hd);
  527|      0|        return NULL;
  528|      0|    }
  529|      0|    return m;
  530|      0|}
  531|       |#endif /* !_WIN32 */
  532|       |
  533|       |int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
  534|       |                              JS_BOOL use_realpath, JS_BOOL is_main)
  535|    367|{
  536|    367|    JSModuleDef *m;
  537|    367|    char buf[PATH_MAX + 16];
  538|    367|    JSValue meta_obj;
  539|    367|    JSAtom module_name_atom;
  540|    367|    const char *module_name;
  541|       |
  542|    367|    assert(JS_VALUE_GET_TAG(func_val) == JS_TAG_MODULE);
  543|    367|    m = JS_VALUE_GET_PTR(func_val);
  544|       |
  545|    367|    module_name_atom = JS_GetModuleName(ctx, m);
  546|    367|    module_name = JS_AtomToCString(ctx, module_name_atom);
  547|    367|    JS_FreeAtom(ctx, module_name_atom);
  548|    367|    if (!module_name)
  549|      0|        return -1;
  550|    367|    if (!strchr(module_name, ':')) {
  551|      0|        strcpy(buf, "file://");
  552|      0|#if !defined(_WIN32)
  553|       |        /* realpath() cannot be used with modules compiled with qjsc
  554|       |           because the corresponding module source code is not
  555|       |           necessarily present */
  556|      0|        if (use_realpath) {
  557|      0|            char *res = realpath(module_name, buf + strlen(buf));
  558|      0|            if (!res) {
  559|      0|                JS_ThrowTypeError(ctx, "realpath failure");
  560|      0|                JS_FreeCString(ctx, module_name);
  561|      0|                return -1;
  562|      0|            }
  563|      0|        } else
  564|      0|#endif
  565|      0|        {
  566|      0|            pstrcat(buf, sizeof(buf), module_name);
  567|      0|        }
  568|    367|    } else {
  569|    367|        pstrcpy(buf, sizeof(buf), module_name);
  570|    367|    }
  571|    367|    JS_FreeCString(ctx, module_name);
  572|       |
  573|    367|    meta_obj = JS_GetImportMeta(ctx, m);
  574|    367|    if (JS_IsException(meta_obj))
  575|      0|        return -1;
  576|    367|    JS_DefinePropertyValueStr(ctx, meta_obj, "url",
  577|    367|                              JS_NewString(ctx, buf),
  578|    367|                              JS_PROP_C_W_E);
  579|    367|    JS_DefinePropertyValueStr(ctx, meta_obj, "main",
  580|    367|                              JS_NewBool(ctx, is_main),
  581|    367|                              JS_PROP_C_W_E);
  582|    367|    JS_FreeValue(ctx, meta_obj);
  583|    367|    return 0;
  584|    367|}
  585|       |
  586|       |JSModuleDef *js_module_loader(JSContext *ctx,
  587|       |                              const char *module_name, void *opaque)
  588|    118|{
  589|    118|    JSModuleDef *m;
  590|       |
  591|    118|    if (has_suffix(module_name, ".so")) {
  592|      0|        m = js_module_loader_so(ctx, module_name);
  593|    118|    } else {
  594|    118|        size_t buf_len;
  595|    118|        uint8_t *buf;
  596|    118|        JSValue func_val;
  597|       |
  598|    118|        buf = js_load_file(ctx, &buf_len, module_name);
  599|    118|        if (!buf) {
  600|    118|            JS_ThrowReferenceError(ctx, "could not load module filename '%s'",
  601|    118|                                   module_name);
  602|    118|            return NULL;
  603|    118|        }
  604|       |
  605|       |        /* compile the module */
  606|      0|        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,
  607|      0|                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
  608|      0|        js_free(ctx, buf);
  609|      0|        if (JS_IsException(func_val))
  610|      0|            return NULL;
  611|       |        /* XXX: could propagate the exception */
  612|      0|        js_module_set_import_meta(ctx, func_val, TRUE, FALSE);
  613|       |        /* the module is already referenced, so we must free it */
  614|      0|        m = JS_VALUE_GET_PTR(func_val);
  615|      0|        JS_FreeValue(ctx, func_val);
  616|      0|    }
  617|      0|    return m;
  618|    118|}
  619|       |
  620|       |static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
  621|       |                           int argc, JSValueConst *argv)
  622|      0|{
  623|      0|    int status;
  624|      0|    if (JS_ToInt32(ctx, &status, argv[0]))
  625|      0|        status = -1;
  626|      0|    exit(status);
  627|      0|    return JS_UNDEFINED;
  628|      0|}
  629|       |
  630|       |static JSValue js_std_getenv(JSContext *ctx, JSValueConst this_val,
  631|       |                           int argc, JSValueConst *argv)
  632|      0|{
  633|      0|    const char *name, *str;
  634|      0|    name = JS_ToCString(ctx, argv[0]);
  635|      0|    if (!name)
  636|      0|        return JS_EXCEPTION;
  637|      0|    str = getenv(name);
  638|      0|    JS_FreeCString(ctx, name);
  639|      0|    if (!str)
  640|      0|        return JS_UNDEFINED;
  641|      0|    else
  642|      0|        return JS_NewString(ctx, str);
  643|      0|}
  644|       |
  645|       |#if defined(_WIN32)
  646|       |static void setenv(const char *name, const char *value, int overwrite)
  647|       |{
  648|       |    char *str;
  649|       |    size_t name_len, value_len;
  650|       |    name_len = strlen(name);
  651|       |    value_len = strlen(value);
  652|       |    str = malloc(name_len + 1 + value_len + 1);
  653|       |    memcpy(str, name, name_len);
  654|       |    str[name_len] = '=';
  655|       |    memcpy(str + name_len + 1, value, value_len);
  656|       |    str[name_len + 1 + value_len] = '\0';
  657|       |    _putenv(str);
  658|       |    free(str);
  659|       |}
  660|       |
  661|       |static void unsetenv(const char *name)
  662|       |{
  663|       |    setenv(name, "", TRUE);
  664|       |}
  665|       |#endif /* _WIN32 */
  666|       |
  667|       |static JSValue js_std_setenv(JSContext *ctx, JSValueConst this_val,
  668|       |                           int argc, JSValueConst *argv)
  669|      0|{
  670|      0|    const char *name, *value;
  671|      0|    name = JS_ToCString(ctx, argv[0]);
  672|      0|    if (!name)
  673|      0|        return JS_EXCEPTION;
  674|      0|    value = JS_ToCString(ctx, argv[1]);
  675|      0|    if (!value) {
  676|      0|        JS_FreeCString(ctx, name);
  677|      0|        return JS_EXCEPTION;
  678|      0|    }
  679|      0|    setenv(name, value, TRUE);
  680|      0|    JS_FreeCString(ctx, name);
  681|      0|    JS_FreeCString(ctx, value);
  682|      0|    return JS_UNDEFINED;
  683|      0|}
  684|       |
  685|       |static JSValue js_std_unsetenv(JSContext *ctx, JSValueConst this_val,
  686|       |                               int argc, JSValueConst *argv)
  687|      0|{
  688|      0|    const char *name;
  689|      0|    name = JS_ToCString(ctx, argv[0]);
  690|      0|    if (!name)
  691|      0|        return JS_EXCEPTION;
  692|      0|    unsetenv(name);
  693|      0|    JS_FreeCString(ctx, name);
  694|      0|    return JS_UNDEFINED;
  695|      0|}
  696|       |
  697|       |/* return an object containing the list of the available environment
  698|       |   variables. */
  699|       |static JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,
  700|       |                                 int argc, JSValueConst *argv)
  701|      0|{
  702|      0|    char **envp;
  703|      0|    const char *name, *p, *value;
  704|      0|    JSValue obj;
  705|      0|    uint32_t idx;
  706|      0|    size_t name_len;
  707|      0|    JSAtom atom;
  708|      0|    int ret;
  709|       |
  710|      0|    obj = JS_NewObject(ctx);
  711|      0|    if (JS_IsException(obj))
  712|      0|        return JS_EXCEPTION;
  713|      0|    envp = environ;
  714|      0|    for(idx = 0; envp[idx] != NULL; idx++) {
  715|      0|        name = envp[idx];
  716|      0|        p = strchr(name, '=');
  717|      0|        name_len = p - name;
  718|      0|        if (!p)
  719|      0|            continue;
  720|      0|        value = p + 1;
  721|      0|        atom = JS_NewAtomLen(ctx, name, name_len);
  722|      0|        if (atom == JS_ATOM_NULL)
  723|      0|            goto fail;
  724|      0|        ret = JS_DefinePropertyValue(ctx, obj, atom, JS_NewString(ctx, value),
  725|      0|                                     JS_PROP_C_W_E);
  726|      0|        JS_FreeAtom(ctx, atom);
  727|      0|        if (ret < 0)
  728|      0|            goto fail;
  729|      0|    }
  730|      0|    return obj;
  731|      0| fail:
  732|      0|    JS_FreeValue(ctx, obj);
  733|      0|    return JS_EXCEPTION;
  734|      0|}
  735|       |
  736|       |static JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,
  737|       |                         int argc, JSValueConst *argv)
  738|      0|{
  739|      0|    JS_RunGC(JS_GetRuntime(ctx));
  740|      0|    return JS_UNDEFINED;
  741|      0|}
  742|       |
  743|       |static int interrupt_handler(JSRuntime *rt, void *opaque)
  744|      0|{
  745|      0|    return (os_pending_signals >> SIGINT) & 1;
  746|      0|}
  747|       |
  748|       |static int get_bool_option(JSContext *ctx, BOOL *pbool,
  749|       |                           JSValueConst obj,
  750|       |                           const char *option)
  751|      0|{
  752|      0|    JSValue val;
  753|      0|    val = JS_GetPropertyStr(ctx, obj, option);
  754|      0|    if (JS_IsException(val))
  755|      0|        return -1;
  756|      0|    if (!JS_IsUndefined(val)) {
  757|      0|        *pbool = JS_ToBool(ctx, val);
  758|      0|    }
  759|      0|    JS_FreeValue(ctx, val);
  760|      0|    return 0;
  761|      0|}
  762|       |
  763|       |static JSValue js_evalScript(JSContext *ctx, JSValueConst this_val,
  764|       |                             int argc, JSValueConst *argv)
  765|      0|{
  766|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
  767|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
  768|      0|    const char *str;
  769|      0|    size_t len;
  770|      0|    JSValue ret;
  771|      0|    JSValueConst options_obj;
  772|      0|    BOOL backtrace_barrier = FALSE;
  773|      0|    BOOL is_async = FALSE;
  774|      0|    int flags;
  775|       |
  776|      0|    if (argc >= 2) {
  777|      0|        options_obj = argv[1];
  778|      0|        if (get_bool_option(ctx, &backtrace_barrier, options_obj,
  779|      0|                            "backtrace_barrier"))
  780|      0|            return JS_EXCEPTION;
  781|      0|        if (get_bool_option(ctx, &is_async, options_obj,
  782|      0|                            "async"))
  783|      0|            return JS_EXCEPTION;
  784|      0|    }
  785|       |
  786|      0|    str = JS_ToCStringLen(ctx, &len, argv[0]);
  787|      0|    if (!str)
  788|      0|        return JS_EXCEPTION;
  789|      0|    if (!ts->recv_pipe && ++ts->eval_script_recurse == 1) {
  790|       |        /* install the interrupt handler */
  791|      0|        JS_SetInterruptHandler(JS_GetRuntime(ctx), interrupt_handler, NULL);
  792|      0|    }
  793|      0|    flags = JS_EVAL_TYPE_GLOBAL;
  794|      0|    if (backtrace_barrier)
  795|      0|        flags |= JS_EVAL_FLAG_BACKTRACE_BARRIER;
  796|      0|    if (is_async)
  797|      0|        flags |= JS_EVAL_FLAG_ASYNC;
  798|      0|    ret = JS_Eval(ctx, str, len, "<evalScript>", flags);
  799|      0|    JS_FreeCString(ctx, str);
  800|      0|    if (!ts->recv_pipe && --ts->eval_script_recurse == 0) {
  801|       |        /* remove the interrupt handler */
  802|      0|        JS_SetInterruptHandler(JS_GetRuntime(ctx), NULL, NULL);
  803|      0|        os_pending_signals &= ~((uint64_t)1 << SIGINT);
  804|       |        /* convert the uncatchable "interrupted" error into a normal error
  805|       |           so that it can be caught by the REPL */
  806|      0|        if (JS_IsException(ret))
  807|      0|            JS_ResetUncatchableError(ctx);
  808|      0|    }
  809|      0|    return ret;
  810|      0|}
  811|       |
  812|       |static JSClassID js_std_file_class_id;
  813|       |
  814|       |typedef struct {
  815|       |    FILE *f;
  816|       |    BOOL close_in_finalizer;
  817|       |    BOOL is_popen;
  818|       |} JSSTDFile;
  819|       |
  820|       |static void js_std_file_finalizer(JSRuntime *rt, JSValue val)
  821|      0|{
  822|      0|    JSSTDFile *s = JS_GetOpaque(val, js_std_file_class_id);
  823|      0|    if (s) {
  824|      0|        if (s->f && s->close_in_finalizer) {
  825|      0|            if (s->is_popen)
  826|      0|                pclose(s->f);
  827|      0|            else
  828|      0|                fclose(s->f);
  829|      0|        }
  830|      0|        js_free_rt(rt, s);
  831|      0|    }
  832|      0|}
  833|       |
  834|       |static ssize_t js_get_errno(ssize_t ret)
  835|      0|{
  836|      0|    if (ret == -1)
  837|      0|        ret = -errno;
  838|      0|    return ret;
  839|      0|}
  840|       |
  841|       |static JSValue js_std_strerror(JSContext *ctx, JSValueConst this_val,
  842|       |                                     int argc, JSValueConst *argv)
  843|      0|{
  844|      0|    int err;
  845|      0|    if (JS_ToInt32(ctx, &err, argv[0]))
  846|      0|        return JS_EXCEPTION;
  847|      0|    return JS_NewString(ctx, strerror(err));
  848|      0|}
  849|       |
  850|       |static JSValue js_std_parseExtJSON(JSContext *ctx, JSValueConst this_val,
  851|       |                                   int argc, JSValueConst *argv)
  852|      0|{
  853|      0|    JSValue obj;
  854|      0|    const char *str;
  855|      0|    size_t len;
  856|       |
  857|      0|    str = JS_ToCStringLen(ctx, &len, argv[0]);
  858|      0|    if (!str)
  859|      0|        return JS_EXCEPTION;
  860|      0|    obj = JS_ParseJSON2(ctx, str, len, "<input>", JS_PARSE_JSON_EXT);
  861|      0|    JS_FreeCString(ctx, str);
  862|      0|    return obj;
  863|      0|}
  864|       |
  865|       |static JSValue js_new_std_file(JSContext *ctx, FILE *f,
  866|       |                               BOOL close_in_finalizer,
  867|       |                               BOOL is_popen)
  868|      0|{
  869|      0|    JSSTDFile *s;
  870|      0|    JSValue obj;
  871|      0|    obj = JS_NewObjectClass(ctx, js_std_file_class_id);
  872|      0|    if (JS_IsException(obj))
  873|      0|        return obj;
  874|      0|    s = js_mallocz(ctx, sizeof(*s));
  875|      0|    if (!s) {
  876|      0|        JS_FreeValue(ctx, obj);
  877|      0|        return JS_EXCEPTION;
  878|      0|    }
  879|      0|    s->close_in_finalizer = close_in_finalizer;
  880|      0|    s->is_popen = is_popen;
  881|      0|    s->f = f;
  882|      0|    JS_SetOpaque(obj, s);
  883|      0|    return obj;
  884|      0|}
  885|       |
  886|       |static void js_set_error_object(JSContext *ctx, JSValue obj, int err)
  887|      0|{
  888|      0|    if (!JS_IsUndefined(obj)) {
  889|      0|        JS_SetPropertyStr(ctx, obj, "errno", JS_NewInt32(ctx, err));
  890|      0|    }
  891|      0|}
  892|       |
  893|       |static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
  894|       |                           int argc, JSValueConst *argv)
  895|      0|{
  896|      0|    const char *filename, *mode = NULL;
  897|      0|    FILE *f;
  898|      0|    int err;
  899|       |
  900|      0|    filename = JS_ToCString(ctx, argv[0]);
  901|      0|    if (!filename)
  902|      0|        goto fail;
  903|      0|    mode = JS_ToCString(ctx, argv[1]);
  904|      0|    if (!mode)
  905|      0|        goto fail;
  906|      0|    if (mode[strspn(mode, "rwa+b")] != '\0') {
  907|      0|        JS_ThrowTypeError(ctx, "invalid file mode");
  908|      0|        goto fail;
  909|      0|    }
  910|       |
  911|      0|    f = fopen(filename, mode);
  912|      0|    if (!f)
  913|      0|        err = errno;
  914|      0|    else
  915|      0|        err = 0;
  916|      0|    if (argc >= 3)
  917|      0|        js_set_error_object(ctx, argv[2], err);
  918|      0|    JS_FreeCString(ctx, filename);
  919|      0|    JS_FreeCString(ctx, mode);
  920|      0|    if (!f)
  921|      0|        return JS_NULL;
  922|      0|    return js_new_std_file(ctx, f, TRUE, FALSE);
  923|      0| fail:
  924|      0|    JS_FreeCString(ctx, filename);
  925|      0|    JS_FreeCString(ctx, mode);
  926|      0|    return JS_EXCEPTION;
  927|      0|}
  928|       |
  929|       |static JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,
  930|       |                            int argc, JSValueConst *argv)
  931|      0|{
  932|      0|    const char *filename, *mode = NULL;
  933|      0|    FILE *f;
  934|      0|    int err;
  935|       |
  936|      0|    filename = JS_ToCString(ctx, argv[0]);
  937|      0|    if (!filename)
  938|      0|        goto fail;
  939|      0|    mode = JS_ToCString(ctx, argv[1]);
  940|      0|    if (!mode)
  941|      0|        goto fail;
  942|      0|    if (mode[strspn(mode, "rw")] != '\0') {
  943|      0|        JS_ThrowTypeError(ctx, "invalid file mode");
  944|      0|        goto fail;
  945|      0|    }
  946|       |
  947|      0|    f = popen(filename, mode);
  948|      0|    if (!f)
  949|      0|        err = errno;
  950|      0|    else
  951|      0|        err = 0;
  952|      0|    if (argc >= 3)
  953|      0|        js_set_error_object(ctx, argv[2], err);
  954|      0|    JS_FreeCString(ctx, filename);
  955|      0|    JS_FreeCString(ctx, mode);
  956|      0|    if (!f)
  957|      0|        return JS_NULL;
  958|      0|    return js_new_std_file(ctx, f, TRUE, TRUE);
  959|      0| fail:
  960|      0|    JS_FreeCString(ctx, filename);
  961|      0|    JS_FreeCString(ctx, mode);
  962|      0|    return JS_EXCEPTION;
  963|      0|}
  964|       |
  965|       |static JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,
  966|       |                             int argc, JSValueConst *argv)
  967|      0|{
  968|      0|    const char *mode;
  969|      0|    FILE *f;
  970|      0|    int fd, err;
  971|       |
  972|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
  973|      0|        return JS_EXCEPTION;
  974|      0|    mode = JS_ToCString(ctx, argv[1]);
  975|      0|    if (!mode)
  976|      0|        goto fail;
  977|      0|    if (mode[strspn(mode, "rwa+")] != '\0') {
  978|      0|        JS_ThrowTypeError(ctx, "invalid file mode");
  979|      0|        goto fail;
  980|      0|    }
  981|       |
  982|      0|    f = fdopen(fd, mode);
  983|      0|    if (!f)
  984|      0|        err = errno;
  985|      0|    else
  986|      0|        err = 0;
  987|      0|    if (argc >= 3)
  988|      0|        js_set_error_object(ctx, argv[2], err);
  989|      0|    JS_FreeCString(ctx, mode);
  990|      0|    if (!f)
  991|      0|        return JS_NULL;
  992|      0|    return js_new_std_file(ctx, f, TRUE, FALSE);
  993|      0| fail:
  994|      0|    JS_FreeCString(ctx, mode);
  995|      0|    return JS_EXCEPTION;
  996|      0|}
  997|       |
  998|       |static JSValue js_std_tmpfile(JSContext *ctx, JSValueConst this_val,
  999|       |                              int argc, JSValueConst *argv)
 1000|      0|{
 1001|      0|    FILE *f;
 1002|      0|    f = tmpfile();
 1003|      0|    if (argc >= 1)
 1004|      0|        js_set_error_object(ctx, argv[0], f ? 0 : errno);
 1005|      0|    if (!f)
 1006|      0|        return JS_NULL;
 1007|      0|    return js_new_std_file(ctx, f, TRUE, FALSE);
 1008|      0|}
 1009|       |
 1010|       |static JSValue js_std_sprintf(JSContext *ctx, JSValueConst this_val,
 1011|       |                          int argc, JSValueConst *argv)
 1012|      0|{
 1013|      0|    return js_printf_internal(ctx, argc, argv, NULL);
 1014|      0|}
 1015|       |
 1016|       |static JSValue js_std_printf(JSContext *ctx, JSValueConst this_val,
 1017|       |                             int argc, JSValueConst *argv)
 1018|      0|{
 1019|      0|    return js_printf_internal(ctx, argc, argv, stdout);
 1020|      0|}
 1021|       |
 1022|       |static FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)
 1023|      0|{
 1024|      0|    JSSTDFile *s = JS_GetOpaque2(ctx, obj, js_std_file_class_id);
 1025|      0|    if (!s)
 1026|      0|        return NULL;
 1027|      0|    if (!s->f) {
 1028|      0|        JS_ThrowTypeError(ctx, "invalid file handle");
 1029|      0|        return NULL;
 1030|      0|    }
 1031|      0|    return s->f;
 1032|      0|}
 1033|       |
 1034|       |static JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,
 1035|       |                                int argc, JSValueConst *argv, int magic)
 1036|      0|{
 1037|      0|    FILE *f;
 1038|      0|    int i;
 1039|      0|    const char *str;
 1040|      0|    size_t len;
 1041|       |
 1042|      0|    if (magic == 0) {
 1043|      0|        f = stdout;
 1044|      0|    } else {
 1045|      0|        f = js_std_file_get(ctx, this_val);
 1046|      0|        if (!f)
 1047|      0|            return JS_EXCEPTION;
 1048|      0|    }
 1049|       |
 1050|      0|    for(i = 0; i < argc; i++) {
 1051|      0|        str = JS_ToCStringLen(ctx, &len, argv[i]);
 1052|      0|        if (!str)
 1053|      0|            return JS_EXCEPTION;
 1054|      0|        fwrite(str, 1, len, f);
 1055|      0|        JS_FreeCString(ctx, str);
 1056|      0|    }
 1057|      0|    return JS_UNDEFINED;
 1058|      0|}
 1059|       |
 1060|       |static JSValue js_std_file_close(JSContext *ctx, JSValueConst this_val,
 1061|       |                                 int argc, JSValueConst *argv)
 1062|      0|{
 1063|      0|    JSSTDFile *s = JS_GetOpaque2(ctx, this_val, js_std_file_class_id);
 1064|      0|    int err;
 1065|      0|    if (!s)
 1066|      0|        return JS_EXCEPTION;
 1067|      0|    if (!s->f)
 1068|      0|        return JS_ThrowTypeError(ctx, "invalid file handle");
 1069|      0|    if (s->is_popen)
 1070|      0|        err = js_get_errno(pclose(s->f));
 1071|      0|    else
 1072|      0|        err = js_get_errno(fclose(s->f));
 1073|      0|    s->f = NULL;
 1074|      0|    return JS_NewInt32(ctx, err);
 1075|      0|}
 1076|       |
 1077|       |static JSValue js_std_file_printf(JSContext *ctx, JSValueConst this_val,
 1078|       |                                  int argc, JSValueConst *argv)
 1079|      0|{
 1080|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1081|      0|    if (!f)
 1082|      0|        return JS_EXCEPTION;
 1083|      0|    return js_printf_internal(ctx, argc, argv, f);
 1084|      0|}
 1085|       |
 1086|       |static JSValue js_std_file_flush(JSContext *ctx, JSValueConst this_val,
 1087|       |                                 int argc, JSValueConst *argv)
 1088|      0|{
 1089|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1090|      0|    if (!f)
 1091|      0|        return JS_EXCEPTION;
 1092|      0|    fflush(f);
 1093|      0|    return JS_UNDEFINED;
 1094|      0|}
 1095|       |
 1096|       |static JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,
 1097|       |                                int argc, JSValueConst *argv, int is_bigint)
 1098|      0|{
 1099|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1100|      0|    int64_t pos;
 1101|      0|    if (!f)
 1102|      0|        return JS_EXCEPTION;
 1103|      0|#if defined(__linux__) || defined(__GLIBC__)
 1104|      0|    pos = ftello(f);
 1105|       |#else
 1106|       |    pos = ftell(f);
 1107|       |#endif
 1108|      0|    if (is_bigint)
 1109|      0|        return JS_NewBigInt64(ctx, pos);
 1110|      0|    else
 1111|      0|        return JS_NewInt64(ctx, pos);
 1112|      0|}
 1113|       |
 1114|       |static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
 1115|       |                                int argc, JSValueConst *argv)
 1116|      0|{
 1117|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1118|      0|    int64_t pos;
 1119|      0|    int whence, ret;
 1120|      0|    if (!f)
 1121|      0|        return JS_EXCEPTION;
 1122|      0|    if (JS_ToInt64Ext(ctx, &pos, argv[0]))
 1123|      0|        return JS_EXCEPTION;
 1124|      0|    if (JS_ToInt32(ctx, &whence, argv[1]))
 1125|      0|        return JS_EXCEPTION;
 1126|      0|#if defined(__linux__) || defined(__GLIBC__)
 1127|      0|    ret = fseeko(f, pos, whence);
 1128|       |#else
 1129|       |    ret = fseek(f, pos, whence);
 1130|       |#endif
 1131|      0|    if (ret < 0)
 1132|      0|        ret = -errno;
 1133|      0|    return JS_NewInt32(ctx, ret);
 1134|      0|}
 1135|       |
 1136|       |static JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,
 1137|       |                               int argc, JSValueConst *argv)
 1138|      0|{
 1139|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1140|      0|    if (!f)
 1141|      0|        return JS_EXCEPTION;
 1142|      0|    return JS_NewBool(ctx, feof(f));
 1143|      0|}
 1144|       |
 1145|       |static JSValue js_std_file_error(JSContext *ctx, JSValueConst this_val,
 1146|       |                               int argc, JSValueConst *argv)
 1147|      0|{
 1148|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1149|      0|    if (!f)
 1150|      0|        return JS_EXCEPTION;
 1151|      0|    return JS_NewBool(ctx, ferror(f));
 1152|      0|}
 1153|       |
 1154|       |static JSValue js_std_file_clearerr(JSContext *ctx, JSValueConst this_val,
 1155|       |                                    int argc, JSValueConst *argv)
 1156|      0|{
 1157|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1158|      0|    if (!f)
 1159|      0|        return JS_EXCEPTION;
 1160|      0|    clearerr(f);
 1161|      0|    return JS_UNDEFINED;
 1162|      0|}
 1163|       |
 1164|       |static JSValue js_std_file_fileno(JSContext *ctx, JSValueConst this_val,
 1165|       |                                  int argc, JSValueConst *argv)
 1166|      0|{
 1167|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1168|      0|    if (!f)
 1169|      0|        return JS_EXCEPTION;
 1170|      0|    return JS_NewInt32(ctx, fileno(f));
 1171|      0|}
 1172|       |
 1173|       |static JSValue js_std_file_read_write(JSContext *ctx, JSValueConst this_val,
 1174|       |                                      int argc, JSValueConst *argv, int magic)
 1175|      0|{
 1176|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1177|      0|    uint64_t pos, len;
 1178|      0|    size_t size, ret;
 1179|      0|    uint8_t *buf;
 1180|       |
 1181|      0|    if (!f)
 1182|      0|        return JS_EXCEPTION;
 1183|      0|    if (JS_ToIndex(ctx, &pos, argv[1]))
 1184|      0|        return JS_EXCEPTION;
 1185|      0|    if (JS_ToIndex(ctx, &len, argv[2]))
 1186|      0|        return JS_EXCEPTION;
 1187|      0|    buf = JS_GetArrayBuffer(ctx, &size, argv[0]);
 1188|      0|    if (!buf)
 1189|      0|        return JS_EXCEPTION;
 1190|      0|    if (pos + len > size)
 1191|      0|        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
 1192|      0|    if (magic)
 1193|      0|        ret = fwrite(buf + pos, 1, len, f);
 1194|      0|    else
 1195|      0|        ret = fread(buf + pos, 1, len, f);
 1196|      0|    return JS_NewInt64(ctx, ret);
 1197|      0|}
 1198|       |
 1199|       |/* XXX: could use less memory and go faster */
 1200|       |static JSValue js_std_file_getline(JSContext *ctx, JSValueConst this_val,
 1201|       |                                   int argc, JSValueConst *argv)
 1202|      0|{
 1203|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1204|      0|    int c;
 1205|      0|    DynBuf dbuf;
 1206|      0|    JSValue obj;
 1207|       |
 1208|      0|    if (!f)
 1209|      0|        return JS_EXCEPTION;
 1210|       |
 1211|      0|    js_std_dbuf_init(ctx, &dbuf);
 1212|      0|    for(;;) {
 1213|      0|        c = fgetc(f);
 1214|      0|        if (c == EOF) {
 1215|      0|            if (dbuf.size == 0) {
 1216|       |                /* EOF */
 1217|      0|                dbuf_free(&dbuf);
 1218|      0|                return JS_NULL;
 1219|      0|            } else {
 1220|      0|                break;
 1221|      0|            }
 1222|      0|        }
 1223|      0|        if (c == '\n')
 1224|      0|            break;
 1225|      0|        if (dbuf_putc(&dbuf, c)) {
 1226|      0|            dbuf_free(&dbuf);
 1227|      0|            return JS_ThrowOutOfMemory(ctx);
 1228|      0|        }
 1229|      0|    }
 1230|      0|    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
 1231|      0|    dbuf_free(&dbuf);
 1232|      0|    return obj;
 1233|      0|}
 1234|       |
 1235|       |/* XXX: could use less memory and go faster */
 1236|       |static JSValue js_std_file_readAsString(JSContext *ctx, JSValueConst this_val,
 1237|       |                                        int argc, JSValueConst *argv)
 1238|      0|{
 1239|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1240|      0|    int c;
 1241|      0|    DynBuf dbuf;
 1242|      0|    JSValue obj;
 1243|      0|    uint64_t max_size64;
 1244|      0|    size_t max_size;
 1245|      0|    JSValueConst max_size_val;
 1246|       |
 1247|      0|    if (!f)
 1248|      0|        return JS_EXCEPTION;
 1249|       |
 1250|      0|    if (argc >= 1)
 1251|      0|        max_size_val = argv[0];
 1252|      0|    else
 1253|      0|        max_size_val = JS_UNDEFINED;
 1254|      0|    max_size = (size_t)-1;
 1255|      0|    if (!JS_IsUndefined(max_size_val)) {
 1256|      0|        if (JS_ToIndex(ctx, &max_size64, max_size_val))
 1257|      0|            return JS_EXCEPTION;
 1258|      0|        if (max_size64 < max_size)
 1259|      0|            max_size = max_size64;
 1260|      0|    }
 1261|       |
 1262|      0|    js_std_dbuf_init(ctx, &dbuf);
 1263|      0|    while (max_size != 0) {
 1264|      0|        c = fgetc(f);
 1265|      0|        if (c == EOF)
 1266|      0|            break;
 1267|      0|        if (dbuf_putc(&dbuf, c)) {
 1268|      0|            dbuf_free(&dbuf);
 1269|      0|            return JS_EXCEPTION;
 1270|      0|        }
 1271|      0|        max_size--;
 1272|      0|    }
 1273|      0|    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
 1274|      0|    dbuf_free(&dbuf);
 1275|      0|    return obj;
 1276|      0|}
 1277|       |
 1278|       |static JSValue js_std_file_getByte(JSContext *ctx, JSValueConst this_val,
 1279|       |                                   int argc, JSValueConst *argv)
 1280|      0|{
 1281|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1282|      0|    if (!f)
 1283|      0|        return JS_EXCEPTION;
 1284|      0|    return JS_NewInt32(ctx, fgetc(f));
 1285|      0|}
 1286|       |
 1287|       |static JSValue js_std_file_putByte(JSContext *ctx, JSValueConst this_val,
 1288|       |                                   int argc, JSValueConst *argv)
 1289|      0|{
 1290|      0|    FILE *f = js_std_file_get(ctx, this_val);
 1291|      0|    int c;
 1292|      0|    if (!f)
 1293|      0|        return JS_EXCEPTION;
 1294|      0|    if (JS_ToInt32(ctx, &c, argv[0]))
 1295|      0|        return JS_EXCEPTION;
 1296|      0|    c = fputc(c, f);
 1297|      0|    return JS_NewInt32(ctx, c);
 1298|      0|}
 1299|       |
 1300|       |/* urlGet */
 1301|       |
 1302|      0|#define URL_GET_PROGRAM "curl -s -i --"
 1303|      0|#define URL_GET_BUF_SIZE 4096
 1304|       |
 1305|       |static int http_get_header_line(FILE *f, char *buf, size_t buf_size,
 1306|       |                                DynBuf *dbuf)
 1307|      0|{
 1308|      0|    int c;
 1309|      0|    char *p;
 1310|       |
 1311|      0|    p = buf;
 1312|      0|    for(;;) {
 1313|      0|        c = fgetc(f);
 1314|      0|        if (c < 0)
 1315|      0|            return -1;
 1316|      0|        if ((p - buf) < buf_size - 1)
 1317|      0|            *p++ = c;
 1318|      0|        if (dbuf)
 1319|      0|            dbuf_putc(dbuf, c);
 1320|      0|        if (c == '\n')
 1321|      0|            break;
 1322|      0|    }
 1323|      0|    *p = '\0';
 1324|      0|    return 0;
 1325|      0|}
 1326|       |
 1327|       |static int http_get_status(const char *buf)
 1328|      0|{
 1329|      0|    const char *p = buf;
 1330|      0|    while (*p != ' ' && *p != '\0')
 1331|      0|        p++;
 1332|      0|    if (*p != ' ')
 1333|      0|        return 0;
 1334|      0|    while (*p == ' ')
 1335|      0|        p++;
 1336|      0|    return atoi(p);
 1337|      0|}
 1338|       |
 1339|       |static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
 1340|       |                             int argc, JSValueConst *argv)
 1341|      0|{
 1342|      0|    const char *url;
 1343|      0|    DynBuf cmd_buf;
 1344|      0|    DynBuf data_buf_s, *data_buf = &data_buf_s;
 1345|      0|    DynBuf header_buf_s, *header_buf = &header_buf_s;
 1346|      0|    char *buf;
 1347|      0|    size_t i, len;
 1348|      0|    int status;
 1349|      0|    JSValue response = JS_UNDEFINED, ret_obj;
 1350|      0|    JSValueConst options_obj;
 1351|      0|    FILE *f;
 1352|      0|    BOOL binary_flag, full_flag;
 1353|       |
 1354|      0|    url = JS_ToCString(ctx, argv[0]);
 1355|      0|    if (!url)
 1356|      0|        return JS_EXCEPTION;
 1357|       |
 1358|      0|    binary_flag = FALSE;
 1359|      0|    full_flag = FALSE;
 1360|       |
 1361|      0|    if (argc >= 2) {
 1362|      0|        options_obj = argv[1];
 1363|       |
 1364|      0|        if (get_bool_option(ctx, &binary_flag, options_obj, "binary"))
 1365|      0|            goto fail_obj;
 1366|       |
 1367|      0|        if (get_bool_option(ctx, &full_flag, options_obj, "full")) {
 1368|      0|        fail_obj:
 1369|      0|            JS_FreeCString(ctx, url);
 1370|      0|            return JS_EXCEPTION;
 1371|      0|        }
 1372|      0|    }
 1373|       |
 1374|      0|    js_std_dbuf_init(ctx, &cmd_buf);
 1375|      0|    dbuf_printf(&cmd_buf, "%s '", URL_GET_PROGRAM);
 1376|      0|    for(i = 0; url[i] != '\0'; i++) {
 1377|      0|        unsigned char c = url[i];
 1378|      0|        switch (c) {
 1379|      0|        case '\'':
 1380|       |            /* shell single quoted string does not support \' */
 1381|      0|            dbuf_putstr(&cmd_buf, "'\\''");
 1382|      0|            break;
 1383|      0|        case '[': case ']': case '{': case '}': case '\\':
 1384|       |            /* prevent interpretation by curl as range or set specification */
 1385|      0|            dbuf_putc(&cmd_buf, '\\');
 1386|       |            /* FALLTHROUGH */
 1387|      0|        default:
 1388|      0|            dbuf_putc(&cmd_buf, c);
 1389|      0|            break;
 1390|      0|        }
 1391|      0|    }
 1392|      0|    JS_FreeCString(ctx, url);
 1393|      0|    dbuf_putstr(&cmd_buf, "'");
 1394|      0|    dbuf_putc(&cmd_buf, '\0');
 1395|      0|    if (dbuf_error(&cmd_buf)) {
 1396|      0|        dbuf_free(&cmd_buf);
 1397|      0|        return JS_EXCEPTION;
 1398|      0|    }
 1399|       |    //    printf("%s\n", (char *)cmd_buf.buf);
 1400|      0|    f = popen((char *)cmd_buf.buf, "r");
 1401|      0|    dbuf_free(&cmd_buf);
 1402|      0|    if (!f) {
 1403|      0|        return JS_ThrowTypeError(ctx, "could not start curl");
 1404|      0|    }
 1405|       |
 1406|      0|    js_std_dbuf_init(ctx, data_buf);
 1407|      0|    js_std_dbuf_init(ctx, header_buf);
 1408|       |
 1409|      0|    buf = js_malloc(ctx, URL_GET_BUF_SIZE);
 1410|      0|    if (!buf)
 1411|      0|        goto fail;
 1412|       |
 1413|       |    /* get the HTTP status */
 1414|      0|    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0) {
 1415|      0|        status = 0;
 1416|      0|        goto bad_header;
 1417|      0|    }
 1418|      0|    status = http_get_status(buf);
 1419|      0|    if (!full_flag && !(status >= 200 && status <= 299)) {
 1420|      0|        goto bad_header;
 1421|      0|    }
 1422|       |
 1423|       |    /* wait until there is an empty line */
 1424|      0|    for(;;) {
 1425|      0|        if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, header_buf) < 0) {
 1426|      0|        bad_header:
 1427|      0|            response = JS_NULL;
 1428|      0|            goto done;
 1429|      0|        }
 1430|      0|        if (!strcmp(buf, "\r\n"))
 1431|      0|            break;
 1432|      0|    }
 1433|      0|    if (dbuf_error(header_buf))
 1434|      0|        goto fail;
 1435|      0|    header_buf->size -= 2; /* remove the trailing CRLF */
 1436|       |
 1437|       |    /* download the data */
 1438|      0|    for(;;) {
 1439|      0|        len = fread(buf, 1, URL_GET_BUF_SIZE, f);
 1440|      0|        if (len == 0)
 1441|      0|            break;
 1442|      0|        dbuf_put(data_buf, (uint8_t *)buf, len);
 1443|      0|    }
 1444|      0|    if (dbuf_error(data_buf))
 1445|      0|        goto fail;
 1446|      0|    if (binary_flag) {
 1447|      0|        response = JS_NewArrayBufferCopy(ctx,
 1448|      0|                                         data_buf->buf, data_buf->size);
 1449|      0|    } else {
 1450|      0|        response = JS_NewStringLen(ctx, (char *)data_buf->buf, data_buf->size);
 1451|      0|    }
 1452|      0|    if (JS_IsException(response))
 1453|      0|        goto fail;
 1454|      0| done:
 1455|      0|    js_free(ctx, buf);
 1456|      0|    buf = NULL;
 1457|      0|    pclose(f);
 1458|      0|    f = NULL;
 1459|      0|    dbuf_free(data_buf);
 1460|      0|    data_buf = NULL;
 1461|       |
 1462|      0|    if (full_flag) {
 1463|      0|        ret_obj = JS_NewObject(ctx);
 1464|      0|        if (JS_IsException(ret_obj))
 1465|      0|            goto fail;
 1466|      0|        JS_DefinePropertyValueStr(ctx, ret_obj, "response",
 1467|      0|                                  response,
 1468|      0|                                  JS_PROP_C_W_E);
 1469|      0|        if (!JS_IsNull(response)) {
 1470|      0|            JS_DefinePropertyValueStr(ctx, ret_obj, "responseHeaders",
 1471|      0|                                      JS_NewStringLen(ctx, (char *)header_buf->buf,
 1472|      0|                                                      header_buf->size),
 1473|      0|                                      JS_PROP_C_W_E);
 1474|      0|            JS_DefinePropertyValueStr(ctx, ret_obj, "status",
 1475|      0|                                      JS_NewInt32(ctx, status),
 1476|      0|                                      JS_PROP_C_W_E);
 1477|      0|        }
 1478|      0|    } else {
 1479|      0|        ret_obj = response;
 1480|      0|    }
 1481|      0|    dbuf_free(header_buf);
 1482|      0|    return ret_obj;
 1483|      0| fail:
 1484|      0|    if (f)
 1485|      0|        pclose(f);
 1486|      0|    js_free(ctx, buf);
 1487|      0|    if (data_buf)
 1488|      0|        dbuf_free(data_buf);
 1489|      0|    if (header_buf)
 1490|      0|        dbuf_free(header_buf);
 1491|      0|    JS_FreeValue(ctx, response);
 1492|      0|    return JS_EXCEPTION;
 1493|      0|}
 1494|       |
 1495|       |static JSClassDef js_std_file_class = {
 1496|       |    "FILE",
 1497|       |    .finalizer = js_std_file_finalizer,
 1498|       |};
 1499|       |
 1500|       |static const JSCFunctionListEntry js_std_error_props[] = {
 1501|       |    /* various errno values */
 1502|       |#define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
 1503|       |    DEF(EINVAL),
 1504|       |    DEF(EIO),
 1505|       |    DEF(EACCES),
 1506|       |    DEF(EEXIST),
 1507|       |    DEF(ENOSPC),
 1508|       |    DEF(ENOSYS),
 1509|       |    DEF(EBUSY),
 1510|       |    DEF(ENOENT),
 1511|       |    DEF(EPERM),
 1512|       |    DEF(EPIPE),
 1513|       |    DEF(EBADF),
 1514|       |#undef DEF
 1515|       |};
 1516|       |
 1517|       |static const JSCFunctionListEntry js_std_funcs[] = {
 1518|       |    JS_CFUNC_DEF("exit", 1, js_std_exit ),
 1519|       |    JS_CFUNC_DEF("gc", 0, js_std_gc ),
 1520|       |    JS_CFUNC_DEF("evalScript", 1, js_evalScript ),
 1521|       |    JS_CFUNC_DEF("loadScript", 1, js_loadScript ),
 1522|       |    JS_CFUNC_DEF("getenv", 1, js_std_getenv ),
 1523|       |    JS_CFUNC_DEF("setenv", 1, js_std_setenv ),
 1524|       |    JS_CFUNC_DEF("unsetenv", 1, js_std_unsetenv ),
 1525|       |    JS_CFUNC_DEF("getenviron", 1, js_std_getenviron ),
 1526|       |    JS_CFUNC_DEF("urlGet", 1, js_std_urlGet ),
 1527|       |    JS_CFUNC_DEF("loadFile", 1, js_std_loadFile ),
 1528|       |    JS_CFUNC_DEF("strerror", 1, js_std_strerror ),
 1529|       |    JS_CFUNC_DEF("parseExtJSON", 1, js_std_parseExtJSON ),
 1530|       |
 1531|       |    /* FILE I/O */
 1532|       |    JS_CFUNC_DEF("open", 2, js_std_open ),
 1533|       |    JS_CFUNC_DEF("popen", 2, js_std_popen ),
 1534|       |    JS_CFUNC_DEF("fdopen", 2, js_std_fdopen ),
 1535|       |    JS_CFUNC_DEF("tmpfile", 0, js_std_tmpfile ),
 1536|       |    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 0 ),
 1537|       |    JS_CFUNC_DEF("printf", 1, js_std_printf ),
 1538|       |    JS_CFUNC_DEF("sprintf", 1, js_std_sprintf ),
 1539|       |    JS_PROP_INT32_DEF("SEEK_SET", SEEK_SET, JS_PROP_CONFIGURABLE ),
 1540|       |    JS_PROP_INT32_DEF("SEEK_CUR", SEEK_CUR, JS_PROP_CONFIGURABLE ),
 1541|       |    JS_PROP_INT32_DEF("SEEK_END", SEEK_END, JS_PROP_CONFIGURABLE ),
 1542|       |    JS_OBJECT_DEF("Error", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),
 1543|       |};
 1544|       |
 1545|       |static const JSCFunctionListEntry js_std_file_proto_funcs[] = {
 1546|       |    JS_CFUNC_DEF("close", 0, js_std_file_close ),
 1547|       |    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 1 ),
 1548|       |    JS_CFUNC_DEF("printf", 1, js_std_file_printf ),
 1549|       |    JS_CFUNC_DEF("flush", 0, js_std_file_flush ),
 1550|       |    JS_CFUNC_MAGIC_DEF("tell", 0, js_std_file_tell, 0 ),
 1551|       |    JS_CFUNC_MAGIC_DEF("tello", 0, js_std_file_tell, 1 ),
 1552|       |    JS_CFUNC_DEF("seek", 2, js_std_file_seek ),
 1553|       |    JS_CFUNC_DEF("eof", 0, js_std_file_eof ),
 1554|       |    JS_CFUNC_DEF("fileno", 0, js_std_file_fileno ),
 1555|       |    JS_CFUNC_DEF("error", 0, js_std_file_error ),
 1556|       |    JS_CFUNC_DEF("clearerr", 0, js_std_file_clearerr ),
 1557|       |    JS_CFUNC_MAGIC_DEF("read", 3, js_std_file_read_write, 0 ),
 1558|       |    JS_CFUNC_MAGIC_DEF("write", 3, js_std_file_read_write, 1 ),
 1559|       |    JS_CFUNC_DEF("getline", 0, js_std_file_getline ),
 1560|       |    JS_CFUNC_DEF("readAsString", 0, js_std_file_readAsString ),
 1561|       |    JS_CFUNC_DEF("getByte", 0, js_std_file_getByte ),
 1562|       |    JS_CFUNC_DEF("putByte", 1, js_std_file_putByte ),
 1563|       |    /* setvbuf, ...  */
 1564|       |};
 1565|       |
 1566|       |static int js_std_init(JSContext *ctx, JSModuleDef *m)
 1567|      0|{
 1568|      0|    JSValue proto;
 1569|       |
 1570|       |    /* FILE class */
 1571|       |    /* the class ID is created once */
 1572|      0|    JS_NewClassID(&js_std_file_class_id);
 1573|       |    /* the class is created once per runtime */
 1574|      0|    JS_NewClass(JS_GetRuntime(ctx), js_std_file_class_id, &js_std_file_class);
 1575|      0|    proto = JS_NewObject(ctx);
 1576|      0|    JS_SetPropertyFunctionList(ctx, proto, js_std_file_proto_funcs,
 1577|      0|                               countof(js_std_file_proto_funcs));
 1578|      0|    JS_SetClassProto(ctx, js_std_file_class_id, proto);
 1579|       |
 1580|      0|    JS_SetModuleExportList(ctx, m, js_std_funcs,
 1581|      0|                           countof(js_std_funcs));
 1582|      0|    JS_SetModuleExport(ctx, m, "in", js_new_std_file(ctx, stdin, FALSE, FALSE));
 1583|      0|    JS_SetModuleExport(ctx, m, "out", js_new_std_file(ctx, stdout, FALSE, FALSE));
 1584|      0|    JS_SetModuleExport(ctx, m, "err", js_new_std_file(ctx, stderr, FALSE, FALSE));
 1585|      0|    return 0;
 1586|      0|}
 1587|       |
 1588|       |JSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name)
 1589|  17.7k|{
 1590|  17.7k|    JSModuleDef *m;
 1591|  17.7k|    m = JS_NewCModule(ctx, module_name, js_std_init);
 1592|  17.7k|    if (!m)
 1593|      0|        return NULL;
 1594|  17.7k|    JS_AddModuleExportList(ctx, m, js_std_funcs, countof(js_std_funcs));
 1595|  17.7k|    JS_AddModuleExport(ctx, m, "in");
 1596|  17.7k|    JS_AddModuleExport(ctx, m, "out");
 1597|  17.7k|    JS_AddModuleExport(ctx, m, "err");
 1598|  17.7k|    return m;
 1599|  17.7k|}
 1600|       |
 1601|       |/**********************************************************/
 1602|       |/* 'os' object */
 1603|       |
 1604|       |static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
 1605|       |                          int argc, JSValueConst *argv)
 1606|      0|{
 1607|      0|    const char *filename;
 1608|      0|    int flags, mode, ret;
 1609|       |
 1610|      0|    filename = JS_ToCString(ctx, argv[0]);
 1611|      0|    if (!filename)
 1612|      0|        return JS_EXCEPTION;
 1613|      0|    if (JS_ToInt32(ctx, &flags, argv[1]))
 1614|      0|        goto fail;
 1615|      0|    if (argc >= 3 && !JS_IsUndefined(argv[2])) {
 1616|      0|        if (JS_ToInt32(ctx, &mode, argv[2])) {
 1617|      0|        fail:
 1618|      0|            JS_FreeCString(ctx, filename);
 1619|      0|            return JS_EXCEPTION;
 1620|      0|        }
 1621|      0|    } else {
 1622|      0|        mode = 0666;
 1623|      0|    }
 1624|       |#if defined(_WIN32)
 1625|       |    /* force binary mode by default */
 1626|       |    if (!(flags & O_TEXT))
 1627|       |        flags |= O_BINARY;
 1628|       |#endif
 1629|      0|    ret = js_get_errno(open(filename, flags, mode));
 1630|      0|    JS_FreeCString(ctx, filename);
 1631|      0|    return JS_NewInt32(ctx, ret);
 1632|      0|}
 1633|       |
 1634|       |static JSValue js_os_close(JSContext *ctx, JSValueConst this_val,
 1635|       |                           int argc, JSValueConst *argv)
 1636|      0|{
 1637|      0|    int fd, ret;
 1638|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1639|      0|        return JS_EXCEPTION;
 1640|      0|    ret = js_get_errno(close(fd));
 1641|      0|    return JS_NewInt32(ctx, ret);
 1642|      0|}
 1643|       |
 1644|       |static JSValue js_os_seek(JSContext *ctx, JSValueConst this_val,
 1645|       |                          int argc, JSValueConst *argv)
 1646|      0|{
 1647|      0|    int fd, whence;
 1648|      0|    int64_t pos, ret;
 1649|      0|    BOOL is_bigint;
 1650|       |
 1651|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1652|      0|        return JS_EXCEPTION;
 1653|      0|    is_bigint = JS_IsBigInt(ctx, argv[1]);
 1654|      0|    if (JS_ToInt64Ext(ctx, &pos, argv[1]))
 1655|      0|        return JS_EXCEPTION;
 1656|      0|    if (JS_ToInt32(ctx, &whence, argv[2]))
 1657|      0|        return JS_EXCEPTION;
 1658|      0|    ret = lseek(fd, pos, whence);
 1659|      0|    if (ret == -1)
 1660|      0|        ret = -errno;
 1661|      0|    if (is_bigint)
 1662|      0|        return JS_NewBigInt64(ctx, ret);
 1663|      0|    else
 1664|      0|        return JS_NewInt64(ctx, ret);
 1665|      0|}
 1666|       |
 1667|       |static JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,
 1668|       |                                int argc, JSValueConst *argv, int magic)
 1669|      0|{
 1670|      0|    int fd;
 1671|      0|    uint64_t pos, len;
 1672|      0|    size_t size;
 1673|      0|    ssize_t ret;
 1674|      0|    uint8_t *buf;
 1675|       |
 1676|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1677|      0|        return JS_EXCEPTION;
 1678|      0|    if (JS_ToIndex(ctx, &pos, argv[2]))
 1679|      0|        return JS_EXCEPTION;
 1680|      0|    if (JS_ToIndex(ctx, &len, argv[3]))
 1681|      0|        return JS_EXCEPTION;
 1682|      0|    buf = JS_GetArrayBuffer(ctx, &size, argv[1]);
 1683|      0|    if (!buf)
 1684|      0|        return JS_EXCEPTION;
 1685|      0|    if (pos + len > size)
 1686|      0|        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
 1687|      0|    if (magic)
 1688|      0|        ret = js_get_errno(write(fd, buf + pos, len));
 1689|      0|    else
 1690|      0|        ret = js_get_errno(read(fd, buf + pos, len));
 1691|      0|    return JS_NewInt64(ctx, ret);
 1692|      0|}
 1693|       |
 1694|       |static JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,
 1695|       |                            int argc, JSValueConst *argv)
 1696|      0|{
 1697|      0|    int fd;
 1698|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1699|      0|        return JS_EXCEPTION;
 1700|      0|    return JS_NewBool(ctx, isatty(fd));
 1701|      0|}
 1702|       |
 1703|       |#if defined(_WIN32)
 1704|       |static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
 1705|       |                                   int argc, JSValueConst *argv)
 1706|       |{
 1707|       |    int fd;
 1708|       |    HANDLE handle;
 1709|       |    CONSOLE_SCREEN_BUFFER_INFO info;
 1710|       |    JSValue obj;
 1711|       |
 1712|       |    if (JS_ToInt32(ctx, &fd, argv[0]))
 1713|       |        return JS_EXCEPTION;
 1714|       |    handle = (HANDLE)_get_osfhandle(fd);
 1715|       |
 1716|       |    if (!GetConsoleScreenBufferInfo(handle, &info))
 1717|       |        return JS_NULL;
 1718|       |    obj = JS_NewArray(ctx);
 1719|       |    if (JS_IsException(obj))
 1720|       |        return obj;
 1721|       |    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, info.dwSize.X), JS_PROP_C_W_E);
 1722|       |    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, info.dwSize.Y), JS_PROP_C_W_E);
 1723|       |    return obj;
 1724|       |}
 1725|       |
 1726|       |/* Windows 10 built-in VT100 emulation */
 1727|       |#define __ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
 1728|       |#define __ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200
 1729|       |
 1730|       |static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
 1731|       |                               int argc, JSValueConst *argv)
 1732|       |{
 1733|       |    int fd;
 1734|       |    HANDLE handle;
 1735|       |
 1736|       |    if (JS_ToInt32(ctx, &fd, argv[0]))
 1737|       |        return JS_EXCEPTION;
 1738|       |    handle = (HANDLE)_get_osfhandle(fd);
 1739|       |    SetConsoleMode(handle, ENABLE_WINDOW_INPUT | __ENABLE_VIRTUAL_TERMINAL_INPUT);
 1740|       |    _setmode(fd, _O_BINARY);
 1741|       |    if (fd == 0) {
 1742|       |        handle = (HANDLE)_get_osfhandle(1); /* corresponding output */
 1743|       |        SetConsoleMode(handle, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | __ENABLE_VIRTUAL_TERMINAL_PROCESSING);
 1744|       |    }
 1745|       |    return JS_UNDEFINED;
 1746|       |}
 1747|       |#else
 1748|       |static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
 1749|       |                                   int argc, JSValueConst *argv)
 1750|      0|{
 1751|      0|    int fd;
 1752|      0|    struct winsize ws;
 1753|      0|    JSValue obj;
 1754|       |
 1755|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1756|      0|        return JS_EXCEPTION;
 1757|      0|    if (ioctl(fd, TIOCGWINSZ, &ws) == 0 &&
 1758|      0|        ws.ws_col >= 4 && ws.ws_row >= 4) {
 1759|      0|        obj = JS_NewArray(ctx);
 1760|      0|        if (JS_IsException(obj))
 1761|      0|            return obj;
 1762|      0|        JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ws.ws_col), JS_PROP_C_W_E);
 1763|      0|        JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, ws.ws_row), JS_PROP_C_W_E);
 1764|      0|        return obj;
 1765|      0|    } else {
 1766|      0|        return JS_NULL;
 1767|      0|    }
 1768|      0|}
 1769|       |
 1770|       |static struct termios oldtty;
 1771|       |
 1772|       |static void term_exit(void)
 1773|      0|{
 1774|      0|    tcsetattr(0, TCSANOW, &oldtty);
 1775|      0|}
 1776|       |
 1777|       |/* XXX: should add a way to go back to normal mode */
 1778|       |static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
 1779|       |                               int argc, JSValueConst *argv)
 1780|      0|{
 1781|      0|    struct termios tty;
 1782|      0|    int fd;
 1783|       |
 1784|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1785|      0|        return JS_EXCEPTION;
 1786|       |
 1787|      0|    memset(&tty, 0, sizeof(tty));
 1788|      0|    tcgetattr(fd, &tty);
 1789|      0|    oldtty = tty;
 1790|       |
 1791|      0|    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
 1792|      0|                          |INLCR|IGNCR|ICRNL|IXON);
 1793|      0|    tty.c_oflag |= OPOST;
 1794|      0|    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);
 1795|      0|    tty.c_cflag &= ~(CSIZE|PARENB);
 1796|      0|    tty.c_cflag |= CS8;
 1797|      0|    tty.c_cc[VMIN] = 1;
 1798|      0|    tty.c_cc[VTIME] = 0;
 1799|       |
 1800|      0|    tcsetattr(fd, TCSANOW, &tty);
 1801|       |
 1802|      0|    atexit(term_exit);
 1803|      0|    return JS_UNDEFINED;
 1804|      0|}
 1805|       |
 1806|       |#endif /* !_WIN32 */
 1807|       |
 1808|       |static JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,
 1809|       |                            int argc, JSValueConst *argv)
 1810|      0|{
 1811|      0|    const char *filename;
 1812|      0|    int ret;
 1813|       |
 1814|      0|    filename = JS_ToCString(ctx, argv[0]);
 1815|      0|    if (!filename)
 1816|      0|        return JS_EXCEPTION;
 1817|       |#if defined(_WIN32)
 1818|       |    {
 1819|       |        struct stat st;
 1820|       |        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
 1821|       |            ret = rmdir(filename);
 1822|       |        } else {
 1823|       |            ret = unlink(filename);
 1824|       |        }
 1825|       |    }
 1826|       |#else
 1827|      0|    ret = remove(filename);
 1828|      0|#endif
 1829|      0|    ret = js_get_errno(ret);
 1830|      0|    JS_FreeCString(ctx, filename);
 1831|      0|    return JS_NewInt32(ctx, ret);
 1832|      0|}
 1833|       |
 1834|       |static JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,
 1835|       |                            int argc, JSValueConst *argv)
 1836|      0|{
 1837|      0|    const char *oldpath, *newpath;
 1838|      0|    int ret;
 1839|       |
 1840|      0|    oldpath = JS_ToCString(ctx, argv[0]);
 1841|      0|    if (!oldpath)
 1842|      0|        return JS_EXCEPTION;
 1843|      0|    newpath = JS_ToCString(ctx, argv[1]);
 1844|      0|    if (!newpath) {
 1845|      0|        JS_FreeCString(ctx, oldpath);
 1846|      0|        return JS_EXCEPTION;
 1847|      0|    }
 1848|      0|    ret = js_get_errno(rename(oldpath, newpath));
 1849|      0|    JS_FreeCString(ctx, oldpath);
 1850|      0|    JS_FreeCString(ctx, newpath);
 1851|      0|    return JS_NewInt32(ctx, ret);
 1852|      0|}
 1853|       |
 1854|       |static BOOL is_main_thread(JSRuntime *rt)
 1855|      0|{
 1856|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 1857|      0|    return !ts->recv_pipe;
 1858|      0|}
 1859|       |
 1860|       |static JSOSRWHandler *find_rh(JSThreadState *ts, int fd)
 1861|      0|{
 1862|      0|    JSOSRWHandler *rh;
 1863|      0|    struct list_head *el;
 1864|       |
 1865|      0|    list_for_each(el, &ts->os_rw_handlers) {
 1866|      0|        rh = list_entry(el, JSOSRWHandler, link);
 1867|      0|        if (rh->fd == fd)
 1868|      0|            return rh;
 1869|      0|    }
 1870|      0|    return NULL;
 1871|      0|}
 1872|       |
 1873|       |static void free_rw_handler(JSRuntime *rt, JSOSRWHandler *rh)
 1874|      0|{
 1875|      0|    int i;
 1876|      0|    list_del(&rh->link);
 1877|      0|    for(i = 0; i < 2; i++) {
 1878|      0|        JS_FreeValueRT(rt, rh->rw_func[i]);
 1879|      0|    }
 1880|      0|    js_free_rt(rt, rh);
 1881|      0|}
 1882|       |
 1883|       |static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
 1884|       |                                    int argc, JSValueConst *argv, int magic)
 1885|      0|{
 1886|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 1887|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 1888|      0|    JSOSRWHandler *rh;
 1889|      0|    int fd;
 1890|      0|    JSValueConst func;
 1891|       |
 1892|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 1893|      0|        return JS_EXCEPTION;
 1894|      0|    func = argv[1];
 1895|      0|    if (JS_IsNull(func)) {
 1896|      0|        rh = find_rh(ts, fd);
 1897|      0|        if (rh) {
 1898|      0|            JS_FreeValue(ctx, rh->rw_func[magic]);
 1899|      0|            rh->rw_func[magic] = JS_NULL;
 1900|      0|            if (JS_IsNull(rh->rw_func[0]) &&
 1901|      0|                JS_IsNull(rh->rw_func[1])) {
 1902|       |                /* remove the entry */
 1903|      0|                free_rw_handler(JS_GetRuntime(ctx), rh);
 1904|      0|            }
 1905|      0|        }
 1906|      0|    } else {
 1907|      0|        if (!JS_IsFunction(ctx, func))
 1908|      0|            return JS_ThrowTypeError(ctx, "not a function");
 1909|      0|        rh = find_rh(ts, fd);
 1910|      0|        if (!rh) {
 1911|      0|            rh = js_mallocz(ctx, sizeof(*rh));
 1912|      0|            if (!rh)
 1913|      0|                return JS_EXCEPTION;
 1914|      0|            rh->fd = fd;
 1915|      0|            rh->rw_func[0] = JS_NULL;
 1916|      0|            rh->rw_func[1] = JS_NULL;
 1917|      0|            list_add_tail(&rh->link, &ts->os_rw_handlers);
 1918|      0|        }
 1919|      0|        JS_FreeValue(ctx, rh->rw_func[magic]);
 1920|      0|        rh->rw_func[magic] = JS_DupValue(ctx, func);
 1921|      0|    }
 1922|      0|    return JS_UNDEFINED;
 1923|      0|}
 1924|       |
 1925|       |static JSOSSignalHandler *find_sh(JSThreadState *ts, int sig_num)
 1926|      0|{
 1927|      0|    JSOSSignalHandler *sh;
 1928|      0|    struct list_head *el;
 1929|      0|    list_for_each(el, &ts->os_signal_handlers) {
 1930|      0|        sh = list_entry(el, JSOSSignalHandler, link);
 1931|      0|        if (sh->sig_num == sig_num)
 1932|      0|            return sh;
 1933|      0|    }
 1934|      0|    return NULL;
 1935|      0|}
 1936|       |
 1937|       |static void free_sh(JSRuntime *rt, JSOSSignalHandler *sh)
 1938|      0|{
 1939|      0|    list_del(&sh->link);
 1940|      0|    JS_FreeValueRT(rt, sh->func);
 1941|      0|    js_free_rt(rt, sh);
 1942|      0|}
 1943|       |
 1944|       |static void os_signal_handler(int sig_num)
 1945|      0|{
 1946|      0|    os_pending_signals |= ((uint64_t)1 << sig_num);
 1947|      0|}
 1948|       |
 1949|       |#if defined(_WIN32)
 1950|       |typedef void (*sighandler_t)(int sig_num);
 1951|       |#endif
 1952|       |
 1953|       |static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
 1954|       |                            int argc, JSValueConst *argv)
 1955|      0|{
 1956|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 1957|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 1958|      0|    JSOSSignalHandler *sh;
 1959|      0|    uint32_t sig_num;
 1960|      0|    JSValueConst func;
 1961|      0|    sighandler_t handler;
 1962|       |
 1963|      0|    if (!is_main_thread(rt))
 1964|      0|        return JS_ThrowTypeError(ctx, "signal handler can only be set in the main thread");
 1965|       |
 1966|      0|    if (JS_ToUint32(ctx, &sig_num, argv[0]))
 1967|      0|        return JS_EXCEPTION;
 1968|      0|    if (sig_num >= 64)
 1969|      0|        return JS_ThrowRangeError(ctx, "invalid signal number");
 1970|      0|    func = argv[1];
 1971|       |    /* func = null: SIG_DFL, func = undefined, SIG_IGN */
 1972|      0|    if (JS_IsNull(func) || JS_IsUndefined(func)) {
 1973|      0|        sh = find_sh(ts, sig_num);
 1974|      0|        if (sh) {
 1975|      0|            free_sh(JS_GetRuntime(ctx), sh);
 1976|      0|        }
 1977|      0|        if (JS_IsNull(func))
 1978|      0|            handler = SIG_DFL;
 1979|      0|        else
 1980|      0|            handler = SIG_IGN;
 1981|      0|        signal(sig_num, handler);
 1982|      0|    } else {
 1983|      0|        if (!JS_IsFunction(ctx, func))
 1984|      0|            return JS_ThrowTypeError(ctx, "not a function");
 1985|      0|        sh = find_sh(ts, sig_num);
 1986|      0|        if (!sh) {
 1987|      0|            sh = js_mallocz(ctx, sizeof(*sh));
 1988|      0|            if (!sh)
 1989|      0|                return JS_EXCEPTION;
 1990|      0|            sh->sig_num = sig_num;
 1991|      0|            list_add_tail(&sh->link, &ts->os_signal_handlers);
 1992|      0|        }
 1993|      0|        JS_FreeValue(ctx, sh->func);
 1994|      0|        sh->func = JS_DupValue(ctx, func);
 1995|      0|        signal(sig_num, os_signal_handler);
 1996|      0|    }
 1997|      0|    return JS_UNDEFINED;
 1998|      0|}
 1999|       |
 2000|       |#if defined(__linux__) || defined(__APPLE__)
 2001|       |static int64_t get_time_ms(void)
 2002|      0|{
 2003|      0|    struct timespec ts;
 2004|      0|    clock_gettime(CLOCK_MONOTONIC, &ts);
 2005|      0|    return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
 2006|      0|}
 2007|       |
 2008|       |static int64_t get_time_ns(void)
 2009|      0|{
 2010|      0|    struct timespec ts;
 2011|      0|    clock_gettime(CLOCK_MONOTONIC, &ts);
 2012|      0|    return (uint64_t)ts.tv_sec * 1000000000 + ts.tv_nsec;
 2013|      0|}
 2014|       |#else
 2015|       |/* more portable, but does not work if the date is updated */
 2016|       |static int64_t get_time_ms(void)
 2017|       |{
 2018|       |    struct timeval tv;
 2019|       |    gettimeofday(&tv, NULL);
 2020|       |    return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
 2021|       |}
 2022|       |
 2023|       |static int64_t get_time_ns(void)
 2024|       |{
 2025|       |    struct timeval tv;
 2026|       |    gettimeofday(&tv, NULL);
 2027|       |    return (int64_t)tv.tv_sec * 1000000000 + (tv.tv_usec * 1000);
 2028|       |}
 2029|       |#endif
 2030|       |
 2031|       |static JSValue js_os_now(JSContext *ctx, JSValue this_val,
 2032|       |                         int argc, JSValue *argv)
 2033|      0|{
 2034|      0|    return JS_NewFloat64(ctx, (double)get_time_ns() / 1e6);
 2035|      0|}
 2036|       |
 2037|       |static void free_timer(JSRuntime *rt, JSOSTimer *th)
 2038|      0|{
 2039|      0|    list_del(&th->link);
 2040|      0|    JS_FreeValueRT(rt, th->func);
 2041|      0|    js_free_rt(rt, th);
 2042|      0|}
 2043|       |
 2044|       |static JSValue js_os_setTimeout(JSContext *ctx, JSValueConst this_val,
 2045|       |                                int argc, JSValueConst *argv)
 2046|      0|{
 2047|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 2048|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 2049|      0|    int64_t delay;
 2050|      0|    JSValueConst func;
 2051|      0|    JSOSTimer *th;
 2052|       |
 2053|      0|    func = argv[0];
 2054|      0|    if (!JS_IsFunction(ctx, func))
 2055|      0|        return JS_ThrowTypeError(ctx, "not a function");
 2056|      0|    if (JS_ToInt64(ctx, &delay, argv[1]))
 2057|      0|        return JS_EXCEPTION;
 2058|      0|    th = js_mallocz(ctx, sizeof(*th));
 2059|      0|    if (!th)
 2060|      0|        return JS_EXCEPTION;
 2061|      0|    th->timer_id = ts->next_timer_id;
 2062|      0|    if (ts->next_timer_id == INT32_MAX)
 2063|      0|        ts->next_timer_id = 1;
 2064|      0|    else
 2065|      0|        ts->next_timer_id++;
 2066|      0|    th->timeout = get_time_ms() + delay;
 2067|      0|    th->func = JS_DupValue(ctx, func);
 2068|      0|    list_add_tail(&th->link, &ts->os_timers);
 2069|      0|    return JS_NewInt32(ctx, th->timer_id);
 2070|      0|}
 2071|       |
 2072|       |static JSOSTimer *find_timer_by_id(JSThreadState *ts, int timer_id)
 2073|      0|{
 2074|      0|    struct list_head *el;
 2075|      0|    if (timer_id <= 0)
 2076|      0|        return NULL;
 2077|      0|    list_for_each(el, &ts->os_timers) {
 2078|      0|        JSOSTimer *th = list_entry(el, JSOSTimer, link);
 2079|      0|        if (th->timer_id == timer_id)
 2080|      0|            return th;
 2081|      0|    }
 2082|      0|    return NULL;
 2083|      0|}
 2084|       |
 2085|       |static JSValue js_os_clearTimeout(JSContext *ctx, JSValueConst this_val,
 2086|       |                                  int argc, JSValueConst *argv)
 2087|      0|{
 2088|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 2089|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 2090|      0|    JSOSTimer *th;
 2091|      0|    int timer_id;
 2092|       |
 2093|      0|    if (JS_ToInt32(ctx, &timer_id, argv[0]))
 2094|      0|        return JS_EXCEPTION;
 2095|      0|    th = find_timer_by_id(ts, timer_id);
 2096|      0|    if (!th)
 2097|      0|        return JS_UNDEFINED;
 2098|      0|    free_timer(rt, th);
 2099|      0|    return JS_UNDEFINED;
 2100|      0|}
 2101|       |
 2102|       |/* return a promise */
 2103|       |static JSValue js_os_sleepAsync(JSContext *ctx, JSValueConst this_val,
 2104|       |                                int argc, JSValueConst *argv)
 2105|      0|{
 2106|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 2107|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 2108|      0|    int64_t delay;
 2109|      0|    JSOSTimer *th;
 2110|      0|    JSValue promise, resolving_funcs[2];
 2111|       |
 2112|      0|    if (JS_ToInt64(ctx, &delay, argv[0]))
 2113|      0|        return JS_EXCEPTION;
 2114|      0|    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
 2115|      0|    if (JS_IsException(promise))
 2116|      0|        return JS_EXCEPTION;
 2117|       |
 2118|      0|    th = js_mallocz(ctx, sizeof(*th));
 2119|      0|    if (!th) {
 2120|      0|        JS_FreeValue(ctx, promise);
 2121|      0|        JS_FreeValue(ctx, resolving_funcs[0]);
 2122|      0|        JS_FreeValue(ctx, resolving_funcs[1]);
 2123|      0|        return JS_EXCEPTION;
 2124|      0|    }
 2125|      0|    th->timer_id = -1;
 2126|      0|    th->timeout = get_time_ms() + delay;
 2127|      0|    th->func = JS_DupValue(ctx, resolving_funcs[0]);
 2128|      0|    list_add_tail(&th->link, &ts->os_timers);
 2129|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
 2130|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
 2131|      0|    return promise;
 2132|      0|}
 2133|       |
 2134|       |static void call_handler(JSContext *ctx, JSValueConst func)
 2135|      0|{
 2136|      0|    JSValue ret, func1;
 2137|       |    /* 'func' might be destroyed when calling itself (if it frees the
 2138|       |       handler), so must take extra care */
 2139|      0|    func1 = JS_DupValue(ctx, func);
 2140|      0|    ret = JS_Call(ctx, func1, JS_UNDEFINED, 0, NULL);
 2141|      0|    JS_FreeValue(ctx, func1);
 2142|      0|    if (JS_IsException(ret))
 2143|      0|        js_std_dump_error(ctx);
 2144|      0|    JS_FreeValue(ctx, ret);
 2145|      0|}
 2146|       |
 2147|       |#ifdef USE_WORKER
 2148|       |
 2149|       |#ifdef _WIN32
 2150|       |
 2151|       |static int js_waker_init(JSWaker *w)
 2152|       |{
 2153|       |    w->handle = CreateEvent(NULL, TRUE, FALSE, NULL);
 2154|       |    return w->handle ? 0 : -1;
 2155|       |}
 2156|       |
 2157|       |static void js_waker_signal(JSWaker *w)
 2158|       |{
 2159|       |    SetEvent(w->handle);
 2160|       |}
 2161|       |
 2162|       |static void js_waker_clear(JSWaker *w)
 2163|       |{
 2164|       |    ResetEvent(w->handle);
 2165|       |}
 2166|       |
 2167|       |static void js_waker_close(JSWaker *w)
 2168|       |{
 2169|       |    CloseHandle(w->handle);
 2170|       |    w->handle = INVALID_HANDLE_VALUE;
 2171|       |}
 2172|       |
 2173|       |#else // !_WIN32
 2174|       |
 2175|       |static int js_waker_init(JSWaker *w)
 2176|      0|{
 2177|      0|    int fds[2];
 2178|       |
 2179|      0|    if (pipe(fds) < 0)
 2180|      0|        return -1;
 2181|      0|    w->read_fd = fds[0];
 2182|      0|    w->write_fd = fds[1];
 2183|      0|    return 0;
 2184|      0|}
 2185|       |
 2186|       |static void js_waker_signal(JSWaker *w)
 2187|      0|{
 2188|      0|    int ret;
 2189|       |
 2190|      0|    for(;;) {
 2191|      0|        ret = write(w->write_fd, "", 1);
 2192|      0|        if (ret == 1)
 2193|      0|            break;
 2194|      0|        if (ret < 0 && (errno != EAGAIN || errno != EINTR))
 2195|      0|            break;
 2196|      0|    }
 2197|      0|}
 2198|       |
 2199|       |static void js_waker_clear(JSWaker *w)
 2200|      0|{
 2201|      0|    uint8_t buf[16];
 2202|      0|    int ret;
 2203|       |
 2204|      0|    for(;;) {
 2205|      0|        ret = read(w->read_fd, buf, sizeof(buf));
 2206|      0|        if (ret >= 0)
 2207|      0|            break;
 2208|      0|        if (errno != EAGAIN && errno != EINTR)
 2209|      0|            break;
 2210|      0|    }
 2211|      0|}
 2212|       |
 2213|       |static void js_waker_close(JSWaker *w)
 2214|      0|{
 2215|      0|    close(w->read_fd);
 2216|      0|    close(w->write_fd);
 2217|      0|    w->read_fd = -1;
 2218|      0|    w->write_fd = -1;
 2219|      0|}
 2220|       |
 2221|       |#endif // _WIN32
 2222|       |
 2223|       |static void js_free_message(JSWorkerMessage *msg);
 2224|       |
 2225|       |/* return 1 if a message was handled, 0 if no message */
 2226|       |static int handle_posted_message(JSRuntime *rt, JSContext *ctx,
 2227|       |                                 JSWorkerMessageHandler *port)
 2228|      0|{
 2229|      0|    JSWorkerMessagePipe *ps = port->recv_pipe;
 2230|      0|    int ret;
 2231|      0|    struct list_head *el;
 2232|      0|    JSWorkerMessage *msg;
 2233|      0|    JSValue obj, data_obj, func, retval;
 2234|       |
 2235|      0|    pthread_mutex_lock(&ps->mutex);
 2236|      0|    if (!list_empty(&ps->msg_queue)) {
 2237|      0|        el = ps->msg_queue.next;
 2238|      0|        msg = list_entry(el, JSWorkerMessage, link);
 2239|       |
 2240|       |        /* remove the message from the queue */
 2241|      0|        list_del(&msg->link);
 2242|       |
 2243|      0|        if (list_empty(&ps->msg_queue))
 2244|      0|            js_waker_clear(&ps->waker);
 2245|       |
 2246|      0|        pthread_mutex_unlock(&ps->mutex);
 2247|       |
 2248|      0|        data_obj = JS_ReadObject(ctx, msg->data, msg->data_len,
 2249|      0|                                 JS_READ_OBJ_SAB | JS_READ_OBJ_REFERENCE);
 2250|       |
 2251|      0|        js_free_message(msg);
 2252|       |
 2253|      0|        if (JS_IsException(data_obj))
 2254|      0|            goto fail;
 2255|      0|        obj = JS_NewObject(ctx);
 2256|      0|        if (JS_IsException(obj)) {
 2257|      0|            JS_FreeValue(ctx, data_obj);
 2258|      0|            goto fail;
 2259|      0|        }
 2260|      0|        JS_DefinePropertyValueStr(ctx, obj, "data", data_obj, JS_PROP_C_W_E);
 2261|       |
 2262|       |        /* 'func' might be destroyed when calling itself (if it frees the
 2263|       |           handler), so must take extra care */
 2264|      0|        func = JS_DupValue(ctx, port->on_message_func);
 2265|      0|        retval = JS_Call(ctx, func, JS_UNDEFINED, 1, (JSValueConst *)&obj);
 2266|      0|        JS_FreeValue(ctx, obj);
 2267|      0|        JS_FreeValue(ctx, func);
 2268|      0|        if (JS_IsException(retval)) {
 2269|      0|        fail:
 2270|      0|            js_std_dump_error(ctx);
 2271|      0|        } else {
 2272|      0|            JS_FreeValue(ctx, retval);
 2273|      0|        }
 2274|      0|        ret = 1;
 2275|      0|    } else {
 2276|      0|        pthread_mutex_unlock(&ps->mutex);
 2277|      0|        ret = 0;
 2278|      0|    }
 2279|      0|    return ret;
 2280|      0|}
 2281|       |#else
 2282|       |static int handle_posted_message(JSRuntime *rt, JSContext *ctx,
 2283|       |                                 JSWorkerMessageHandler *port)
 2284|       |{
 2285|       |    return 0;
 2286|       |}
 2287|       |#endif /* !USE_WORKER */
 2288|       |
 2289|       |#if defined(_WIN32)
 2290|       |
 2291|       |static int js_os_poll(JSContext *ctx)
 2292|       |{
 2293|       |    JSRuntime *rt = JS_GetRuntime(ctx);
 2294|       |    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 2295|       |    int min_delay, count;
 2296|       |    int64_t cur_time, delay;
 2297|       |    JSOSRWHandler *rh;
 2298|       |    struct list_head *el;
 2299|       |    HANDLE handles[MAXIMUM_WAIT_OBJECTS]; // 64
 2300|       |
 2301|       |    /* XXX: handle signals if useful */
 2302|       |
 2303|       |    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers) &&
 2304|       |        list_empty(&ts->port_list)) {
 2305|       |        return -1; /* no more events */
 2306|       |    }
 2307|       |    
 2308|       |    if (!list_empty(&ts->os_timers)) {
 2309|       |        cur_time = get_time_ms();
 2310|       |        min_delay = 10000;
 2311|       |        list_for_each(el, &ts->os_timers) {
 2312|       |            JSOSTimer *th = list_entry(el, JSOSTimer, link);
 2313|       |            delay = th->timeout - cur_time;
 2314|       |            if (delay <= 0) {
 2315|       |                JSValue func;
 2316|       |                /* the timer expired */
 2317|       |                func = th->func;
 2318|       |                th->func = JS_UNDEFINED;
 2319|       |                free_timer(rt, th);
 2320|       |                call_handler(ctx, func);
 2321|       |                JS_FreeValue(ctx, func);
 2322|       |                return 0;
 2323|       |            } else if (delay < min_delay) {
 2324|       |                min_delay = delay;
 2325|       |            }
 2326|       |        }
 2327|       |    } else {
 2328|       |        min_delay = -1;
 2329|       |    }
 2330|       |
 2331|       |    count = 0;
 2332|       |    list_for_each(el, &ts->os_rw_handlers) {
 2333|       |        rh = list_entry(el, JSOSRWHandler, link);
 2334|       |        if (rh->fd == 0 && !JS_IsNull(rh->rw_func[0])) {
 2335|       |            handles[count++] = (HANDLE)_get_osfhandle(rh->fd); // stdin
 2336|       |            if (count == (int)countof(handles))
 2337|       |                break;
 2338|       |        }
 2339|       |    }
 2340|       |
 2341|       |    list_for_each(el, &ts->port_list) {
 2342|       |        JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
 2343|       |        if (JS_IsNull(port->on_message_func))
 2344|       |            continue;
 2345|       |        handles[count++] = port->recv_pipe->waker.handle;
 2346|       |        if (count == (int)countof(handles))
 2347|       |            break;
 2348|       |    }
 2349|       |
 2350|       |    if (count > 0) {
 2351|       |        DWORD ret, timeout = INFINITE;
 2352|       |        if (min_delay != -1)
 2353|       |            timeout = min_delay;
 2354|       |        ret = WaitForMultipleObjects(count, handles, FALSE, timeout);
 2355|       |
 2356|       |        if (ret < count) {
 2357|       |            list_for_each(el, &ts->os_rw_handlers) {
 2358|       |                rh = list_entry(el, JSOSRWHandler, link);
 2359|       |                if (rh->fd == 0 && !JS_IsNull(rh->rw_func[0])) {
 2360|       |                    call_handler(ctx, rh->rw_func[0]);
 2361|       |                    /* must stop because the list may have been modified */
 2362|       |                    goto done;
 2363|       |                }
 2364|       |            }
 2365|       |
 2366|       |            list_for_each(el, &ts->port_list) {
 2367|       |                JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
 2368|       |                if (!JS_IsNull(port->on_message_func)) {
 2369|       |                    JSWorkerMessagePipe *ps = port->recv_pipe;
 2370|       |                    if (ps->waker.handle == handles[ret]) {
 2371|       |                        if (handle_posted_message(rt, ctx, port))
 2372|       |                            goto done;
 2373|       |                    }
 2374|       |                }
 2375|       |            }
 2376|       |        }
 2377|       |    } else {
 2378|       |        Sleep(min_delay);
 2379|       |    }
 2380|       | done:
 2381|       |    return 0;
 2382|       |}
 2383|       |
 2384|       |#else
 2385|       |
 2386|       |static int js_os_poll(JSContext *ctx)
 2387|      0|{
 2388|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 2389|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 2390|      0|    int ret, fd_max, min_delay;
 2391|      0|    int64_t cur_time, delay;
 2392|      0|    fd_set rfds, wfds;
 2393|      0|    JSOSRWHandler *rh;
 2394|      0|    struct list_head *el;
 2395|      0|    struct timeval tv, *tvp;
 2396|       |
 2397|       |    /* only check signals in the main thread */
 2398|      0|    if (!ts->recv_pipe &&
 2399|      0|        unlikely(os_pending_signals != 0)) {
 2400|      0|        JSOSSignalHandler *sh;
 2401|      0|        uint64_t mask;
 2402|       |
 2403|      0|        list_for_each(el, &ts->os_signal_handlers) {
 2404|      0|            sh = list_entry(el, JSOSSignalHandler, link);
 2405|      0|            mask = (uint64_t)1 << sh->sig_num;
 2406|      0|            if (os_pending_signals & mask) {
 2407|      0|                os_pending_signals &= ~mask;
 2408|      0|                call_handler(ctx, sh->func);
 2409|      0|                return 0;
 2410|      0|            }
 2411|      0|        }
 2412|      0|    }
 2413|       |
 2414|      0|    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers) &&
 2415|      0|        list_empty(&ts->port_list))
 2416|      0|        return -1; /* no more events */
 2417|       |
 2418|      0|    if (!list_empty(&ts->os_timers)) {
 2419|      0|        cur_time = get_time_ms();
 2420|      0|        min_delay = 10000;
 2421|      0|        list_for_each(el, &ts->os_timers) {
 2422|      0|            JSOSTimer *th = list_entry(el, JSOSTimer, link);
 2423|      0|            delay = th->timeout - cur_time;
 2424|      0|            if (delay <= 0) {
 2425|      0|                JSValue func;
 2426|       |                /* the timer expired */
 2427|      0|                func = th->func;
 2428|      0|                th->func = JS_UNDEFINED;
 2429|      0|                free_timer(rt, th);
 2430|      0|                call_handler(ctx, func);
 2431|      0|                JS_FreeValue(ctx, func);
 2432|      0|                return 0;
 2433|      0|            } else if (delay < min_delay) {
 2434|      0|                min_delay = delay;
 2435|      0|            }
 2436|      0|        }
 2437|      0|        tv.tv_sec = min_delay / 1000;
 2438|      0|        tv.tv_usec = (min_delay % 1000) * 1000;
 2439|      0|        tvp = &tv;
 2440|      0|    } else {
 2441|      0|        tvp = NULL;
 2442|      0|    }
 2443|       |
 2444|      0|    FD_ZERO(&rfds);
 2445|      0|    FD_ZERO(&wfds);
 2446|      0|    fd_max = -1;
 2447|      0|    list_for_each(el, &ts->os_rw_handlers) {
 2448|      0|        rh = list_entry(el, JSOSRWHandler, link);
 2449|      0|        fd_max = max_int(fd_max, rh->fd);
 2450|      0|        if (!JS_IsNull(rh->rw_func[0]))
 2451|      0|            FD_SET(rh->fd, &rfds);
 2452|      0|        if (!JS_IsNull(rh->rw_func[1]))
 2453|      0|            FD_SET(rh->fd, &wfds);
 2454|      0|    }
 2455|       |
 2456|      0|    list_for_each(el, &ts->port_list) {
 2457|      0|        JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
 2458|      0|        if (!JS_IsNull(port->on_message_func)) {
 2459|      0|            JSWorkerMessagePipe *ps = port->recv_pipe;
 2460|      0|            fd_max = max_int(fd_max, ps->waker.read_fd);
 2461|      0|            FD_SET(ps->waker.read_fd, &rfds);
 2462|      0|        }
 2463|      0|    }
 2464|       |
 2465|      0|    ret = select(fd_max + 1, &rfds, &wfds, NULL, tvp);
 2466|      0|    if (ret > 0) {
 2467|      0|        list_for_each(el, &ts->os_rw_handlers) {
 2468|      0|            rh = list_entry(el, JSOSRWHandler, link);
 2469|      0|            if (!JS_IsNull(rh->rw_func[0]) &&
 2470|      0|                FD_ISSET(rh->fd, &rfds)) {
 2471|      0|                call_handler(ctx, rh->rw_func[0]);
 2472|       |                /* must stop because the list may have been modified */
 2473|      0|                goto done;
 2474|      0|            }
 2475|      0|            if (!JS_IsNull(rh->rw_func[1]) &&
 2476|      0|                FD_ISSET(rh->fd, &wfds)) {
 2477|      0|                call_handler(ctx, rh->rw_func[1]);
 2478|       |                /* must stop because the list may have been modified */
 2479|      0|                goto done;
 2480|      0|            }
 2481|      0|        }
 2482|       |
 2483|      0|        list_for_each(el, &ts->port_list) {
 2484|      0|            JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
 2485|      0|            if (!JS_IsNull(port->on_message_func)) {
 2486|      0|                JSWorkerMessagePipe *ps = port->recv_pipe;
 2487|      0|                if (FD_ISSET(ps->waker.read_fd, &rfds)) {
 2488|      0|                    if (handle_posted_message(rt, ctx, port))
 2489|      0|                        goto done;
 2490|      0|                }
 2491|      0|            }
 2492|      0|        }
 2493|      0|    }
 2494|      0| done:
 2495|      0|    return 0;
 2496|      0|}
 2497|       |#endif /* !_WIN32 */
 2498|       |
 2499|       |static JSValue make_obj_error(JSContext *ctx,
 2500|       |                              JSValue obj,
 2501|       |                              int err)
 2502|      0|{
 2503|      0|    JSValue arr;
 2504|      0|    if (JS_IsException(obj))
 2505|      0|        return obj;
 2506|      0|    arr = JS_NewArray(ctx);
 2507|      0|    if (JS_IsException(arr))
 2508|      0|        return JS_EXCEPTION;
 2509|      0|    JS_DefinePropertyValueUint32(ctx, arr, 0, obj,
 2510|      0|                                 JS_PROP_C_W_E);
 2511|      0|    JS_DefinePropertyValueUint32(ctx, arr, 1, JS_NewInt32(ctx, err),
 2512|      0|                                 JS_PROP_C_W_E);
 2513|      0|    return arr;
 2514|      0|}
 2515|       |
 2516|       |static JSValue make_string_error(JSContext *ctx,
 2517|       |                                 const char *buf,
 2518|       |                                 int err)
 2519|      0|{
 2520|      0|    return make_obj_error(ctx, JS_NewString(ctx, buf), err);
 2521|      0|}
 2522|       |
 2523|       |/* return [cwd, errorcode] */
 2524|       |static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,
 2525|       |                            int argc, JSValueConst *argv)
 2526|      0|{
 2527|      0|    char buf[PATH_MAX];
 2528|      0|    int err;
 2529|       |
 2530|      0|    if (!getcwd(buf, sizeof(buf))) {
 2531|      0|        buf[0] = '\0';
 2532|      0|        err = errno;
 2533|      0|    } else {
 2534|      0|        err = 0;
 2535|      0|    }
 2536|      0|    return make_string_error(ctx, buf, err);
 2537|      0|}
 2538|       |
 2539|       |static JSValue js_os_chdir(JSContext *ctx, JSValueConst this_val,
 2540|       |                           int argc, JSValueConst *argv)
 2541|      0|{
 2542|      0|    const char *target;
 2543|      0|    int err;
 2544|       |
 2545|      0|    target = JS_ToCString(ctx, argv[0]);
 2546|      0|    if (!target)
 2547|      0|        return JS_EXCEPTION;
 2548|      0|    err = js_get_errno(chdir(target));
 2549|      0|    JS_FreeCString(ctx, target);
 2550|      0|    return JS_NewInt32(ctx, err);
 2551|      0|}
 2552|       |
 2553|       |static JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,
 2554|       |                           int argc, JSValueConst *argv)
 2555|      0|{
 2556|      0|    int mode, ret;
 2557|      0|    const char *path;
 2558|       |
 2559|      0|    if (argc >= 2) {
 2560|      0|        if (JS_ToInt32(ctx, &mode, argv[1]))
 2561|      0|            return JS_EXCEPTION;
 2562|      0|    } else {
 2563|      0|        mode = 0777;
 2564|      0|    }
 2565|      0|    path = JS_ToCString(ctx, argv[0]);
 2566|      0|    if (!path)
 2567|      0|        return JS_EXCEPTION;
 2568|       |#if defined(_WIN32)
 2569|       |    (void)mode;
 2570|       |    ret = js_get_errno(mkdir(path));
 2571|       |#else
 2572|      0|    ret = js_get_errno(mkdir(path, mode));
 2573|      0|#endif
 2574|      0|    JS_FreeCString(ctx, path);
 2575|      0|    return JS_NewInt32(ctx, ret);
 2576|      0|}
 2577|       |
 2578|       |/* return [array, errorcode] */
 2579|       |static JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,
 2580|       |                             int argc, JSValueConst *argv)
 2581|      0|{
 2582|      0|    const char *path;
 2583|      0|    DIR *f;
 2584|      0|    struct dirent *d;
 2585|      0|    JSValue obj;
 2586|      0|    int err;
 2587|      0|    uint32_t len;
 2588|       |
 2589|      0|    path = JS_ToCString(ctx, argv[0]);
 2590|      0|    if (!path)
 2591|      0|        return JS_EXCEPTION;
 2592|      0|    obj = JS_NewArray(ctx);
 2593|      0|    if (JS_IsException(obj)) {
 2594|      0|        JS_FreeCString(ctx, path);
 2595|      0|        return JS_EXCEPTION;
 2596|      0|    }
 2597|      0|    f = opendir(path);
 2598|      0|    if (!f)
 2599|      0|        err = errno;
 2600|      0|    else
 2601|      0|        err = 0;
 2602|      0|    JS_FreeCString(ctx, path);
 2603|      0|    if (!f)
 2604|      0|        goto done;
 2605|      0|    len = 0;
 2606|      0|    for(;;) {
 2607|      0|        errno = 0;
 2608|      0|        d = readdir(f);
 2609|      0|        if (!d) {
 2610|      0|            err = errno;
 2611|      0|            break;
 2612|      0|        }
 2613|      0|        JS_DefinePropertyValueUint32(ctx, obj, len++,
 2614|      0|                                     JS_NewString(ctx, d->d_name),
 2615|      0|                                     JS_PROP_C_W_E);
 2616|      0|    }
 2617|      0|    closedir(f);
 2618|      0| done:
 2619|      0|    return make_obj_error(ctx, obj, err);
 2620|      0|}
 2621|       |
 2622|       |#if !defined(_WIN32)
 2623|       |static int64_t timespec_to_ms(const struct timespec *tv)
 2624|      0|{
 2625|      0|    return (int64_t)tv->tv_sec * 1000 + (tv->tv_nsec / 1000000);
 2626|      0|}
 2627|       |#endif
 2628|       |
 2629|       |/* return [obj, errcode] */
 2630|       |static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
 2631|       |                          int argc, JSValueConst *argv, int is_lstat)
 2632|      0|{
 2633|      0|    const char *path;
 2634|      0|    int err, res;
 2635|      0|    struct stat st;
 2636|      0|    JSValue obj;
 2637|       |
 2638|      0|    path = JS_ToCString(ctx, argv[0]);
 2639|      0|    if (!path)
 2640|      0|        return JS_EXCEPTION;
 2641|       |#if defined(_WIN32)
 2642|       |    res = stat(path, &st);
 2643|       |#else
 2644|      0|    if (is_lstat)
 2645|      0|        res = lstat(path, &st);
 2646|      0|    else
 2647|      0|        res = stat(path, &st);
 2648|      0|#endif
 2649|      0|    if (res < 0)
 2650|      0|        err = errno;
 2651|      0|    else
 2652|      0|        err = 0;
 2653|      0|    JS_FreeCString(ctx, path);
 2654|      0|    if (res < 0) {
 2655|      0|        obj = JS_NULL;
 2656|      0|    } else {
 2657|      0|        obj = JS_NewObject(ctx);
 2658|      0|        if (JS_IsException(obj))
 2659|      0|            return JS_EXCEPTION;
 2660|      0|        JS_DefinePropertyValueStr(ctx, obj, "dev",
 2661|      0|                                  JS_NewInt64(ctx, st.st_dev),
 2662|      0|                                  JS_PROP_C_W_E);
 2663|      0|        JS_DefinePropertyValueStr(ctx, obj, "ino",
 2664|      0|                                  JS_NewInt64(ctx, st.st_ino),
 2665|      0|                                  JS_PROP_C_W_E);
 2666|      0|        JS_DefinePropertyValueStr(ctx, obj, "mode",
 2667|      0|                                  JS_NewInt32(ctx, st.st_mode),
 2668|      0|                                  JS_PROP_C_W_E);
 2669|      0|        JS_DefinePropertyValueStr(ctx, obj, "nlink",
 2670|      0|                                  JS_NewInt64(ctx, st.st_nlink),
 2671|      0|                                  JS_PROP_C_W_E);
 2672|      0|        JS_DefinePropertyValueStr(ctx, obj, "uid",
 2673|      0|                                  JS_NewInt64(ctx, st.st_uid),
 2674|      0|                                  JS_PROP_C_W_E);
 2675|      0|        JS_DefinePropertyValueStr(ctx, obj, "gid",
 2676|      0|                                  JS_NewInt64(ctx, st.st_gid),
 2677|      0|                                  JS_PROP_C_W_E);
 2678|      0|        JS_DefinePropertyValueStr(ctx, obj, "rdev",
 2679|      0|                                  JS_NewInt64(ctx, st.st_rdev),
 2680|      0|                                  JS_PROP_C_W_E);
 2681|      0|        JS_DefinePropertyValueStr(ctx, obj, "size",
 2682|      0|                                  JS_NewInt64(ctx, st.st_size),
 2683|      0|                                  JS_PROP_C_W_E);
 2684|      0|#if !defined(_WIN32)
 2685|      0|        JS_DefinePropertyValueStr(ctx, obj, "blocks",
 2686|      0|                                  JS_NewInt64(ctx, st.st_blocks),
 2687|      0|                                  JS_PROP_C_W_E);
 2688|      0|#endif
 2689|       |#if defined(_WIN32)
 2690|       |        JS_DefinePropertyValueStr(ctx, obj, "atime",
 2691|       |                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),
 2692|       |                                  JS_PROP_C_W_E);
 2693|       |        JS_DefinePropertyValueStr(ctx, obj, "mtime",
 2694|       |                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),
 2695|       |                                  JS_PROP_C_W_E);
 2696|       |        JS_DefinePropertyValueStr(ctx, obj, "ctime",
 2697|       |                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),
 2698|       |                                  JS_PROP_C_W_E);
 2699|       |#elif defined(__APPLE__)
 2700|       |        JS_DefinePropertyValueStr(ctx, obj, "atime",
 2701|       |                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),
 2702|       |                                  JS_PROP_C_W_E);
 2703|       |        JS_DefinePropertyValueStr(ctx, obj, "mtime",
 2704|       |                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtimespec)),
 2705|       |                                  JS_PROP_C_W_E);
 2706|       |        JS_DefinePropertyValueStr(ctx, obj, "ctime",
 2707|       |                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctimespec)),
 2708|       |                                  JS_PROP_C_W_E);
 2709|       |#else
 2710|      0|        JS_DefinePropertyValueStr(ctx, obj, "atime",
 2711|      0|                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atim)),
 2712|      0|                                  JS_PROP_C_W_E);
 2713|      0|        JS_DefinePropertyValueStr(ctx, obj, "mtime",
 2714|      0|                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtim)),
 2715|      0|                                  JS_PROP_C_W_E);
 2716|      0|        JS_DefinePropertyValueStr(ctx, obj, "ctime",
 2717|      0|                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctim)),
 2718|      0|                                  JS_PROP_C_W_E);
 2719|      0|#endif
 2720|      0|    }
 2721|      0|    return make_obj_error(ctx, obj, err);
 2722|      0|}
 2723|       |
 2724|       |#if !defined(_WIN32)
 2725|       |static void ms_to_timeval(struct timeval *tv, uint64_t v)
 2726|      0|{
 2727|      0|    tv->tv_sec = v / 1000;
 2728|      0|    tv->tv_usec = (v % 1000) * 1000;
 2729|      0|}
 2730|       |#endif
 2731|       |
 2732|       |static JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,
 2733|       |                            int argc, JSValueConst *argv)
 2734|      0|{
 2735|      0|    const char *path;
 2736|      0|    int64_t atime, mtime;
 2737|      0|    int ret;
 2738|       |
 2739|      0|    if (JS_ToInt64(ctx, &atime, argv[1]))
 2740|      0|        return JS_EXCEPTION;
 2741|      0|    if (JS_ToInt64(ctx, &mtime, argv[2]))
 2742|      0|        return JS_EXCEPTION;
 2743|      0|    path = JS_ToCString(ctx, argv[0]);
 2744|      0|    if (!path)
 2745|      0|        return JS_EXCEPTION;
 2746|       |#if defined(_WIN32)
 2747|       |    {
 2748|       |        struct _utimbuf times;
 2749|       |        times.actime = atime / 1000;
 2750|       |        times.modtime = mtime / 1000;
 2751|       |        ret = js_get_errno(_utime(path, &times));
 2752|       |    }
 2753|       |#else
 2754|      0|    {
 2755|      0|        struct timeval times[2];
 2756|      0|        ms_to_timeval(&times[0], atime);
 2757|      0|        ms_to_timeval(&times[1], mtime);
 2758|      0|        ret = js_get_errno(utimes(path, times));
 2759|      0|    }
 2760|      0|#endif
 2761|      0|    JS_FreeCString(ctx, path);
 2762|      0|    return JS_NewInt32(ctx, ret);
 2763|      0|}
 2764|       |
 2765|       |/* sleep(delay_ms) */
 2766|       |static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
 2767|       |                           int argc, JSValueConst *argv)
 2768|      0|{
 2769|      0|    int64_t delay;
 2770|      0|    int ret;
 2771|       |
 2772|      0|    if (JS_ToInt64(ctx, &delay, argv[0]))
 2773|      0|        return JS_EXCEPTION;
 2774|      0|    if (delay < 0)
 2775|      0|        delay = 0;
 2776|       |#if defined(_WIN32)
 2777|       |    {
 2778|       |        if (delay > INT32_MAX)
 2779|       |            delay = INT32_MAX;
 2780|       |        Sleep(delay);
 2781|       |        ret = 0;
 2782|       |    }
 2783|       |#else
 2784|      0|    {
 2785|      0|        struct timespec ts;
 2786|       |
 2787|      0|        ts.tv_sec = delay / 1000;
 2788|      0|        ts.tv_nsec = (delay % 1000) * 1000000;
 2789|      0|        ret = js_get_errno(nanosleep(&ts, NULL));
 2790|      0|    }
 2791|      0|#endif
 2792|      0|    return JS_NewInt32(ctx, ret);
 2793|      0|}
 2794|       |
 2795|       |#if defined(_WIN32)
 2796|       |static char *realpath(const char *path, char *buf)
 2797|       |{
 2798|       |    if (!_fullpath(buf, path, PATH_MAX)) {
 2799|       |        errno = ENOENT;
 2800|       |        return NULL;
 2801|       |    } else {
 2802|       |        return buf;
 2803|       |    }
 2804|       |}
 2805|       |#endif
 2806|       |
 2807|       |/* return [path, errorcode] */
 2808|       |static JSValue js_os_realpath(JSContext *ctx, JSValueConst this_val,
 2809|       |                              int argc, JSValueConst *argv)
 2810|      0|{
 2811|      0|    const char *path;
 2812|      0|    char buf[PATH_MAX], *res;
 2813|      0|    int err;
 2814|       |
 2815|      0|    path = JS_ToCString(ctx, argv[0]);
 2816|      0|    if (!path)
 2817|      0|        return JS_EXCEPTION;
 2818|      0|    res = realpath(path, buf);
 2819|      0|    JS_FreeCString(ctx, path);
 2820|      0|    if (!res) {
 2821|      0|        buf[0] = '\0';
 2822|      0|        err = errno;
 2823|      0|    } else {
 2824|      0|        err = 0;
 2825|      0|    }
 2826|      0|    return make_string_error(ctx, buf, err);
 2827|      0|}
 2828|       |
 2829|       |#if !defined(_WIN32)
 2830|       |static JSValue js_os_symlink(JSContext *ctx, JSValueConst this_val,
 2831|       |                             int argc, JSValueConst *argv)
 2832|      0|{
 2833|      0|    const char *target, *linkpath;
 2834|      0|    int err;
 2835|       |
 2836|      0|    target = JS_ToCString(ctx, argv[0]);
 2837|      0|    if (!target)
 2838|      0|        return JS_EXCEPTION;
 2839|      0|    linkpath = JS_ToCString(ctx, argv[1]);
 2840|      0|    if (!linkpath) {
 2841|      0|        JS_FreeCString(ctx, target);
 2842|      0|        return JS_EXCEPTION;
 2843|      0|    }
 2844|      0|    err = js_get_errno(symlink(target, linkpath));
 2845|      0|    JS_FreeCString(ctx, target);
 2846|      0|    JS_FreeCString(ctx, linkpath);
 2847|      0|    return JS_NewInt32(ctx, err);
 2848|      0|}
 2849|       |
 2850|       |/* return [path, errorcode] */
 2851|       |static JSValue js_os_readlink(JSContext *ctx, JSValueConst this_val,
 2852|       |                              int argc, JSValueConst *argv)
 2853|      0|{
 2854|      0|    const char *path;
 2855|      0|    char buf[PATH_MAX];
 2856|      0|    int err;
 2857|      0|    ssize_t res;
 2858|       |
 2859|      0|    path = JS_ToCString(ctx, argv[0]);
 2860|      0|    if (!path)
 2861|      0|        return JS_EXCEPTION;
 2862|      0|    res = readlink(path, buf, sizeof(buf) - 1);
 2863|      0|    if (res < 0) {
 2864|      0|        buf[0] = '\0';
 2865|      0|        err = errno;
 2866|      0|    } else {
 2867|      0|        buf[res] = '\0';
 2868|      0|        err = 0;
 2869|      0|    }
 2870|      0|    JS_FreeCString(ctx, path);
 2871|      0|    return make_string_error(ctx, buf, err);
 2872|      0|}
 2873|       |
 2874|       |static char **build_envp(JSContext *ctx, JSValueConst obj)
 2875|      0|{
 2876|      0|    uint32_t len, i;
 2877|      0|    JSPropertyEnum *tab;
 2878|      0|    char **envp, *pair;
 2879|      0|    const char *key, *str;
 2880|      0|    JSValue val;
 2881|      0|    size_t key_len, str_len;
 2882|       |
 2883|      0|    if (JS_GetOwnPropertyNames(ctx, &tab, &len, obj,
 2884|      0|                               JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY) < 0)
 2885|      0|        return NULL;
 2886|      0|    envp = js_mallocz(ctx, sizeof(envp[0]) * ((size_t)len + 1));
 2887|      0|    if (!envp)
 2888|      0|        goto fail;
 2889|      0|    for(i = 0; i < len; i++) {
 2890|      0|        val = JS_GetProperty(ctx, obj, tab[i].atom);
 2891|      0|        if (JS_IsException(val))
 2892|      0|            goto fail;
 2893|      0|        str = JS_ToCString(ctx, val);
 2894|      0|        JS_FreeValue(ctx, val);
 2895|      0|        if (!str)
 2896|      0|            goto fail;
 2897|      0|        key = JS_AtomToCString(ctx, tab[i].atom);
 2898|      0|        if (!key) {
 2899|      0|            JS_FreeCString(ctx, str);
 2900|      0|            goto fail;
 2901|      0|        }
 2902|      0|        key_len = strlen(key);
 2903|      0|        str_len = strlen(str);
 2904|      0|        pair = js_malloc(ctx, key_len + str_len + 2);
 2905|      0|        if (!pair) {
 2906|      0|            JS_FreeCString(ctx, key);
 2907|      0|            JS_FreeCString(ctx, str);
 2908|      0|            goto fail;
 2909|      0|        }
 2910|      0|        memcpy(pair, key, key_len);
 2911|      0|        pair[key_len] = '=';
 2912|      0|        memcpy(pair + key_len + 1, str, str_len);
 2913|      0|        pair[key_len + 1 + str_len] = '\0';
 2914|      0|        envp[i] = pair;
 2915|      0|        JS_FreeCString(ctx, key);
 2916|      0|        JS_FreeCString(ctx, str);
 2917|      0|    }
 2918|      0| done:
 2919|      0|    for(i = 0; i < len; i++)
 2920|      0|        JS_FreeAtom(ctx, tab[i].atom);
 2921|      0|    js_free(ctx, tab);
 2922|      0|    return envp;
 2923|      0| fail:
 2924|      0|    if (envp) {
 2925|      0|        for(i = 0; i < len; i++)
 2926|      0|            js_free(ctx, envp[i]);
 2927|      0|        js_free(ctx, envp);
 2928|      0|        envp = NULL;
 2929|      0|    }
 2930|      0|    goto done;
 2931|      0|}
 2932|       |
 2933|       |/* execvpe is not available on non GNU systems */
 2934|       |static int my_execvpe(const char *filename, char **argv, char **envp)
 2935|      0|{
 2936|      0|    char *path, *p, *p_next, *p1;
 2937|      0|    char buf[PATH_MAX];
 2938|      0|    size_t filename_len, path_len;
 2939|      0|    BOOL eacces_error;
 2940|       |
 2941|      0|    filename_len = strlen(filename);
 2942|      0|    if (filename_len == 0) {
 2943|      0|        errno = ENOENT;
 2944|      0|        return -1;
 2945|      0|    }
 2946|      0|    if (strchr(filename, '/'))
 2947|      0|        return execve(filename, argv, envp);
 2948|       |
 2949|      0|    path = getenv("PATH");
 2950|      0|    if (!path)
 2951|      0|        path = (char *)"/bin:/usr/bin";
 2952|      0|    eacces_error = FALSE;
 2953|      0|    p = path;
 2954|      0|    for(p = path; p != NULL; p = p_next) {
 2955|      0|        p1 = strchr(p, ':');
 2956|      0|        if (!p1) {
 2957|      0|            p_next = NULL;
 2958|      0|            path_len = strlen(p);
 2959|      0|        } else {
 2960|      0|            p_next = p1 + 1;
 2961|      0|            path_len = p1 - p;
 2962|      0|        }
 2963|       |        /* path too long */
 2964|      0|        if ((path_len + 1 + filename_len + 1) > PATH_MAX)
 2965|      0|            continue;
 2966|      0|        memcpy(buf, p, path_len);
 2967|      0|        buf[path_len] = '/';
 2968|      0|        memcpy(buf + path_len + 1, filename, filename_len);
 2969|      0|        buf[path_len + 1 + filename_len] = '\0';
 2970|       |
 2971|      0|        execve(buf, argv, envp);
 2972|       |
 2973|      0|        switch(errno) {
 2974|      0|        case EACCES:
 2975|      0|            eacces_error = TRUE;
 2976|      0|            break;
 2977|      0|        case ENOENT:
 2978|      0|        case ENOTDIR:
 2979|      0|            break;
 2980|      0|        default:
 2981|      0|            return -1;
 2982|      0|        }
 2983|      0|    }
 2984|      0|    if (eacces_error)
 2985|      0|        errno = EACCES;
 2986|      0|    return -1;
 2987|      0|}
 2988|       |
 2989|       |/* exec(args[, options]) -> exitcode */
 2990|       |static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
 2991|       |                          int argc, JSValueConst *argv)
 2992|      0|{
 2993|      0|    JSValueConst options, args = argv[0];
 2994|      0|    JSValue val, ret_val;
 2995|      0|    const char **exec_argv, *file = NULL, *str, *cwd = NULL;
 2996|      0|    char **envp = environ;
 2997|      0|    uint32_t exec_argc, i;
 2998|      0|    int ret, pid, status;
 2999|      0|    BOOL block_flag = TRUE, use_path = TRUE;
 3000|      0|    static const char *std_name[3] = { "stdin", "stdout", "stderr" };
 3001|      0|    int std_fds[3];
 3002|      0|    uint32_t uid = -1, gid = -1;
 3003|       |
 3004|      0|    val = JS_GetPropertyStr(ctx, args, "length");
 3005|      0|    if (JS_IsException(val))
 3006|      0|        return JS_EXCEPTION;
 3007|      0|    ret = JS_ToUint32(ctx, &exec_argc, val);
 3008|      0|    JS_FreeValue(ctx, val);
 3009|      0|    if (ret)
 3010|      0|        return JS_EXCEPTION;
 3011|       |    /* arbitrary limit to avoid overflow */
 3012|      0|    if (exec_argc < 1 || exec_argc > 65535) {
 3013|      0|        return JS_ThrowTypeError(ctx, "invalid number of arguments");
 3014|      0|    }
 3015|      0|    exec_argv = js_mallocz(ctx, sizeof(exec_argv[0]) * (exec_argc + 1));
 3016|      0|    if (!exec_argv)
 3017|      0|        return JS_EXCEPTION;
 3018|      0|    for(i = 0; i < exec_argc; i++) {
 3019|      0|        val = JS_GetPropertyUint32(ctx, args, i);
 3020|      0|        if (JS_IsException(val))
 3021|      0|            goto exception;
 3022|      0|        str = JS_ToCString(ctx, val);
 3023|      0|        JS_FreeValue(ctx, val);
 3024|      0|        if (!str)
 3025|      0|            goto exception;
 3026|      0|        exec_argv[i] = str;
 3027|      0|    }
 3028|      0|    exec_argv[exec_argc] = NULL;
 3029|       |
 3030|      0|    for(i = 0; i < 3; i++)
 3031|      0|        std_fds[i] = i;
 3032|       |
 3033|       |    /* get the options, if any */
 3034|      0|    if (argc >= 2) {
 3035|      0|        options = argv[1];
 3036|       |
 3037|      0|        if (get_bool_option(ctx, &block_flag, options, "block"))
 3038|      0|            goto exception;
 3039|      0|        if (get_bool_option(ctx, &use_path, options, "usePath"))
 3040|      0|            goto exception;
 3041|       |
 3042|      0|        val = JS_GetPropertyStr(ctx, options, "file");
 3043|      0|        if (JS_IsException(val))
 3044|      0|            goto exception;
 3045|      0|        if (!JS_IsUndefined(val)) {
 3046|      0|            file = JS_ToCString(ctx, val);
 3047|      0|            JS_FreeValue(ctx, val);
 3048|      0|            if (!file)
 3049|      0|                goto exception;
 3050|      0|        }
 3051|       |
 3052|      0|        val = JS_GetPropertyStr(ctx, options, "cwd");
 3053|      0|        if (JS_IsException(val))
 3054|      0|            goto exception;
 3055|      0|        if (!JS_IsUndefined(val)) {
 3056|      0|            cwd = JS_ToCString(ctx, val);
 3057|      0|            JS_FreeValue(ctx, val);
 3058|      0|            if (!cwd)
 3059|      0|                goto exception;
 3060|      0|        }
 3061|       |
 3062|       |        /* stdin/stdout/stderr handles */
 3063|      0|        for(i = 0; i < 3; i++) {
 3064|      0|            val = JS_GetPropertyStr(ctx, options, std_name[i]);
 3065|      0|            if (JS_IsException(val))
 3066|      0|                goto exception;
 3067|      0|            if (!JS_IsUndefined(val)) {
 3068|      0|                int fd;
 3069|      0|                ret = JS_ToInt32(ctx, &fd, val);
 3070|      0|                JS_FreeValue(ctx, val);
 3071|      0|                if (ret)
 3072|      0|                    goto exception;
 3073|      0|                std_fds[i] = fd;
 3074|      0|            }
 3075|      0|        }
 3076|       |
 3077|      0|        val = JS_GetPropertyStr(ctx, options, "env");
 3078|      0|        if (JS_IsException(val))
 3079|      0|            goto exception;
 3080|      0|        if (!JS_IsUndefined(val)) {
 3081|      0|            envp = build_envp(ctx, val);
 3082|      0|            JS_FreeValue(ctx, val);
 3083|      0|            if (!envp)
 3084|      0|                goto exception;
 3085|      0|        }
 3086|       |
 3087|      0|        val = JS_GetPropertyStr(ctx, options, "uid");
 3088|      0|        if (JS_IsException(val))
 3089|      0|            goto exception;
 3090|      0|        if (!JS_IsUndefined(val)) {
 3091|      0|            ret = JS_ToUint32(ctx, &uid, val);
 3092|      0|            JS_FreeValue(ctx, val);
 3093|      0|            if (ret)
 3094|      0|                goto exception;
 3095|      0|        }
 3096|       |
 3097|      0|        val = JS_GetPropertyStr(ctx, options, "gid");
 3098|      0|        if (JS_IsException(val))
 3099|      0|            goto exception;
 3100|      0|        if (!JS_IsUndefined(val)) {
 3101|      0|            ret = JS_ToUint32(ctx, &gid, val);
 3102|      0|            JS_FreeValue(ctx, val);
 3103|      0|            if (ret)
 3104|      0|                goto exception;
 3105|      0|        }
 3106|      0|    }
 3107|       |
 3108|      0|    pid = fork();
 3109|      0|    if (pid < 0) {
 3110|      0|        JS_ThrowTypeError(ctx, "fork error");
 3111|      0|        goto exception;
 3112|      0|    }
 3113|      0|    if (pid == 0) {
 3114|       |        /* child */
 3115|       |
 3116|       |        /* remap the stdin/stdout/stderr handles if necessary */
 3117|      0|        for(i = 0; i < 3; i++) {
 3118|      0|            if (std_fds[i] != i) {
 3119|      0|                if (dup2(std_fds[i], i) < 0)
 3120|      0|                    _exit(127);
 3121|      0|            }
 3122|      0|        }
 3123|      0|#if defined(HAVE_CLOSEFROM)
 3124|       |        /* closefrom() is available on many recent unix systems:
 3125|       |           Linux with glibc 2.34+, Solaris 9+, FreeBSD 7.3+,
 3126|       |           NetBSD 3.0+, OpenBSD 3.5+.
 3127|       |           Linux with the musl libc and macOS don't have it.
 3128|       |         */
 3129|       |
 3130|      0|        closefrom(3);
 3131|       |#else
 3132|       |        {
 3133|       |            /* Close the file handles manually, limit to 1024 to avoid
 3134|       |               costly loop on linux Alpine where sysconf(_SC_OPEN_MAX)
 3135|       |               returns a huge value 1048576.
 3136|       |               Patch inspired by nicolas-duteil-nova. See also:
 3137|       |               https://stackoverflow.com/questions/73229353/
 3138|       |               https://stackoverflow.com/questions/899038/#918469
 3139|       |             */
 3140|       |            int fd_max = min_int(sysconf(_SC_OPEN_MAX), 1024);
 3141|       |            for(i = 3; i < fd_max; i++)
 3142|       |                close(i);
 3143|       |        }
 3144|       |#endif
 3145|      0|        if (cwd) {
 3146|      0|            if (chdir(cwd) < 0)
 3147|      0|                _exit(127);
 3148|      0|        }
 3149|      0|        if (uid != -1) {
 3150|      0|            if (setuid(uid) < 0)
 3151|      0|                _exit(127);
 3152|      0|        }
 3153|      0|        if (gid != -1) {
 3154|      0|            if (setgid(gid) < 0)
 3155|      0|                _exit(127);
 3156|      0|        }
 3157|       |
 3158|      0|        if (!file)
 3159|      0|            file = exec_argv[0];
 3160|      0|        if (use_path)
 3161|      0|            ret = my_execvpe(file, (char **)exec_argv, envp);
 3162|      0|        else
 3163|      0|            ret = execve(file, (char **)exec_argv, envp);
 3164|      0|        _exit(127);
 3165|      0|    }
 3166|       |    /* parent */
 3167|      0|    if (block_flag) {
 3168|      0|        for(;;) {
 3169|      0|            ret = waitpid(pid, &status, 0);
 3170|      0|            if (ret == pid) {
 3171|      0|                if (WIFEXITED(status)) {
 3172|      0|                    ret = WEXITSTATUS(status);
 3173|      0|                    break;
 3174|      0|                } else if (WIFSIGNALED(status)) {
 3175|      0|                    ret = -WTERMSIG(status);
 3176|      0|                    break;
 3177|      0|                }
 3178|      0|            }
 3179|      0|        }
 3180|      0|    } else {
 3181|      0|        ret = pid;
 3182|      0|    }
 3183|      0|    ret_val = JS_NewInt32(ctx, ret);
 3184|      0| done:
 3185|      0|    JS_FreeCString(ctx, file);
 3186|      0|    JS_FreeCString(ctx, cwd);
 3187|      0|    for(i = 0; i < exec_argc; i++)
 3188|      0|        JS_FreeCString(ctx, exec_argv[i]);
 3189|      0|    js_free(ctx, exec_argv);
 3190|      0|    if (envp != environ) {
 3191|      0|        char **p;
 3192|      0|        p = envp;
 3193|      0|        while (*p != NULL) {
 3194|      0|            js_free(ctx, *p);
 3195|      0|            p++;
 3196|      0|        }
 3197|      0|        js_free(ctx, envp);
 3198|      0|    }
 3199|      0|    return ret_val;
 3200|      0| exception:
 3201|      0|    ret_val = JS_EXCEPTION;
 3202|      0|    goto done;
 3203|      0|}
 3204|       |
 3205|       |/* getpid() -> pid */
 3206|       |static JSValue js_os_getpid(JSContext *ctx, JSValueConst this_val,
 3207|       |                            int argc, JSValueConst *argv)
 3208|      0|{
 3209|      0|    return JS_NewInt32(ctx, getpid());
 3210|      0|}
 3211|       |
 3212|       |/* waitpid(pid, block) -> [pid, status] */
 3213|       |static JSValue js_os_waitpid(JSContext *ctx, JSValueConst this_val,
 3214|       |                             int argc, JSValueConst *argv)
 3215|      0|{
 3216|      0|    int pid, status, options, ret;
 3217|      0|    JSValue obj;
 3218|       |
 3219|      0|    if (JS_ToInt32(ctx, &pid, argv[0]))
 3220|      0|        return JS_EXCEPTION;
 3221|      0|    if (JS_ToInt32(ctx, &options, argv[1]))
 3222|      0|        return JS_EXCEPTION;
 3223|       |
 3224|      0|    ret = waitpid(pid, &status, options);
 3225|      0|    if (ret < 0) {
 3226|      0|        ret = -errno;
 3227|      0|        status = 0;
 3228|      0|    }
 3229|       |
 3230|      0|    obj = JS_NewArray(ctx);
 3231|      0|    if (JS_IsException(obj))
 3232|      0|        return obj;
 3233|      0|    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ret),
 3234|      0|                                 JS_PROP_C_W_E);
 3235|      0|    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, status),
 3236|      0|                                 JS_PROP_C_W_E);
 3237|      0|    return obj;
 3238|      0|}
 3239|       |
 3240|       |/* pipe() -> [read_fd, write_fd] or null if error */
 3241|       |static JSValue js_os_pipe(JSContext *ctx, JSValueConst this_val,
 3242|       |                          int argc, JSValueConst *argv)
 3243|      0|{
 3244|      0|    int pipe_fds[2], ret;
 3245|      0|    JSValue obj;
 3246|       |
 3247|      0|    ret = pipe(pipe_fds);
 3248|      0|    if (ret < 0)
 3249|      0|        return JS_NULL;
 3250|      0|    obj = JS_NewArray(ctx);
 3251|      0|    if (JS_IsException(obj))
 3252|      0|        return obj;
 3253|      0|    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, pipe_fds[0]),
 3254|      0|                                 JS_PROP_C_W_E);
 3255|      0|    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, pipe_fds[1]),
 3256|      0|                                 JS_PROP_C_W_E);
 3257|      0|    return obj;
 3258|      0|}
 3259|       |
 3260|       |/* kill(pid, sig) */
 3261|       |static JSValue js_os_kill(JSContext *ctx, JSValueConst this_val,
 3262|       |                          int argc, JSValueConst *argv)
 3263|      0|{
 3264|      0|    int pid, sig, ret;
 3265|       |
 3266|      0|    if (JS_ToInt32(ctx, &pid, argv[0]))
 3267|      0|        return JS_EXCEPTION;
 3268|      0|    if (JS_ToInt32(ctx, &sig, argv[1]))
 3269|      0|        return JS_EXCEPTION;
 3270|      0|    ret = js_get_errno(kill(pid, sig));
 3271|      0|    return JS_NewInt32(ctx, ret);
 3272|      0|}
 3273|       |
 3274|       |/* dup(fd) */
 3275|       |static JSValue js_os_dup(JSContext *ctx, JSValueConst this_val,
 3276|       |                         int argc, JSValueConst *argv)
 3277|      0|{
 3278|      0|    int fd, ret;
 3279|       |
 3280|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 3281|      0|        return JS_EXCEPTION;
 3282|      0|    ret = js_get_errno(dup(fd));
 3283|      0|    return JS_NewInt32(ctx, ret);
 3284|      0|}
 3285|       |
 3286|       |/* dup2(fd) */
 3287|       |static JSValue js_os_dup2(JSContext *ctx, JSValueConst this_val,
 3288|       |                         int argc, JSValueConst *argv)
 3289|      0|{
 3290|      0|    int fd, fd2, ret;
 3291|       |
 3292|      0|    if (JS_ToInt32(ctx, &fd, argv[0]))
 3293|      0|        return JS_EXCEPTION;
 3294|      0|    if (JS_ToInt32(ctx, &fd2, argv[1]))
 3295|      0|        return JS_EXCEPTION;
 3296|      0|    ret = js_get_errno(dup2(fd, fd2));
 3297|      0|    return JS_NewInt32(ctx, ret);
 3298|      0|}
 3299|       |
 3300|       |#endif /* !_WIN32 */
 3301|       |
 3302|       |#ifdef USE_WORKER
 3303|       |
 3304|       |/* Worker */
 3305|       |
 3306|       |typedef struct {
 3307|       |    JSWorkerMessagePipe *recv_pipe;
 3308|       |    JSWorkerMessagePipe *send_pipe;
 3309|       |    JSWorkerMessageHandler *msg_handler;
 3310|       |} JSWorkerData;
 3311|       |
 3312|       |typedef struct {
 3313|       |    char *filename; /* module filename */
 3314|       |    char *basename; /* module base name */
 3315|       |    JSWorkerMessagePipe *recv_pipe, *send_pipe;
 3316|       |    int strip_flags;
 3317|       |} WorkerFuncArgs;
 3318|       |
 3319|       |typedef struct {
 3320|       |    int ref_count;
 3321|       |    uint64_t buf[0];
 3322|       |} JSSABHeader;
 3323|       |
 3324|       |static JSClassID js_worker_class_id;
 3325|       |static JSContext *(*js_worker_new_context_func)(JSRuntime *rt);
 3326|       |
 3327|       |static int atomic_add_int(int *ptr, int v)
 3328|      0|{
 3329|      0|    return atomic_fetch_add((_Atomic(uint32_t) *)ptr, v) + v;
 3330|      0|}
 3331|       |
 3332|       |/* shared array buffer allocator */
 3333|       |static void *js_sab_alloc(void *opaque, size_t size)
 3334|      0|{
 3335|      0|    JSSABHeader *sab;
 3336|      0|    sab = malloc(sizeof(JSSABHeader) + size);
 3337|      0|    if (!sab)
 3338|      0|        return NULL;
 3339|      0|    sab->ref_count = 1;
 3340|      0|    return sab->buf;
 3341|      0|}
 3342|       |
 3343|       |static void js_sab_free(void *opaque, void *ptr)
 3344|      0|{
 3345|      0|    JSSABHeader *sab;
 3346|      0|    int ref_count;
 3347|      0|    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));
 3348|      0|    ref_count = atomic_add_int(&sab->ref_count, -1);
 3349|      0|    assert(ref_count >= 0);
 3350|      0|    if (ref_count == 0) {
 3351|      0|        free(sab);
 3352|      0|    }
 3353|      0|}
 3354|       |
 3355|       |static void js_sab_dup(void *opaque, void *ptr)
 3356|      0|{
 3357|      0|    JSSABHeader *sab;
 3358|      0|    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));
 3359|      0|    atomic_add_int(&sab->ref_count, 1);
 3360|      0|}
 3361|       |
 3362|       |static JSWorkerMessagePipe *js_new_message_pipe(void)
 3363|      0|{
 3364|      0|    JSWorkerMessagePipe *ps;
 3365|       |
 3366|      0|    ps = malloc(sizeof(*ps));
 3367|      0|    if (!ps)
 3368|      0|        return NULL;
 3369|      0|    if (js_waker_init(&ps->waker)) {
 3370|      0|        free(ps);
 3371|      0|        return NULL;
 3372|      0|    }
 3373|      0|    ps->ref_count = 1;
 3374|      0|    init_list_head(&ps->msg_queue);
 3375|      0|    pthread_mutex_init(&ps->mutex, NULL);
 3376|      0|    return ps;
 3377|      0|}
 3378|       |
 3379|       |static JSWorkerMessagePipe *js_dup_message_pipe(JSWorkerMessagePipe *ps)
 3380|      0|{
 3381|      0|    atomic_add_int(&ps->ref_count, 1);
 3382|      0|    return ps;
 3383|      0|}
 3384|       |
 3385|       |static void js_free_message(JSWorkerMessage *msg)
 3386|      0|{
 3387|      0|    size_t i;
 3388|       |    /* free the SAB */
 3389|      0|    for(i = 0; i < msg->sab_tab_len; i++) {
 3390|      0|        js_sab_free(NULL, msg->sab_tab[i]);
 3391|      0|    }
 3392|      0|    free(msg->sab_tab);
 3393|      0|    free(msg->data);
 3394|      0|    free(msg);
 3395|      0|}
 3396|       |
 3397|       |static void js_free_message_pipe(JSWorkerMessagePipe *ps)
 3398|  34.8k|{
 3399|  34.8k|    struct list_head *el, *el1;
 3400|  34.8k|    JSWorkerMessage *msg;
 3401|  34.8k|    int ref_count;
 3402|       |
 3403|  34.8k|    if (!ps)
 3404|  34.8k|        return;
 3405|       |
 3406|      0|    ref_count = atomic_add_int(&ps->ref_count, -1);
 3407|      0|    assert(ref_count >= 0);
 3408|      0|    if (ref_count == 0) {
 3409|      0|        list_for_each_safe(el, el1, &ps->msg_queue) {
 3410|      0|            msg = list_entry(el, JSWorkerMessage, link);
 3411|      0|            js_free_message(msg);
 3412|      0|        }
 3413|      0|        pthread_mutex_destroy(&ps->mutex);
 3414|      0|        js_waker_close(&ps->waker);
 3415|      0|        free(ps);
 3416|      0|    }
 3417|      0|}
 3418|       |
 3419|       |static void js_free_port(JSRuntime *rt, JSWorkerMessageHandler *port)
 3420|      0|{
 3421|      0|    if (port) {
 3422|      0|        js_free_message_pipe(port->recv_pipe);
 3423|      0|        JS_FreeValueRT(rt, port->on_message_func);
 3424|      0|        list_del(&port->link);
 3425|      0|        js_free_rt(rt, port);
 3426|      0|    }
 3427|      0|}
 3428|       |
 3429|       |static void js_worker_finalizer(JSRuntime *rt, JSValue val)
 3430|      0|{
 3431|      0|    JSWorkerData *worker = JS_GetOpaque(val, js_worker_class_id);
 3432|      0|    if (worker) {
 3433|      0|        js_free_message_pipe(worker->recv_pipe);
 3434|      0|        js_free_message_pipe(worker->send_pipe);
 3435|      0|        js_free_port(rt, worker->msg_handler);
 3436|      0|        js_free_rt(rt, worker);
 3437|      0|    }
 3438|      0|}
 3439|       |
 3440|       |static JSClassDef js_worker_class = {
 3441|       |    "Worker",
 3442|       |    .finalizer = js_worker_finalizer,
 3443|       |};
 3444|       |
 3445|       |static void *worker_func(void *opaque)
 3446|      0|{
 3447|      0|    WorkerFuncArgs *args = opaque;
 3448|      0|    JSRuntime *rt;
 3449|      0|    JSThreadState *ts;
 3450|      0|    JSContext *ctx;
 3451|      0|    JSValue val;
 3452|       |
 3453|      0|    rt = JS_NewRuntime();
 3454|      0|    if (rt == NULL) {
 3455|      0|        fprintf(stderr, "JS_NewRuntime failure");
 3456|      0|        exit(1);
 3457|      0|    }
 3458|      0|    JS_SetStripInfo(rt, args->strip_flags);
 3459|      0|    js_std_init_handlers(rt);
 3460|       |
 3461|      0|    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);
 3462|       |
 3463|       |    /* set the pipe to communicate with the parent */
 3464|      0|    ts = JS_GetRuntimeOpaque(rt);
 3465|      0|    ts->recv_pipe = args->recv_pipe;
 3466|      0|    ts->send_pipe = args->send_pipe;
 3467|       |
 3468|       |    /* function pointer to avoid linking the whole JS_NewContext() if
 3469|       |       not needed */
 3470|      0|    ctx = js_worker_new_context_func(rt);
 3471|      0|    if (ctx == NULL) {
 3472|      0|        fprintf(stderr, "JS_NewContext failure");
 3473|      0|    }
 3474|       |
 3475|      0|    JS_SetCanBlock(rt, TRUE);
 3476|       |
 3477|      0|    js_std_add_helpers(ctx, -1, NULL);
 3478|       |
 3479|      0|    val = JS_LoadModule(ctx, args->basename, args->filename);
 3480|      0|    free(args->filename);
 3481|      0|    free(args->basename);
 3482|      0|    free(args);
 3483|      0|    val = js_std_await(ctx, val);
 3484|      0|    if (JS_IsException(val))
 3485|      0|        js_std_dump_error(ctx);
 3486|      0|    JS_FreeValue(ctx, val);
 3487|       |
 3488|      0|    js_std_loop(ctx);
 3489|       |
 3490|      0|    JS_FreeContext(ctx);
 3491|      0|    js_std_free_handlers(rt);
 3492|      0|    JS_FreeRuntime(rt);
 3493|      0|    return NULL;
 3494|      0|}
 3495|       |
 3496|       |static JSValue js_worker_ctor_internal(JSContext *ctx, JSValueConst new_target,
 3497|       |                                       JSWorkerMessagePipe *recv_pipe,
 3498|       |                                       JSWorkerMessagePipe *send_pipe)
 3499|      0|{
 3500|      0|    JSValue obj = JS_UNDEFINED, proto;
 3501|      0|    JSWorkerData *s;
 3502|       |
 3503|       |    /* create the object */
 3504|      0|    if (JS_IsUndefined(new_target)) {
 3505|      0|        proto = JS_GetClassProto(ctx, js_worker_class_id);
 3506|      0|    } else {
 3507|      0|        proto = JS_GetPropertyStr(ctx, new_target, "prototype");
 3508|      0|        if (JS_IsException(proto))
 3509|      0|            goto fail;
 3510|      0|    }
 3511|      0|    obj = JS_NewObjectProtoClass(ctx, proto, js_worker_class_id);
 3512|      0|    JS_FreeValue(ctx, proto);
 3513|      0|    if (JS_IsException(obj))
 3514|      0|        goto fail;
 3515|      0|    s = js_mallocz(ctx, sizeof(*s));
 3516|      0|    if (!s)
 3517|      0|        goto fail;
 3518|      0|    s->recv_pipe = js_dup_message_pipe(recv_pipe);
 3519|      0|    s->send_pipe = js_dup_message_pipe(send_pipe);
 3520|       |
 3521|      0|    JS_SetOpaque(obj, s);
 3522|      0|    return obj;
 3523|      0| fail:
 3524|      0|    JS_FreeValue(ctx, obj);
 3525|      0|    return JS_EXCEPTION;
 3526|      0|}
 3527|       |
 3528|       |static JSValue js_worker_ctor(JSContext *ctx, JSValueConst new_target,
 3529|       |                              int argc, JSValueConst *argv)
 3530|      0|{
 3531|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 3532|      0|    WorkerFuncArgs *args = NULL;
 3533|      0|    pthread_t tid;
 3534|      0|    pthread_attr_t attr;
 3535|      0|    JSValue obj = JS_UNDEFINED;
 3536|      0|    int ret;
 3537|      0|    const char *filename = NULL, *basename;
 3538|      0|    JSAtom basename_atom;
 3539|       |
 3540|       |    /* XXX: in order to avoid problems with resource liberation, we
 3541|       |       don't support creating workers inside workers */
 3542|      0|    if (!is_main_thread(rt))
 3543|      0|        return JS_ThrowTypeError(ctx, "cannot create a worker inside a worker");
 3544|       |
 3545|       |    /* base name, assuming the calling function is a normal JS
 3546|       |       function */
 3547|      0|    basename_atom = JS_GetScriptOrModuleName(ctx, 1);
 3548|      0|    if (basename_atom == JS_ATOM_NULL) {
 3549|      0|        return JS_ThrowTypeError(ctx, "could not determine calling script or module name");
 3550|      0|    }
 3551|      0|    basename = JS_AtomToCString(ctx, basename_atom);
 3552|      0|    JS_FreeAtom(ctx, basename_atom);
 3553|      0|    if (!basename)
 3554|      0|        goto fail;
 3555|       |
 3556|       |    /* module name */
 3557|      0|    filename = JS_ToCString(ctx, argv[0]);
 3558|      0|    if (!filename)
 3559|      0|        goto fail;
 3560|       |
 3561|      0|    args = malloc(sizeof(*args));
 3562|      0|    if (!args)
 3563|      0|        goto oom_fail;
 3564|      0|    memset(args, 0, sizeof(*args));
 3565|      0|    args->filename = strdup(filename);
 3566|      0|    args->basename = strdup(basename);
 3567|       |
 3568|       |    /* ports */
 3569|      0|    args->recv_pipe = js_new_message_pipe();
 3570|      0|    if (!args->recv_pipe)
 3571|      0|        goto oom_fail;
 3572|      0|    args->send_pipe = js_new_message_pipe();
 3573|      0|    if (!args->send_pipe)
 3574|      0|        goto oom_fail;
 3575|       |
 3576|      0|    args->strip_flags = JS_GetStripInfo(rt);
 3577|       |    
 3578|      0|    obj = js_worker_ctor_internal(ctx, new_target,
 3579|      0|                                  args->send_pipe, args->recv_pipe);
 3580|      0|    if (JS_IsException(obj))
 3581|      0|        goto fail;
 3582|       |
 3583|      0|    pthread_attr_init(&attr);
 3584|       |    /* no join at the end */
 3585|      0|    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 3586|      0|    ret = pthread_create(&tid, &attr, worker_func, args);
 3587|      0|    pthread_attr_destroy(&attr);
 3588|      0|    if (ret != 0) {
 3589|      0|        JS_ThrowTypeError(ctx, "could not create worker");
 3590|      0|        goto fail;
 3591|      0|    }
 3592|      0|    JS_FreeCString(ctx, basename);
 3593|      0|    JS_FreeCString(ctx, filename);
 3594|      0|    return obj;
 3595|      0| oom_fail:
 3596|      0|    JS_ThrowOutOfMemory(ctx);
 3597|      0| fail:
 3598|      0|    JS_FreeCString(ctx, basename);
 3599|      0|    JS_FreeCString(ctx, filename);
 3600|      0|    if (args) {
 3601|      0|        free(args->filename);
 3602|      0|        free(args->basename);
 3603|      0|        js_free_message_pipe(args->recv_pipe);
 3604|      0|        js_free_message_pipe(args->send_pipe);
 3605|      0|        free(args);
 3606|      0|    }
 3607|      0|    JS_FreeValue(ctx, obj);
 3608|      0|    return JS_EXCEPTION;
 3609|      0|}
 3610|       |
 3611|       |static JSValue js_worker_postMessage(JSContext *ctx, JSValueConst this_val,
 3612|       |                                     int argc, JSValueConst *argv)
 3613|      0|{
 3614|      0|    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
 3615|      0|    JSWorkerMessagePipe *ps;
 3616|      0|    size_t data_len, sab_tab_len, i;
 3617|      0|    uint8_t *data;
 3618|      0|    JSWorkerMessage *msg;
 3619|      0|    uint8_t **sab_tab;
 3620|       |
 3621|      0|    if (!worker)
 3622|      0|        return JS_EXCEPTION;
 3623|       |
 3624|      0|    data = JS_WriteObject2(ctx, &data_len, argv[0],
 3625|      0|                           JS_WRITE_OBJ_SAB | JS_WRITE_OBJ_REFERENCE,
 3626|      0|                           &sab_tab, &sab_tab_len);
 3627|      0|    if (!data)
 3628|      0|        return JS_EXCEPTION;
 3629|       |
 3630|      0|    msg = malloc(sizeof(*msg));
 3631|      0|    if (!msg)
 3632|      0|        goto fail;
 3633|      0|    msg->data = NULL;
 3634|      0|    msg->sab_tab = NULL;
 3635|       |
 3636|       |    /* must reallocate because the allocator may be different */
 3637|      0|    msg->data = malloc(data_len);
 3638|      0|    if (!msg->data)
 3639|      0|        goto fail;
 3640|      0|    memcpy(msg->data, data, data_len);
 3641|      0|    msg->data_len = data_len;
 3642|       |
 3643|      0|    if (sab_tab_len > 0) {
 3644|      0|        msg->sab_tab = malloc(sizeof(msg->sab_tab[0]) * sab_tab_len);
 3645|      0|        if (!msg->sab_tab)
 3646|      0|            goto fail;
 3647|      0|        memcpy(msg->sab_tab, sab_tab, sizeof(msg->sab_tab[0]) * sab_tab_len);
 3648|      0|    }
 3649|      0|    msg->sab_tab_len = sab_tab_len;
 3650|       |
 3651|      0|    js_free(ctx, data);
 3652|      0|    js_free(ctx, sab_tab);
 3653|       |
 3654|       |    /* increment the SAB reference counts */
 3655|      0|    for(i = 0; i < msg->sab_tab_len; i++) {
 3656|      0|        js_sab_dup(NULL, msg->sab_tab[i]);
 3657|      0|    }
 3658|       |
 3659|      0|    ps = worker->send_pipe;
 3660|      0|    pthread_mutex_lock(&ps->mutex);
 3661|       |    /* indicate that data is present */
 3662|      0|    if (list_empty(&ps->msg_queue))
 3663|      0|        js_waker_signal(&ps->waker);
 3664|      0|    list_add_tail(&msg->link, &ps->msg_queue);
 3665|      0|    pthread_mutex_unlock(&ps->mutex);
 3666|      0|    return JS_UNDEFINED;
 3667|      0| fail:
 3668|      0|    if (msg) {
 3669|      0|        free(msg->data);
 3670|      0|        free(msg->sab_tab);
 3671|      0|        free(msg);
 3672|      0|    }
 3673|      0|    js_free(ctx, data);
 3674|      0|    js_free(ctx, sab_tab);
 3675|      0|    return JS_EXCEPTION;
 3676|       |
 3677|      0|}
 3678|       |
 3679|       |static JSValue js_worker_set_onmessage(JSContext *ctx, JSValueConst this_val,
 3680|       |                                   JSValueConst func)
 3681|      0|{
 3682|      0|    JSRuntime *rt = JS_GetRuntime(ctx);
 3683|      0|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 3684|      0|    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
 3685|      0|    JSWorkerMessageHandler *port;
 3686|       |
 3687|      0|    if (!worker)
 3688|      0|        return JS_EXCEPTION;
 3689|       |
 3690|      0|    port = worker->msg_handler;
 3691|      0|    if (JS_IsNull(func)) {
 3692|      0|        if (port) {
 3693|      0|            js_free_port(rt, port);
 3694|      0|            worker->msg_handler = NULL;
 3695|      0|        }
 3696|      0|    } else {
 3697|      0|        if (!JS_IsFunction(ctx, func))
 3698|      0|            return JS_ThrowTypeError(ctx, "not a function");
 3699|      0|        if (!port) {
 3700|      0|            port = js_mallocz(ctx, sizeof(*port));
 3701|      0|            if (!port)
 3702|      0|                return JS_EXCEPTION;
 3703|      0|            port->recv_pipe = js_dup_message_pipe(worker->recv_pipe);
 3704|      0|            port->on_message_func = JS_NULL;
 3705|      0|            list_add_tail(&port->link, &ts->port_list);
 3706|      0|            worker->msg_handler = port;
 3707|      0|        }
 3708|      0|        JS_FreeValue(ctx, port->on_message_func);
 3709|      0|        port->on_message_func = JS_DupValue(ctx, func);
 3710|      0|    }
 3711|      0|    return JS_UNDEFINED;
 3712|      0|}
 3713|       |
 3714|       |static JSValue js_worker_get_onmessage(JSContext *ctx, JSValueConst this_val)
 3715|      0|{
 3716|      0|    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
 3717|      0|    JSWorkerMessageHandler *port;
 3718|      0|    if (!worker)
 3719|      0|        return JS_EXCEPTION;
 3720|      0|    port = worker->msg_handler;
 3721|      0|    if (port) {
 3722|      0|        return JS_DupValue(ctx, port->on_message_func);
 3723|      0|    } else {
 3724|      0|        return JS_NULL;
 3725|      0|    }
 3726|      0|}
 3727|       |
 3728|       |static const JSCFunctionListEntry js_worker_proto_funcs[] = {
 3729|       |    JS_CFUNC_DEF("postMessage", 1, js_worker_postMessage ),
 3730|       |    JS_CGETSET_DEF("onmessage", js_worker_get_onmessage, js_worker_set_onmessage ),
 3731|       |};
 3732|       |
 3733|       |#endif /* USE_WORKER */
 3734|       |
 3735|       |void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt))
 3736|  17.7k|{
 3737|  17.7k|#ifdef USE_WORKER
 3738|  17.7k|    js_worker_new_context_func = func;
 3739|  17.7k|#endif
 3740|  17.7k|}
 3741|       |
 3742|       |#if defined(_WIN32)
 3743|       |#define OS_PLATFORM "win32"
 3744|       |#elif defined(__APPLE__)
 3745|       |#define OS_PLATFORM "darwin"
 3746|       |#elif defined(EMSCRIPTEN)
 3747|       |#define OS_PLATFORM "js"
 3748|       |#else
 3749|       |#define OS_PLATFORM "linux"
 3750|       |#endif
 3751|       |
 3752|       |#define OS_FLAG(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
 3753|       |
 3754|       |static const JSCFunctionListEntry js_os_funcs[] = {
 3755|       |    JS_CFUNC_DEF("open", 2, js_os_open ),
 3756|       |    OS_FLAG(O_RDONLY),
 3757|       |    OS_FLAG(O_WRONLY),
 3758|       |    OS_FLAG(O_RDWR),
 3759|       |    OS_FLAG(O_APPEND),
 3760|       |    OS_FLAG(O_CREAT),
 3761|       |    OS_FLAG(O_EXCL),
 3762|       |    OS_FLAG(O_TRUNC),
 3763|       |#if defined(_WIN32)
 3764|       |    OS_FLAG(O_BINARY),
 3765|       |    OS_FLAG(O_TEXT),
 3766|       |#endif
 3767|       |    JS_CFUNC_DEF("close", 1, js_os_close ),
 3768|       |    JS_CFUNC_DEF("seek", 3, js_os_seek ),
 3769|       |    JS_CFUNC_MAGIC_DEF("read", 4, js_os_read_write, 0 ),
 3770|       |    JS_CFUNC_MAGIC_DEF("write", 4, js_os_read_write, 1 ),
 3771|       |    JS_CFUNC_DEF("isatty", 1, js_os_isatty ),
 3772|       |    JS_CFUNC_DEF("ttyGetWinSize", 1, js_os_ttyGetWinSize ),
 3773|       |    JS_CFUNC_DEF("ttySetRaw", 1, js_os_ttySetRaw ),
 3774|       |    JS_CFUNC_DEF("remove", 1, js_os_remove ),
 3775|       |    JS_CFUNC_DEF("rename", 2, js_os_rename ),
 3776|       |    JS_CFUNC_MAGIC_DEF("setReadHandler", 2, js_os_setReadHandler, 0 ),
 3777|       |    JS_CFUNC_MAGIC_DEF("setWriteHandler", 2, js_os_setReadHandler, 1 ),
 3778|       |    JS_CFUNC_DEF("signal", 2, js_os_signal ),
 3779|       |    OS_FLAG(SIGINT),
 3780|       |    OS_FLAG(SIGABRT),
 3781|       |    OS_FLAG(SIGFPE),
 3782|       |    OS_FLAG(SIGILL),
 3783|       |    OS_FLAG(SIGSEGV),
 3784|       |    OS_FLAG(SIGTERM),
 3785|       |#if !defined(_WIN32)
 3786|       |    OS_FLAG(SIGQUIT),
 3787|       |    OS_FLAG(SIGPIPE),
 3788|       |    OS_FLAG(SIGALRM),
 3789|       |    OS_FLAG(SIGUSR1),
 3790|       |    OS_FLAG(SIGUSR2),
 3791|       |    OS_FLAG(SIGCHLD),
 3792|       |    OS_FLAG(SIGCONT),
 3793|       |    OS_FLAG(SIGSTOP),
 3794|       |    OS_FLAG(SIGTSTP),
 3795|       |    OS_FLAG(SIGTTIN),
 3796|       |    OS_FLAG(SIGTTOU),
 3797|       |#endif
 3798|       |    JS_CFUNC_DEF("now", 0, js_os_now ),
 3799|       |    JS_CFUNC_DEF("setTimeout", 2, js_os_setTimeout ),
 3800|       |    JS_CFUNC_DEF("clearTimeout", 1, js_os_clearTimeout ),
 3801|       |    JS_CFUNC_DEF("sleepAsync", 1, js_os_sleepAsync ),
 3802|       |    JS_PROP_STRING_DEF("platform", OS_PLATFORM, 0 ),
 3803|       |    JS_CFUNC_DEF("getcwd", 0, js_os_getcwd ),
 3804|       |    JS_CFUNC_DEF("chdir", 0, js_os_chdir ),
 3805|       |    JS_CFUNC_DEF("mkdir", 1, js_os_mkdir ),
 3806|       |    JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
 3807|       |    /* st_mode constants */
 3808|       |    OS_FLAG(S_IFMT),
 3809|       |    OS_FLAG(S_IFIFO),
 3810|       |    OS_FLAG(S_IFCHR),
 3811|       |    OS_FLAG(S_IFDIR),
 3812|       |    OS_FLAG(S_IFBLK),
 3813|       |    OS_FLAG(S_IFREG),
 3814|       |#if !defined(_WIN32)
 3815|       |    OS_FLAG(S_IFSOCK),
 3816|       |    OS_FLAG(S_IFLNK),
 3817|       |    OS_FLAG(S_ISGID),
 3818|       |    OS_FLAG(S_ISUID),
 3819|       |#endif
 3820|       |    JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
 3821|       |    JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
 3822|       |    JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
 3823|       |    JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
 3824|       |#if !defined(_WIN32)
 3825|       |    JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
 3826|       |    JS_CFUNC_DEF("symlink", 2, js_os_symlink ),
 3827|       |    JS_CFUNC_DEF("readlink", 1, js_os_readlink ),
 3828|       |    JS_CFUNC_DEF("exec", 1, js_os_exec ),
 3829|       |    JS_CFUNC_DEF("getpid", 0, js_os_getpid ),
 3830|       |    JS_CFUNC_DEF("waitpid", 2, js_os_waitpid ),
 3831|       |    OS_FLAG(WNOHANG),
 3832|       |    JS_CFUNC_DEF("pipe", 0, js_os_pipe ),
 3833|       |    JS_CFUNC_DEF("kill", 2, js_os_kill ),
 3834|       |    JS_CFUNC_DEF("dup", 1, js_os_dup ),
 3835|       |    JS_CFUNC_DEF("dup2", 2, js_os_dup2 ),
 3836|       |#endif
 3837|       |};
 3838|       |
 3839|       |static int js_os_init(JSContext *ctx, JSModuleDef *m)
 3840|      0|{
 3841|      0|    os_poll_func = js_os_poll;
 3842|       |
 3843|      0|#ifdef USE_WORKER
 3844|      0|    {
 3845|      0|        JSRuntime *rt = JS_GetRuntime(ctx);
 3846|      0|        JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 3847|      0|        JSValue proto, obj;
 3848|       |        /* Worker class */
 3849|      0|        JS_NewClassID(&js_worker_class_id);
 3850|      0|        JS_NewClass(JS_GetRuntime(ctx), js_worker_class_id, &js_worker_class);
 3851|      0|        proto = JS_NewObject(ctx);
 3852|      0|        JS_SetPropertyFunctionList(ctx, proto, js_worker_proto_funcs, countof(js_worker_proto_funcs));
 3853|       |
 3854|      0|        obj = JS_NewCFunction2(ctx, js_worker_ctor, "Worker", 1,
 3855|      0|                               JS_CFUNC_constructor, 0);
 3856|      0|        JS_SetConstructor(ctx, obj, proto);
 3857|       |
 3858|      0|        JS_SetClassProto(ctx, js_worker_class_id, proto);
 3859|       |
 3860|       |        /* set 'Worker.parent' if necessary */
 3861|      0|        if (ts->recv_pipe && ts->send_pipe) {
 3862|      0|            JS_DefinePropertyValueStr(ctx, obj, "parent",
 3863|      0|                                      js_worker_ctor_internal(ctx, JS_UNDEFINED, ts->recv_pipe, ts->send_pipe),
 3864|      0|                                      JS_PROP_C_W_E);
 3865|      0|        }
 3866|       |
 3867|      0|        JS_SetModuleExport(ctx, m, "Worker", obj);
 3868|      0|    }
 3869|      0|#endif /* USE_WORKER */
 3870|       |
 3871|      0|    return JS_SetModuleExportList(ctx, m, js_os_funcs,
 3872|      0|                                  countof(js_os_funcs));
 3873|      0|}
 3874|       |
 3875|       |JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name)
 3876|  17.7k|{
 3877|  17.7k|    JSModuleDef *m;
 3878|  17.7k|    m = JS_NewCModule(ctx, module_name, js_os_init);
 3879|  17.7k|    if (!m)
 3880|      0|        return NULL;
 3881|  17.7k|    JS_AddModuleExportList(ctx, m, js_os_funcs, countof(js_os_funcs));
 3882|  17.7k|#ifdef USE_WORKER
 3883|  17.7k|    JS_AddModuleExport(ctx, m, "Worker");
 3884|  17.7k|#endif
 3885|  17.7k|    return m;
 3886|  17.7k|}
 3887|       |
 3888|       |/**********************************************************/
 3889|       |
 3890|       |static JSValue js_print(JSContext *ctx, JSValueConst this_val,
 3891|       |                        int argc, JSValueConst *argv)
 3892|    584|{
 3893|    584|    int i;
 3894|    584|    const char *str;
 3895|    584|    size_t len;
 3896|       |
 3897|  28.8k|    for(i = 0; i < argc; i++) {
 3898|  28.2k|        if (i != 0)
 3899|  27.7k|            putchar(' ');
 3900|  28.2k|        str = JS_ToCStringLen(ctx, &len, argv[i]);
 3901|  28.2k|        if (!str)
 3902|      0|            return JS_EXCEPTION;
 3903|  28.2k|        fwrite(str, 1, len, stdout);
 3904|  28.2k|        JS_FreeCString(ctx, str);
 3905|  28.2k|    }
 3906|    584|    putchar('\n');
 3907|    584|    return JS_UNDEFINED;
 3908|    584|}
 3909|       |
 3910|       |static JSValue js_console_log(JSContext *ctx, JSValueConst this_val,
 3911|       |                              int argc, JSValueConst *argv)
 3912|    584|{
 3913|    584|    JSValue ret;
 3914|    584|    ret = js_print(ctx, this_val, argc, argv);
 3915|    584|    fflush(stdout);
 3916|    584|    return ret;
 3917|    584|}
 3918|       |
 3919|       |void js_std_add_helpers(JSContext *ctx, int argc, char **argv)
 3920|  17.7k|{
 3921|  17.7k|    JSValue global_obj, console, args, performance;
 3922|  17.7k|    int i;
 3923|       |
 3924|       |    /* XXX: should these global definitions be enumerable? */
 3925|  17.7k|    global_obj = JS_GetGlobalObject(ctx);
 3926|       |
 3927|  17.7k|    console = JS_NewObject(ctx);
 3928|  17.7k|    JS_SetPropertyStr(ctx, console, "log",
 3929|  17.7k|                      JS_NewCFunction(ctx, js_console_log, "log", 1));
 3930|  17.7k|    JS_SetPropertyStr(ctx, global_obj, "console", console);
 3931|       |
 3932|  17.7k|    performance = JS_NewObject(ctx);
 3933|  17.7k|    JS_SetPropertyStr(ctx, performance, "now",
 3934|  17.7k|                      JS_NewCFunction(ctx, js_os_now, "now", 0));
 3935|  17.7k|    JS_SetPropertyStr(ctx, global_obj, "performance", performance);
 3936|       |
 3937|       |    /* same methods as the mozilla JS shell */
 3938|  17.7k|    if (argc >= 0) {
 3939|  17.7k|        args = JS_NewArray(ctx);
 3940|  35.5k|        for(i = 0; i < argc; i++) {
 3941|  17.7k|            JS_SetPropertyUint32(ctx, args, i, JS_NewString(ctx, argv[i]));
 3942|  17.7k|        }
 3943|  17.7k|        JS_SetPropertyStr(ctx, global_obj, "scriptArgs", args);
 3944|  17.7k|    }
 3945|       |
 3946|  17.7k|    JS_SetPropertyStr(ctx, global_obj, "print",
 3947|  17.7k|                      JS_NewCFunction(ctx, js_print, "print", 1));
 3948|  17.7k|    JS_SetPropertyStr(ctx, global_obj, "__loadScript",
 3949|  17.7k|                      JS_NewCFunction(ctx, js_loadScript, "__loadScript", 1));
 3950|       |
 3951|  17.7k|    JS_FreeValue(ctx, global_obj);
 3952|  17.7k|}
 3953|       |
 3954|       |void js_std_init_handlers(JSRuntime *rt)
 3955|  17.7k|{
 3956|  17.7k|    JSThreadState *ts;
 3957|       |
 3958|  17.7k|    ts = malloc(sizeof(*ts));
 3959|  17.7k|    if (!ts) {
 3960|      0|        fprintf(stderr, "Could not allocate memory for the worker");
 3961|      0|        exit(1);
 3962|      0|    }
 3963|  17.7k|    memset(ts, 0, sizeof(*ts));
 3964|  17.7k|    init_list_head(&ts->os_rw_handlers);
 3965|  17.7k|    init_list_head(&ts->os_signal_handlers);
 3966|  17.7k|    init_list_head(&ts->os_timers);
 3967|  17.7k|    init_list_head(&ts->port_list);
 3968|  17.7k|    ts->next_timer_id = 1;
 3969|       |
 3970|  17.7k|    JS_SetRuntimeOpaque(rt, ts);
 3971|       |
 3972|  17.7k|#ifdef USE_WORKER
 3973|       |    /* set the SharedArrayBuffer memory handlers */
 3974|  17.7k|    {
 3975|  17.7k|        JSSharedArrayBufferFunctions sf;
 3976|  17.7k|        memset(&sf, 0, sizeof(sf));
 3977|  17.7k|        sf.sab_alloc = js_sab_alloc;
 3978|  17.7k|        sf.sab_free = js_sab_free;
 3979|  17.7k|        sf.sab_dup = js_sab_dup;
 3980|  17.7k|        JS_SetSharedArrayBufferFunctions(rt, &sf);
 3981|  17.7k|    }
 3982|  17.7k|#endif
 3983|  17.7k|}
 3984|       |
 3985|       |void js_std_free_handlers(JSRuntime *rt)
 3986|  17.4k|{
 3987|  17.4k|    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
 3988|  17.4k|    struct list_head *el, *el1;
 3989|       |
 3990|  17.4k|    list_for_each_safe(el, el1, &ts->os_rw_handlers) {
 3991|      0|        JSOSRWHandler *rh = list_entry(el, JSOSRWHandler, link);
 3992|      0|        free_rw_handler(rt, rh);
 3993|      0|    }
 3994|       |
 3995|  17.4k|    list_for_each_safe(el, el1, &ts->os_signal_handlers) {
 3996|      0|        JSOSSignalHandler *sh = list_entry(el, JSOSSignalHandler, link);
 3997|      0|        free_sh(rt, sh);
 3998|      0|    }
 3999|       |
 4000|  17.4k|    list_for_each_safe(el, el1, &ts->os_timers) {
 4001|      0|        JSOSTimer *th = list_entry(el, JSOSTimer, link);
 4002|      0|        free_timer(rt, th);
 4003|      0|    }
 4004|       |
 4005|  17.4k|#ifdef USE_WORKER
 4006|       |    /* XXX: free port_list ? */
 4007|  17.4k|    js_free_message_pipe(ts->recv_pipe);
 4008|  17.4k|    js_free_message_pipe(ts->send_pipe);
 4009|  17.4k|#endif
 4010|       |
 4011|  17.4k|    free(ts);
 4012|  17.4k|    JS_SetRuntimeOpaque(rt, NULL); /* fail safe */
 4013|  17.4k|}
 4014|       |
 4015|       |static void js_dump_obj(JSContext *ctx, FILE *f, JSValueConst val)
 4016|  28.5k|{
 4017|  28.5k|    const char *str;
 4018|       |
 4019|  28.5k|    str = JS_ToCString(ctx, val);
 4020|  28.5k|    if (str) {
 4021|  28.5k|        fprintf(f, "%s\n", str);
 4022|  28.5k|        JS_FreeCString(ctx, str);
 4023|  28.5k|    } else {
 4024|      0|        fprintf(f, "[exception]\n");
 4025|      0|    }
 4026|  28.5k|}
 4027|       |
 4028|       |static void js_std_dump_error1(JSContext *ctx, JSValueConst exception_val)
 4029|  14.3k|{
 4030|  14.3k|    JSValue val;
 4031|  14.3k|    BOOL is_error;
 4032|       |
 4033|  14.3k|    is_error = JS_IsError(ctx, exception_val);
 4034|  14.3k|    js_dump_obj(ctx, stderr, exception_val);
 4035|  14.3k|    if (is_error) {
 4036|  14.2k|        val = JS_GetPropertyStr(ctx, exception_val, "stack");
 4037|  14.2k|        if (!JS_IsUndefined(val)) {
 4038|  14.2k|            js_dump_obj(ctx, stderr, val);
 4039|  14.2k|        }
 4040|  14.2k|        JS_FreeValue(ctx, val);
 4041|  14.2k|    }
 4042|  14.3k|}
 4043|       |
 4044|       |void js_std_dump_error(JSContext *ctx)
 4045|  13.9k|{
 4046|  13.9k|    JSValue exception_val;
 4047|       |
 4048|  13.9k|    exception_val = JS_GetException(ctx);
 4049|  13.9k|    js_std_dump_error1(ctx, exception_val);
 4050|  13.9k|    JS_FreeValue(ctx, exception_val);
 4051|  13.9k|}
 4052|       |
 4053|       |void js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,
 4054|       |                                      JSValueConst reason,
 4055|       |                                      BOOL is_handled, void *opaque)
 4056|    352|{
 4057|    352|    if (!is_handled) {
 4058|    352|        fprintf(stderr, "Possibly unhandled promise rejection: ");
 4059|    352|        js_std_dump_error1(ctx, reason);
 4060|    352|        exit(1);
 4061|    352|    }
 4062|    352|}
 4063|       |
 4064|       |/* main loop which calls the user JS callbacks */
 4065|       |void js_std_loop(JSContext *ctx)
 4066|  3.46k|{
 4067|  3.46k|    JSContext *ctx1;
 4068|  3.46k|    int err;
 4069|       |
 4070|  3.46k|    for(;;) {
 4071|       |        /* execute the pending jobs */
 4072|  3.46k|        for(;;) {
 4073|  3.46k|            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
 4074|  3.46k|            if (err <= 0) {
 4075|  3.46k|                if (err < 0) {
 4076|      0|                    js_std_dump_error(ctx1);
 4077|      0|                }
 4078|  3.46k|                break;
 4079|  3.46k|            }
 4080|  3.46k|        }
 4081|       |
 4082|  3.46k|        if (!os_poll_func || os_poll_func(ctx))
 4083|  3.46k|            break;
 4084|  3.46k|    }
 4085|  3.46k|}
 4086|       |
 4087|       |/* Wait for a promise and execute pending jobs while waiting for
 4088|       |   it. Return the promise result or JS_EXCEPTION in case of promise
 4089|       |   rejection. */
 4090|       |JSValue js_std_await(JSContext *ctx, JSValue obj)
 4091|    533|{
 4092|    533|    JSValue ret;
 4093|    533|    int state;
 4094|       |
 4095|    533|    for(;;) {
 4096|    533|        state = JS_PromiseState(ctx, obj);
 4097|    533|        if (state == JS_PROMISE_FULFILLED) {
 4098|     15|            ret = JS_PromiseResult(ctx, obj);
 4099|     15|            JS_FreeValue(ctx, obj);
 4100|     15|            break;
 4101|    518|        } else if (state == JS_PROMISE_REJECTED) {
 4102|      0|            ret = JS_Throw(ctx, JS_PromiseResult(ctx, obj));
 4103|      0|            JS_FreeValue(ctx, obj);
 4104|      0|            break;
 4105|    518|        } else if (state == JS_PROMISE_PENDING) {
 4106|      0|            JSContext *ctx1;
 4107|      0|            int err;
 4108|      0|            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
 4109|      0|            if (err < 0) {
 4110|      0|                js_std_dump_error(ctx1);
 4111|      0|            }
 4112|      0|            if (os_poll_func)
 4113|      0|                os_poll_func(ctx);
 4114|    518|        } else {
 4115|       |            /* not a promise */
 4116|    518|            ret = obj;
 4117|    518|            break;
 4118|    518|        }
 4119|    533|    }
 4120|    533|    return ret;
 4121|    533|}
 4122|       |
 4123|       |void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
 4124|       |                        int load_only)
 4125|      0|{
 4126|      0|    JSValue obj, val;
 4127|      0|    obj = JS_ReadObject(ctx, buf, buf_len, JS_READ_OBJ_BYTECODE);
 4128|      0|    if (JS_IsException(obj))
 4129|      0|        goto exception;
 4130|      0|    if (load_only) {
 4131|      0|        if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
 4132|      0|            js_module_set_import_meta(ctx, obj, FALSE, FALSE);
 4133|      0|        }
 4134|      0|    } else {
 4135|      0|        if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
 4136|      0|            if (JS_ResolveModule(ctx, obj) < 0) {
 4137|      0|                JS_FreeValue(ctx, obj);
 4138|      0|                goto exception;
 4139|      0|            }
 4140|      0|            js_module_set_import_meta(ctx, obj, FALSE, TRUE);
 4141|      0|            val = JS_EvalFunction(ctx, obj);
 4142|      0|            val = js_std_await(ctx, val);
 4143|      0|        } else {
 4144|      0|            val = JS_EvalFunction(ctx, obj);
 4145|      0|        }
 4146|      0|        if (JS_IsException(val)) {
 4147|      0|        exception:
 4148|      0|            js_std_dump_error(ctx);
 4149|      0|            exit(1);
 4150|      0|        }
 4151|      0|        JS_FreeValue(ctx, val);
 4152|      0|    }
 4153|      0|}

/home/eugeneriabinin777/quickjs/quickjs-opcode.h:
    1|       |/*
    2|       | * QuickJS opcode definitions
    3|       | *
    4|       | * Copyright (c) 2017-2018 Fabrice Bellard
    5|       | * Copyright (c) 2017-2018 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |
   26|       |#ifdef FMT
   27|       |FMT(none)
   28|       |FMT(none_int)
   29|       |FMT(none_loc)
   30|       |FMT(none_arg)
   31|       |FMT(none_var_ref)
   32|       |FMT(u8)
   33|       |FMT(i8)
   34|       |FMT(loc8)
   35|       |FMT(const8)
   36|       |FMT(label8)
   37|       |FMT(u16)
   38|       |FMT(i16)
   39|       |FMT(label16)
   40|       |FMT(npop)
   41|       |FMT(npopx)
   42|       |FMT(npop_u16)
   43|       |FMT(loc)
   44|       |FMT(arg)
   45|       |FMT(var_ref)
   46|       |FMT(u32)
   47|       |FMT(i32)
   48|       |FMT(const)
   49|       |FMT(label)
   50|       |FMT(atom)
   51|       |FMT(atom_u8)
   52|       |FMT(atom_u16)
   53|       |FMT(atom_label_u8)
   54|       |FMT(atom_label_u16)
   55|       |FMT(label_u16)
   56|       |#undef FMT
   57|       |#endif /* FMT */
   58|       |
   59|  9.82M|#ifdef DEF
   60|       |
   61|       |#ifndef def
   62|       |#define def(id, size, n_pop, n_push, f) DEF(id, size, n_pop, n_push, f)
   63|       |#endif
   64|       |
   65|  9.82M|DEF(invalid, 1, 0, 0, none) /* never emitted */
   66|       |
   67|       |/* push values */
   68|  9.82M|DEF(       push_i32, 5, 0, 1, i32)
   69|  9.82M|DEF(     push_const, 5, 0, 1, const)
   70|  9.82M|DEF(       fclosure, 5, 0, 1, const) /* must follow push_const */
   71|  9.82M|DEF(push_atom_value, 5, 0, 1, atom)
   72|  9.82M|DEF( private_symbol, 5, 0, 1, atom)
   73|  9.82M|DEF(      undefined, 1, 0, 1, none)
   74|  9.82M|DEF(           null, 1, 0, 1, none)
   75|  9.82M|DEF(      push_this, 1, 0, 1, none) /* only used at the start of a function */
   76|  9.82M|DEF(     push_false, 1, 0, 1, none)
   77|  9.82M|DEF(      push_true, 1, 0, 1, none)
   78|  9.82M|DEF(         object, 1, 0, 1, none)
   79|  9.82M|DEF( special_object, 2, 0, 1, u8) /* only used at the start of a function */
   80|  9.82M|DEF(           rest, 3, 0, 1, u16) /* only used at the start of a function */
   81|       |
   82|  9.82M|DEF(           drop, 1, 1, 0, none) /* a -> */
   83|  9.82M|DEF(            nip, 1, 2, 1, none) /* a b -> b */
   84|  9.82M|DEF(           nip1, 1, 3, 2, none) /* a b c -> b c */
   85|  9.82M|DEF(            dup, 1, 1, 2, none) /* a -> a a */
   86|  9.82M|DEF(           dup1, 1, 2, 3, none) /* a b -> a a b */
   87|  9.82M|DEF(           dup2, 1, 2, 4, none) /* a b -> a b a b */
   88|  9.82M|DEF(           dup3, 1, 3, 6, none) /* a b c -> a b c a b c */
   89|  9.82M|DEF(        insert2, 1, 2, 3, none) /* obj a -> a obj a (dup_x1) */
   90|  9.82M|DEF(        insert3, 1, 3, 4, none) /* obj prop a -> a obj prop a (dup_x2) */
   91|  9.82M|DEF(        insert4, 1, 4, 5, none) /* this obj prop a -> a this obj prop a */
   92|  9.82M|DEF(          perm3, 1, 3, 3, none) /* obj a b -> a obj b */
   93|  9.82M|DEF(          perm4, 1, 4, 4, none) /* obj prop a b -> a obj prop b */
   94|  9.82M|DEF(          perm5, 1, 5, 5, none) /* this obj prop a b -> a this obj prop b */
   95|  9.82M|DEF(           swap, 1, 2, 2, none) /* a b -> b a */
   96|  9.82M|DEF(          swap2, 1, 4, 4, none) /* a b c d -> c d a b */
   97|  9.82M|DEF(          rot3l, 1, 3, 3, none) /* x a b -> a b x */
   98|  9.82M|DEF(          rot3r, 1, 3, 3, none) /* a b x -> x a b */
   99|  9.82M|DEF(          rot4l, 1, 4, 4, none) /* x a b c -> a b c x */
  100|  9.82M|DEF(          rot5l, 1, 5, 5, none) /* x a b c d -> a b c d x */
  101|       |
  102|  9.82M|DEF(call_constructor, 3, 2, 1, npop) /* func new.target args -> ret. arguments are not counted in n_pop */
  103|  9.82M|DEF(           call, 3, 1, 1, npop) /* arguments are not counted in n_pop */
  104|  9.82M|DEF(      tail_call, 3, 1, 0, npop) /* arguments are not counted in n_pop */
  105|  9.82M|DEF(    call_method, 3, 2, 1, npop) /* arguments are not counted in n_pop */
  106|  9.82M|DEF(tail_call_method, 3, 2, 0, npop) /* arguments are not counted in n_pop */
  107|  9.82M|DEF(     array_from, 3, 0, 1, npop) /* arguments are not counted in n_pop */
  108|  9.82M|DEF(          apply, 3, 3, 1, u16)
  109|  9.82M|DEF(         return, 1, 1, 0, none)
  110|  9.82M|DEF(   return_undef, 1, 0, 0, none)
  111|  9.82M|DEF(check_ctor_return, 1, 1, 2, none)
  112|  9.82M|DEF(     check_ctor, 1, 0, 0, none)
  113|  9.82M|DEF(      init_ctor, 1, 0, 1, none)
  114|  9.82M|DEF(    check_brand, 1, 2, 2, none) /* this_obj func -> this_obj func */
  115|  9.82M|DEF(      add_brand, 1, 2, 0, none) /* this_obj home_obj -> */
  116|  9.82M|DEF(   return_async, 1, 1, 0, none)
  117|  9.82M|DEF(          throw, 1, 1, 0, none)
  118|  9.82M|DEF(    throw_error, 6, 0, 0, atom_u8)
  119|  9.82M|DEF(           eval, 5, 1, 1, npop_u16) /* func args... -> ret_val */
  120|  9.82M|DEF(     apply_eval, 3, 2, 1, u16) /* func array -> ret_eval */
  121|  9.82M|DEF(         regexp, 1, 2, 1, none) /* create a RegExp object from the pattern and a
  122|       |                                       bytecode string */
  123|  9.82M|DEF(      get_super, 1, 1, 1, none)
  124|  9.82M|DEF(         import, 1, 1, 1, none) /* dynamic module import */
  125|       |
  126|  9.82M|DEF(      check_var, 5, 0, 1, atom) /* check if a variable exists */
  127|  9.82M|DEF(  get_var_undef, 5, 0, 1, atom) /* push undefined if the variable does not exist */
  128|  9.82M|DEF(        get_var, 5, 0, 1, atom) /* throw an exception if the variable does not exist */
  129|  9.82M|DEF(        put_var, 5, 1, 0, atom) /* must come after get_var */
  130|  9.82M|DEF(   put_var_init, 5, 1, 0, atom) /* must come after put_var. Used to initialize a global lexical variable */
  131|  9.82M|DEF( put_var_strict, 5, 2, 0, atom) /* for strict mode variable write */
  132|       |
  133|  9.82M|DEF(  get_ref_value, 1, 2, 3, none)
  134|  9.82M|DEF(  put_ref_value, 1, 3, 0, none)
  135|       |
  136|  9.82M|DEF(     define_var, 6, 0, 0, atom_u8)
  137|  9.82M|DEF(check_define_var, 6, 0, 0, atom_u8)
  138|  9.82M|DEF(    define_func, 6, 1, 0, atom_u8)
  139|  9.82M|DEF(      get_field, 5, 1, 1, atom)
  140|  9.82M|DEF(     get_field2, 5, 1, 2, atom)
  141|  9.82M|DEF(      put_field, 5, 2, 0, atom)
  142|  9.82M|DEF( get_private_field, 1, 2, 1, none) /* obj prop -> value */
  143|  9.82M|DEF( put_private_field, 1, 3, 0, none) /* obj value prop -> */
  144|  9.82M|DEF(define_private_field, 1, 3, 1, none) /* obj prop value -> obj */
  145|  9.82M|DEF(   get_array_el, 1, 2, 1, none)
  146|  9.82M|DEF(  get_array_el2, 1, 2, 2, none) /* obj prop -> obj value */
  147|  9.82M|DEF(   put_array_el, 1, 3, 0, none)
  148|  9.82M|DEF(get_super_value, 1, 3, 1, none) /* this obj prop -> value */
  149|  9.82M|DEF(put_super_value, 1, 4, 0, none) /* this obj prop value -> */
  150|  9.82M|DEF(   define_field, 5, 2, 1, atom)
  151|  9.82M|DEF(       set_name, 5, 1, 1, atom)
  152|  9.82M|DEF(set_name_computed, 1, 2, 2, none)
  153|  9.82M|DEF(      set_proto, 1, 2, 1, none)
  154|  9.82M|DEF(set_home_object, 1, 2, 2, none)
  155|  9.82M|DEF(define_array_el, 1, 3, 2, none)
  156|  9.82M|DEF(         append, 1, 3, 2, none) /* append enumerated object, update length */
  157|  9.82M|DEF(copy_data_properties, 2, 3, 3, u8)
  158|  9.82M|DEF(  define_method, 6, 2, 1, atom_u8)
  159|  9.82M|DEF(define_method_computed, 2, 3, 1, u8) /* must come after define_method */
  160|  9.82M|DEF(   define_class, 6, 2, 2, atom_u8) /* parent ctor -> ctor proto */
  161|  9.82M|DEF(   define_class_computed, 6, 3, 3, atom_u8) /* field_name parent ctor -> field_name ctor proto (class with computed name) */
  162|       |
  163|  9.82M|DEF(        get_loc, 3, 0, 1, loc)
  164|  9.82M|DEF(        put_loc, 3, 1, 0, loc) /* must come after get_loc */
  165|  9.82M|DEF(        set_loc, 3, 1, 1, loc) /* must come after put_loc */
  166|  9.82M|DEF(        get_arg, 3, 0, 1, arg)
  167|  9.82M|DEF(        put_arg, 3, 1, 0, arg) /* must come after get_arg */
  168|  9.82M|DEF(        set_arg, 3, 1, 1, arg) /* must come after put_arg */
  169|  9.82M|DEF(    get_var_ref, 3, 0, 1, var_ref)
  170|  9.82M|DEF(    put_var_ref, 3, 1, 0, var_ref) /* must come after get_var_ref */
  171|  9.82M|DEF(    set_var_ref, 3, 1, 1, var_ref) /* must come after put_var_ref */
  172|  9.82M|DEF(set_loc_uninitialized, 3, 0, 0, loc)
  173|  9.82M|DEF(  get_loc_check, 3, 0, 1, loc)
  174|  9.82M|DEF(  put_loc_check, 3, 1, 0, loc) /* must come after get_loc_check */
  175|  9.82M|DEF(  put_loc_check_init, 3, 1, 0, loc)
  176|  9.82M|DEF(get_loc_checkthis, 3, 0, 1, loc)
  177|  9.82M|DEF(get_var_ref_check, 3, 0, 1, var_ref)
  178|  9.82M|DEF(put_var_ref_check, 3, 1, 0, var_ref) /* must come after get_var_ref_check */
  179|  9.82M|DEF(put_var_ref_check_init, 3, 1, 0, var_ref)
  180|  9.82M|DEF(      close_loc, 3, 0, 0, loc)
  181|  9.82M|DEF(       if_false, 5, 1, 0, label)
  182|  9.82M|DEF(        if_true, 5, 1, 0, label) /* must come after if_false */
  183|  9.82M|DEF(           goto, 5, 0, 0, label) /* must come after if_true */
  184|  9.82M|DEF(          catch, 5, 0, 1, label)
  185|  9.82M|DEF(          gosub, 5, 0, 0, label) /* used to execute the finally block */
  186|  9.82M|DEF(            ret, 1, 1, 0, none) /* used to return from the finally block */
  187|  9.82M|DEF(      nip_catch, 1, 2, 1, none) /* catch ... a -> a */
  188|       |
  189|  9.82M|DEF(      to_object, 1, 1, 1, none)
  190|       |//DEF(      to_string, 1, 1, 1, none)
  191|  9.82M|DEF(     to_propkey, 1, 1, 1, none)
  192|  9.82M|DEF(    to_propkey2, 1, 2, 2, none)
  193|       |
  194|  9.82M|DEF(   with_get_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
  195|  9.82M|DEF(   with_put_var, 10, 2, 1, atom_label_u8)     /* must be in the same order as scope_xxx */
  196|  9.82M|DEF(with_delete_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
  197|  9.82M|DEF(  with_make_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
  198|  9.82M|DEF(   with_get_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
  199|       |
  200|  9.82M|DEF(   make_loc_ref, 7, 0, 2, atom_u16)
  201|  9.82M|DEF(   make_arg_ref, 7, 0, 2, atom_u16)
  202|  9.82M|DEF(make_var_ref_ref, 7, 0, 2, atom_u16)
  203|  9.82M|DEF(   make_var_ref, 5, 0, 2, atom)
  204|       |
  205|  9.82M|DEF(   for_in_start, 1, 1, 1, none)
  206|  9.82M|DEF(   for_of_start, 1, 1, 3, none)
  207|  9.82M|DEF(for_await_of_start, 1, 1, 3, none)
  208|  9.82M|DEF(    for_in_next, 1, 1, 3, none)
  209|  9.82M|DEF(    for_of_next, 2, 3, 5, u8)
  210|  9.82M|DEF(for_await_of_next, 1, 3, 4, none) /* iter next catch_offset -> iter next catch_offset obj */
  211|  9.82M|DEF(iterator_check_object, 1, 1, 1, none)
  212|  9.82M|DEF(iterator_get_value_done, 1, 2, 3, none) /* catch_offset obj -> catch_offset value done */
  213|  9.82M|DEF( iterator_close, 1, 3, 0, none)
  214|  9.82M|DEF(  iterator_next, 1, 4, 4, none)
  215|  9.82M|DEF(  iterator_call, 2, 4, 5, u8)
  216|  9.82M|DEF(  initial_yield, 1, 0, 0, none)
  217|  9.82M|DEF(          yield, 1, 1, 2, none)
  218|  9.82M|DEF(     yield_star, 1, 1, 2, none)
  219|  9.82M|DEF(async_yield_star, 1, 1, 2, none)
  220|  9.82M|DEF(          await, 1, 1, 1, none)
  221|       |
  222|       |/* arithmetic/logic operations */
  223|  9.82M|DEF(            neg, 1, 1, 1, none)
  224|  9.82M|DEF(           plus, 1, 1, 1, none)
  225|  9.82M|DEF(            dec, 1, 1, 1, none)
  226|  9.82M|DEF(            inc, 1, 1, 1, none)
  227|  9.82M|DEF(       post_dec, 1, 1, 2, none)
  228|  9.82M|DEF(       post_inc, 1, 1, 2, none)
  229|  9.82M|DEF(        dec_loc, 2, 0, 0, loc8)
  230|  9.82M|DEF(        inc_loc, 2, 0, 0, loc8)
  231|  9.82M|DEF(        add_loc, 2, 1, 0, loc8)
  232|  9.82M|DEF(            not, 1, 1, 1, none)
  233|  9.82M|DEF(           lnot, 1, 1, 1, none)
  234|  9.82M|DEF(         typeof, 1, 1, 1, none)
  235|  9.82M|DEF(         delete, 1, 2, 1, none)
  236|  9.82M|DEF(     delete_var, 5, 0, 1, atom)
  237|       |
  238|  9.82M|DEF(            mul, 1, 2, 1, none)
  239|  9.82M|DEF(            div, 1, 2, 1, none)
  240|  9.82M|DEF(            mod, 1, 2, 1, none)
  241|  9.82M|DEF(            add, 1, 2, 1, none)
  242|  9.82M|DEF(            sub, 1, 2, 1, none)
  243|  9.82M|DEF(            pow, 1, 2, 1, none)
  244|  9.82M|DEF(            shl, 1, 2, 1, none)
  245|  9.82M|DEF(            sar, 1, 2, 1, none)
  246|  9.82M|DEF(            shr, 1, 2, 1, none)
  247|  9.82M|DEF(             lt, 1, 2, 1, none)
  248|  9.82M|DEF(            lte, 1, 2, 1, none)
  249|  9.82M|DEF(             gt, 1, 2, 1, none)
  250|  9.82M|DEF(            gte, 1, 2, 1, none)
  251|  9.82M|DEF(     instanceof, 1, 2, 1, none)
  252|  9.82M|DEF(             in, 1, 2, 1, none)
  253|  9.82M|DEF(             eq, 1, 2, 1, none)
  254|  9.82M|DEF(            neq, 1, 2, 1, none)
  255|  9.82M|DEF(      strict_eq, 1, 2, 1, none)
  256|  9.82M|DEF(     strict_neq, 1, 2, 1, none)
  257|  9.82M|DEF(            and, 1, 2, 1, none)
  258|  9.82M|DEF(            xor, 1, 2, 1, none)
  259|  9.82M|DEF(             or, 1, 2, 1, none)
  260|  9.82M|DEF(is_undefined_or_null, 1, 1, 1, none)
  261|  9.82M|DEF(     private_in, 1, 2, 1, none)
  262|  9.82M|DEF(push_bigint_i32, 5, 0, 1, i32)
  263|       |/* must be the last non short and non temporary opcode */
  264|  9.82M|DEF(            nop, 1, 0, 0, none)
  265|       |
  266|       |/* temporary opcodes: never emitted in the final bytecode */
  267|       |
  268|  9.82M|def(    enter_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
  269|  9.82M|def(    leave_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
  270|       |
  271|  9.82M|def(          label, 5, 0, 0, label) /* emitted in phase 1, removed in phase 3 */
  272|       |
  273|       |/* the following opcodes must be in the same order as the 'with_x' and
  274|       |   get_var_undef, get_var and put_var opcodes */
  275|  9.82M|def(scope_get_var_undef, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
  276|  9.82M|def(  scope_get_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
  277|  9.82M|def(  scope_put_var, 7, 1, 0, atom_u16) /* emitted in phase 1, removed in phase 2 */
  278|  9.82M|def(scope_delete_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
  279|  9.82M|def( scope_make_ref, 11, 0, 2, atom_label_u16) /* emitted in phase 1, removed in phase 2 */
  280|  9.82M|def(  scope_get_ref, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
  281|  9.82M|def(scope_put_var_init, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
  282|  9.82M|def(scope_get_var_checkthis, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2, only used to return 'this' in derived class constructors */
  283|  9.82M|def(scope_get_private_field, 7, 1, 1, atom_u16) /* obj -> value, emitted in phase 1, removed in phase 2 */
  284|  9.82M|def(scope_get_private_field2, 7, 1, 2, atom_u16) /* obj -> obj value, emitted in phase 1, removed in phase 2 */
  285|  9.82M|def(scope_put_private_field, 7, 2, 0, atom_u16) /* obj value ->, emitted in phase 1, removed in phase 2 */
  286|  9.82M|def(scope_in_private_field, 7, 1, 1, atom_u16) /* obj -> res emitted in phase 1, removed in phase 2 */
  287|  9.82M|def(get_field_opt_chain, 5, 1, 1, atom) /* emitted in phase 1, removed in phase 2 */
  288|  9.82M|def(get_array_el_opt_chain, 1, 2, 1, none) /* emitted in phase 1, removed in phase 2 */
  289|  9.82M|def( set_class_name, 5, 1, 1, u32) /* emitted in phase 1, removed in phase 2 */
  290|       |
  291|  9.82M|def(       line_num, 5, 0, 0, u32) /* emitted in phase 1, removed in phase 3 */
  292|       |
  293|  9.82M|#if SHORT_OPCODES
  294|  9.82M|DEF(    push_minus1, 1, 0, 1, none_int)
  295|  9.82M|DEF(         push_0, 1, 0, 1, none_int)
  296|  9.82M|DEF(         push_1, 1, 0, 1, none_int)
  297|  9.82M|DEF(         push_2, 1, 0, 1, none_int)
  298|  9.82M|DEF(         push_3, 1, 0, 1, none_int)
  299|  9.82M|DEF(         push_4, 1, 0, 1, none_int)
  300|  9.82M|DEF(         push_5, 1, 0, 1, none_int)
  301|  9.82M|DEF(         push_6, 1, 0, 1, none_int)
  302|  9.82M|DEF(         push_7, 1, 0, 1, none_int)
  303|  9.82M|DEF(        push_i8, 2, 0, 1, i8)
  304|  9.82M|DEF(       push_i16, 3, 0, 1, i16)
  305|  9.82M|DEF(    push_const8, 2, 0, 1, const8)
  306|  9.82M|DEF(      fclosure8, 2, 0, 1, const8) /* must follow push_const8 */
  307|  9.82M|DEF(push_empty_string, 1, 0, 1, none)
  308|       |
  309|  9.82M|DEF(       get_loc8, 2, 0, 1, loc8)
  310|  9.82M|DEF(       put_loc8, 2, 1, 0, loc8)
  311|  9.82M|DEF(       set_loc8, 2, 1, 1, loc8)
  312|       |
  313|  9.82M|DEF(       get_loc0, 1, 0, 1, none_loc)
  314|  9.82M|DEF(       get_loc1, 1, 0, 1, none_loc)
  315|  9.82M|DEF(       get_loc2, 1, 0, 1, none_loc)
  316|  9.82M|DEF(       get_loc3, 1, 0, 1, none_loc)
  317|  9.82M|DEF(       put_loc0, 1, 1, 0, none_loc)
  318|  9.82M|DEF(       put_loc1, 1, 1, 0, none_loc)
  319|  9.82M|DEF(       put_loc2, 1, 1, 0, none_loc)
  320|  9.82M|DEF(       put_loc3, 1, 1, 0, none_loc)
  321|  9.82M|DEF(       set_loc0, 1, 1, 1, none_loc)
  322|  9.82M|DEF(       set_loc1, 1, 1, 1, none_loc)
  323|  9.82M|DEF(       set_loc2, 1, 1, 1, none_loc)
  324|  9.82M|DEF(       set_loc3, 1, 1, 1, none_loc)
  325|  9.82M|DEF(       get_arg0, 1, 0, 1, none_arg)
  326|  9.82M|DEF(       get_arg1, 1, 0, 1, none_arg)
  327|  9.82M|DEF(       get_arg2, 1, 0, 1, none_arg)
  328|  9.82M|DEF(       get_arg3, 1, 0, 1, none_arg)
  329|  9.82M|DEF(       put_arg0, 1, 1, 0, none_arg)
  330|  9.82M|DEF(       put_arg1, 1, 1, 0, none_arg)
  331|  9.82M|DEF(       put_arg2, 1, 1, 0, none_arg)
  332|  9.82M|DEF(       put_arg3, 1, 1, 0, none_arg)
  333|  9.82M|DEF(       set_arg0, 1, 1, 1, none_arg)
  334|  9.82M|DEF(       set_arg1, 1, 1, 1, none_arg)
  335|  9.82M|DEF(       set_arg2, 1, 1, 1, none_arg)
  336|  9.82M|DEF(       set_arg3, 1, 1, 1, none_arg)
  337|  9.82M|DEF(   get_var_ref0, 1, 0, 1, none_var_ref)
  338|  9.82M|DEF(   get_var_ref1, 1, 0, 1, none_var_ref)
  339|  9.82M|DEF(   get_var_ref2, 1, 0, 1, none_var_ref)
  340|  9.82M|DEF(   get_var_ref3, 1, 0, 1, none_var_ref)
  341|  9.82M|DEF(   put_var_ref0, 1, 1, 0, none_var_ref)
  342|  9.82M|DEF(   put_var_ref1, 1, 1, 0, none_var_ref)
  343|  9.82M|DEF(   put_var_ref2, 1, 1, 0, none_var_ref)
  344|  9.82M|DEF(   put_var_ref3, 1, 1, 0, none_var_ref)
  345|  9.82M|DEF(   set_var_ref0, 1, 1, 1, none_var_ref)
  346|  9.82M|DEF(   set_var_ref1, 1, 1, 1, none_var_ref)
  347|  9.82M|DEF(   set_var_ref2, 1, 1, 1, none_var_ref)
  348|  9.82M|DEF(   set_var_ref3, 1, 1, 1, none_var_ref)
  349|       |
  350|  9.82M|DEF(     get_length, 1, 1, 1, none)
  351|       |
  352|  9.82M|DEF(      if_false8, 2, 1, 0, label8)
  353|  9.82M|DEF(       if_true8, 2, 1, 0, label8) /* must come after if_false8 */
  354|  9.82M|DEF(          goto8, 2, 0, 0, label8) /* must come after if_true8 */
  355|  9.82M|DEF(         goto16, 3, 0, 0, label16)
  356|       |
  357|  9.82M|DEF(          call0, 1, 1, 1, npopx)
  358|  9.82M|DEF(          call1, 1, 1, 1, npopx)
  359|  9.82M|DEF(          call2, 1, 1, 1, npopx)
  360|  9.82M|DEF(          call3, 1, 1, 1, npopx)
  361|       |
  362|  9.82M|DEF(   is_undefined, 1, 1, 1, none)
  363|  9.82M|DEF(        is_null, 1, 1, 1, none)
  364|  9.82M|DEF(typeof_is_undefined, 1, 1, 1, none)
  365|  9.82M|DEF( typeof_is_function, 1, 1, 1, none)
  366|  9.82M|#endif
  367|       |
  368|  9.82M|#undef DEF
  369|  9.82M|#undef def
  370|  9.82M|#endif  /* DEF */

/home/eugeneriabinin777/quickjs/quickjs.c:
    1|       |/*
    2|       | * QuickJS Javascript Engine
    3|       | *
    4|       | * Copyright (c) 2017-2025 Fabrice Bellard
    5|       | * Copyright (c) 2017-2025 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |#include <stdlib.h>
   26|       |#include <stdio.h>
   27|       |#include <stdarg.h>
   28|       |#include <inttypes.h>
   29|       |#include <string.h>
   30|       |#include <assert.h>
   31|       |#include <sys/time.h>
   32|       |#include <time.h>
   33|       |#include <fenv.h>
   34|       |#include <math.h>
   35|       |#if defined(__APPLE__)
   36|       |#include <malloc/malloc.h>
   37|       |#elif defined(__linux__) || defined(__GLIBC__)
   38|       |#include <malloc.h>
   39|       |#elif defined(__FreeBSD__)
   40|       |#include <malloc_np.h>
   41|       |#endif
   42|       |
   43|       |#include "cutils.h"
   44|       |#include "list.h"
   45|       |#include "quickjs.h"
   46|       |#include "libregexp.h"
   47|       |#include "libunicode.h"
   48|       |#include "dtoa.h"
   49|       |
   50|  2.37M|#define OPTIMIZE         1
   51|       |#define SHORT_OPCODES    1
   52|       |#if defined(EMSCRIPTEN)
   53|       |#define DIRECT_DISPATCH  0
   54|       |#else
   55|       |#define DIRECT_DISPATCH  1
   56|       |#endif
   57|       |
   58|       |#if defined(__APPLE__)
   59|       |#define MALLOC_OVERHEAD  0
   60|       |#else
   61|   143M|#define MALLOC_OVERHEAD  8
   62|       |#endif
   63|       |
   64|       |#if !defined(_WIN32)
   65|       |/* define it if printf uses the RNDN rounding mode instead of RNDNA */
   66|       |#define CONFIG_PRINTF_RNDN
   67|       |#endif
   68|       |
   69|       |/* define to include Atomics.* operations which depend on the OS
   70|       |   threads */
   71|       |#if !defined(EMSCRIPTEN)
   72|       |#define CONFIG_ATOMICS
   73|       |#endif
   74|       |
   75|       |#if !defined(EMSCRIPTEN)
   76|       |/* enable stack limitation */
   77|       |#define CONFIG_STACK_CHECK
   78|       |#endif
   79|       |
   80|       |
   81|       |/* dump object free */
   82|       |//#define DUMP_FREE
   83|       |//#define DUMP_CLOSURE
   84|       |/* dump the bytecode of the compiled functions: combination of bits
   85|       |   1: dump pass 3 final byte code
   86|       |   2: dump pass 2 code
   87|       |   4: dump pass 1 code
   88|       |   8: dump stdlib functions
   89|       |  16: dump bytecode in hex
   90|       |  32: dump line number table
   91|       |  64: dump compute_stack_size
   92|       | */
   93|       |//#define DUMP_BYTECODE  (1)
   94|       |/* dump the occurence of the automatic GC */
   95|       |//#define DUMP_GC
   96|       |/* dump objects freed by the garbage collector */
   97|       |//#define DUMP_GC_FREE
   98|       |/* dump objects leaking when freeing the runtime */
   99|       |//#define DUMP_LEAKS  1
  100|       |/* dump memory usage before running the garbage collector */
  101|       |//#define DUMP_MEM
  102|       |//#define DUMP_OBJECTS    /* dump objects in JS_FreeContext */
  103|       |//#define DUMP_ATOMS      /* dump atoms in JS_FreeContext */
  104|       |//#define DUMP_SHAPES     /* dump shapes in JS_FreeContext */
  105|       |//#define DUMP_MODULE_RESOLVE
  106|       |//#define DUMP_PROMISE
  107|       |//#define DUMP_READ_OBJECT
  108|       |//#define DUMP_ROPE_REBALANCE
  109|       |
  110|       |/* test the GC by forcing it before each object allocation */
  111|       |//#define FORCE_GC_AT_MALLOC
  112|       |
  113|       |#ifdef CONFIG_ATOMICS
  114|       |#include <pthread.h>
  115|       |#include <stdatomic.h>
  116|       |#include <errno.h>
  117|       |#endif
  118|       |
  119|       |enum {
  120|       |    /* classid tag        */    /* union usage   | properties */
  121|       |    JS_CLASS_OBJECT = 1,        /* must be first */
  122|       |    JS_CLASS_ARRAY,             /* u.array       | length */
  123|       |    JS_CLASS_ERROR,
  124|       |    JS_CLASS_NUMBER,            /* u.object_data */
  125|       |    JS_CLASS_STRING,            /* u.object_data */
  126|       |    JS_CLASS_BOOLEAN,           /* u.object_data */
  127|       |    JS_CLASS_SYMBOL,            /* u.object_data */
  128|       |    JS_CLASS_ARGUMENTS,         /* u.array       | length */
  129|       |    JS_CLASS_MAPPED_ARGUMENTS,  /*               | length */
  130|       |    JS_CLASS_DATE,              /* u.object_data */
  131|       |    JS_CLASS_MODULE_NS,
  132|       |    JS_CLASS_C_FUNCTION,        /* u.cfunc */
  133|       |    JS_CLASS_BYTECODE_FUNCTION, /* u.func */
  134|       |    JS_CLASS_BOUND_FUNCTION,    /* u.bound_function */
  135|       |    JS_CLASS_C_FUNCTION_DATA,   /* u.c_function_data_record */
  136|       |    JS_CLASS_GENERATOR_FUNCTION, /* u.func */
  137|       |    JS_CLASS_FOR_IN_ITERATOR,   /* u.for_in_iterator */
  138|       |    JS_CLASS_REGEXP,            /* u.regexp */
  139|       |    JS_CLASS_ARRAY_BUFFER,      /* u.array_buffer */
  140|       |    JS_CLASS_SHARED_ARRAY_BUFFER, /* u.array_buffer */
  141|       |    JS_CLASS_UINT8C_ARRAY,      /* u.array (typed_array) */
  142|       |    JS_CLASS_INT8_ARRAY,        /* u.array (typed_array) */
  143|       |    JS_CLASS_UINT8_ARRAY,       /* u.array (typed_array) */
  144|       |    JS_CLASS_INT16_ARRAY,       /* u.array (typed_array) */
  145|       |    JS_CLASS_UINT16_ARRAY,      /* u.array (typed_array) */
  146|       |    JS_CLASS_INT32_ARRAY,       /* u.array (typed_array) */
  147|       |    JS_CLASS_UINT32_ARRAY,      /* u.array (typed_array) */
  148|       |    JS_CLASS_BIG_INT64_ARRAY,   /* u.array (typed_array) */
  149|       |    JS_CLASS_BIG_UINT64_ARRAY,  /* u.array (typed_array) */
  150|       |    JS_CLASS_FLOAT32_ARRAY,     /* u.array (typed_array) */
  151|       |    JS_CLASS_FLOAT64_ARRAY,     /* u.array (typed_array) */
  152|       |    JS_CLASS_DATAVIEW,          /* u.typed_array */
  153|       |    JS_CLASS_BIG_INT,           /* u.object_data */
  154|       |    JS_CLASS_MAP,               /* u.map_state */
  155|       |    JS_CLASS_SET,               /* u.map_state */
  156|       |    JS_CLASS_WEAKMAP,           /* u.map_state */
  157|       |    JS_CLASS_WEAKSET,           /* u.map_state */
  158|       |    JS_CLASS_MAP_ITERATOR,      /* u.map_iterator_data */
  159|       |    JS_CLASS_SET_ITERATOR,      /* u.map_iterator_data */
  160|       |    JS_CLASS_ARRAY_ITERATOR,    /* u.array_iterator_data */
  161|       |    JS_CLASS_STRING_ITERATOR,   /* u.array_iterator_data */
  162|       |    JS_CLASS_REGEXP_STRING_ITERATOR,   /* u.regexp_string_iterator_data */
  163|       |    JS_CLASS_GENERATOR,         /* u.generator_data */
  164|       |    JS_CLASS_PROXY,             /* u.proxy_data */
  165|       |    JS_CLASS_PROMISE,           /* u.promise_data */
  166|       |    JS_CLASS_PROMISE_RESOLVE_FUNCTION,  /* u.promise_function_data */
  167|       |    JS_CLASS_PROMISE_REJECT_FUNCTION,   /* u.promise_function_data */
  168|       |    JS_CLASS_ASYNC_FUNCTION,            /* u.func */
  169|       |    JS_CLASS_ASYNC_FUNCTION_RESOLVE,    /* u.async_function_data */
  170|       |    JS_CLASS_ASYNC_FUNCTION_REJECT,     /* u.async_function_data */
  171|       |    JS_CLASS_ASYNC_FROM_SYNC_ITERATOR,  /* u.async_from_sync_iterator_data */
  172|       |    JS_CLASS_ASYNC_GENERATOR_FUNCTION,  /* u.func */
  173|       |    JS_CLASS_ASYNC_GENERATOR,   /* u.async_generator_data */
  174|       |    JS_CLASS_WEAK_REF,
  175|       |    JS_CLASS_FINALIZATION_REGISTRY,
  176|       |    
  177|       |    JS_CLASS_INIT_COUNT, /* last entry for predefined classes */
  178|       |};
  179|       |
  180|       |/* number of typed array types */
  181|   213k|#define JS_TYPED_ARRAY_COUNT  (JS_CLASS_FLOAT64_ARRAY - JS_CLASS_UINT8C_ARRAY + 1)
  182|       |static uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT];
  183|   390k|#define typed_array_size_log2(classid)  (typed_array_size_log2[(classid)- JS_CLASS_UINT8C_ARRAY])
  184|       |
  185|       |typedef enum JSErrorEnum {
  186|       |    JS_EVAL_ERROR,
  187|       |    JS_RANGE_ERROR,
  188|       |    JS_REFERENCE_ERROR,
  189|       |    JS_SYNTAX_ERROR,
  190|       |    JS_TYPE_ERROR,
  191|       |    JS_URI_ERROR,
  192|       |    JS_INTERNAL_ERROR,
  193|       |    JS_AGGREGATE_ERROR,
  194|       |
  195|       |    JS_NATIVE_ERROR_COUNT, /* number of different NativeError objects */
  196|       |} JSErrorEnum;
  197|       |
  198|       |/* the variable and scope indexes must fit on 16 bits. The (-1) and
  199|       |   ARG_SCOPE_END values are reserved. */
  200|   308k|#define JS_MAX_LOCAL_VARS 65534
  201|   313k|#define JS_STACK_SIZE_MAX 65534
  202|  14.7M|#define JS_STRING_LEN_MAX ((1 << 30) - 1)
  203|       |
  204|       |/* strings <= this length are not concatenated using ropes. if too
  205|       |   small, the rope memory overhead becomes high. */
  206|  1.83M|#define JS_STRING_ROPE_SHORT_LEN  512
  207|       |/* specific threshold for initial rope use */
  208|  1.57M|#define JS_STRING_ROPE_SHORT2_LEN 8192
  209|       |/* rope depth at which we rebalance */
  210|   247k|#define JS_STRING_ROPE_MAX_DEPTH 60
  211|       |
  212|       |#define __exception __attribute__((warn_unused_result))
  213|       |
  214|       |typedef struct JSShape JSShape;
  215|       |typedef struct JSString JSString;
  216|       |typedef struct JSString JSAtomStruct;
  217|       |typedef struct JSObject JSObject;
  218|       |
  219|   151M|#define JS_VALUE_GET_OBJ(v) ((JSObject *)JS_VALUE_GET_PTR(v))
  220|  42.2M|#define JS_VALUE_GET_STRING(v) ((JSString *)JS_VALUE_GET_PTR(v))
  221|   778k|#define JS_VALUE_GET_STRING_ROPE(v) ((JSStringRope *)JS_VALUE_GET_PTR(v))
  222|       |
  223|       |typedef enum {
  224|       |    JS_GC_PHASE_NONE,
  225|       |    JS_GC_PHASE_DECREF,
  226|       |    JS_GC_PHASE_REMOVE_CYCLES,
  227|       |} JSGCPhaseEnum;
  228|       |
  229|       |typedef enum OPCodeEnum OPCodeEnum;
  230|       |
  231|       |struct JSRuntime {
  232|       |    JSMallocFunctions mf;
  233|       |    JSMallocState malloc_state;
  234|       |    const char *rt_info;
  235|       |
  236|       |    int atom_hash_size; /* power of two */
  237|       |    int atom_count;
  238|       |    int atom_size;
  239|       |    int atom_count_resize; /* resize hash table at this count */
  240|       |    uint32_t *atom_hash;
  241|       |    JSAtomStruct **atom_array;
  242|       |    int atom_free_index; /* 0 = none */
  243|       |
  244|       |    int class_count;    /* size of class_array */
  245|       |    JSClass *class_array;
  246|       |
  247|       |    struct list_head context_list; /* list of JSContext.link */
  248|       |    /* list of JSGCObjectHeader.link. List of allocated GC objects (used
  249|       |       by the garbage collector) */
  250|       |    struct list_head gc_obj_list;
  251|       |    /* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */
  252|       |    struct list_head gc_zero_ref_count_list;
  253|       |    struct list_head tmp_obj_list; /* used during GC */
  254|       |    JSGCPhaseEnum gc_phase : 8;
  255|       |    size_t malloc_gc_threshold;
  256|       |    struct list_head weakref_list; /* list of JSWeakRefHeader.link */
  257|       |#ifdef DUMP_LEAKS
  258|       |    struct list_head string_list; /* list of JSString.link */
  259|       |#endif
  260|       |    /* stack limitation */
  261|       |    uintptr_t stack_size; /* in bytes, 0 if no limit */
  262|       |    uintptr_t stack_top;
  263|       |    uintptr_t stack_limit; /* lower stack limit */
  264|       |
  265|       |    JSValue current_exception;
  266|       |    /* true if inside an out of memory error, to avoid recursing */
  267|       |    BOOL in_out_of_memory : 8;
  268|       |
  269|       |    struct JSStackFrame *current_stack_frame;
  270|       |
  271|       |    JSInterruptHandler *interrupt_handler;
  272|       |    void *interrupt_opaque;
  273|       |
  274|       |    JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
  275|       |    void *host_promise_rejection_tracker_opaque;
  276|       |
  277|       |    struct list_head job_list; /* list of JSJobEntry.link */
  278|       |
  279|       |    JSModuleNormalizeFunc *module_normalize_func;
  280|       |    JSModuleLoaderFunc *module_loader_func;
  281|       |    void *module_loader_opaque;
  282|       |    /* timestamp for internal use in module evaluation */
  283|       |    int64_t module_async_evaluation_next_timestamp;
  284|       |
  285|       |    BOOL can_block : 8; /* TRUE if Atomics.wait can block */
  286|       |    /* used to allocate, free and clone SharedArrayBuffers */
  287|       |    JSSharedArrayBufferFunctions sab_funcs;
  288|       |    /* see JS_SetStripInfo() */
  289|       |    uint8_t strip_flags;
  290|       |    
  291|       |    /* Shape hash table */
  292|       |    int shape_hash_bits;
  293|       |    int shape_hash_size;
  294|       |    int shape_hash_count; /* number of hashed shapes */
  295|       |    JSShape **shape_hash;
  296|       |    void *user_opaque;
  297|       |};
  298|       |
  299|       |struct JSClass {
  300|       |    uint32_t class_id; /* 0 means free entry */
  301|       |    JSAtom class_name;
  302|       |    JSClassFinalizer *finalizer;
  303|       |    JSClassGCMark *gc_mark;
  304|       |    JSClassCall *call;
  305|       |    /* pointers for exotic behavior, can be NULL if none are present */
  306|       |    const JSClassExoticMethods *exotic;
  307|       |};
  308|       |
  309|  5.29M|#define JS_MODE_STRICT (1 << 0)
  310|  61.2k|#define JS_MODE_ASYNC  (1 << 2) /* async function */
  311|   144k|#define JS_MODE_BACKTRACE_BARRIER (1 << 3) /* stop backtrace before this frame */
  312|       |
  313|       |typedef struct JSStackFrame {
  314|       |    struct JSStackFrame *prev_frame; /* NULL if first stack frame */
  315|       |    JSValue cur_func; /* current function, JS_UNDEFINED if the frame is detached */
  316|       |    JSValue *arg_buf; /* arguments */
  317|       |    JSValue *var_buf; /* variables */
  318|       |    struct list_head var_ref_list; /* list of JSVarRef.var_ref_link */
  319|       |    const uint8_t *cur_pc; /* only used in bytecode functions : PC of the
  320|       |                        instruction after the call */
  321|       |    int arg_count;
  322|       |    int js_mode; /* not supported for C functions */
  323|       |    /* only used in generators. Current stack pointer value. NULL if
  324|       |       the function is running. */
  325|       |    JSValue *cur_sp;
  326|       |} JSStackFrame;
  327|       |
  328|       |typedef enum {
  329|       |    JS_GC_OBJ_TYPE_JS_OBJECT,
  330|       |    JS_GC_OBJ_TYPE_FUNCTION_BYTECODE,
  331|       |    JS_GC_OBJ_TYPE_SHAPE,
  332|       |    JS_GC_OBJ_TYPE_VAR_REF,
  333|       |    JS_GC_OBJ_TYPE_ASYNC_FUNCTION,
  334|       |    JS_GC_OBJ_TYPE_JS_CONTEXT,
  335|       |} JSGCObjectTypeEnum;
  336|       |
  337|       |/* header for GC objects. GC objects are C data structures with a
  338|       |   reference count that can reference other GC objects. JS Objects are
  339|       |   a particular type of GC object. */
  340|       |struct JSGCObjectHeader {
  341|       |    int ref_count; /* must come first, 32-bit */
  342|       |    JSGCObjectTypeEnum gc_obj_type : 4;
  343|       |    uint8_t mark : 4; /* used by the GC */
  344|       |    uint8_t dummy1; /* not used by the GC */
  345|       |    uint16_t dummy2; /* not used by the GC */
  346|       |    struct list_head link;
  347|       |};
  348|       |
  349|       |typedef enum {
  350|       |    JS_WEAKREF_TYPE_MAP,
  351|       |    JS_WEAKREF_TYPE_WEAKREF,
  352|       |    JS_WEAKREF_TYPE_FINREC,
  353|       |} JSWeakRefHeaderTypeEnum;
  354|       |
  355|       |typedef struct {
  356|       |    struct list_head link;
  357|       |    JSWeakRefHeaderTypeEnum weakref_type;
  358|       |} JSWeakRefHeader;
  359|       |
  360|       |typedef struct JSVarRef {
  361|       |    union {
  362|       |        JSGCObjectHeader header; /* must come first */
  363|       |        struct {
  364|       |            int __gc_ref_count; /* corresponds to header.ref_count */
  365|       |            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */
  366|       |            uint8_t is_detached;
  367|       |        };
  368|       |    };
  369|       |    JSValue *pvalue; /* pointer to the value, either on the stack or
  370|       |                        to 'value' */
  371|       |    union {
  372|       |        JSValue value; /* used when is_detached = TRUE */
  373|       |        struct {
  374|       |            struct list_head var_ref_link; /* JSStackFrame.var_ref_list list */
  375|       |            struct JSAsyncFunctionState *async_func; /* != NULL if async stack frame */
  376|       |        }; /* used when is_detached = FALSE */
  377|       |    };
  378|       |} JSVarRef;
  379|       |
  380|       |/* bigint */
  381|       |
  382|       |#if JS_LIMB_BITS == 32
  383|       |
  384|       |typedef int32_t js_slimb_t;
  385|       |typedef uint32_t js_limb_t;
  386|       |typedef int64_t js_sdlimb_t;
  387|       |typedef uint64_t js_dlimb_t;
  388|       |
  389|       |#define JS_LIMB_DIGITS 9
  390|       |
  391|       |#else
  392|       |
  393|       |typedef __int128 int128_t;
  394|       |typedef unsigned __int128 uint128_t;
  395|       |typedef int64_t js_slimb_t;
  396|       |typedef uint64_t js_limb_t;
  397|       |typedef int128_t js_sdlimb_t;
  398|       |typedef uint128_t js_dlimb_t;
  399|       |
  400|   246k|#define JS_LIMB_DIGITS 19
  401|       |
  402|       |#endif
  403|       |
  404|       |typedef struct JSBigInt {
  405|       |    JSRefCountHeader header; /* must come first, 32-bit */
  406|       |    uint32_t len; /* number of limbs, >= 1 */
  407|       |    js_limb_t tab[]; /* two's complement representation, always
  408|       |                        normalized so that 'len' is the minimum
  409|       |                        possible length >= 1 */
  410|       |} JSBigInt;
  411|       |
  412|       |/* this bigint structure can hold a 64 bit integer */
  413|       |typedef struct {
  414|       |    js_limb_t big_int_buf[sizeof(JSBigInt) / sizeof(js_limb_t)]; /* for JSBigInt */
  415|       |    /* must come just after */
  416|       |    js_limb_t tab[(64 + JS_LIMB_BITS - 1) / JS_LIMB_BITS];
  417|       |} JSBigIntBuf;
  418|       |    
  419|       |typedef enum {
  420|       |    JS_AUTOINIT_ID_PROTOTYPE,
  421|       |    JS_AUTOINIT_ID_MODULE_NS,
  422|       |    JS_AUTOINIT_ID_PROP,
  423|       |} JSAutoInitIDEnum;
  424|       |
  425|       |/* must be large enough to have a negligible runtime cost and small
  426|       |   enough to call the interrupt callback often. */
  427|  19.6k|#define JS_INTERRUPT_COUNTER_INIT 10000
  428|       |
  429|       |struct JSContext {
  430|       |    JSGCObjectHeader header; /* must come first */
  431|       |    JSRuntime *rt;
  432|       |    struct list_head link;
  433|       |
  434|       |    uint16_t binary_object_count;
  435|       |    int binary_object_size;
  436|       |
  437|       |    JSShape *array_shape;   /* initial shape for Array objects */
  438|       |
  439|       |    JSValue *class_proto;
  440|       |    JSValue function_proto;
  441|       |    JSValue function_ctor;
  442|       |    JSValue array_ctor;
  443|       |    JSValue regexp_ctor;
  444|       |    JSValue promise_ctor;
  445|       |    JSValue native_error_proto[JS_NATIVE_ERROR_COUNT];
  446|       |    JSValue iterator_proto;
  447|       |    JSValue async_iterator_proto;
  448|       |    JSValue array_proto_values;
  449|       |    JSValue throw_type_error;
  450|       |    JSValue eval_obj;
  451|       |
  452|       |    JSValue global_obj; /* global object */
  453|       |    JSValue global_var_obj; /* contains the global let/const definitions */
  454|       |
  455|       |    uint64_t random_state;
  456|       |
  457|       |    /* when the counter reaches zero, JSRutime.interrupt_handler is called */
  458|       |    int interrupt_counter;
  459|       |
  460|       |    struct list_head loaded_modules; /* list of JSModuleDef.link */
  461|       |
  462|       |    /* if NULL, RegExp compilation is not supported */
  463|       |    JSValue (*compile_regexp)(JSContext *ctx, JSValueConst pattern,
  464|       |                              JSValueConst flags);
  465|       |    /* if NULL, eval is not supported */
  466|       |    JSValue (*eval_internal)(JSContext *ctx, JSValueConst this_obj,
  467|       |                             const char *input, size_t input_len,
  468|       |                             const char *filename, int flags, int scope_idx);
  469|       |    void *user_opaque;
  470|       |};
  471|       |
  472|       |typedef union JSFloat64Union {
  473|       |    double d;
  474|       |    uint64_t u64;
  475|       |    uint32_t u32[2];
  476|       |} JSFloat64Union;
  477|       |
  478|       |enum {
  479|       |    JS_ATOM_TYPE_STRING = 1,
  480|       |    JS_ATOM_TYPE_GLOBAL_SYMBOL,
  481|       |    JS_ATOM_TYPE_SYMBOL,
  482|       |    JS_ATOM_TYPE_PRIVATE,
  483|       |};
  484|       |
  485|       |typedef enum {
  486|       |    JS_ATOM_KIND_STRING,
  487|       |    JS_ATOM_KIND_SYMBOL,
  488|       |    JS_ATOM_KIND_PRIVATE,
  489|       |} JSAtomKindEnum;
  490|       |
  491|  38.6M|#define JS_ATOM_HASH_MASK  ((1 << 30) - 1)
  492|  1.05M|#define JS_ATOM_HASH_PRIVATE JS_ATOM_HASH_MASK
  493|       |
  494|       |struct JSString {
  495|       |    JSRefCountHeader header; /* must come first, 32-bit */
  496|       |    uint32_t len : 31;
  497|       |    uint8_t is_wide_char : 1; /* 0 = 8 bits, 1 = 16 bits characters */
  498|       |    /* for JS_ATOM_TYPE_SYMBOL: hash = weakref_count, atom_type = 3,
  499|       |       for JS_ATOM_TYPE_PRIVATE: hash = JS_ATOM_HASH_PRIVATE, atom_type = 3
  500|       |       XXX: could change encoding to have one more bit in hash */
  501|       |    uint32_t hash : 30;
  502|       |    uint8_t atom_type : 2; /* != 0 if atom, JS_ATOM_TYPE_x */
  503|       |    uint32_t hash_next; /* atom_index for JS_ATOM_TYPE_SYMBOL */
  504|       |#ifdef DUMP_LEAKS
  505|       |    struct list_head link; /* string list */
  506|       |#endif
  507|       |    union {
  508|       |        uint8_t str8[0]; /* 8 bit strings will get an extra null terminator */
  509|       |        uint16_t str16[0];
  510|       |    } u;
  511|       |};
  512|       |
  513|       |typedef struct JSStringRope {
  514|       |    JSRefCountHeader header; /* must come first, 32-bit */
  515|       |    uint32_t len;
  516|       |    uint8_t is_wide_char; /* 0 = 8 bits, 1 = 16 bits characters */
  517|       |    uint8_t depth; /* max depth of the rope tree */
  518|       |    /* XXX: could reduce memory usage by using a direct pointer with
  519|       |       bit 0 to select rope or string */
  520|       |    JSValue left;
  521|       |    JSValue right; /* might be the empty string */
  522|       |} JSStringRope;
  523|       |
  524|       |typedef struct JSClosureVar {
  525|       |    uint8_t is_local : 1;
  526|       |    uint8_t is_arg : 1;
  527|       |    uint8_t is_const : 1;
  528|       |    uint8_t is_lexical : 1;
  529|       |    uint8_t var_kind : 4; /* see JSVarKindEnum */
  530|       |    /* 8 bits available */
  531|       |    uint16_t var_idx; /* is_local = TRUE: index to a normal variable of the
  532|       |                    parent function. otherwise: index to a closure
  533|       |                    variable of the parent function */
  534|       |    JSAtom var_name;
  535|       |} JSClosureVar;
  536|       |
  537|      0|#define ARG_SCOPE_INDEX 1
  538|  1.43M|#define ARG_SCOPE_END (-2)
  539|       |
  540|       |typedef struct JSVarScope {
  541|       |    int parent;  /* index into fd->scopes of the enclosing scope */
  542|       |    int first;   /* index into fd->vars of the last variable in this scope */
  543|       |} JSVarScope;
  544|       |
  545|       |typedef enum {
  546|       |    /* XXX: add more variable kinds here instead of using bit fields */
  547|       |    JS_VAR_NORMAL,
  548|       |    JS_VAR_FUNCTION_DECL, /* lexical var with function declaration */
  549|       |    JS_VAR_NEW_FUNCTION_DECL, /* lexical var with async/generator
  550|       |                                 function declaration */
  551|       |    JS_VAR_CATCH,
  552|       |    JS_VAR_FUNCTION_NAME, /* function expression name */
  553|       |    JS_VAR_PRIVATE_FIELD,
  554|       |    JS_VAR_PRIVATE_METHOD,
  555|       |    JS_VAR_PRIVATE_GETTER,
  556|       |    JS_VAR_PRIVATE_SETTER, /* must come after JS_VAR_PRIVATE_GETTER */
  557|       |    JS_VAR_PRIVATE_GETTER_SETTER, /* must come after JS_VAR_PRIVATE_SETTER */
  558|       |} JSVarKindEnum;
  559|       |
  560|       |/* XXX: could use a different structure in bytecode functions to save
  561|       |   memory */
  562|       |typedef struct JSVarDef {
  563|       |    JSAtom var_name;
  564|       |    /* index into fd->scopes of this variable lexical scope */
  565|       |    int scope_level;
  566|       |    /* during compilation:
  567|       |        - if scope_level = 0: scope in which the variable is defined
  568|       |        - if scope_level != 0: index into fd->vars of the next
  569|       |          variable in the same or enclosing lexical scope
  570|       |       in a bytecode function:
  571|       |       index into fd->vars of the next
  572|       |       variable in the same or enclosing lexical scope
  573|       |    */
  574|       |    int scope_next;
  575|       |    uint8_t is_const : 1;
  576|       |    uint8_t is_lexical : 1;
  577|       |    uint8_t is_captured : 1;
  578|       |    uint8_t is_static_private : 1; /* only used during private class field parsing */
  579|       |    uint8_t var_kind : 4; /* see JSVarKindEnum */
  580|       |    /* only used during compilation: function pool index for lexical
  581|       |       variables with var_kind =
  582|       |       JS_VAR_FUNCTION_DECL/JS_VAR_NEW_FUNCTION_DECL or scope level of
  583|       |       the definition of the 'var' variables (they have scope_level =
  584|       |       0) */
  585|       |    int func_pool_idx : 24; /* only used during compilation : index in
  586|       |                               the constant pool for hoisted function
  587|       |                               definition */
  588|       |} JSVarDef;
  589|       |
  590|       |/* for the encoding of the pc2line table */
  591|  3.38M|#define PC2LINE_BASE     (-1)
  592|  4.15M|#define PC2LINE_RANGE    5
  593|  2.07M|#define PC2LINE_OP_FIRST 1
  594|   655k|#define PC2LINE_DIFF_PC_MAX ((255 - PC2LINE_OP_FIRST) / PC2LINE_RANGE)
  595|       |
  596|       |typedef enum JSFunctionKindEnum {
  597|       |    JS_FUNC_NORMAL = 0,
  598|       |    JS_FUNC_GENERATOR = (1 << 0),
  599|       |    JS_FUNC_ASYNC = (1 << 1),
  600|       |    JS_FUNC_ASYNC_GENERATOR = (JS_FUNC_GENERATOR | JS_FUNC_ASYNC),
  601|       |} JSFunctionKindEnum;
  602|       |
  603|       |typedef struct JSFunctionBytecode {
  604|       |    JSGCObjectHeader header; /* must come first */
  605|       |    uint8_t js_mode;
  606|       |    uint8_t has_prototype : 1; /* true if a prototype field is necessary */
  607|       |    uint8_t has_simple_parameter_list : 1;
  608|       |    uint8_t is_derived_class_constructor : 1;
  609|       |    /* true if home_object needs to be initialized */
  610|       |    uint8_t need_home_object : 1;
  611|       |    uint8_t func_kind : 2;
  612|       |    uint8_t new_target_allowed : 1;
  613|       |    uint8_t super_call_allowed : 1;
  614|       |    uint8_t super_allowed : 1;
  615|       |    uint8_t arguments_allowed : 1;
  616|       |    uint8_t has_debug : 1;
  617|       |    uint8_t read_only_bytecode : 1;
  618|       |    uint8_t is_direct_or_indirect_eval : 1; /* used by JS_GetScriptOrModuleName() */
  619|       |    /* XXX: 10 bits available */
  620|       |    uint8_t *byte_code_buf; /* (self pointer) */
  621|       |    int byte_code_len;
  622|       |    JSAtom func_name;
  623|       |    JSVarDef *vardefs; /* arguments + local variables (arg_count + var_count) (self pointer) */
  624|       |    JSClosureVar *closure_var; /* list of variables in the closure (self pointer) */
  625|       |    uint16_t arg_count;
  626|       |    uint16_t var_count;
  627|       |    uint16_t defined_arg_count; /* for length function property */
  628|       |    uint16_t stack_size; /* maximum stack size */
  629|       |    JSContext *realm; /* function realm */
  630|       |    JSValue *cpool; /* constant pool (self pointer) */
  631|       |    int cpool_count;
  632|       |    int closure_var_count;
  633|       |    struct {
  634|       |        /* debug info, move to separate structure to save memory? */
  635|       |        JSAtom filename;
  636|       |        int source_len; 
  637|       |        int pc2line_len;
  638|       |        uint8_t *pc2line_buf;
  639|       |        char *source;
  640|       |    } debug;
  641|       |} JSFunctionBytecode;
  642|       |
  643|       |typedef struct JSBoundFunction {
  644|       |    JSValue func_obj;
  645|       |    JSValue this_val;
  646|       |    int argc;
  647|       |    JSValue argv[0];
  648|       |} JSBoundFunction;
  649|       |
  650|       |typedef enum JSIteratorKindEnum {
  651|       |    JS_ITERATOR_KIND_KEY,
  652|       |    JS_ITERATOR_KIND_VALUE,
  653|       |    JS_ITERATOR_KIND_KEY_AND_VALUE,
  654|       |} JSIteratorKindEnum;
  655|       |
  656|       |typedef struct JSForInIterator {
  657|       |    JSValue obj;
  658|       |    uint32_t idx;
  659|       |    uint32_t atom_count;
  660|       |    uint8_t in_prototype_chain;
  661|       |    uint8_t is_array;
  662|       |    JSPropertyEnum *tab_atom; /* is_array = FALSE */
  663|       |} JSForInIterator;
  664|       |
  665|       |typedef struct JSRegExp {
  666|       |    JSString *pattern;
  667|       |    JSString *bytecode; /* also contains the flags */
  668|       |} JSRegExp;
  669|       |
  670|       |typedef struct JSProxyData {
  671|       |    JSValue target;
  672|       |    JSValue handler;
  673|       |    uint8_t is_func;
  674|       |    uint8_t is_revoked;
  675|       |} JSProxyData;
  676|       |
  677|       |typedef struct JSArrayBuffer {
  678|       |    int byte_length; /* 0 if detached */
  679|       |    uint8_t detached;
  680|       |    uint8_t shared; /* if shared, the array buffer cannot be detached */
  681|       |    uint8_t *data; /* NULL if detached */
  682|       |    struct list_head array_list;
  683|       |    void *opaque;
  684|       |    JSFreeArrayBufferDataFunc *free_func;
  685|       |} JSArrayBuffer;
  686|       |
  687|       |typedef struct JSTypedArray {
  688|       |    struct list_head link; /* link to arraybuffer */
  689|       |    JSObject *obj; /* back pointer to the TypedArray/DataView object */
  690|       |    JSObject *buffer; /* based array buffer */
  691|       |    uint32_t offset; /* offset in the array buffer */
  692|       |    uint32_t length; /* length in the array buffer */
  693|       |} JSTypedArray;
  694|       |
  695|       |typedef struct JSAsyncFunctionState {
  696|       |    JSGCObjectHeader header;
  697|       |    JSValue this_val; /* 'this' argument */
  698|       |    int argc; /* number of function arguments */
  699|       |    BOOL throw_flag; /* used to throw an exception in JS_CallInternal() */
  700|       |    BOOL is_completed; /* TRUE if the function has returned. The stack
  701|       |                          frame is no longer valid */
  702|       |    JSValue resolving_funcs[2]; /* only used in JS async functions */
  703|       |    JSStackFrame frame;
  704|       |} JSAsyncFunctionState;
  705|       |
  706|       |typedef enum {
  707|       |   /* binary operators */
  708|       |   JS_OVOP_ADD,
  709|       |   JS_OVOP_SUB,
  710|       |   JS_OVOP_MUL,
  711|       |   JS_OVOP_DIV,
  712|       |   JS_OVOP_MOD,
  713|       |   JS_OVOP_POW,
  714|       |   JS_OVOP_OR,
  715|       |   JS_OVOP_AND,
  716|       |   JS_OVOP_XOR,
  717|       |   JS_OVOP_SHL,
  718|       |   JS_OVOP_SAR,
  719|       |   JS_OVOP_SHR,
  720|       |   JS_OVOP_EQ,
  721|       |   JS_OVOP_LESS,
  722|       |
  723|       |   JS_OVOP_BINARY_COUNT,
  724|       |   /* unary operators */
  725|       |   JS_OVOP_POS = JS_OVOP_BINARY_COUNT,
  726|       |   JS_OVOP_NEG,
  727|       |   JS_OVOP_INC,
  728|       |   JS_OVOP_DEC,
  729|       |   JS_OVOP_NOT,
  730|       |
  731|       |   JS_OVOP_COUNT,
  732|       |} JSOverloadableOperatorEnum;
  733|       |
  734|       |typedef struct {
  735|       |    uint32_t operator_index;
  736|       |    JSObject *ops[JS_OVOP_BINARY_COUNT]; /* self operators */
  737|       |} JSBinaryOperatorDefEntry;
  738|       |
  739|       |typedef struct {
  740|       |    int count;
  741|       |    JSBinaryOperatorDefEntry *tab;
  742|       |} JSBinaryOperatorDef;
  743|       |
  744|       |typedef struct {
  745|       |    uint32_t operator_counter;
  746|       |    BOOL is_primitive; /* OperatorSet for a primitive type */
  747|       |    /* NULL if no operator is defined */
  748|       |    JSObject *self_ops[JS_OVOP_COUNT]; /* self operators */
  749|       |    JSBinaryOperatorDef left;
  750|       |    JSBinaryOperatorDef right;
  751|       |} JSOperatorSetData;
  752|       |
  753|       |typedef struct JSReqModuleEntry {
  754|       |    JSAtom module_name;
  755|       |    JSModuleDef *module; /* used using resolution */
  756|       |} JSReqModuleEntry;
  757|       |
  758|       |typedef enum JSExportTypeEnum {
  759|       |    JS_EXPORT_TYPE_LOCAL,
  760|       |    JS_EXPORT_TYPE_INDIRECT,
  761|       |} JSExportTypeEnum;
  762|       |
  763|       |typedef struct JSExportEntry {
  764|       |    union {
  765|       |        struct {
  766|       |            int var_idx; /* closure variable index */
  767|       |            JSVarRef *var_ref; /* if != NULL, reference to the variable */
  768|       |        } local; /* for local export */
  769|       |        int req_module_idx; /* module for indirect export */
  770|       |    } u;
  771|       |    JSExportTypeEnum export_type;
  772|       |    JSAtom local_name; /* '*' if export ns from. not used for local
  773|       |                          export after compilation */
  774|       |    JSAtom export_name; /* exported variable name */
  775|       |} JSExportEntry;
  776|       |
  777|       |typedef struct JSStarExportEntry {
  778|       |    int req_module_idx; /* in req_module_entries */
  779|       |} JSStarExportEntry;
  780|       |
  781|       |typedef struct JSImportEntry {
  782|       |    int var_idx; /* closure variable index */
  783|       |    JSAtom import_name;
  784|       |    int req_module_idx; /* in req_module_entries */
  785|       |} JSImportEntry;
  786|       |
  787|       |typedef enum {
  788|       |    JS_MODULE_STATUS_UNLINKED,
  789|       |    JS_MODULE_STATUS_LINKING,
  790|       |    JS_MODULE_STATUS_LINKED,
  791|       |    JS_MODULE_STATUS_EVALUATING,
  792|       |    JS_MODULE_STATUS_EVALUATING_ASYNC,
  793|       |    JS_MODULE_STATUS_EVALUATED,
  794|       |} JSModuleStatus;
  795|       |
  796|       |struct JSModuleDef {
  797|       |    JSRefCountHeader header; /* must come first, 32-bit */
  798|       |    JSAtom module_name;
  799|       |    struct list_head link;
  800|       |
  801|       |    JSReqModuleEntry *req_module_entries;
  802|       |    int req_module_entries_count;
  803|       |    int req_module_entries_size;
  804|       |
  805|       |    JSExportEntry *export_entries;
  806|       |    int export_entries_count;
  807|       |    int export_entries_size;
  808|       |
  809|       |    JSStarExportEntry *star_export_entries;
  810|       |    int star_export_entries_count;
  811|       |    int star_export_entries_size;
  812|       |
  813|       |    JSImportEntry *import_entries;
  814|       |    int import_entries_count;
  815|       |    int import_entries_size;
  816|       |
  817|       |    JSValue module_ns;
  818|       |    JSValue func_obj; /* only used for JS modules */
  819|       |    JSModuleInitFunc *init_func; /* only used for C modules */
  820|       |    BOOL has_tla : 8; /* true if func_obj contains await */
  821|       |    BOOL resolved : 8;
  822|       |    BOOL func_created : 8;
  823|       |    JSModuleStatus status : 8;
  824|       |    /* temp use during js_module_link() & js_module_evaluate() */
  825|       |    int dfs_index, dfs_ancestor_index;
  826|       |    JSModuleDef *stack_prev;
  827|       |    /* temp use during js_module_evaluate() */
  828|       |    JSModuleDef **async_parent_modules;
  829|       |    int async_parent_modules_count;
  830|       |    int async_parent_modules_size;
  831|       |    int pending_async_dependencies;
  832|       |    BOOL async_evaluation;
  833|       |    int64_t async_evaluation_timestamp;
  834|       |    JSModuleDef *cycle_root;
  835|       |    JSValue promise; /* corresponds to spec field: capability */
  836|       |    JSValue resolving_funcs[2]; /* corresponds to spec field: capability */
  837|       |
  838|       |    /* true if evaluation yielded an exception. It is saved in
  839|       |       eval_exception */
  840|       |    BOOL eval_has_exception : 8;
  841|       |    JSValue eval_exception;
  842|       |    JSValue meta_obj; /* for import.meta */
  843|       |};
  844|       |
  845|       |typedef struct JSJobEntry {
  846|       |    struct list_head link;
  847|       |    JSContext *ctx;
  848|       |    JSJobFunc *job_func;
  849|       |    int argc;
  850|       |    JSValue argv[0];
  851|       |} JSJobEntry;
  852|       |
  853|       |typedef struct JSProperty {
  854|       |    union {
  855|       |        JSValue value;      /* JS_PROP_NORMAL */
  856|       |        struct {            /* JS_PROP_GETSET */
  857|       |            JSObject *getter; /* NULL if undefined */
  858|       |            JSObject *setter; /* NULL if undefined */
  859|       |        } getset;
  860|       |        JSVarRef *var_ref;  /* JS_PROP_VARREF */
  861|       |        struct {            /* JS_PROP_AUTOINIT */
  862|       |            /* in order to use only 2 pointers, we compress the realm
  863|       |               and the init function pointer */
  864|       |            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
  865|       |                                       in the 2 low bits */
  866|       |            void *opaque;
  867|       |        } init;
  868|       |    } u;
  869|       |} JSProperty;
  870|       |
  871|  5.69M|#define JS_PROP_INITIAL_SIZE 2
  872|  5.70M|#define JS_PROP_INITIAL_HASH_SIZE 4 /* must be a power of two */
  873|       |#define JS_ARRAY_INITIAL_SIZE 2
  874|       |
  875|       |typedef struct JSShapeProperty {
  876|       |    uint32_t hash_next : 26; /* 0 if last in list */
  877|       |    uint32_t flags : 6;   /* JS_PROP_XXX */
  878|       |    JSAtom atom; /* JS_ATOM_NULL = free property entry */
  879|       |} JSShapeProperty;
  880|       |
  881|       |struct JSShape {
  882|       |    /* hash table of size hash_mask + 1 before the start of the
  883|       |       structure (see prop_hash_end()). */
  884|       |    JSGCObjectHeader header;
  885|       |    /* true if the shape is inserted in the shape hash table. If not,
  886|       |       JSShape.hash is not valid */
  887|       |    uint8_t is_hashed;
  888|       |    /* If true, the shape may have small array index properties 'n' with 0
  889|       |       <= n <= 2^31-1. If false, the shape is guaranteed not to have
  890|       |       small array index properties */
  891|       |    uint8_t has_small_array_index;
  892|       |    uint32_t hash; /* current hash value */
  893|       |    uint32_t prop_hash_mask;
  894|       |    int prop_size; /* allocated properties */
  895|       |    int prop_count; /* include deleted properties */
  896|       |    int deleted_prop_count;
  897|       |    JSShape *shape_hash_next; /* in JSRuntime.shape_hash[h] list */
  898|       |    JSObject *proto;
  899|       |    JSShapeProperty prop[0]; /* prop_size elements */
  900|       |};
  901|       |
  902|       |struct JSObject {
  903|       |    union {
  904|       |        JSGCObjectHeader header;
  905|       |        struct {
  906|       |            int __gc_ref_count; /* corresponds to header.ref_count */
  907|       |            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */
  908|       |
  909|       |            uint8_t extensible : 1;
  910|       |            uint8_t free_mark : 1; /* only used when freeing objects with cycles */
  911|       |            uint8_t is_exotic : 1; /* TRUE if object has exotic property handlers */
  912|       |            uint8_t fast_array : 1; /* TRUE if u.array is used for get/put (for JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS and typed arrays) */
  913|       |            uint8_t is_constructor : 1; /* TRUE if object is a constructor function */
  914|       |            uint8_t is_uncatchable_error : 1; /* if TRUE, error is not catchable */
  915|       |            uint8_t tmp_mark : 1; /* used in JS_WriteObjectRec() */
  916|       |            uint8_t is_HTMLDDA : 1; /* specific annex B IsHtmlDDA behavior */
  917|       |            uint16_t class_id; /* see JS_CLASS_x */
  918|       |        };
  919|       |    };
  920|       |    /* count the number of weak references to this object. The object
  921|       |       structure is freed only if header.ref_count = 0 and
  922|       |       weakref_count = 0 */
  923|       |    uint32_t weakref_count; 
  924|       |    JSShape *shape; /* prototype and property names + flag */
  925|       |    JSProperty *prop; /* array of properties */
  926|       |    union {
  927|       |        void *opaque;
  928|       |        struct JSBoundFunction *bound_function; /* JS_CLASS_BOUND_FUNCTION */
  929|       |        struct JSCFunctionDataRecord *c_function_data_record; /* JS_CLASS_C_FUNCTION_DATA */
  930|       |        struct JSForInIterator *for_in_iterator; /* JS_CLASS_FOR_IN_ITERATOR */
  931|       |        struct JSArrayBuffer *array_buffer; /* JS_CLASS_ARRAY_BUFFER, JS_CLASS_SHARED_ARRAY_BUFFER */
  932|       |        struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_DATAVIEW */
  933|       |        struct JSMapState *map_state;   /* JS_CLASS_MAP..JS_CLASS_WEAKSET */
  934|       |        struct JSMapIteratorData *map_iterator_data; /* JS_CLASS_MAP_ITERATOR, JS_CLASS_SET_ITERATOR */
  935|       |        struct JSArrayIteratorData *array_iterator_data; /* JS_CLASS_ARRAY_ITERATOR, JS_CLASS_STRING_ITERATOR */
  936|       |        struct JSRegExpStringIteratorData *regexp_string_iterator_data; /* JS_CLASS_REGEXP_STRING_ITERATOR */
  937|       |        struct JSGeneratorData *generator_data; /* JS_CLASS_GENERATOR */
  938|       |        struct JSProxyData *proxy_data; /* JS_CLASS_PROXY */
  939|       |        struct JSPromiseData *promise_data; /* JS_CLASS_PROMISE */
  940|       |        struct JSPromiseFunctionData *promise_function_data; /* JS_CLASS_PROMISE_RESOLVE_FUNCTION, JS_CLASS_PROMISE_REJECT_FUNCTION */
  941|       |        struct JSAsyncFunctionState *async_function_data; /* JS_CLASS_ASYNC_FUNCTION_RESOLVE, JS_CLASS_ASYNC_FUNCTION_REJECT */
  942|       |        struct JSAsyncFromSyncIteratorData *async_from_sync_iterator_data; /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */
  943|       |        struct JSAsyncGeneratorData *async_generator_data; /* JS_CLASS_ASYNC_GENERATOR */
  944|       |        struct { /* JS_CLASS_BYTECODE_FUNCTION: 12/24 bytes */
  945|       |            /* also used by JS_CLASS_GENERATOR_FUNCTION, JS_CLASS_ASYNC_FUNCTION and JS_CLASS_ASYNC_GENERATOR_FUNCTION */
  946|       |            struct JSFunctionBytecode *function_bytecode;
  947|       |            JSVarRef **var_refs;
  948|       |            JSObject *home_object; /* for 'super' access */
  949|       |        } func;
  950|       |        struct { /* JS_CLASS_C_FUNCTION: 12/20 bytes */
  951|       |            JSContext *realm;
  952|       |            JSCFunctionType c_function;
  953|       |            uint8_t length;
  954|       |            uint8_t cproto;
  955|       |            int16_t magic;
  956|       |        } cfunc;
  957|       |        /* array part for fast arrays and typed arrays */
  958|       |        struct { /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS, JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */
  959|       |            union {
  960|       |                uint32_t size;          /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */
  961|       |                struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */
  962|       |            } u1;
  963|       |            union {
  964|       |                JSValue *values;        /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */
  965|       |                void *ptr;              /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */
  966|       |                int8_t *int8_ptr;       /* JS_CLASS_INT8_ARRAY */
  967|       |                uint8_t *uint8_ptr;     /* JS_CLASS_UINT8_ARRAY, JS_CLASS_UINT8C_ARRAY */
  968|       |                int16_t *int16_ptr;     /* JS_CLASS_INT16_ARRAY */
  969|       |                uint16_t *uint16_ptr;   /* JS_CLASS_UINT16_ARRAY */
  970|       |                int32_t *int32_ptr;     /* JS_CLASS_INT32_ARRAY */
  971|       |                uint32_t *uint32_ptr;   /* JS_CLASS_UINT32_ARRAY */
  972|       |                int64_t *int64_ptr;     /* JS_CLASS_INT64_ARRAY */
  973|       |                uint64_t *uint64_ptr;   /* JS_CLASS_UINT64_ARRAY */
  974|       |                float *float_ptr;       /* JS_CLASS_FLOAT32_ARRAY */
  975|       |                double *double_ptr;     /* JS_CLASS_FLOAT64_ARRAY */
  976|       |            } u;
  977|       |            uint32_t count; /* <= 2^31-1. 0 for a detached typed array */
  978|       |        } array;    /* 12/20 bytes */
  979|       |        JSRegExp regexp;    /* JS_CLASS_REGEXP: 8/16 bytes */
  980|       |        JSValue object_data;    /* for JS_SetObjectData(): 8/16/16 bytes */
  981|       |    } u;
  982|       |};
  983|       |
  984|       |enum {
  985|       |    __JS_ATOM_NULL = JS_ATOM_NULL,
  986|       |#define DEF(name, str) JS_ATOM_ ## name,
  987|       |#include "quickjs-atom.h"
  988|       |#undef DEF
  989|       |    JS_ATOM_END,
  990|       |};
  991|  7.37M|#define JS_ATOM_LAST_KEYWORD JS_ATOM_super
  992|  7.25M|#define JS_ATOM_LAST_STRICT_KEYWORD JS_ATOM_yield
  993|       |
  994|       |static const char js_atom_init[] =
  995|       |#define DEF(name, str) str "\0"
  996|       |#include "quickjs-atom.h"
  997|       |#undef DEF
  998|       |;
  999|       |
 1000|       |typedef enum OPCodeFormat {
 1001|       |#define FMT(f) OP_FMT_ ## f,
 1002|       |#define DEF(id, size, n_pop, n_push, f)
 1003|       |#include "quickjs-opcode.h"
 1004|       |#undef DEF
 1005|       |#undef FMT
 1006|       |} OPCodeFormat;
 1007|       |
 1008|       |enum OPCodeEnum {
 1009|       |#define FMT(f)
 1010|       |#define DEF(id, size, n_pop, n_push, f) OP_ ## id,
 1011|       |#define def(id, size, n_pop, n_push, f)
 1012|       |#include "quickjs-opcode.h"
 1013|       |#undef def
 1014|       |#undef DEF
 1015|       |#undef FMT
 1016|       |    OP_COUNT, /* excluding temporary opcodes */
 1017|       |    /* temporary opcodes : overlap with the short opcodes */
 1018|       |    OP_TEMP_START = OP_nop + 1,
 1019|       |    OP___dummy = OP_TEMP_START - 1,
 1020|       |#define FMT(f)
 1021|       |#define DEF(id, size, n_pop, n_push, f)
 1022|       |#define def(id, size, n_pop, n_push, f) OP_ ## id,
 1023|       |#include "quickjs-opcode.h"
 1024|       |#undef def
 1025|       |#undef DEF
 1026|       |#undef FMT
 1027|       |    OP_TEMP_END,
 1028|       |};
 1029|       |
 1030|       |static int JS_InitAtoms(JSRuntime *rt);
 1031|       |static JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,
 1032|       |                               int atom_type);
 1033|       |static void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p);
 1034|       |static void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b);
 1035|       |static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
 1036|       |                                  JSValueConst this_obj,
 1037|       |                                  int argc, JSValueConst *argv, int flags);
 1038|       |static JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,
 1039|       |                                      JSValueConst this_obj,
 1040|       |                                      int argc, JSValueConst *argv, int flags);
 1041|       |static JSValue JS_CallInternal(JSContext *ctx, JSValueConst func_obj,
 1042|       |                               JSValueConst this_obj, JSValueConst new_target,
 1043|       |                               int argc, JSValue *argv, int flags);
 1044|       |static JSValue JS_CallConstructorInternal(JSContext *ctx,
 1045|       |                                          JSValueConst func_obj,
 1046|       |                                          JSValueConst new_target,
 1047|       |                                          int argc, JSValue *argv, int flags);
 1048|       |static JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_obj,
 1049|       |                           int argc, JSValueConst *argv);
 1050|       |static JSValue JS_InvokeFree(JSContext *ctx, JSValue this_val, JSAtom atom,
 1051|       |                             int argc, JSValueConst *argv);
 1052|       |static __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,
 1053|       |                                            JSValue val, BOOL is_array_ctor);
 1054|       |static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
 1055|       |                             JSValueConst val, int flags, int scope_idx);
 1056|       |JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
 1057|       |static __maybe_unused void JS_DumpAtoms(JSRuntime *rt);
 1058|       |static __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p);
 1059|       |static __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt);
 1060|       |static __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p);
 1061|       |static __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p);
 1062|       |static __maybe_unused void JS_DumpValueShort(JSRuntime *rt, JSValueConst val);
 1063|       |static __maybe_unused void JS_DumpValue(JSContext *ctx, JSValueConst val);
 1064|       |static __maybe_unused void JS_PrintValue(JSContext *ctx,
 1065|       |                                                  const char *str,
 1066|       |                                                  JSValueConst val);
 1067|       |static __maybe_unused void JS_DumpShapes(JSRuntime *rt);
 1068|       |static JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,
 1069|       |                                 int argc, JSValueConst *argv, int magic);
 1070|       |static void js_array_finalizer(JSRuntime *rt, JSValue val);
 1071|       |static void js_array_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
 1072|       |static void js_object_data_finalizer(JSRuntime *rt, JSValue val);
 1073|       |static void js_object_data_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
 1074|       |static void js_c_function_finalizer(JSRuntime *rt, JSValue val);
 1075|       |static void js_c_function_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
 1076|       |static void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val);
 1077|       |static void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,
 1078|       |                                JS_MarkFunc *mark_func);
 1079|       |static void js_bound_function_finalizer(JSRuntime *rt, JSValue val);
 1080|       |static void js_bound_function_mark(JSRuntime *rt, JSValueConst val,
 1081|       |                                JS_MarkFunc *mark_func);
 1082|       |static void js_for_in_iterator_finalizer(JSRuntime *rt, JSValue val);
 1083|       |static void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,
 1084|       |                                JS_MarkFunc *mark_func);
 1085|       |static void js_regexp_finalizer(JSRuntime *rt, JSValue val);
 1086|       |static void js_array_buffer_finalizer(JSRuntime *rt, JSValue val);
 1087|       |static void js_typed_array_finalizer(JSRuntime *rt, JSValue val);
 1088|       |static void js_typed_array_mark(JSRuntime *rt, JSValueConst val,
 1089|       |                                JS_MarkFunc *mark_func);
 1090|       |static void js_proxy_finalizer(JSRuntime *rt, JSValue val);
 1091|       |static void js_proxy_mark(JSRuntime *rt, JSValueConst val,
 1092|       |                                JS_MarkFunc *mark_func);
 1093|       |static void js_map_finalizer(JSRuntime *rt, JSValue val);
 1094|       |static void js_map_mark(JSRuntime *rt, JSValueConst val,
 1095|       |                                JS_MarkFunc *mark_func);
 1096|       |static void js_map_iterator_finalizer(JSRuntime *rt, JSValue val);
 1097|       |static void js_map_iterator_mark(JSRuntime *rt, JSValueConst val,
 1098|       |                                JS_MarkFunc *mark_func);
 1099|       |static void js_array_iterator_finalizer(JSRuntime *rt, JSValue val);
 1100|       |static void js_array_iterator_mark(JSRuntime *rt, JSValueConst val,
 1101|       |                                JS_MarkFunc *mark_func);
 1102|       |static void js_regexp_string_iterator_finalizer(JSRuntime *rt, JSValue val);
 1103|       |static void js_regexp_string_iterator_mark(JSRuntime *rt, JSValueConst val,
 1104|       |                                JS_MarkFunc *mark_func);
 1105|       |static void js_generator_finalizer(JSRuntime *rt, JSValue obj);
 1106|       |static void js_generator_mark(JSRuntime *rt, JSValueConst val,
 1107|       |                                JS_MarkFunc *mark_func);
 1108|       |static void js_promise_finalizer(JSRuntime *rt, JSValue val);
 1109|       |static void js_promise_mark(JSRuntime *rt, JSValueConst val,
 1110|       |                                JS_MarkFunc *mark_func);
 1111|       |static void js_promise_resolve_function_finalizer(JSRuntime *rt, JSValue val);
 1112|       |static void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,
 1113|       |                                JS_MarkFunc *mark_func);
 1114|       |
 1115|  1.24M|#define HINT_STRING  0
 1116|  8.08M|#define HINT_NUMBER  1
 1117|  1.05M|#define HINT_NONE    2
 1118|  2.36M|#define HINT_FORCE_ORDINARY (1 << 4) // don't try Symbol.toPrimitive
 1119|       |static JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint);
 1120|       |static JSValue JS_ToStringFree(JSContext *ctx, JSValue val);
 1121|       |static int JS_ToBoolFree(JSContext *ctx, JSValue val);
 1122|       |static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val);
 1123|       |static int JS_ToFloat64Free(JSContext *ctx, double *pres, JSValue val);
 1124|       |static int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val);
 1125|       |static JSValue js_new_string8_len(JSContext *ctx, const char *buf, int len);
 1126|       |static JSValue js_compile_regexp(JSContext *ctx, JSValueConst pattern,
 1127|       |                                 JSValueConst flags);
 1128|       |static JSValue js_regexp_constructor_internal(JSContext *ctx, JSValueConst ctor,
 1129|       |                                              JSValue pattern, JSValue bc);
 1130|       |static void gc_decref(JSRuntime *rt);
 1131|       |static int JS_NewClass1(JSRuntime *rt, JSClassID class_id,
 1132|       |                        const JSClassDef *class_def, JSAtom name);
 1133|       |
 1134|       |typedef enum JSStrictEqModeEnum {
 1135|       |    JS_EQ_STRICT,
 1136|       |    JS_EQ_SAME_VALUE,
 1137|       |    JS_EQ_SAME_VALUE_ZERO,
 1138|       |} JSStrictEqModeEnum;
 1139|       |
 1140|       |static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
 1141|       |                          JSStrictEqModeEnum eq_mode);
 1142|       |static BOOL js_strict_eq(JSContext *ctx, JSValueConst op1, JSValueConst op2);
 1143|       |static BOOL js_same_value(JSContext *ctx, JSValueConst op1, JSValueConst op2);
 1144|       |static BOOL js_same_value_zero(JSContext *ctx, JSValueConst op1, JSValueConst op2);
 1145|       |static JSValue JS_ToObject(JSContext *ctx, JSValueConst val);
 1146|       |static JSValue JS_ToObjectFree(JSContext *ctx, JSValue val);
 1147|       |static JSProperty *add_property(JSContext *ctx,
 1148|       |                                JSObject *p, JSAtom prop, int prop_flags);
 1149|       |static int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val);
 1150|       |JSValue JS_ThrowOutOfMemory(JSContext *ctx);
 1151|       |static JSValue JS_ThrowTypeErrorRevokedProxy(JSContext *ctx);
 1152|       |static JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj);
 1153|       |static int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,
 1154|       |                                   JSValueConst proto_val, BOOL throw_flag);
 1155|       |
 1156|       |static int js_resolve_proxy(JSContext *ctx, JSValueConst *pval, int throw_exception);
 1157|       |static int js_proxy_isExtensible(JSContext *ctx, JSValueConst obj);
 1158|       |static int js_proxy_preventExtensions(JSContext *ctx, JSValueConst obj);
 1159|       |static int JS_CreateProperty(JSContext *ctx, JSObject *p,
 1160|       |                             JSAtom prop, JSValueConst val,
 1161|       |                             JSValueConst getter, JSValueConst setter,
 1162|       |                             int flags);
 1163|       |static int js_string_memcmp(const JSString *p1, int pos1, const JSString *p2,
 1164|       |                            int pos2, int len);
 1165|       |static JSValue js_array_buffer_constructor3(JSContext *ctx,
 1166|       |                                            JSValueConst new_target,
 1167|       |                                            uint64_t len, JSClassID class_id,
 1168|       |                                            uint8_t *buf,
 1169|       |                                            JSFreeArrayBufferDataFunc *free_func,
 1170|       |                                            void *opaque, BOOL alloc_flag);
 1171|       |static JSArrayBuffer *js_get_array_buffer(JSContext *ctx, JSValueConst obj);
 1172|       |static JSValue js_typed_array_constructor(JSContext *ctx,
 1173|       |                                          JSValueConst this_val,
 1174|       |                                          int argc, JSValueConst *argv,
 1175|       |                                          int classid);
 1176|       |static JSValue js_typed_array_constructor_ta(JSContext *ctx,
 1177|       |                                             JSValueConst new_target,
 1178|       |                                             JSValueConst src_obj,
 1179|       |                                             int classid);
 1180|       |static BOOL typed_array_is_detached(JSContext *ctx, JSObject *p);
 1181|       |static uint32_t typed_array_get_length(JSContext *ctx, JSObject *p);
 1182|       |static JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx);
 1183|       |static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf, int var_idx,
 1184|       |                             BOOL is_arg);
 1185|       |static void __async_func_free(JSRuntime *rt, JSAsyncFunctionState *s);
 1186|       |static void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s);
 1187|       |static JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,
 1188|       |                                          JSValueConst this_obj,
 1189|       |                                          int argc, JSValueConst *argv,
 1190|       |                                          int flags);
 1191|       |static void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val);
 1192|       |static void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,
 1193|       |                                           JS_MarkFunc *mark_func);
 1194|       |static JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
 1195|       |                               const char *input, size_t input_len,
 1196|       |                               const char *filename, int flags, int scope_idx);
 1197|       |static void js_free_module_def(JSContext *ctx, JSModuleDef *m);
 1198|       |static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
 1199|       |                               JS_MarkFunc *mark_func);
 1200|       |static JSValue js_import_meta(JSContext *ctx);
 1201|       |static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
 1202|       |static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);
 1203|       |static JSValue js_new_promise_capability(JSContext *ctx,
 1204|       |                                         JSValue *resolving_funcs,
 1205|       |                                         JSValueConst ctor);
 1206|       |static __exception int perform_promise_then(JSContext *ctx,
 1207|       |                                            JSValueConst promise,
 1208|       |                                            JSValueConst *resolve_reject,
 1209|       |                                            JSValueConst *cap_resolving_funcs);
 1210|       |static JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,
 1211|       |                                  int argc, JSValueConst *argv, int magic);
 1212|       |static JSValue js_promise_then(JSContext *ctx, JSValueConst this_val,
 1213|       |                               int argc, JSValueConst *argv);
 1214|       |static int js_string_compare(JSContext *ctx,
 1215|       |                             const JSString *p1, const JSString *p2);
 1216|       |static JSValue JS_ToNumber(JSContext *ctx, JSValueConst val);
 1217|       |static int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,
 1218|       |                               JSValue prop, JSValue val, int flags);
 1219|       |static int JS_NumberIsInteger(JSContext *ctx, JSValueConst val);
 1220|       |static BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val);
 1221|       |static JSValue JS_ToNumberFree(JSContext *ctx, JSValue val);
 1222|       |static int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,
 1223|       |                                     JSObject *p, JSAtom prop);
 1224|       |static void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc);
 1225|       |static void JS_AddIntrinsicBasicObjects(JSContext *ctx);
 1226|       |static void js_free_shape(JSRuntime *rt, JSShape *sh);
 1227|       |static void js_free_shape_null(JSRuntime *rt, JSShape *sh);
 1228|       |static int js_shape_prepare_update(JSContext *ctx, JSObject *p,
 1229|       |                                   JSShapeProperty **pprs);
 1230|       |static int init_shape_hash(JSRuntime *rt);
 1231|       |static __exception int js_get_length32(JSContext *ctx, uint32_t *pres,
 1232|       |                                       JSValueConst obj);
 1233|       |static __exception int js_get_length64(JSContext *ctx, int64_t *pres,
 1234|       |                                       JSValueConst obj);
 1235|       |static void free_arg_list(JSContext *ctx, JSValue *tab, uint32_t len);
 1236|       |static JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,
 1237|       |                               JSValueConst array_arg);
 1238|       |static BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,
 1239|       |                              JSValue **arrpp, uint32_t *countp);
 1240|       |static JSValue JS_CreateAsyncFromSyncIterator(JSContext *ctx,
 1241|       |                                              JSValueConst sync_iter);
 1242|       |static void js_c_function_data_finalizer(JSRuntime *rt, JSValue val);
 1243|       |static void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,
 1244|       |                                    JS_MarkFunc *mark_func);
 1245|       |static JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,
 1246|       |                                       JSValueConst this_val,
 1247|       |                                       int argc, JSValueConst *argv, int flags);
 1248|       |static JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val);
 1249|       |static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
 1250|       |                          JSGCObjectTypeEnum type);
 1251|       |static void remove_gc_object(JSGCObjectHeader *h);
 1252|       |static JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);
 1253|       |static JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
 1254|       |                                 void *opaque);
 1255|       |static JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,
 1256|       |                                               JSAtom atom, void *opaque);
 1257|       |static JSValue js_object_groupBy(JSContext *ctx, JSValueConst this_val,
 1258|       |                                 int argc, JSValueConst *argv, int is_map);
 1259|       |static void map_delete_weakrefs(JSRuntime *rt, JSWeakRefHeader *wh);
 1260|       |static void weakref_delete_weakref(JSRuntime *rt, JSWeakRefHeader *wh);
 1261|       |static void finrec_delete_weakref(JSRuntime *rt, JSWeakRefHeader *wh);
 1262|       |static void JS_RunGCInternal(JSRuntime *rt, BOOL remove_weak_objects);
 1263|       |
 1264|       |static const JSClassExoticMethods js_arguments_exotic_methods;
 1265|       |static const JSClassExoticMethods js_string_exotic_methods;
 1266|       |static const JSClassExoticMethods js_proxy_exotic_methods;
 1267|       |static const JSClassExoticMethods js_module_ns_exotic_methods;
 1268|       |static JSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;
 1269|       |
 1270|       |static void js_trigger_gc(JSRuntime *rt, size_t size)
 1271|  9.09M|{
 1272|  9.09M|    BOOL force_gc;
 1273|       |#ifdef FORCE_GC_AT_MALLOC
 1274|       |    force_gc = TRUE;
 1275|       |#else
 1276|  9.09M|    force_gc = ((rt->malloc_state.malloc_size + size) >
 1277|  9.09M|                rt->malloc_gc_threshold);
 1278|  9.09M|#endif
 1279|  9.09M|    if (force_gc) {
 1280|       |#ifdef DUMP_GC
 1281|       |        printf("GC: size=%" PRIu64 "\n",
 1282|       |               (uint64_t)rt->malloc_state.malloc_size);
 1283|       |#endif
 1284|    976|        JS_RunGC(rt);
 1285|    976|        rt->malloc_gc_threshold = rt->malloc_state.malloc_size +
 1286|    976|            (rt->malloc_state.malloc_size >> 1);
 1287|    976|    }
 1288|  9.09M|}
 1289|       |
 1290|       |static size_t js_malloc_usable_size_unknown(const void *ptr)
 1291|      0|{
 1292|      0|    return 0;
 1293|      0|}
 1294|       |
 1295|       |void *js_malloc_rt(JSRuntime *rt, size_t size)
 1296|  70.0M|{
 1297|  70.0M|    return rt->mf.js_malloc(&rt->malloc_state, size);
 1298|  70.0M|}
 1299|       |
 1300|       |void js_free_rt(JSRuntime *rt, void *ptr)
 1301|  74.4M|{
 1302|  74.4M|    rt->mf.js_free(&rt->malloc_state, ptr);
 1303|  74.4M|}
 1304|       |
 1305|       |void *js_realloc_rt(JSRuntime *rt, void *ptr, size_t size)
 1306|  22.5M|{
 1307|  22.5M|    return rt->mf.js_realloc(&rt->malloc_state, ptr, size);
 1308|  22.5M|}
 1309|       |
 1310|       |size_t js_malloc_usable_size_rt(JSRuntime *rt, const void *ptr)
 1311|  3.92M|{
 1312|  3.92M|    return rt->mf.js_malloc_usable_size(ptr);
 1313|  3.92M|}
 1314|       |
 1315|       |void *js_mallocz_rt(JSRuntime *rt, size_t size)
 1316|   589k|{
 1317|   589k|    void *ptr;
 1318|   589k|    ptr = js_malloc_rt(rt, size);
 1319|   589k|    if (!ptr)
 1320|      0|        return NULL;
 1321|   589k|    return memset(ptr, 0, size);
 1322|   589k|}
 1323|       |
 1324|       |/* Throw out of memory in case of error */
 1325|       |void *js_malloc(JSContext *ctx, size_t size)
 1326|  44.5M|{
 1327|  44.5M|    void *ptr;
 1328|  44.5M|    ptr = js_malloc_rt(ctx->rt, size);
 1329|  44.5M|    if (unlikely(!ptr)) {
 1330|      0|        JS_ThrowOutOfMemory(ctx);
 1331|      0|        return NULL;
 1332|      0|    }
 1333|  44.5M|    return ptr;
 1334|  44.5M|}
 1335|       |
 1336|       |/* Throw out of memory in case of error */
 1337|       |void *js_mallocz(JSContext *ctx, size_t size)
 1338|   447k|{
 1339|   447k|    void *ptr;
 1340|   447k|    ptr = js_mallocz_rt(ctx->rt, size);
 1341|   447k|    if (unlikely(!ptr)) {
 1342|      0|        JS_ThrowOutOfMemory(ctx);
 1343|      0|        return NULL;
 1344|      0|    }
 1345|   447k|    return ptr;
 1346|   447k|}
 1347|       |
 1348|       |void js_free(JSContext *ctx, void *ptr)
 1349|  18.5M|{
 1350|  18.5M|    js_free_rt(ctx->rt, ptr);
 1351|  18.5M|}
 1352|       |
 1353|       |/* Throw out of memory in case of error */
 1354|       |void *js_realloc(JSContext *ctx, void *ptr, size_t size)
 1355|  8.13M|{
 1356|  8.13M|    void *ret;
 1357|  8.13M|    ret = js_realloc_rt(ctx->rt, ptr, size);
 1358|  8.13M|    if (unlikely(!ret && size != 0)) {
 1359|      0|        JS_ThrowOutOfMemory(ctx);
 1360|      0|        return NULL;
 1361|      0|    }
 1362|  8.13M|    return ret;
 1363|  8.13M|}
 1364|       |
 1365|       |/* store extra allocated size in *pslack if successful */
 1366|       |void *js_realloc2(JSContext *ctx, void *ptr, size_t size, size_t *pslack)
 1367|  3.35M|{
 1368|  3.35M|    void *ret;
 1369|  3.35M|    ret = js_realloc_rt(ctx->rt, ptr, size);
 1370|  3.35M|    if (unlikely(!ret && size != 0)) {
 1371|      0|        JS_ThrowOutOfMemory(ctx);
 1372|      0|        return NULL;
 1373|      0|    }
 1374|  3.35M|    if (pslack) {
 1375|  3.35M|        size_t new_size = js_malloc_usable_size_rt(ctx->rt, ret);
 1376|  3.35M|        *pslack = (new_size > size) ? new_size - size : 0;
 1377|  3.35M|    }
 1378|  3.35M|    return ret;
 1379|  3.35M|}
 1380|       |
 1381|       |size_t js_malloc_usable_size(JSContext *ctx, const void *ptr)
 1382|   574k|{
 1383|   574k|    return js_malloc_usable_size_rt(ctx->rt, ptr);
 1384|   574k|}
 1385|       |
 1386|       |/* Throw out of memory exception in case of error */
 1387|       |char *js_strndup(JSContext *ctx, const char *s, size_t n)
 1388|   127k|{
 1389|   127k|    char *ptr;
 1390|   127k|    ptr = js_malloc(ctx, n + 1);
 1391|   127k|    if (ptr) {
 1392|   127k|        memcpy(ptr, s, n);
 1393|   127k|        ptr[n] = '\0';
 1394|   127k|    }
 1395|   127k|    return ptr;
 1396|   127k|}
 1397|       |
 1398|       |char *js_strdup(JSContext *ctx, const char *str)
 1399|     90|{
 1400|     90|    return js_strndup(ctx, str, strlen(str));
 1401|     90|}
 1402|       |
 1403|       |static no_inline int js_realloc_array(JSContext *ctx, void **parray,
 1404|       |                                      int elem_size, int *psize, int req_size)
 1405|  1.15M|{
 1406|  1.15M|    int new_size;
 1407|  1.15M|    size_t slack;
 1408|  1.15M|    void *new_array;
 1409|       |    /* XXX: potential arithmetic overflow */
 1410|  1.15M|    new_size = max_int(req_size, *psize * 3 / 2);
 1411|  1.15M|    new_array = js_realloc2(ctx, *parray, new_size * elem_size, &slack);
 1412|  1.15M|    if (!new_array)
 1413|      0|        return -1;
 1414|  1.15M|    new_size += slack / elem_size;
 1415|  1.15M|    *psize = new_size;
 1416|  1.15M|    *parray = new_array;
 1417|  1.15M|    return 0;
 1418|  1.15M|}
 1419|       |
 1420|       |/* resize the array and update its size if req_size > *psize */
 1421|       |static inline int js_resize_array(JSContext *ctx, void **parray, int elem_size,
 1422|       |                                  int *psize, int req_size)
 1423|  6.93M|{
 1424|  6.93M|    if (unlikely(req_size > *psize))
 1425|  1.15M|        return js_realloc_array(ctx, parray, elem_size, psize, req_size);
 1426|  5.78M|    else
 1427|  5.78M|        return 0;
 1428|  6.93M|}
 1429|       |
 1430|       |static inline void js_dbuf_init(JSContext *ctx, DynBuf *s)
 1431|   763k|{
 1432|   763k|    dbuf_init2(s, ctx->rt, (DynBufReallocFunc *)js_realloc_rt);
 1433|   763k|}
 1434|       |
 1435|  19.9M|static inline int is_digit(int c) {
 1436|  19.9M|    return c >= '0' && c <= '9';
 1437|  19.9M|}
 1438|       |
 1439|  22.3M|static inline int string_get(const JSString *p, int idx) {
 1440|  22.3M|    return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];
 1441|  22.3M|}
 1442|       |
 1443|       |typedef struct JSClassShortDef {
 1444|       |    JSAtom class_name;
 1445|       |    JSClassFinalizer *finalizer;
 1446|       |    JSClassGCMark *gc_mark;
 1447|       |} JSClassShortDef;
 1448|       |
 1449|       |static JSClassShortDef const js_std_class_def[] = {
 1450|       |    { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_OBJECT */
 1451|       |    { JS_ATOM_Array, js_array_finalizer, js_array_mark },       /* JS_CLASS_ARRAY */
 1452|       |    { JS_ATOM_Error, NULL, NULL }, /* JS_CLASS_ERROR */
 1453|       |    { JS_ATOM_Number, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_NUMBER */
 1454|       |    { JS_ATOM_String, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_STRING */
 1455|       |    { JS_ATOM_Boolean, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_BOOLEAN */
 1456|       |    { JS_ATOM_Symbol, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_SYMBOL */
 1457|       |    { JS_ATOM_Arguments, js_array_finalizer, js_array_mark },   /* JS_CLASS_ARGUMENTS */
 1458|       |    { JS_ATOM_Arguments, NULL, NULL },                          /* JS_CLASS_MAPPED_ARGUMENTS */
 1459|       |    { JS_ATOM_Date, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_DATE */
 1460|       |    { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_MODULE_NS */
 1461|       |    { JS_ATOM_Function, js_c_function_finalizer, js_c_function_mark }, /* JS_CLASS_C_FUNCTION */
 1462|       |    { JS_ATOM_Function, js_bytecode_function_finalizer, js_bytecode_function_mark }, /* JS_CLASS_BYTECODE_FUNCTION */
 1463|       |    { JS_ATOM_Function, js_bound_function_finalizer, js_bound_function_mark }, /* JS_CLASS_BOUND_FUNCTION */
 1464|       |    { JS_ATOM_Function, js_c_function_data_finalizer, js_c_function_data_mark }, /* JS_CLASS_C_FUNCTION_DATA */
 1465|       |    { JS_ATOM_GeneratorFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_GENERATOR_FUNCTION */
 1466|       |    { JS_ATOM_ForInIterator, js_for_in_iterator_finalizer, js_for_in_iterator_mark },      /* JS_CLASS_FOR_IN_ITERATOR */
 1467|       |    { JS_ATOM_RegExp, js_regexp_finalizer, NULL },                              /* JS_CLASS_REGEXP */
 1468|       |    { JS_ATOM_ArrayBuffer, js_array_buffer_finalizer, NULL },                   /* JS_CLASS_ARRAY_BUFFER */
 1469|       |    { JS_ATOM_SharedArrayBuffer, js_array_buffer_finalizer, NULL },             /* JS_CLASS_SHARED_ARRAY_BUFFER */
 1470|       |    { JS_ATOM_Uint8ClampedArray, js_typed_array_finalizer, js_typed_array_mark }, /* JS_CLASS_UINT8C_ARRAY */
 1471|       |    { JS_ATOM_Int8Array, js_typed_array_finalizer, js_typed_array_mark },       /* JS_CLASS_INT8_ARRAY */
 1472|       |    { JS_ATOM_Uint8Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_UINT8_ARRAY */
 1473|       |    { JS_ATOM_Int16Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT16_ARRAY */
 1474|       |    { JS_ATOM_Uint16Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT16_ARRAY */
 1475|       |    { JS_ATOM_Int32Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT32_ARRAY */
 1476|       |    { JS_ATOM_Uint32Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT32_ARRAY */
 1477|       |    { JS_ATOM_BigInt64Array, js_typed_array_finalizer, js_typed_array_mark },   /* JS_CLASS_BIG_INT64_ARRAY */
 1478|       |    { JS_ATOM_BigUint64Array, js_typed_array_finalizer, js_typed_array_mark },  /* JS_CLASS_BIG_UINT64_ARRAY */
 1479|       |    { JS_ATOM_Float32Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT32_ARRAY */
 1480|       |    { JS_ATOM_Float64Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT64_ARRAY */
 1481|       |    { JS_ATOM_DataView, js_typed_array_finalizer, js_typed_array_mark },        /* JS_CLASS_DATAVIEW */
 1482|       |    { JS_ATOM_BigInt, js_object_data_finalizer, js_object_data_mark },      /* JS_CLASS_BIG_INT */
 1483|       |    { JS_ATOM_Map, js_map_finalizer, js_map_mark },             /* JS_CLASS_MAP */
 1484|       |    { JS_ATOM_Set, js_map_finalizer, js_map_mark },             /* JS_CLASS_SET */
 1485|       |    { JS_ATOM_WeakMap, js_map_finalizer, js_map_mark },         /* JS_CLASS_WEAKMAP */
 1486|       |    { JS_ATOM_WeakSet, js_map_finalizer, js_map_mark },         /* JS_CLASS_WEAKSET */
 1487|       |    { JS_ATOM_Map_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_MAP_ITERATOR */
 1488|       |    { JS_ATOM_Set_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_SET_ITERATOR */
 1489|       |    { JS_ATOM_Array_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_ARRAY_ITERATOR */
 1490|       |    { JS_ATOM_String_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_STRING_ITERATOR */
 1491|       |    { JS_ATOM_RegExp_String_Iterator, js_regexp_string_iterator_finalizer, js_regexp_string_iterator_mark }, /* JS_CLASS_REGEXP_STRING_ITERATOR */
 1492|       |    { JS_ATOM_Generator, js_generator_finalizer, js_generator_mark }, /* JS_CLASS_GENERATOR */
 1493|       |};
 1494|       |
 1495|       |static int init_class_range(JSRuntime *rt, JSClassShortDef const *tab,
 1496|       |                            int start, int count)
 1497|  88.8k|{
 1498|  88.8k|    JSClassDef cm_s, *cm = &cm_s;
 1499|  88.8k|    int i, class_id;
 1500|       |
 1501|  1.06M|    for(i = 0; i < count; i++) {
 1502|   977k|        class_id = i + start;
 1503|   977k|        memset(cm, 0, sizeof(*cm));
 1504|   977k|        cm->finalizer = tab[i].finalizer;
 1505|   977k|        cm->gc_mark = tab[i].gc_mark;
 1506|   977k|        if (JS_NewClass1(rt, class_id, cm, tab[i].class_name) < 0)
 1507|      0|            return -1;
 1508|   977k|    }
 1509|  88.8k|    return 0;
 1510|  88.8k|}
 1511|       |
 1512|       |#if !defined(CONFIG_STACK_CHECK)
 1513|       |/* no stack limitation */
 1514|       |static inline uintptr_t js_get_stack_pointer(void)
 1515|       |{
 1516|       |    return 0;
 1517|       |}
 1518|       |
 1519|       |static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
 1520|       |{
 1521|       |    return FALSE;
 1522|       |}
 1523|       |#else
 1524|       |/* Note: OS and CPU dependent */
 1525|       |static inline uintptr_t js_get_stack_pointer(void)
 1526|  33.3M|{
 1527|  33.3M|    return (uintptr_t)__builtin_frame_address(0);
 1528|  33.3M|}
 1529|       |
 1530|       |static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
 1531|  33.3M|{
 1532|  33.3M|    uintptr_t sp;
 1533|  33.3M|    sp = js_get_stack_pointer() - alloca_size;
 1534|  33.3M|    return unlikely(sp < rt->stack_limit);
 1535|  33.3M|}
 1536|       |#endif
 1537|       |
 1538|       |JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque)
 1539|  17.7k|{
 1540|  17.7k|    JSRuntime *rt;
 1541|  17.7k|    JSMallocState ms;
 1542|       |
 1543|  17.7k|    memset(&ms, 0, sizeof(ms));
 1544|  17.7k|    ms.opaque = opaque;
 1545|  17.7k|    ms.malloc_limit = -1;
 1546|       |
 1547|  17.7k|    rt = mf->js_malloc(&ms, sizeof(JSRuntime));
 1548|  17.7k|    if (!rt)
 1549|      0|        return NULL;
 1550|  17.7k|    memset(rt, 0, sizeof(*rt));
 1551|  17.7k|    rt->mf = *mf;
 1552|  17.7k|    if (!rt->mf.js_malloc_usable_size) {
 1553|       |        /* use dummy function if none provided */
 1554|      0|        rt->mf.js_malloc_usable_size = js_malloc_usable_size_unknown;
 1555|      0|    }
 1556|  17.7k|    rt->malloc_state = ms;
 1557|  17.7k|    rt->malloc_gc_threshold = 256 * 1024;
 1558|       |
 1559|  17.7k|    init_list_head(&rt->context_list);
 1560|  17.7k|    init_list_head(&rt->gc_obj_list);
 1561|  17.7k|    init_list_head(&rt->gc_zero_ref_count_list);
 1562|  17.7k|    rt->gc_phase = JS_GC_PHASE_NONE;
 1563|  17.7k|    init_list_head(&rt->weakref_list);
 1564|       |
 1565|       |#ifdef DUMP_LEAKS
 1566|       |    init_list_head(&rt->string_list);
 1567|       |#endif
 1568|  17.7k|    init_list_head(&rt->job_list);
 1569|       |
 1570|  17.7k|    if (JS_InitAtoms(rt))
 1571|      0|        goto fail;
 1572|       |
 1573|       |    /* create the object, array and function classes */
 1574|  17.7k|    if (init_class_range(rt, js_std_class_def, JS_CLASS_OBJECT,
 1575|  17.7k|                         countof(js_std_class_def)) < 0)
 1576|      0|        goto fail;
 1577|  17.7k|    rt->class_array[JS_CLASS_ARGUMENTS].exotic = &js_arguments_exotic_methods;
 1578|  17.7k|    rt->class_array[JS_CLASS_STRING].exotic = &js_string_exotic_methods;
 1579|  17.7k|    rt->class_array[JS_CLASS_MODULE_NS].exotic = &js_module_ns_exotic_methods;
 1580|       |
 1581|  17.7k|    rt->class_array[JS_CLASS_C_FUNCTION].call = js_call_c_function;
 1582|  17.7k|    rt->class_array[JS_CLASS_C_FUNCTION_DATA].call = js_c_function_data_call;
 1583|  17.7k|    rt->class_array[JS_CLASS_BOUND_FUNCTION].call = js_call_bound_function;
 1584|  17.7k|    rt->class_array[JS_CLASS_GENERATOR_FUNCTION].call = js_generator_function_call;
 1585|  17.7k|    if (init_shape_hash(rt))
 1586|      0|        goto fail;
 1587|       |
 1588|  17.7k|    rt->stack_size = JS_DEFAULT_STACK_SIZE;
 1589|  17.7k|    JS_UpdateStackTop(rt);
 1590|       |
 1591|  17.7k|    rt->current_exception = JS_UNINITIALIZED;
 1592|       |
 1593|  17.7k|    return rt;
 1594|      0| fail:
 1595|      0|    JS_FreeRuntime(rt);
 1596|      0|    return NULL;
 1597|  17.7k|}
 1598|       |
 1599|       |void *JS_GetRuntimeOpaque(JSRuntime *rt)
 1600|  17.4k|{
 1601|  17.4k|    return rt->user_opaque;
 1602|  17.4k|}
 1603|       |
 1604|       |void JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque)
 1605|  35.1k|{
 1606|  35.1k|    rt->user_opaque = opaque;
 1607|  35.1k|}
 1608|       |
 1609|       |/* default memory allocation functions with memory limitation */
 1610|       |static size_t js_def_malloc_usable_size(const void *ptr)
 1611|   186M|{
 1612|       |#if defined(__APPLE__)
 1613|       |    return malloc_size(ptr);
 1614|       |#elif defined(_WIN32)
 1615|       |    return _msize((void *)ptr);
 1616|       |#elif defined(EMSCRIPTEN)
 1617|       |    return 0;
 1618|       |#elif defined(__linux__) || defined(__GLIBC__)
 1619|   186M|    return malloc_usable_size((void *)ptr);
 1620|       |#else
 1621|       |    /* change this to `return 0;` if compilation fails */
 1622|       |    return malloc_usable_size((void *)ptr);
 1623|       |#endif
 1624|   186M|}
 1625|       |
 1626|       |static void *js_def_malloc(JSMallocState *s, size_t size)
 1627|  72.1M|{
 1628|  72.1M|    void *ptr;
 1629|       |
 1630|       |    /* Do not allocate zero bytes: behavior is platform dependent */
 1631|  72.1M|    assert(size != 0);
 1632|       |
 1633|  72.1M|    if (unlikely(s->malloc_size + size > s->malloc_limit))
 1634|      0|        return NULL;
 1635|       |
 1636|  72.1M|    ptr = malloc(size);
 1637|  72.1M|    if (!ptr)
 1638|      0|        return NULL;
 1639|       |
 1640|  72.1M|    s->malloc_count++;
 1641|  72.1M|    s->malloc_size += js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
 1642|  72.1M|    return ptr;
 1643|  72.1M|}
 1644|       |
 1645|       |static void js_def_free(JSMallocState *s, void *ptr)
 1646|  74.4M|{
 1647|  74.4M|    if (!ptr)
 1648|  3.77M|        return;
 1649|       |
 1650|  70.7M|    s->malloc_count--;
 1651|  70.7M|    s->malloc_size -= js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
 1652|  70.7M|    free(ptr);
 1653|  70.7M|}
 1654|       |
 1655|       |static void *js_def_realloc(JSMallocState *s, void *ptr, size_t size)
 1656|  22.5M|{
 1657|  22.5M|    size_t old_size;
 1658|       |
 1659|  22.5M|    if (!ptr) {
 1660|  2.07M|        if (size == 0)
 1661|  34.1k|            return NULL;
 1662|  2.03M|        return js_def_malloc(s, size);
 1663|  2.07M|    }
 1664|  20.4M|    old_size = js_def_malloc_usable_size(ptr);
 1665|  20.4M|    if (size == 0) {
 1666|   965k|        s->malloc_count--;
 1667|   965k|        s->malloc_size -= old_size + MALLOC_OVERHEAD;
 1668|   965k|        free(ptr);
 1669|   965k|        return NULL;
 1670|   965k|    }
 1671|  19.4M|    if (s->malloc_size + size - old_size > s->malloc_limit)
 1672|      0|        return NULL;
 1673|       |
 1674|  19.4M|    ptr = realloc(ptr, size);
 1675|  19.4M|    if (!ptr)
 1676|      0|        return NULL;
 1677|       |
 1678|  19.4M|    s->malloc_size += js_def_malloc_usable_size(ptr) - old_size;
 1679|  19.4M|    return ptr;
 1680|  19.4M|}
 1681|       |
 1682|       |static const JSMallocFunctions def_malloc_funcs = {
 1683|       |    js_def_malloc,
 1684|       |    js_def_free,
 1685|       |    js_def_realloc,
 1686|       |    js_def_malloc_usable_size,
 1687|       |};
 1688|       |
 1689|       |JSRuntime *JS_NewRuntime(void)
 1690|  17.7k|{
 1691|  17.7k|    return JS_NewRuntime2(&def_malloc_funcs, NULL);
 1692|  17.7k|}
 1693|       |
 1694|       |void JS_SetMemoryLimit(JSRuntime *rt, size_t limit)
 1695|      0|{
 1696|      0|    rt->malloc_state.malloc_limit = limit;
 1697|      0|}
 1698|       |
 1699|       |/* use -1 to disable automatic GC */
 1700|       |void JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold)
 1701|      0|{
 1702|      0|    rt->malloc_gc_threshold = gc_threshold;
 1703|      0|}
 1704|       |
 1705|       |#define malloc(s) malloc_is_forbidden(s)
 1706|       |#define free(p) free_is_forbidden(p)
 1707|       |#define realloc(p,s) realloc_is_forbidden(p,s)
 1708|       |
 1709|       |void JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque)
 1710|      0|{
 1711|      0|    rt->interrupt_handler = cb;
 1712|      0|    rt->interrupt_opaque = opaque;
 1713|      0|}
 1714|       |
 1715|       |void JS_SetCanBlock(JSRuntime *rt, BOOL can_block)
 1716|      0|{
 1717|      0|    rt->can_block = can_block;
 1718|      0|}
 1719|       |
 1720|       |void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
 1721|       |                                      const JSSharedArrayBufferFunctions *sf)
 1722|  17.7k|{
 1723|  17.7k|    rt->sab_funcs = *sf;
 1724|  17.7k|}
 1725|       |
 1726|       |void JS_SetStripInfo(JSRuntime *rt, int flags)
 1727|  17.7k|{
 1728|  17.7k|    rt->strip_flags = flags;
 1729|  17.7k|}
 1730|       |
 1731|       |int JS_GetStripInfo(JSRuntime *rt)
 1732|      0|{
 1733|      0|    return rt->strip_flags;
 1734|      0|}
 1735|       |
 1736|       |/* return 0 if OK, < 0 if exception */
 1737|       |int JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func,
 1738|       |                  int argc, JSValueConst *argv)
 1739|      0|{
 1740|      0|    JSRuntime *rt = ctx->rt;
 1741|      0|    JSJobEntry *e;
 1742|      0|    int i;
 1743|       |
 1744|      0|    e = js_malloc(ctx, sizeof(*e) + argc * sizeof(JSValue));
 1745|      0|    if (!e)
 1746|      0|        return -1;
 1747|      0|    e->ctx = ctx;
 1748|      0|    e->job_func = job_func;
 1749|      0|    e->argc = argc;
 1750|      0|    for(i = 0; i < argc; i++) {
 1751|      0|        e->argv[i] = JS_DupValue(ctx, argv[i]);
 1752|      0|    }
 1753|      0|    list_add_tail(&e->link, &rt->job_list);
 1754|      0|    return 0;
 1755|      0|}
 1756|       |
 1757|       |BOOL JS_IsJobPending(JSRuntime *rt)
 1758|      0|{
 1759|      0|    return !list_empty(&rt->job_list);
 1760|      0|}
 1761|       |
 1762|       |/* return < 0 if exception, 0 if no job pending, 1 if a job was
 1763|       |   executed successfully. the context of the job is stored in '*pctx' */
 1764|       |int JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx)
 1765|  3.46k|{
 1766|  3.46k|    JSContext *ctx;
 1767|  3.46k|    JSJobEntry *e;
 1768|  3.46k|    JSValue res;
 1769|  3.46k|    int i, ret;
 1770|       |
 1771|  3.46k|    if (list_empty(&rt->job_list)) {
 1772|  3.46k|        *pctx = NULL;
 1773|  3.46k|        return 0;
 1774|  3.46k|    }
 1775|       |
 1776|       |    /* get the first pending job and execute it */
 1777|      0|    e = list_entry(rt->job_list.next, JSJobEntry, link);
 1778|      0|    list_del(&e->link);
 1779|      0|    ctx = e->ctx;
 1780|      0|    res = e->job_func(e->ctx, e->argc, (JSValueConst *)e->argv);
 1781|      0|    for(i = 0; i < e->argc; i++)
 1782|      0|        JS_FreeValue(ctx, e->argv[i]);
 1783|      0|    if (JS_IsException(res))
 1784|      0|        ret = -1;
 1785|      0|    else
 1786|      0|        ret = 1;
 1787|      0|    JS_FreeValue(ctx, res);
 1788|      0|    js_free(ctx, e);
 1789|      0|    *pctx = ctx;
 1790|      0|    return ret;
 1791|  3.46k|}
 1792|       |
 1793|       |static inline uint32_t atom_get_free(const JSAtomStruct *p)
 1794|  10.9M|{
 1795|  10.9M|    return (uintptr_t)p >> 1;
 1796|  10.9M|}
 1797|       |
 1798|       |static inline BOOL atom_is_free(const JSAtomStruct *p)
 1799|  12.8M|{
 1800|  12.8M|    return (uintptr_t)p & 1;
 1801|  12.8M|}
 1802|       |
 1803|       |static inline JSAtomStruct *atom_set_free(uint32_t v)
 1804|  19.4M|{
 1805|  19.4M|    return (JSAtomStruct *)(((uintptr_t)v << 1) | 1);
 1806|  19.4M|}
 1807|       |
 1808|       |/* Note: the string contents are uninitialized */
 1809|       |static JSString *js_alloc_string_rt(JSRuntime *rt, int max_len, int is_wide_char)
 1810|  24.8M|{
 1811|  24.8M|    JSString *str;
 1812|  24.8M|    str = js_malloc_rt(rt, sizeof(JSString) + (max_len << is_wide_char) + 1 - is_wide_char);
 1813|  24.8M|    if (unlikely(!str))
 1814|      0|        return NULL;
 1815|  24.8M|    str->header.ref_count = 1;
 1816|  24.8M|    str->is_wide_char = is_wide_char;
 1817|  24.8M|    str->len = max_len;
 1818|  24.8M|    str->atom_type = 0;
 1819|  24.8M|    str->hash = 0;          /* optional but costless */
 1820|  24.8M|    str->hash_next = 0;     /* optional */
 1821|       |#ifdef DUMP_LEAKS
 1822|       |    list_add_tail(&str->link, &rt->string_list);
 1823|       |#endif
 1824|  24.8M|    return str;
 1825|  24.8M|}
 1826|       |
 1827|       |static JSString *js_alloc_string(JSContext *ctx, int max_len, int is_wide_char)
 1828|  20.8M|{
 1829|  20.8M|    JSString *p;
 1830|  20.8M|    p = js_alloc_string_rt(ctx->rt, max_len, is_wide_char);
 1831|  20.8M|    if (unlikely(!p)) {
 1832|      0|        JS_ThrowOutOfMemory(ctx);
 1833|      0|        return NULL;
 1834|      0|    }
 1835|  20.8M|    return p;
 1836|  20.8M|}
 1837|       |
 1838|       |/* same as JS_FreeValueRT() but faster */
 1839|       |static inline void js_free_string(JSRuntime *rt, JSString *str)
 1840|   222k|{
 1841|   222k|    if (--str->header.ref_count <= 0) {
 1842|  88.8k|        if (str->atom_type) {
 1843|      0|            JS_FreeAtomStruct(rt, str);
 1844|  88.8k|        } else {
 1845|       |#ifdef DUMP_LEAKS
 1846|       |            list_del(&str->link);
 1847|       |#endif
 1848|  88.8k|            js_free_rt(rt, str);
 1849|  88.8k|        }
 1850|  88.8k|    }
 1851|   222k|}
 1852|       |
 1853|       |void JS_SetRuntimeInfo(JSRuntime *rt, const char *s)
 1854|      0|{
 1855|      0|    if (rt)
 1856|      0|        rt->rt_info = s;
 1857|      0|}
 1858|       |
 1859|       |void JS_FreeRuntime(JSRuntime *rt)
 1860|  17.4k|{
 1861|  17.4k|    struct list_head *el, *el1;
 1862|  17.4k|    int i;
 1863|       |
 1864|  17.4k|    JS_FreeValueRT(rt, rt->current_exception);
 1865|       |
 1866|  17.4k|    list_for_each_safe(el, el1, &rt->job_list) {
 1867|      0|        JSJobEntry *e = list_entry(el, JSJobEntry, link);
 1868|      0|        for(i = 0; i < e->argc; i++)
 1869|      0|            JS_FreeValueRT(rt, e->argv[i]);
 1870|      0|        js_free_rt(rt, e);
 1871|      0|    }
 1872|  17.4k|    init_list_head(&rt->job_list);
 1873|       |
 1874|       |    /* don't remove the weak objects to avoid create new jobs with
 1875|       |       FinalizationRegistry */
 1876|  17.4k|    JS_RunGCInternal(rt, FALSE);
 1877|       |
 1878|       |#ifdef DUMP_LEAKS
 1879|       |    /* leaking objects */
 1880|       |    {
 1881|       |        BOOL header_done;
 1882|       |        JSGCObjectHeader *p;
 1883|       |        int count;
 1884|       |
 1885|       |        /* remove the internal refcounts to display only the object
 1886|       |           referenced externally */
 1887|       |        list_for_each(el, &rt->gc_obj_list) {
 1888|       |            p = list_entry(el, JSGCObjectHeader, link);
 1889|       |            p->mark = 0;
 1890|       |        }
 1891|       |        gc_decref(rt);
 1892|       |
 1893|       |        header_done = FALSE;
 1894|       |        list_for_each(el, &rt->gc_obj_list) {
 1895|       |            p = list_entry(el, JSGCObjectHeader, link);
 1896|       |            if (p->ref_count != 0) {
 1897|       |                if (!header_done) {
 1898|       |                    printf("Object leaks:\n");
 1899|       |                    JS_DumpObjectHeader(rt);
 1900|       |                    header_done = TRUE;
 1901|       |                }
 1902|       |                JS_DumpGCObject(rt, p);
 1903|       |            }
 1904|       |        }
 1905|       |
 1906|       |        count = 0;
 1907|       |        list_for_each(el, &rt->gc_obj_list) {
 1908|       |            p = list_entry(el, JSGCObjectHeader, link);
 1909|       |            if (p->ref_count == 0) {
 1910|       |                count++;
 1911|       |            }
 1912|       |        }
 1913|       |        if (count != 0)
 1914|       |            printf("Secondary object leaks: %d\n", count);
 1915|       |    }
 1916|       |#endif
 1917|  17.4k|    assert(list_empty(&rt->gc_obj_list));
 1918|  17.4k|    assert(list_empty(&rt->weakref_list));
 1919|       |
 1920|       |    /* free the classes */
 1921|   992k|    for(i = 0; i < rt->class_count; i++) {
 1922|   975k|        JSClass *cl = &rt->class_array[i];
 1923|   975k|        if (cl->class_id != 0) {
 1924|   957k|            JS_FreeAtomRT(rt, cl->class_name);
 1925|   957k|        }
 1926|   975k|    }
 1927|  17.4k|    js_free_rt(rt, rt->class_array);
 1928|       |
 1929|       |#ifdef DUMP_LEAKS
 1930|       |    /* only the atoms defined in JS_InitAtoms() should be left */
 1931|       |    {
 1932|       |        BOOL header_done = FALSE;
 1933|       |
 1934|       |        for(i = 0; i < rt->atom_size; i++) {
 1935|       |            JSAtomStruct *p = rt->atom_array[i];
 1936|       |            if (!atom_is_free(p) /* && p->str*/) {
 1937|       |                if (i >= JS_ATOM_END || p->header.ref_count != 1) {
 1938|       |                    if (!header_done) {
 1939|       |                        header_done = TRUE;
 1940|       |                        if (rt->rt_info) {
 1941|       |                            printf("%s:1: atom leakage:", rt->rt_info);
 1942|       |                        } else {
 1943|       |                            printf("Atom leaks:\n"
 1944|       |                                   "    %6s %6s %s\n",
 1945|       |                                   "ID", "REFCNT", "NAME");
 1946|       |                        }
 1947|       |                    }
 1948|       |                    if (rt->rt_info) {
 1949|       |                        printf(" ");
 1950|       |                    } else {
 1951|       |                        printf("    %6u %6u ", i, p->header.ref_count);
 1952|       |                    }
 1953|       |                    switch (p->atom_type) {
 1954|       |                    case JS_ATOM_TYPE_STRING:
 1955|       |                        JS_DumpString(rt, p);
 1956|       |                        break;
 1957|       |                    case JS_ATOM_TYPE_GLOBAL_SYMBOL:
 1958|       |                        printf("Symbol.for(");
 1959|       |                        JS_DumpString(rt, p);
 1960|       |                        printf(")");
 1961|       |                        break;
 1962|       |                    case JS_ATOM_TYPE_SYMBOL:
 1963|       |                        if (p->hash != JS_ATOM_HASH_PRIVATE) {
 1964|       |                            printf("Symbol(");
 1965|       |                            JS_DumpString(rt, p);
 1966|       |                            printf(")");
 1967|       |                        } else {
 1968|       |                            printf("Private(");
 1969|       |                            JS_DumpString(rt, p);
 1970|       |                            printf(")");
 1971|       |                        }
 1972|       |                        break;
 1973|       |                    }
 1974|       |                    if (rt->rt_info) {
 1975|       |                        printf(":%u", p->header.ref_count);
 1976|       |                    } else {
 1977|       |                        printf("\n");
 1978|       |                    }
 1979|       |                }
 1980|       |            }
 1981|       |        }
 1982|       |        if (rt->rt_info && header_done)
 1983|       |            printf("\n");
 1984|       |    }
 1985|       |#endif
 1986|       |
 1987|       |    /* free the atoms */
 1988|  12.4M|    for(i = 0; i < rt->atom_size; i++) {
 1989|  12.3M|        JSAtomStruct *p = rt->atom_array[i];
 1990|  12.3M|        if (!atom_is_free(p)) {
 1991|       |#ifdef DUMP_LEAKS
 1992|       |            list_del(&p->link);
 1993|       |#endif
 1994|  3.88M|            js_free_rt(rt, p);
 1995|  3.88M|        }
 1996|  12.3M|    }
 1997|  17.4k|    js_free_rt(rt, rt->atom_array);
 1998|  17.4k|    js_free_rt(rt, rt->atom_hash);
 1999|  17.4k|    js_free_rt(rt, rt->shape_hash);
 2000|       |#ifdef DUMP_LEAKS
 2001|       |    if (!list_empty(&rt->string_list)) {
 2002|       |        if (rt->rt_info) {
 2003|       |            printf("%s:1: string leakage:", rt->rt_info);
 2004|       |        } else {
 2005|       |            printf("String leaks:\n"
 2006|       |                   "    %6s %s\n",
 2007|       |                   "REFCNT", "VALUE");
 2008|       |        }
 2009|       |        list_for_each_safe(el, el1, &rt->string_list) {
 2010|       |            JSString *str = list_entry(el, JSString, link);
 2011|       |            if (rt->rt_info) {
 2012|       |                printf(" ");
 2013|       |            } else {
 2014|       |                printf("    %6u ", str->header.ref_count);
 2015|       |            }
 2016|       |            JS_DumpString(rt, str);
 2017|       |            if (rt->rt_info) {
 2018|       |                printf(":%u", str->header.ref_count);
 2019|       |            } else {
 2020|       |                printf("\n");
 2021|       |            }
 2022|       |            list_del(&str->link);
 2023|       |            js_free_rt(rt, str);
 2024|       |        }
 2025|       |        if (rt->rt_info)
 2026|       |            printf("\n");
 2027|       |    }
 2028|       |    {
 2029|       |        JSMallocState *s = &rt->malloc_state;
 2030|       |        if (s->malloc_count > 1) {
 2031|       |            if (rt->rt_info)
 2032|       |                printf("%s:1: ", rt->rt_info);
 2033|       |            printf("Memory leak: %"PRIu64" bytes lost in %"PRIu64" block%s\n",
 2034|       |                   (uint64_t)(s->malloc_size - sizeof(JSRuntime)),
 2035|       |                   (uint64_t)(s->malloc_count - 1), &"s"[s->malloc_count == 2]);
 2036|       |        }
 2037|       |    }
 2038|       |#endif
 2039|       |
 2040|  17.4k|    {
 2041|  17.4k|        JSMallocState ms = rt->malloc_state;
 2042|  17.4k|        rt->mf.js_free(&ms, rt);
 2043|  17.4k|    }
 2044|  17.4k|}
 2045|       |
 2046|       |JSContext *JS_NewContextRaw(JSRuntime *rt)
 2047|  17.7k|{
 2048|  17.7k|    JSContext *ctx;
 2049|  17.7k|    int i;
 2050|       |
 2051|  17.7k|    ctx = js_mallocz_rt(rt, sizeof(JSContext));
 2052|  17.7k|    if (!ctx)
 2053|      0|        return NULL;
 2054|  17.7k|    ctx->header.ref_count = 1;
 2055|  17.7k|    add_gc_object(rt, &ctx->header, JS_GC_OBJ_TYPE_JS_CONTEXT);
 2056|       |
 2057|  17.7k|    ctx->class_proto = js_malloc_rt(rt, sizeof(ctx->class_proto[0]) *
 2058|  17.7k|                                    rt->class_count);
 2059|  17.7k|    if (!ctx->class_proto) {
 2060|      0|        js_free_rt(rt, ctx);
 2061|      0|        return NULL;
 2062|      0|    }
 2063|  17.7k|    ctx->rt = rt;
 2064|  17.7k|    list_add_tail(&ctx->link, &rt->context_list);
 2065|  1.01M|    for(i = 0; i < rt->class_count; i++)
 2066|   995k|        ctx->class_proto[i] = JS_NULL;
 2067|  17.7k|    ctx->array_ctor = JS_NULL;
 2068|  17.7k|    ctx->regexp_ctor = JS_NULL;
 2069|  17.7k|    ctx->promise_ctor = JS_NULL;
 2070|  17.7k|    init_list_head(&ctx->loaded_modules);
 2071|       |
 2072|  17.7k|    JS_AddIntrinsicBasicObjects(ctx);
 2073|  17.7k|    return ctx;
 2074|  17.7k|}
 2075|       |
 2076|       |JSContext *JS_NewContext(JSRuntime *rt)
 2077|  17.7k|{
 2078|  17.7k|    JSContext *ctx;
 2079|       |
 2080|  17.7k|    ctx = JS_NewContextRaw(rt);
 2081|  17.7k|    if (!ctx)
 2082|      0|        return NULL;
 2083|       |
 2084|  17.7k|    JS_AddIntrinsicBaseObjects(ctx);
 2085|  17.7k|    JS_AddIntrinsicDate(ctx);
 2086|  17.7k|    JS_AddIntrinsicEval(ctx);
 2087|  17.7k|    JS_AddIntrinsicStringNormalize(ctx);
 2088|  17.7k|    JS_AddIntrinsicRegExp(ctx);
 2089|  17.7k|    JS_AddIntrinsicJSON(ctx);
 2090|  17.7k|    JS_AddIntrinsicProxy(ctx);
 2091|  17.7k|    JS_AddIntrinsicMapSet(ctx);
 2092|  17.7k|    JS_AddIntrinsicTypedArrays(ctx);
 2093|  17.7k|    JS_AddIntrinsicPromise(ctx);
 2094|  17.7k|    JS_AddIntrinsicWeakRef(ctx);
 2095|  17.7k|    return ctx;
 2096|  17.7k|}
 2097|       |
 2098|       |void *JS_GetContextOpaque(JSContext *ctx)
 2099|      0|{
 2100|      0|    return ctx->user_opaque;
 2101|      0|}
 2102|       |
 2103|       |void JS_SetContextOpaque(JSContext *ctx, void *opaque)
 2104|      0|{
 2105|      0|    ctx->user_opaque = opaque;
 2106|      0|}
 2107|       |
 2108|       |/* set the new value and free the old value after (freeing the value
 2109|       |   can reallocate the object data) */
 2110|       |static inline void set_value(JSContext *ctx, JSValue *pval, JSValue new_val)
 2111|  9.97M|{
 2112|  9.97M|    JSValue old_val;
 2113|  9.97M|    old_val = *pval;
 2114|  9.97M|    *pval = new_val;
 2115|  9.97M|    JS_FreeValue(ctx, old_val);
 2116|  9.97M|}
 2117|       |
 2118|       |void JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj)
 2119|      0|{
 2120|      0|    JSRuntime *rt = ctx->rt;
 2121|      0|    assert(class_id < rt->class_count);
 2122|      0|    set_value(ctx, &ctx->class_proto[class_id], obj);
 2123|      0|}
 2124|       |
 2125|       |JSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id)
 2126|      0|{
 2127|      0|    JSRuntime *rt = ctx->rt;
 2128|      0|    assert(class_id < rt->class_count);
 2129|      0|    return JS_DupValue(ctx, ctx->class_proto[class_id]);
 2130|      0|}
 2131|       |
 2132|       |typedef enum JSFreeModuleEnum {
 2133|       |    JS_FREE_MODULE_ALL,
 2134|       |    JS_FREE_MODULE_NOT_RESOLVED,
 2135|       |} JSFreeModuleEnum;
 2136|       |
 2137|       |/* XXX: would be more efficient with separate module lists */
 2138|       |static void js_free_modules(JSContext *ctx, JSFreeModuleEnum flag)
 2139|  17.4k|{
 2140|  17.4k|    struct list_head *el, *el1;
 2141|  34.8k|    list_for_each_safe(el, el1, &ctx->loaded_modules) {
 2142|  34.8k|        JSModuleDef *m = list_entry(el, JSModuleDef, link);
 2143|  34.8k|        if (flag == JS_FREE_MODULE_ALL ||
 2144|  34.8k|            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved)) {
 2145|  34.8k|            js_free_module_def(ctx, m);
 2146|  34.8k|        }
 2147|  34.8k|    }
 2148|  17.4k|}
 2149|       |
 2150|       |JSContext *JS_DupContext(JSContext *ctx)
 2151|  8.29M|{
 2152|  8.29M|    ctx->header.ref_count++;
 2153|  8.29M|    return ctx;
 2154|  8.29M|}
 2155|       |
 2156|       |/* used by the GC */
 2157|       |static void JS_MarkContext(JSRuntime *rt, JSContext *ctx,
 2158|       |                           JS_MarkFunc *mark_func)
 2159|  36.7k|{
 2160|  36.7k|    int i;
 2161|  36.7k|    struct list_head *el;
 2162|       |
 2163|       |    /* modules are not seen by the GC, so we directly mark the objects
 2164|       |       referenced by each module */
 2165|  73.7k|    list_for_each(el, &ctx->loaded_modules) {
 2166|  73.7k|        JSModuleDef *m = list_entry(el, JSModuleDef, link);
 2167|  73.7k|        js_mark_module_def(rt, m, mark_func);
 2168|  73.7k|    }
 2169|       |
 2170|  36.7k|    JS_MarkValue(rt, ctx->global_obj, mark_func);
 2171|  36.7k|    JS_MarkValue(rt, ctx->global_var_obj, mark_func);
 2172|       |
 2173|  36.7k|    JS_MarkValue(rt, ctx->throw_type_error, mark_func);
 2174|  36.7k|    JS_MarkValue(rt, ctx->eval_obj, mark_func);
 2175|       |
 2176|  36.7k|    JS_MarkValue(rt, ctx->array_proto_values, mark_func);
 2177|   331k|    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
 2178|   294k|        JS_MarkValue(rt, ctx->native_error_proto[i], mark_func);
 2179|   294k|    }
 2180|  2.09M|    for(i = 0; i < rt->class_count; i++) {
 2181|  2.06M|        JS_MarkValue(rt, ctx->class_proto[i], mark_func);
 2182|  2.06M|    }
 2183|  36.7k|    JS_MarkValue(rt, ctx->iterator_proto, mark_func);
 2184|  36.7k|    JS_MarkValue(rt, ctx->async_iterator_proto, mark_func);
 2185|  36.7k|    JS_MarkValue(rt, ctx->promise_ctor, mark_func);
 2186|  36.7k|    JS_MarkValue(rt, ctx->array_ctor, mark_func);
 2187|  36.7k|    JS_MarkValue(rt, ctx->regexp_ctor, mark_func);
 2188|  36.7k|    JS_MarkValue(rt, ctx->function_ctor, mark_func);
 2189|  36.7k|    JS_MarkValue(rt, ctx->function_proto, mark_func);
 2190|       |
 2191|  36.7k|    if (ctx->array_shape)
 2192|  36.7k|        mark_func(rt, &ctx->array_shape->header);
 2193|  36.7k|}
 2194|       |
 2195|       |void JS_FreeContext(JSContext *ctx)
 2196|  8.13M|{
 2197|  8.13M|    JSRuntime *rt = ctx->rt;
 2198|  8.13M|    int i;
 2199|       |
 2200|  8.13M|    if (--ctx->header.ref_count > 0)
 2201|  8.12M|        return;
 2202|  17.4k|    assert(ctx->header.ref_count == 0);
 2203|       |
 2204|       |#ifdef DUMP_ATOMS
 2205|       |    JS_DumpAtoms(ctx->rt);
 2206|       |#endif
 2207|       |#ifdef DUMP_SHAPES
 2208|       |    JS_DumpShapes(ctx->rt);
 2209|       |#endif
 2210|       |#ifdef DUMP_OBJECTS
 2211|       |    {
 2212|       |        struct list_head *el;
 2213|       |        JSGCObjectHeader *p;
 2214|       |        printf("JSObjects: {\n");
 2215|       |        JS_DumpObjectHeader(ctx->rt);
 2216|       |        list_for_each(el, &rt->gc_obj_list) {
 2217|       |            p = list_entry(el, JSGCObjectHeader, link);
 2218|       |            JS_DumpGCObject(rt, p);
 2219|       |        }
 2220|       |        printf("}\n");
 2221|       |    }
 2222|       |#endif
 2223|       |#ifdef DUMP_MEM
 2224|       |    {
 2225|       |        JSMemoryUsage stats;
 2226|       |        JS_ComputeMemoryUsage(rt, &stats);
 2227|       |        JS_DumpMemoryUsage(stdout, &stats, rt);
 2228|       |    }
 2229|       |#endif
 2230|       |
 2231|  17.4k|    js_free_modules(ctx, JS_FREE_MODULE_ALL);
 2232|       |
 2233|  17.4k|    JS_FreeValue(ctx, ctx->global_obj);
 2234|  17.4k|    JS_FreeValue(ctx, ctx->global_var_obj);
 2235|       |
 2236|  17.4k|    JS_FreeValue(ctx, ctx->throw_type_error);
 2237|  17.4k|    JS_FreeValue(ctx, ctx->eval_obj);
 2238|       |
 2239|  17.4k|    JS_FreeValue(ctx, ctx->array_proto_values);
 2240|   156k|    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
 2241|   139k|        JS_FreeValue(ctx, ctx->native_error_proto[i]);
 2242|   139k|    }
 2243|   992k|    for(i = 0; i < rt->class_count; i++) {
 2244|   975k|        JS_FreeValue(ctx, ctx->class_proto[i]);
 2245|   975k|    }
 2246|  17.4k|    js_free_rt(rt, ctx->class_proto);
 2247|  17.4k|    JS_FreeValue(ctx, ctx->iterator_proto);
 2248|  17.4k|    JS_FreeValue(ctx, ctx->async_iterator_proto);
 2249|  17.4k|    JS_FreeValue(ctx, ctx->promise_ctor);
 2250|  17.4k|    JS_FreeValue(ctx, ctx->array_ctor);
 2251|  17.4k|    JS_FreeValue(ctx, ctx->regexp_ctor);
 2252|  17.4k|    JS_FreeValue(ctx, ctx->function_ctor);
 2253|  17.4k|    JS_FreeValue(ctx, ctx->function_proto);
 2254|       |
 2255|  17.4k|    js_free_shape_null(ctx->rt, ctx->array_shape);
 2256|       |
 2257|  17.4k|    list_del(&ctx->link);
 2258|  17.4k|    remove_gc_object(&ctx->header);
 2259|  17.4k|    js_free_rt(ctx->rt, ctx);
 2260|  17.4k|}
 2261|       |
 2262|       |JSRuntime *JS_GetRuntime(JSContext *ctx)
 2263|  3.46k|{
 2264|  3.46k|    return ctx->rt;
 2265|  3.46k|}
 2266|       |
 2267|       |static void update_stack_limit(JSRuntime *rt)
 2268|  17.7k|{
 2269|  17.7k|    if (rt->stack_size == 0) {
 2270|      0|        rt->stack_limit = 0; /* no limit */
 2271|  17.7k|    } else {
 2272|  17.7k|        rt->stack_limit = rt->stack_top - rt->stack_size;
 2273|  17.7k|    }
 2274|  17.7k|}
 2275|       |
 2276|       |void JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size)
 2277|      0|{
 2278|      0|    rt->stack_size = stack_size;
 2279|      0|    update_stack_limit(rt);
 2280|      0|}
 2281|       |
 2282|       |void JS_UpdateStackTop(JSRuntime *rt)
 2283|  17.7k|{
 2284|  17.7k|    rt->stack_top = js_get_stack_pointer();
 2285|  17.7k|    update_stack_limit(rt);
 2286|  17.7k|}
 2287|       |
 2288|       |static inline BOOL is_strict_mode(JSContext *ctx)
 2289|  4.74M|{
 2290|  4.74M|    JSStackFrame *sf = ctx->rt->current_stack_frame;
 2291|  4.74M|    return (sf && (sf->js_mode & JS_MODE_STRICT));
 2292|  4.74M|}
 2293|       |
 2294|       |/* JSAtom support */
 2295|       |
 2296|   172M|#define JS_ATOM_TAG_INT (1U << 31)
 2297|  6.95M|#define JS_ATOM_MAX_INT (JS_ATOM_TAG_INT - 1)
 2298|  71.0k|#define JS_ATOM_MAX     ((1U << 30) - 1)
 2299|       |
 2300|       |/* return the max count from the hash size */
 2301|  35.5k|#define JS_ATOM_COUNT_RESIZE(n) ((n) * 2)
 2302|       |
 2303|       |static inline BOOL __JS_AtomIsConst(JSAtom v)
 2304|  98.1M|{
 2305|       |#if defined(DUMP_LEAKS) && DUMP_LEAKS > 1
 2306|       |        return (int32_t)v <= 0;
 2307|       |#else
 2308|  98.1M|        return (int32_t)v < JS_ATOM_END;
 2309|  98.1M|#endif
 2310|  98.1M|}
 2311|       |
 2312|       |static inline BOOL __JS_AtomIsTaggedInt(JSAtom v)
 2313|   134M|{
 2314|   134M|    return (v & JS_ATOM_TAG_INT) != 0;
 2315|   134M|}
 2316|       |
 2317|       |static inline JSAtom __JS_AtomFromUInt32(uint32_t v)
 2318|  12.2M|{
 2319|  12.2M|    return v | JS_ATOM_TAG_INT;
 2320|  12.2M|}
 2321|       |
 2322|       |static inline uint32_t __JS_AtomToUInt32(JSAtom atom)
 2323|  18.5M|{
 2324|  18.5M|    return atom & ~JS_ATOM_TAG_INT;
 2325|  18.5M|}
 2326|       |
 2327|       |static inline int is_num(int c)
 2328|  6.67M|{
 2329|  6.67M|    return c >= '0' && c <= '9';
 2330|  6.67M|}
 2331|       |
 2332|       |/* return TRUE if the string is a number n with 0 <= n <= 2^32-1 */
 2333|       |static inline BOOL is_num_string(uint32_t *pval, const JSString *p)
 2334|  8.42M|{
 2335|  8.42M|    uint32_t n;
 2336|  8.42M|    uint64_t n64;
 2337|  8.42M|    int c, i, len;
 2338|       |
 2339|  8.42M|    len = p->len;
 2340|  8.42M|    if (len == 0 || len > 10)
 2341|  1.97M|        return FALSE;
 2342|  6.45M|    c = string_get(p, 0);
 2343|  6.45M|    if (is_num(c)) {
 2344|  92.7k|        if (c == '0') {
 2345|  19.6k|            if (len != 1)
 2346|  1.22k|                return FALSE;
 2347|  18.3k|            n = 0;
 2348|  73.1k|        } else {
 2349|  73.1k|            n = c - '0';
 2350|   263k|            for(i = 1; i < len; i++) {
 2351|   222k|                c = string_get(p, i);
 2352|   222k|                if (!is_num(c))
 2353|  22.8k|                    return FALSE;
 2354|   199k|                n64 = (uint64_t)n * 10 + (c - '0');
 2355|   199k|                if ((n64 >> 32) != 0)
 2356|  8.82k|                    return FALSE;
 2357|   190k|                n = n64;
 2358|   190k|            }
 2359|  73.1k|        }
 2360|  59.8k|        *pval = n;
 2361|  59.8k|        return TRUE;
 2362|  6.36M|    } else {
 2363|  6.36M|        return FALSE;
 2364|  6.36M|    }
 2365|  6.45M|}
 2366|       |
 2367|       |/* XXX: could use faster version ? */
 2368|       |static inline uint32_t hash_string8(const uint8_t *str, size_t len, uint32_t h)
 2369|  30.6M|{
 2370|  30.6M|    size_t i;
 2371|       |
 2372|   307M|    for(i = 0; i < len; i++)
 2373|   276M|        h = h * 263 + str[i];
 2374|  30.6M|    return h;
 2375|  30.6M|}
 2376|       |
 2377|       |static inline uint32_t hash_string16(const uint16_t *str,
 2378|       |                                     size_t len, uint32_t h)
 2379|  48.9k|{
 2380|  48.9k|    size_t i;
 2381|       |
 2382|  5.06M|    for(i = 0; i < len; i++)
 2383|  5.01M|        h = h * 263 + str[i];
 2384|  48.9k|    return h;
 2385|  48.9k|}
 2386|       |
 2387|       |static uint32_t hash_string(const JSString *str, uint32_t h)
 2388|  10.8M|{
 2389|  10.8M|    if (str->is_wide_char)
 2390|  48.9k|        h = hash_string16(str->u.str16, str->len, h);
 2391|  10.8M|    else
 2392|  10.8M|        h = hash_string8(str->u.str8, str->len, h);
 2393|  10.8M|    return h;
 2394|  10.8M|}
 2395|       |
 2396|       |static uint32_t hash_string_rope(JSValueConst val, uint32_t h)
 2397|      0|{
 2398|      0|    if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING) {
 2399|      0|        return hash_string(JS_VALUE_GET_STRING(val), h);
 2400|      0|    } else {
 2401|      0|        JSStringRope *r = JS_VALUE_GET_STRING_ROPE(val);
 2402|      0|        h = hash_string_rope(r->left, h);
 2403|      0|        return hash_string_rope(r->right, h);
 2404|      0|    }
 2405|      0|}
 2406|       |
 2407|       |static __maybe_unused void JS_DumpChar(JSRuntime *rt, int c, int sep)
 2408|      0|{
 2409|      0|    if (c == sep || c == '\\') {
 2410|      0|        putchar('\\');
 2411|      0|        putchar(c);
 2412|      0|    } else if (c >= ' ' && c <= 126) {
 2413|      0|        putchar(c);
 2414|      0|    } else if (c == '\n') {
 2415|      0|        putchar('\\');
 2416|      0|        putchar('n');
 2417|      0|    } else {
 2418|      0|        printf("\\u%04x", c);
 2419|      0|    }
 2420|      0|}
 2421|       |
 2422|       |static __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p)
 2423|      0|{
 2424|      0|    int i, sep;
 2425|      0|
 2426|      0|    if (p == NULL) {
 2427|      0|        printf("<null>");
 2428|      0|        return;
 2429|      0|    }
 2430|      0|    printf("%d", p->header.ref_count);
 2431|      0|    sep = (p->header.ref_count == 1) ? '\"' : '\'';
 2432|      0|    putchar(sep);
 2433|      0|    for(i = 0; i < p->len; i++) {
 2434|      0|        JS_DumpChar(rt, string_get(p, i), sep);
 2435|      0|    }
 2436|      0|    putchar(sep);
 2437|      0|}
 2438|       |
 2439|       |static __maybe_unused void JS_DumpAtoms(JSRuntime *rt)
 2440|      0|{
 2441|      0|    JSAtomStruct *p;
 2442|      0|    int h, i;
 2443|      0|    /* This only dumps hashed atoms, not JS_ATOM_TYPE_SYMBOL atoms */
 2444|      0|    printf("JSAtom count=%d size=%d hash_size=%d:\n",
 2445|      0|           rt->atom_count, rt->atom_size, rt->atom_hash_size);
 2446|      0|    printf("JSAtom hash table: {\n");
 2447|      0|    for(i = 0; i < rt->atom_hash_size; i++) {
 2448|      0|        h = rt->atom_hash[i];
 2449|      0|        if (h) {
 2450|      0|            printf("  %d:", i);
 2451|      0|            while (h) {
 2452|      0|                p = rt->atom_array[h];
 2453|      0|                printf(" ");
 2454|      0|                JS_DumpString(rt, p);
 2455|      0|                h = p->hash_next;
 2456|      0|            }
 2457|      0|            printf("\n");
 2458|      0|        }
 2459|      0|    }
 2460|      0|    printf("}\n");
 2461|      0|    printf("JSAtom table: {\n");
 2462|      0|    for(i = 0; i < rt->atom_size; i++) {
 2463|      0|        p = rt->atom_array[i];
 2464|      0|        if (!atom_is_free(p)) {
 2465|      0|            printf("  %d: { %d %08x ", i, p->atom_type, p->hash);
 2466|      0|            if (!(p->len == 0 && p->is_wide_char != 0))
 2467|      0|                JS_DumpString(rt, p);
 2468|      0|            printf(" %d }\n", p->hash_next);
 2469|      0|        }
 2470|      0|    }
 2471|      0|    printf("}\n");
 2472|      0|}
 2473|       |
 2474|       |static int JS_ResizeAtomHash(JSRuntime *rt, int new_hash_size)
 2475|  35.5k|{
 2476|  35.5k|    JSAtomStruct *p;
 2477|  35.5k|    uint32_t new_hash_mask, h, i, hash_next1, j, *new_hash;
 2478|       |
 2479|  35.5k|    assert((new_hash_size & (new_hash_size - 1)) == 0); /* power of two */
 2480|  35.5k|    new_hash_mask = new_hash_size - 1;
 2481|  35.5k|    new_hash = js_mallocz_rt(rt, sizeof(rt->atom_hash[0]) * new_hash_size);
 2482|  35.5k|    if (!new_hash)
 2483|      0|        return -1;
 2484|  4.58M|    for(i = 0; i < rt->atom_hash_size; i++) {
 2485|  4.54M|        h = rt->atom_hash[i];
 2486|  13.3M|        while (h != 0) {
 2487|  8.83M|            p = rt->atom_array[h];
 2488|  8.83M|            hash_next1 = p->hash_next;
 2489|       |            /* add in new hash table */
 2490|  8.83M|            j = p->hash & new_hash_mask;
 2491|  8.83M|            p->hash_next = new_hash[j];
 2492|  8.83M|            new_hash[j] = h;
 2493|  8.83M|            h = hash_next1;
 2494|  8.83M|        }
 2495|  4.54M|    }
 2496|  35.5k|    js_free_rt(rt, rt->atom_hash);
 2497|  35.5k|    rt->atom_hash = new_hash;
 2498|  35.5k|    rt->atom_hash_size = new_hash_size;
 2499|  35.5k|    rt->atom_count_resize = JS_ATOM_COUNT_RESIZE(new_hash_size);
 2500|       |    //    JS_DumpAtoms(rt);
 2501|  35.5k|    return 0;
 2502|  35.5k|}
 2503|       |
 2504|       |static int JS_InitAtoms(JSRuntime *rt)
 2505|  17.7k|{
 2506|  17.7k|    int i, len, atom_type;
 2507|  17.7k|    const char *p;
 2508|       |
 2509|  17.7k|    rt->atom_hash_size = 0;
 2510|  17.7k|    rt->atom_hash = NULL;
 2511|  17.7k|    rt->atom_count = 0;
 2512|  17.7k|    rt->atom_size = 0;
 2513|  17.7k|    rt->atom_free_index = 0;
 2514|  17.7k|    if (JS_ResizeAtomHash(rt, 256))     /* there are at least 195 predefined atoms */
 2515|      0|        return -1;
 2516|       |
 2517|  17.7k|    p = js_atom_init;
 2518|  3.96M|    for(i = 1; i < JS_ATOM_END; i++) {
 2519|  3.94M|        if (i == JS_ATOM_Private_brand)
 2520|  17.7k|            atom_type = JS_ATOM_TYPE_PRIVATE;
 2521|  3.92M|        else if (i >= JS_ATOM_Symbol_toPrimitive)
 2522|   230k|            atom_type = JS_ATOM_TYPE_SYMBOL;
 2523|  3.69M|        else
 2524|  3.69M|            atom_type = JS_ATOM_TYPE_STRING;
 2525|  3.94M|        len = strlen(p);
 2526|  3.94M|        if (__JS_NewAtomInit(rt, p, len, atom_type) == JS_ATOM_NULL)
 2527|      0|            return -1;
 2528|  3.94M|        p = p + len + 1;
 2529|  3.94M|    }
 2530|  17.7k|    return 0;
 2531|  17.7k|}
 2532|       |
 2533|       |static JSAtom JS_DupAtomRT(JSRuntime *rt, JSAtom v)
 2534|   977k|{
 2535|   977k|    JSAtomStruct *p;
 2536|       |
 2537|   977k|    if (!__JS_AtomIsConst(v)) {
 2538|      0|        p = rt->atom_array[v];
 2539|      0|        p->header.ref_count++;
 2540|      0|    }
 2541|   977k|    return v;
 2542|   977k|}
 2543|       |
 2544|       |JSAtom JS_DupAtom(JSContext *ctx, JSAtom v)
 2545|  25.3M|{
 2546|  25.3M|    JSRuntime *rt;
 2547|  25.3M|    JSAtomStruct *p;
 2548|       |
 2549|  25.3M|    if (!__JS_AtomIsConst(v)) {
 2550|  9.07M|        rt = ctx->rt;
 2551|  9.07M|        p = rt->atom_array[v];
 2552|  9.07M|        p->header.ref_count++;
 2553|  9.07M|    }
 2554|  25.3M|    return v;
 2555|  25.3M|}
 2556|       |
 2557|       |static JSAtomKindEnum JS_AtomGetKind(JSContext *ctx, JSAtom v)
 2558|  85.7M|{
 2559|  85.7M|    JSRuntime *rt;
 2560|  85.7M|    JSAtomStruct *p;
 2561|       |
 2562|  85.7M|    rt = ctx->rt;
 2563|  85.7M|    if (__JS_AtomIsTaggedInt(v))
 2564|      0|        return JS_ATOM_KIND_STRING;
 2565|  85.7M|    p = rt->atom_array[v];
 2566|  85.7M|    switch(p->atom_type) {
 2567|  84.7M|    case JS_ATOM_TYPE_STRING:
 2568|  84.7M|        return JS_ATOM_KIND_STRING;
 2569|      0|    case JS_ATOM_TYPE_GLOBAL_SYMBOL:
 2570|      0|        return JS_ATOM_KIND_SYMBOL;
 2571|  1.03M|    case JS_ATOM_TYPE_SYMBOL:
 2572|  1.03M|        if (p->hash == JS_ATOM_HASH_PRIVATE)
 2573|      0|            return JS_ATOM_KIND_PRIVATE;
 2574|  1.03M|        else
 2575|  1.03M|            return JS_ATOM_KIND_SYMBOL;
 2576|      0|    default:
 2577|      0|        abort();
 2578|  85.7M|    }
 2579|  85.7M|}
 2580|       |
 2581|       |static BOOL JS_AtomIsString(JSContext *ctx, JSAtom v)
 2582|      0|{
 2583|      0|    return JS_AtomGetKind(ctx, v) == JS_ATOM_KIND_STRING;
 2584|      0|}
 2585|       |
 2586|       |static JSAtom js_get_atom_index(JSRuntime *rt, JSAtomStruct *p)
 2587|   140k|{
 2588|   140k|    uint32_t i = p->hash_next;  /* atom_index */
 2589|   140k|    if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {
 2590|   140k|        JSAtomStruct *p1;
 2591|       |
 2592|   140k|        i = rt->atom_hash[p->hash & (rt->atom_hash_size - 1)];
 2593|   140k|        p1 = rt->atom_array[i];
 2594|   146k|        while (p1 != p) {
 2595|  5.77k|            assert(i != 0);
 2596|  5.77k|            i = p1->hash_next;
 2597|  5.77k|            p1 = rt->atom_array[i];
 2598|  5.77k|        }
 2599|   140k|    }
 2600|   140k|    return i;
 2601|   140k|}
 2602|       |
 2603|       |/* string case (internal). Return JS_ATOM_NULL if error. 'str' is
 2604|       |   freed. */
 2605|       |static JSAtom __JS_NewAtom(JSRuntime *rt, JSString *str, int atom_type)
 2606|  11.2M|{
 2607|  11.2M|    uint32_t h, h1, i;
 2608|  11.2M|    JSAtomStruct *p;
 2609|  11.2M|    int len;
 2610|       |
 2611|       |#if 0
 2612|       |    printf("__JS_NewAtom: ");  JS_DumpString(rt, str); printf("\n");
 2613|       |#endif
 2614|  11.2M|    if (atom_type < JS_ATOM_TYPE_SYMBOL) {
 2615|       |        /* str is not NULL */
 2616|  11.0M|        if (str->atom_type == atom_type) {
 2617|       |            /* str is the atom, return its index */
 2618|   140k|            i = js_get_atom_index(rt, str);
 2619|       |            /* reduce string refcount and increase atom's unless constant */
 2620|   140k|            if (__JS_AtomIsConst(i))
 2621|  67.0k|                str->header.ref_count--;
 2622|   140k|            return i;
 2623|   140k|        }
 2624|       |        /* try and locate an already registered atom */
 2625|  10.8M|        len = str->len;
 2626|  10.8M|        h = hash_string(str, atom_type);
 2627|  10.8M|        h &= JS_ATOM_HASH_MASK;
 2628|  10.8M|        h1 = h & (rt->atom_hash_size - 1);
 2629|  10.8M|        i = rt->atom_hash[h1];
 2630|  22.2M|        while (i != 0) {
 2631|  11.5M|            p = rt->atom_array[i];
 2632|  11.5M|            if (p->hash == h &&
 2633|  11.5M|                p->atom_type == atom_type &&
 2634|  11.5M|                p->len == len &&
 2635|  11.5M|                js_string_memcmp(p, 0, str, 0, len) == 0) {
 2636|   164k|                if (!__JS_AtomIsConst(i))
 2637|   124k|                    p->header.ref_count++;
 2638|   164k|                goto done;
 2639|   164k|            }
 2640|  11.3M|            i = p->hash_next;
 2641|  11.3M|        }
 2642|  10.8M|    } else {
 2643|   248k|        h1 = 0; /* avoid warning */
 2644|   248k|        if (atom_type == JS_ATOM_TYPE_SYMBOL) {
 2645|   230k|            h = 0;
 2646|   230k|        } else {
 2647|  17.7k|            h = JS_ATOM_HASH_PRIVATE;
 2648|  17.7k|            atom_type = JS_ATOM_TYPE_SYMBOL;
 2649|  17.7k|        }
 2650|   248k|    }
 2651|       |
 2652|  10.9M|    if (rt->atom_free_index == 0) {
 2653|       |        /* allow new atom entries */
 2654|  71.0k|        uint32_t new_size, start;
 2655|  71.0k|        JSAtomStruct **new_array;
 2656|       |
 2657|       |        /* alloc new with size progression 3/2:
 2658|       |           4 6 9 13 19 28 42 63 94 141 211 316 474 711 1066 1599 2398 3597 5395 8092
 2659|       |           preallocating space for predefined atoms (at least 195).
 2660|       |         */
 2661|  71.0k|        new_size = max_int(211, rt->atom_size * 3 / 2);
 2662|  71.0k|        if (new_size > JS_ATOM_MAX)
 2663|      0|            goto fail;
 2664|       |        /* XXX: should use realloc2 to use slack space */
 2665|  71.0k|        new_array = js_realloc_rt(rt, rt->atom_array, sizeof(*new_array) * new_size);
 2666|  71.0k|        if (!new_array)
 2667|      0|            goto fail;
 2668|       |        /* Note: the atom 0 is not used */
 2669|  71.0k|        start = rt->atom_size;
 2670|  71.0k|        if (start == 0) {
 2671|       |            /* JS_ATOM_NULL entry */
 2672|  17.7k|            p = js_mallocz_rt(rt, sizeof(JSAtomStruct));
 2673|  17.7k|            if (!p) {
 2674|      0|                js_free_rt(rt, new_array);
 2675|      0|                goto fail;
 2676|      0|            }
 2677|  17.7k|            p->header.ref_count = 1;  /* not refcounted */
 2678|  17.7k|            p->atom_type = JS_ATOM_TYPE_SYMBOL;
 2679|       |#ifdef DUMP_LEAKS
 2680|       |            list_add_tail(&p->link, &rt->string_list);
 2681|       |#endif
 2682|  17.7k|            new_array[0] = p;
 2683|  17.7k|            rt->atom_count++;
 2684|  17.7k|            start = 1;
 2685|  17.7k|        }
 2686|  71.0k|        rt->atom_size = new_size;
 2687|  71.0k|        rt->atom_array = new_array;
 2688|  71.0k|        rt->atom_free_index = start;
 2689|  12.6M|        for(i = start; i < new_size; i++) {
 2690|  12.6M|            uint32_t next;
 2691|  12.6M|            if (i == (new_size - 1))
 2692|  71.0k|                next = 0;
 2693|  12.5M|            else
 2694|  12.5M|                next = i + 1;
 2695|  12.6M|            rt->atom_array[i] = atom_set_free(next);
 2696|  12.6M|        }
 2697|  71.0k|    }
 2698|       |
 2699|  10.9M|    if (str) {
 2700|  10.9M|        if (str->atom_type == 0) {
 2701|  10.9M|            p = str;
 2702|  10.9M|            p->atom_type = atom_type;
 2703|  10.9M|        } else {
 2704|      0|            p = js_malloc_rt(rt, sizeof(JSString) +
 2705|      0|                             (str->len << str->is_wide_char) +
 2706|      0|                             1 - str->is_wide_char);
 2707|      0|            if (unlikely(!p))
 2708|      0|                goto fail;
 2709|      0|            p->header.ref_count = 1;
 2710|      0|            p->is_wide_char = str->is_wide_char;
 2711|      0|            p->len = str->len;
 2712|       |#ifdef DUMP_LEAKS
 2713|       |            list_add_tail(&p->link, &rt->string_list);
 2714|       |#endif
 2715|      0|            memcpy(p->u.str8, str->u.str8, (str->len << str->is_wide_char) +
 2716|      0|                   1 - str->is_wide_char);
 2717|      0|            js_free_string(rt, str);
 2718|      0|        }
 2719|  10.9M|    } else {
 2720|      0|        p = js_malloc_rt(rt, sizeof(JSAtomStruct)); /* empty wide string */
 2721|      0|        if (!p)
 2722|      0|            return JS_ATOM_NULL;
 2723|      0|        p->header.ref_count = 1;
 2724|      0|        p->is_wide_char = 1;    /* Hack to represent NULL as a JSString */
 2725|      0|        p->len = 0;
 2726|       |#ifdef DUMP_LEAKS
 2727|       |        list_add_tail(&p->link, &rt->string_list);
 2728|       |#endif
 2729|      0|    }
 2730|       |
 2731|       |    /* use an already free entry */
 2732|  10.9M|    i = rt->atom_free_index;
 2733|  10.9M|    rt->atom_free_index = atom_get_free(rt->atom_array[i]);
 2734|  10.9M|    rt->atom_array[i] = p;
 2735|       |
 2736|  10.9M|    p->hash = h;
 2737|  10.9M|    p->hash_next = i;   /* atom_index */
 2738|  10.9M|    p->atom_type = atom_type;
 2739|       |
 2740|  10.9M|    rt->atom_count++;
 2741|       |
 2742|  10.9M|    if (atom_type != JS_ATOM_TYPE_SYMBOL) {
 2743|  10.7M|        p->hash_next = rt->atom_hash[h1];
 2744|  10.7M|        rt->atom_hash[h1] = i;
 2745|  10.7M|        if (unlikely(rt->atom_count >= rt->atom_count_resize))
 2746|  17.7k|            JS_ResizeAtomHash(rt, rt->atom_hash_size * 2);
 2747|  10.7M|    }
 2748|       |
 2749|       |    //    JS_DumpAtoms(rt);
 2750|  10.9M|    return i;
 2751|       |
 2752|      0| fail:
 2753|      0|    i = JS_ATOM_NULL;
 2754|   164k| done:
 2755|   164k|    if (str)
 2756|   164k|        js_free_string(rt, str);
 2757|   164k|    return i;
 2758|      0|}
 2759|       |
 2760|       |/* only works with zero terminated 8 bit strings */
 2761|       |static JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,
 2762|       |                               int atom_type)
 2763|  3.94M|{
 2764|  3.94M|    JSString *p;
 2765|  3.94M|    p = js_alloc_string_rt(rt, len, 0);
 2766|  3.94M|    if (!p)
 2767|      0|        return JS_ATOM_NULL;
 2768|  3.94M|    memcpy(p->u.str8, str, len);
 2769|  3.94M|    p->u.str8[len] = '\0';
 2770|  3.94M|    return __JS_NewAtom(rt, p, atom_type);
 2771|  3.94M|}
 2772|       |
 2773|       |/* Warning: str must be ASCII only */
 2774|       |static JSAtom __JS_FindAtom(JSRuntime *rt, const char *str, size_t len,
 2775|       |                            int atom_type)
 2776|  19.8M|{
 2777|  19.8M|    uint32_t h, h1, i;
 2778|  19.8M|    JSAtomStruct *p;
 2779|       |
 2780|  19.8M|    h = hash_string8((const uint8_t *)str, len, JS_ATOM_TYPE_STRING);
 2781|  19.8M|    h &= JS_ATOM_HASH_MASK;
 2782|  19.8M|    h1 = h & (rt->atom_hash_size - 1);
 2783|  19.8M|    i = rt->atom_hash[h1];
 2784|  34.8M|    while (i != 0) {
 2785|  28.0M|        p = rt->atom_array[i];
 2786|  28.0M|        if (p->hash == h &&
 2787|  28.0M|            p->atom_type == JS_ATOM_TYPE_STRING &&
 2788|  28.0M|            p->len == len &&
 2789|  28.0M|            p->is_wide_char == 0 &&
 2790|  28.0M|            memcmp(p->u.str8, str, len) == 0) {
 2791|  12.9M|            if (!__JS_AtomIsConst(i))
 2792|  9.04M|                p->header.ref_count++;
 2793|  12.9M|            return i;
 2794|  12.9M|        }
 2795|  15.0M|        i = p->hash_next;
 2796|  15.0M|    }
 2797|  6.87M|    return JS_ATOM_NULL;
 2798|  19.8M|}
 2799|       |
 2800|       |static void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p)
 2801|  6.88M|{
 2802|       |#if 0   /* JS_ATOM_NULL is not refcounted: __JS_AtomIsConst() includes 0 */
 2803|       |    if (unlikely(i == JS_ATOM_NULL)) {
 2804|       |        p->header.ref_count = INT32_MAX / 2;
 2805|       |        return;
 2806|       |    }
 2807|       |#endif
 2808|  6.88M|    uint32_t i = p->hash_next;  /* atom_index */
 2809|  6.88M|    if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {
 2810|  6.88M|        JSAtomStruct *p0, *p1;
 2811|  6.88M|        uint32_t h0;
 2812|       |
 2813|  6.88M|        h0 = p->hash & (rt->atom_hash_size - 1);
 2814|  6.88M|        i = rt->atom_hash[h0];
 2815|  6.88M|        p1 = rt->atom_array[i];
 2816|  6.88M|        if (p1 == p) {
 2817|  4.50M|            rt->atom_hash[h0] = p1->hash_next;
 2818|  4.50M|        } else {
 2819|  3.15M|            for(;;) {
 2820|  3.15M|                assert(i != 0);
 2821|  3.15M|                p0 = p1;
 2822|  3.15M|                i = p1->hash_next;
 2823|  3.15M|                p1 = rt->atom_array[i];
 2824|  3.15M|                if (p1 == p) {
 2825|  2.37M|                    p0->hash_next = p1->hash_next;
 2826|  2.37M|                    break;
 2827|  2.37M|                }
 2828|  3.15M|            }
 2829|  2.37M|        }
 2830|  6.88M|    }
 2831|       |    /* insert in free atom list */
 2832|  6.88M|    rt->atom_array[i] = atom_set_free(rt->atom_free_index);
 2833|  6.88M|    rt->atom_free_index = i;
 2834|       |    /* free the string structure */
 2835|       |#ifdef DUMP_LEAKS
 2836|       |    list_del(&p->link);
 2837|       |#endif
 2838|  6.88M|    if (p->atom_type == JS_ATOM_TYPE_SYMBOL &&
 2839|  6.88M|        p->hash != JS_ATOM_HASH_PRIVATE && p->hash != 0) {
 2840|       |        /* live weak references are still present on this object: keep
 2841|       |           it */
 2842|  6.88M|    } else {
 2843|  6.88M|        js_free_rt(rt, p);
 2844|  6.88M|    }
 2845|  6.88M|    rt->atom_count--;
 2846|  6.88M|    assert(rt->atom_count >= 0);
 2847|  6.88M|}
 2848|       |
 2849|       |static void __JS_FreeAtom(JSRuntime *rt, uint32_t i)
 2850|  24.9M|{
 2851|  24.9M|    JSAtomStruct *p;
 2852|       |
 2853|  24.9M|    p = rt->atom_array[i];
 2854|  24.9M|    if (--p->header.ref_count > 0)
 2855|  18.6M|        return;
 2856|  6.30M|    JS_FreeAtomStruct(rt, p);
 2857|  6.30M|}
 2858|       |
 2859|       |/* Warning: 'p' is freed */
 2860|       |static JSAtom JS_NewAtomStr(JSContext *ctx, JSString *p)
 2861|  7.37M|{
 2862|  7.37M|    JSRuntime *rt = ctx->rt;
 2863|  7.37M|    uint32_t n;
 2864|  7.37M|    if (is_num_string(&n, p)) {
 2865|  59.8k|        if (n <= JS_ATOM_MAX_INT) {
 2866|  58.0k|            js_free_string(rt, p);
 2867|  58.0k|            return __JS_AtomFromUInt32(n);
 2868|  58.0k|        }
 2869|  59.8k|    }
 2870|       |    /* XXX: should generate an exception */
 2871|  7.31M|    return __JS_NewAtom(rt, p, JS_ATOM_TYPE_STRING);
 2872|  7.37M|}
 2873|       |
 2874|       |/* XXX: optimize */
 2875|       |static size_t count_ascii(const uint8_t *buf, size_t len)
 2876|  27.8M|{
 2877|  27.8M|    const uint8_t *p, *p_end;
 2878|  27.8M|    p = buf;
 2879|  27.8M|    p_end = buf + len;
 2880|   320M|    while (p < p_end && *p < 128)
 2881|   292M|        p++;
 2882|  27.8M|    return p - buf;
 2883|  27.8M|}
 2884|       |
 2885|       |/* str is UTF-8 encoded */
 2886|       |JSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len)
 2887|  19.8M|{
 2888|  19.8M|    JSValue val;
 2889|       |
 2890|  19.8M|    if (len == 0 ||
 2891|  19.8M|        (!is_digit(*str) &&
 2892|  19.8M|         count_ascii((const uint8_t *)str, len) == len)) {
 2893|  19.8M|        JSAtom atom = __JS_FindAtom(ctx->rt, str, len, JS_ATOM_TYPE_STRING);
 2894|  19.8M|        if (atom)
 2895|  12.9M|            return atom;
 2896|  19.8M|    }
 2897|  6.89M|    val = JS_NewStringLen(ctx, str, len);
 2898|  6.89M|    if (JS_IsException(val))
 2899|      0|        return JS_ATOM_NULL;
 2900|  6.89M|    return JS_NewAtomStr(ctx, JS_VALUE_GET_STRING(val));
 2901|  6.89M|}
 2902|       |
 2903|       |JSAtom JS_NewAtom(JSContext *ctx, const char *str)
 2904|  16.2M|{
 2905|  16.2M|    return JS_NewAtomLen(ctx, str, strlen(str));
 2906|  16.2M|}
 2907|       |
 2908|       |JSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n)
 2909|      0|{
 2910|      0|    if (n <= JS_ATOM_MAX_INT) {
 2911|      0|        return __JS_AtomFromUInt32(n);
 2912|      0|    } else {
 2913|      0|        char buf[11];
 2914|      0|        JSValue val;
 2915|      0|        size_t len;
 2916|      0|        len = u32toa(buf, n);
 2917|      0|        val = js_new_string8_len(ctx, buf, len);
 2918|      0|        if (JS_IsException(val))
 2919|      0|            return JS_ATOM_NULL;
 2920|      0|        return __JS_NewAtom(ctx->rt, JS_VALUE_GET_STRING(val),
 2921|      0|                            JS_ATOM_TYPE_STRING);
 2922|      0|    }
 2923|      0|}
 2924|       |
 2925|       |static JSAtom JS_NewAtomInt64(JSContext *ctx, int64_t n)
 2926|      0|{
 2927|      0|    if ((uint64_t)n <= JS_ATOM_MAX_INT) {
 2928|      0|        return __JS_AtomFromUInt32((uint32_t)n);
 2929|      0|    } else {
 2930|      0|        char buf[24];
 2931|      0|        JSValue val;
 2932|      0|        size_t len;
 2933|      0|        len = i64toa(buf, n);
 2934|      0|        val = js_new_string8_len(ctx, buf, len);
 2935|      0|        if (JS_IsException(val))
 2936|      0|            return JS_ATOM_NULL;
 2937|      0|        return __JS_NewAtom(ctx->rt, JS_VALUE_GET_STRING(val),
 2938|      0|                            JS_ATOM_TYPE_STRING);
 2939|      0|    }
 2940|      0|}
 2941|       |
 2942|       |/* 'p' is freed */
 2943|       |static JSValue JS_NewSymbol(JSContext *ctx, JSString *p, int atom_type)
 2944|      0|{
 2945|      0|    JSRuntime *rt = ctx->rt;
 2946|      0|    JSAtom atom;
 2947|      0|    atom = __JS_NewAtom(rt, p, atom_type);
 2948|      0|    if (atom == JS_ATOM_NULL)
 2949|      0|        return JS_ThrowOutOfMemory(ctx);
 2950|      0|    return JS_MKPTR(JS_TAG_SYMBOL, rt->atom_array[atom]);
 2951|      0|}
 2952|       |
 2953|       |/* descr must be a non-numeric string atom */
 2954|       |static JSValue JS_NewSymbolFromAtom(JSContext *ctx, JSAtom descr,
 2955|       |                                    int atom_type)
 2956|      0|{
 2957|      0|    JSRuntime *rt = ctx->rt;
 2958|      0|    JSString *p;
 2959|       |
 2960|      0|    assert(!__JS_AtomIsTaggedInt(descr));
 2961|      0|    assert(descr < rt->atom_size);
 2962|      0|    p = rt->atom_array[descr];
 2963|      0|    JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));
 2964|      0|    return JS_NewSymbol(ctx, p, atom_type);
 2965|      0|}
 2966|       |
 2967|       |#define ATOM_GET_STR_BUF_SIZE 64
 2968|       |
 2969|       |/* Should only be used for debug. */
 2970|       |static const char *JS_AtomGetStrRT(JSRuntime *rt, char *buf, int buf_size,
 2971|       |                                   JSAtom atom)
 2972|   502k|{
 2973|   502k|    if (__JS_AtomIsTaggedInt(atom)) {
 2974|      3|        snprintf(buf, buf_size, "%u", __JS_AtomToUInt32(atom));
 2975|   502k|    } else {
 2976|   502k|        JSAtomStruct *p;
 2977|   502k|        assert(atom < rt->atom_size);
 2978|   502k|        if (atom == JS_ATOM_NULL) {
 2979|      0|            snprintf(buf, buf_size, "<null>");
 2980|   502k|        } else {
 2981|   502k|            int i, c;
 2982|   502k|            char *q;
 2983|   502k|            JSString *str;
 2984|       |
 2985|   502k|            q = buf;
 2986|   502k|            p = rt->atom_array[atom];
 2987|   502k|            assert(!atom_is_free(p));
 2988|   502k|            str = p;
 2989|   502k|            if (str) {
 2990|   502k|                if (!str->is_wide_char) {
 2991|       |                    /* special case ASCII strings */
 2992|   501k|                    c = 0;
 2993|  6.95M|                    for(i = 0; i < str->len; i++) {
 2994|  6.45M|                        c |= str->u.str8[i];
 2995|  6.45M|                    }
 2996|   501k|                    if (c < 0x80)
 2997|   501k|                        return (const char *)str->u.str8;
 2998|   501k|                }
 2999|  1.21k|                for(i = 0; i < str->len; i++) {
 3000|  1.12k|                    c = string_get(str, i);
 3001|  1.12k|                    if ((q - buf) >= buf_size - UTF8_CHAR_LEN_MAX)
 3002|      2|                        break;
 3003|  1.12k|                    if (c < 128) {
 3004|  1.00k|                        *q++ = c;
 3005|  1.00k|                    } else {
 3006|    115|                        q += unicode_to_utf8((uint8_t *)q, c);
 3007|    115|                    }
 3008|  1.12k|                }
 3009|     90|            }
 3010|     90|            *q = '\0';
 3011|     90|        }
 3012|   502k|    }
 3013|     93|    return buf;
 3014|   502k|}
 3015|       |
 3016|       |static const char *JS_AtomGetStr(JSContext *ctx, char *buf, int buf_size, JSAtom atom)
 3017|   502k|{
 3018|   502k|    return JS_AtomGetStrRT(ctx->rt, buf, buf_size, atom);
 3019|   502k|}
 3020|       |
 3021|       |static JSValue __JS_AtomToValue(JSContext *ctx, JSAtom atom, BOOL force_string)
 3022|  13.6M|{
 3023|  13.6M|    char buf[ATOM_GET_STR_BUF_SIZE];
 3024|       |
 3025|  13.6M|    if (__JS_AtomIsTaggedInt(atom)) {
 3026|  4.89M|        size_t len = u32toa(buf, __JS_AtomToUInt32(atom));
 3027|  4.89M|        return js_new_string8_len(ctx, buf, len);
 3028|  8.76M|    } else {
 3029|  8.76M|        JSRuntime *rt = ctx->rt;
 3030|  8.76M|        JSAtomStruct *p;
 3031|  8.76M|        assert(atom < rt->atom_size);
 3032|  8.76M|        p = rt->atom_array[atom];
 3033|  8.76M|        if (p->atom_type == JS_ATOM_TYPE_STRING) {
 3034|  8.53M|            goto ret_string;
 3035|  8.53M|        } else if (force_string) {
 3036|      0|            if (p->len == 0 && p->is_wide_char != 0) {
 3037|       |                /* no description string */
 3038|      0|                p = rt->atom_array[JS_ATOM_empty_string];
 3039|      0|            }
 3040|  8.53M|        ret_string:
 3041|  8.53M|            return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));
 3042|   230k|        } else {
 3043|   230k|            return JS_DupValue(ctx, JS_MKPTR(JS_TAG_SYMBOL, p));
 3044|   230k|        }
 3045|  8.76M|    }
 3046|  13.6M|}
 3047|       |
 3048|       |JSValue JS_AtomToValue(JSContext *ctx, JSAtom atom)
 3049|  8.12M|{
 3050|  8.12M|    return __JS_AtomToValue(ctx, atom, FALSE);
 3051|  8.12M|}
 3052|       |
 3053|       |JSValue JS_AtomToString(JSContext *ctx, JSAtom atom)
 3054|  5.53M|{
 3055|  5.53M|    return __JS_AtomToValue(ctx, atom, TRUE);
 3056|  5.53M|}
 3057|       |
 3058|       |/* return TRUE if the atom is an array index (i.e. 0 <= index <=
 3059|       |   2^32-2 and return its value */
 3060|       |static BOOL JS_AtomIsArrayIndex(JSContext *ctx, uint32_t *pval, JSAtom atom)
 3061|  2.40M|{
 3062|  2.40M|    if (__JS_AtomIsTaggedInt(atom)) {
 3063|  1.31M|        *pval = __JS_AtomToUInt32(atom);
 3064|  1.31M|        return TRUE;
 3065|  1.31M|    } else {
 3066|  1.08M|        JSRuntime *rt = ctx->rt;
 3067|  1.08M|        JSAtomStruct *p;
 3068|  1.08M|        uint32_t val;
 3069|       |
 3070|  1.08M|        assert(atom < rt->atom_size);
 3071|  1.08M|        p = rt->atom_array[atom];
 3072|  1.08M|        if (p->atom_type == JS_ATOM_TYPE_STRING &&
 3073|  1.08M|            is_num_string(&val, p) && val != -1) {
 3074|      3|            *pval = val;
 3075|      3|            return TRUE;
 3076|  1.08M|        } else {
 3077|  1.08M|            *pval = 0;
 3078|  1.08M|            return FALSE;
 3079|  1.08M|        }
 3080|  1.08M|    }
 3081|  2.40M|}
 3082|       |
 3083|       |/* This test must be fast if atom is not a numeric index (e.g. a
 3084|       |   method name). Return JS_UNDEFINED if not a numeric
 3085|       |   index. JS_EXCEPTION can also be returned. */
 3086|       |static JSValue JS_AtomIsNumericIndex1(JSContext *ctx, JSAtom atom)
 3087|      0|{
 3088|      0|    JSRuntime *rt = ctx->rt;
 3089|      0|    JSAtomStruct *p1;
 3090|      0|    JSString *p;
 3091|      0|    int c, ret;
 3092|      0|    JSValue num, str;
 3093|       |
 3094|      0|    if (__JS_AtomIsTaggedInt(atom))
 3095|      0|        return JS_NewInt32(ctx, __JS_AtomToUInt32(atom));
 3096|      0|    assert(atom < rt->atom_size);
 3097|      0|    p1 = rt->atom_array[atom];
 3098|      0|    if (p1->atom_type != JS_ATOM_TYPE_STRING)
 3099|      0|        return JS_UNDEFINED;
 3100|      0|    switch(atom) {
 3101|      0|    case JS_ATOM_minus_zero:
 3102|      0|        return __JS_NewFloat64(ctx, -0.0);
 3103|      0|    case JS_ATOM_Infinity:
 3104|      0|        return __JS_NewFloat64(ctx, INFINITY);
 3105|      0|    case JS_ATOM_minus_Infinity:
 3106|      0|        return __JS_NewFloat64(ctx, -INFINITY);
 3107|      0|    case JS_ATOM_NaN:
 3108|      0|        return __JS_NewFloat64(ctx, NAN);
 3109|      0|    default:
 3110|      0|        break;
 3111|      0|    }
 3112|      0|    p = p1;
 3113|      0|    if (p->len == 0)
 3114|      0|        return JS_UNDEFINED;
 3115|      0|    c = string_get(p, 0);
 3116|      0|    if (!is_num(c) && c != '-')
 3117|      0|        return JS_UNDEFINED;
 3118|       |    /* this is ECMA CanonicalNumericIndexString primitive */
 3119|      0|    num = JS_ToNumber(ctx, JS_MKPTR(JS_TAG_STRING, p));
 3120|      0|    if (JS_IsException(num))
 3121|      0|        return num;
 3122|      0|    str = JS_ToString(ctx, num);
 3123|      0|    if (JS_IsException(str)) {
 3124|      0|        JS_FreeValue(ctx, num);
 3125|      0|        return str;
 3126|      0|    }
 3127|      0|    ret = js_string_compare(ctx, p, JS_VALUE_GET_STRING(str));
 3128|      0|    JS_FreeValue(ctx, str);
 3129|      0|    if (ret == 0) {
 3130|      0|        return num;
 3131|      0|    } else {
 3132|      0|        JS_FreeValue(ctx, num);
 3133|      0|        return JS_UNDEFINED;
 3134|      0|    }
 3135|      0|}
 3136|       |
 3137|       |/* return -1 if exception or TRUE/FALSE */
 3138|       |static int JS_AtomIsNumericIndex(JSContext *ctx, JSAtom atom)
 3139|      0|{
 3140|      0|    JSValue num;
 3141|      0|    num = JS_AtomIsNumericIndex1(ctx, atom);
 3142|      0|    if (likely(JS_IsUndefined(num)))
 3143|      0|        return FALSE;
 3144|      0|    if (JS_IsException(num))
 3145|      0|        return -1;
 3146|      0|    JS_FreeValue(ctx, num);
 3147|      0|    return TRUE;
 3148|      0|}
 3149|       |
 3150|       |void JS_FreeAtom(JSContext *ctx, JSAtom v)
 3151|  32.6M|{
 3152|  32.6M|    if (!__JS_AtomIsConst(v))
 3153|  18.6M|        __JS_FreeAtom(ctx->rt, v);
 3154|  32.6M|}
 3155|       |
 3156|       |void JS_FreeAtomRT(JSRuntime *rt, JSAtom v)
 3157|  25.9M|{
 3158|  25.9M|    if (!__JS_AtomIsConst(v))
 3159|  6.39M|        __JS_FreeAtom(rt, v);
 3160|  25.9M|}
 3161|       |
 3162|       |/* return TRUE if 'v' is a symbol with a string description */
 3163|       |static BOOL JS_AtomSymbolHasDescription(JSContext *ctx, JSAtom v)
 3164|      1|{
 3165|      1|    JSRuntime *rt;
 3166|      1|    JSAtomStruct *p;
 3167|       |
 3168|      1|    rt = ctx->rt;
 3169|      1|    if (__JS_AtomIsTaggedInt(v))
 3170|      0|        return FALSE;
 3171|      1|    p = rt->atom_array[v];
 3172|      1|    return (((p->atom_type == JS_ATOM_TYPE_SYMBOL &&
 3173|      1|              p->hash != JS_ATOM_HASH_PRIVATE) ||
 3174|      1|             p->atom_type == JS_ATOM_TYPE_GLOBAL_SYMBOL) &&
 3175|      1|            !(p->len == 0 && p->is_wide_char != 0));
 3176|      1|}
 3177|       |
 3178|       |static __maybe_unused void print_atom(JSContext *ctx, JSAtom atom)
 3179|      0|{
 3180|      0|    char buf[ATOM_GET_STR_BUF_SIZE];
 3181|      0|    const char *p;
 3182|      0|    int i;
 3183|      0|
 3184|      0|    /* XXX: should handle embedded null characters */
 3185|      0|    /* XXX: should move encoding code to JS_AtomGetStr */
 3186|      0|    p = JS_AtomGetStr(ctx, buf, sizeof(buf), atom);
 3187|      0|    for (i = 0; p[i]; i++) {
 3188|      0|        int c = (unsigned char)p[i];
 3189|      0|        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
 3190|      0|              (c == '_' || c == '$') || (c >= '0' && c <= '9' && i > 0)))
 3191|      0|            break;
 3192|      0|    }
 3193|      0|    if (i > 0 && p[i] == '\0') {
 3194|      0|        printf("%s", p);
 3195|      0|    } else {
 3196|      0|        putchar('"');
 3197|      0|        printf("%.*s", i, p);
 3198|      0|        for (; p[i]; i++) {
 3199|      0|            int c = (unsigned char)p[i];
 3200|      0|            if (c == '\"' || c == '\\') {
 3201|      0|                putchar('\\');
 3202|      0|                putchar(c);
 3203|      0|            } else if (c >= ' ' && c <= 126) {
 3204|      0|                putchar(c);
 3205|      0|            } else if (c == '\n') {
 3206|      0|                putchar('\\');
 3207|      0|                putchar('n');
 3208|      0|            } else {
 3209|      0|                printf("\\u%04x", c);
 3210|      0|            }
 3211|      0|        }
 3212|      0|        putchar('\"');
 3213|      0|    }
 3214|      0|}
 3215|       |
 3216|       |/* free with JS_FreeCString() */
 3217|       |const char *JS_AtomToCString(JSContext *ctx, JSAtom atom)
 3218|   145k|{
 3219|   145k|    JSValue str;
 3220|   145k|    const char *cstr;
 3221|       |
 3222|   145k|    str = JS_AtomToString(ctx, atom);
 3223|   145k|    if (JS_IsException(str))
 3224|      0|        return NULL;
 3225|   145k|    cstr = JS_ToCString(ctx, str);
 3226|   145k|    JS_FreeValue(ctx, str);
 3227|   145k|    return cstr;
 3228|   145k|}
 3229|       |
 3230|       |/* return a string atom containing name concatenated with str1 */
 3231|       |static JSAtom js_atom_concat_str(JSContext *ctx, JSAtom name, const char *str1)
 3232|      0|{
 3233|      0|    JSValue str;
 3234|      0|    JSAtom atom;
 3235|      0|    const char *cstr;
 3236|      0|    char *cstr2;
 3237|      0|    size_t len, len1;
 3238|       |
 3239|      0|    str = JS_AtomToString(ctx, name);
 3240|      0|    if (JS_IsException(str))
 3241|      0|        return JS_ATOM_NULL;
 3242|      0|    cstr = JS_ToCStringLen(ctx, &len, str);
 3243|      0|    if (!cstr)
 3244|      0|        goto fail;
 3245|      0|    len1 = strlen(str1);
 3246|      0|    cstr2 = js_malloc(ctx, len + len1 + 1);
 3247|      0|    if (!cstr2)
 3248|      0|        goto fail;
 3249|      0|    memcpy(cstr2, cstr, len);
 3250|      0|    memcpy(cstr2 + len, str1, len1);
 3251|      0|    cstr2[len + len1] = '\0';
 3252|      0|    atom = JS_NewAtomLen(ctx, cstr2, len + len1);
 3253|      0|    js_free(ctx, cstr2);
 3254|      0|    JS_FreeCString(ctx, cstr);
 3255|      0|    JS_FreeValue(ctx, str);
 3256|      0|    return atom;
 3257|      0| fail:
 3258|      0|    JS_FreeCString(ctx, cstr);
 3259|      0|    JS_FreeValue(ctx, str);
 3260|      0|    return JS_ATOM_NULL;
 3261|      0|}
 3262|       |
 3263|       |static JSAtom js_atom_concat_num(JSContext *ctx, JSAtom name, uint32_t n)
 3264|      0|{
 3265|      0|    char buf[16];
 3266|      0|    size_t len;
 3267|      0|    len = u32toa(buf, n);
 3268|      0|    buf[len] = '\0';
 3269|      0|    return js_atom_concat_str(ctx, name, buf);
 3270|      0|}
 3271|       |
 3272|       |static inline BOOL JS_IsEmptyString(JSValueConst v)
 3273|  28.5k|{
 3274|  28.5k|    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING && JS_VALUE_GET_STRING(v)->len == 0;
 3275|  28.5k|}
 3276|       |
 3277|       |/* JSClass support */
 3278|       |
 3279|       |#ifdef CONFIG_ATOMICS
 3280|       |static pthread_mutex_t js_class_id_mutex = PTHREAD_MUTEX_INITIALIZER;
 3281|       |#endif
 3282|       |
 3283|       |/* a new class ID is allocated if *pclass_id != 0 */
 3284|       |JSClassID JS_NewClassID(JSClassID *pclass_id)
 3285|      0|{
 3286|      0|    JSClassID class_id;
 3287|      0|#ifdef CONFIG_ATOMICS
 3288|      0|    pthread_mutex_lock(&js_class_id_mutex);
 3289|      0|#endif
 3290|      0|    class_id = *pclass_id;
 3291|      0|    if (class_id == 0) {
 3292|      0|        class_id = js_class_id_alloc++;
 3293|      0|        *pclass_id = class_id;
 3294|      0|    }
 3295|      0|#ifdef CONFIG_ATOMICS
 3296|      0|    pthread_mutex_unlock(&js_class_id_mutex);
 3297|      0|#endif
 3298|      0|    return class_id;
 3299|      0|}
 3300|       |
 3301|       |JSClassID JS_GetClassID(JSValue v)
 3302|      0|{
 3303|      0|    JSObject *p;
 3304|      0|    if (JS_VALUE_GET_TAG(v) != JS_TAG_OBJECT)
 3305|      0|        return JS_INVALID_CLASS_ID;
 3306|      0|    p = JS_VALUE_GET_OBJ(v);
 3307|      0|    return p->class_id;
 3308|      0|}
 3309|       |
 3310|       |BOOL JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id)
 3311|  71.0k|{
 3312|  71.0k|    return (class_id < rt->class_count &&
 3313|  71.0k|            rt->class_array[class_id].class_id != 0);
 3314|  71.0k|}
 3315|       |
 3316|       |/* create a new object internal class. Return -1 if error, 0 if
 3317|       |   OK. The finalizer can be NULL if none is needed. */
 3318|       |static int JS_NewClass1(JSRuntime *rt, JSClassID class_id,
 3319|       |                        const JSClassDef *class_def, JSAtom name)
 3320|   977k|{
 3321|   977k|    int new_size, i;
 3322|   977k|    JSClass *cl, *new_class_array;
 3323|   977k|    struct list_head *el;
 3324|       |
 3325|   977k|    if (class_id >= (1 << 16))
 3326|      0|        return -1;
 3327|   977k|    if (class_id < rt->class_count &&
 3328|   977k|        rt->class_array[class_id].class_id != 0)
 3329|      0|        return -1;
 3330|       |
 3331|   977k|    if (class_id >= rt->class_count) {
 3332|  17.7k|        new_size = max_int(JS_CLASS_INIT_COUNT,
 3333|  17.7k|                           max_int(class_id + 1, rt->class_count * 3 / 2));
 3334|       |
 3335|       |        /* reallocate the context class prototype array, if any */
 3336|  17.7k|        list_for_each(el, &rt->context_list) {
 3337|      0|            JSContext *ctx = list_entry(el, JSContext, link);
 3338|      0|            JSValue *new_tab;
 3339|      0|            new_tab = js_realloc_rt(rt, ctx->class_proto,
 3340|      0|                                    sizeof(ctx->class_proto[0]) * new_size);
 3341|      0|            if (!new_tab)
 3342|      0|                return -1;
 3343|      0|            for(i = rt->class_count; i < new_size; i++)
 3344|      0|                new_tab[i] = JS_NULL;
 3345|      0|            ctx->class_proto = new_tab;
 3346|      0|        }
 3347|       |        /* reallocate the class array */
 3348|  17.7k|        new_class_array = js_realloc_rt(rt, rt->class_array,
 3349|  17.7k|                                        sizeof(JSClass) * new_size);
 3350|  17.7k|        if (!new_class_array)
 3351|      0|            return -1;
 3352|  17.7k|        memset(new_class_array + rt->class_count, 0,
 3353|  17.7k|               (new_size - rt->class_count) * sizeof(JSClass));
 3354|  17.7k|        rt->class_array = new_class_array;
 3355|  17.7k|        rt->class_count = new_size;
 3356|  17.7k|    }
 3357|   977k|    cl = &rt->class_array[class_id];
 3358|   977k|    cl->class_id = class_id;
 3359|   977k|    cl->class_name = JS_DupAtomRT(rt, name);
 3360|   977k|    cl->finalizer = class_def->finalizer;
 3361|   977k|    cl->gc_mark = class_def->gc_mark;
 3362|   977k|    cl->call = class_def->call;
 3363|   977k|    cl->exotic = class_def->exotic;
 3364|   977k|    return 0;
 3365|   977k|}
 3366|       |
 3367|       |int JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def)
 3368|      0|{
 3369|      0|    int ret, len;
 3370|      0|    JSAtom name;
 3371|       |
 3372|      0|    len = strlen(class_def->class_name);
 3373|      0|    name = __JS_FindAtom(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);
 3374|      0|    if (name == JS_ATOM_NULL) {
 3375|      0|        name = __JS_NewAtomInit(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);
 3376|      0|        if (name == JS_ATOM_NULL)
 3377|      0|            return -1;
 3378|      0|    }
 3379|      0|    ret = JS_NewClass1(rt, class_id, class_def, name);
 3380|      0|    JS_FreeAtomRT(rt, name);
 3381|      0|    return ret;
 3382|      0|}
 3383|       |
 3384|       |static JSValue js_new_string8_len(JSContext *ctx, const char *buf, int len)
 3385|  15.7M|{
 3386|  15.7M|    JSString *str;
 3387|       |
 3388|  15.7M|    if (len <= 0) {
 3389|   767k|        return JS_AtomToString(ctx, JS_ATOM_empty_string);
 3390|   767k|    }
 3391|  14.9M|    str = js_alloc_string(ctx, len, 0);
 3392|  14.9M|    if (!str)
 3393|      0|        return JS_EXCEPTION;
 3394|  14.9M|    memcpy(str->u.str8, buf, len);
 3395|  14.9M|    str->u.str8[len] = '\0';
 3396|  14.9M|    return JS_MKPTR(JS_TAG_STRING, str);
 3397|  14.9M|}
 3398|       |
 3399|       |static JSValue js_new_string8(JSContext *ctx, const char *buf)
 3400|      1|{
 3401|      1|    return js_new_string8_len(ctx, buf, strlen(buf));
 3402|      1|}
 3403|       |
 3404|       |static JSValue js_new_string16_len(JSContext *ctx, const uint16_t *buf, int len)
 3405|      0|{
 3406|      0|    JSString *str;
 3407|      0|    str = js_alloc_string(ctx, len, 1);
 3408|      0|    if (!str)
 3409|      0|        return JS_EXCEPTION;
 3410|      0|    memcpy(str->u.str16, buf, len * 2);
 3411|      0|    return JS_MKPTR(JS_TAG_STRING, str);
 3412|      0|}
 3413|       |
 3414|       |static JSValue js_new_string_char(JSContext *ctx, uint16_t c)
 3415|  5.46k|{
 3416|  5.46k|    if (c < 0x100) {
 3417|  5.46k|        uint8_t ch8 = c;
 3418|  5.46k|        return js_new_string8_len(ctx, (const char *)&ch8, 1);
 3419|  5.46k|    } else {
 3420|      0|        uint16_t ch16 = c;
 3421|      0|        return js_new_string16_len(ctx, &ch16, 1);
 3422|      0|    }
 3423|  5.46k|}
 3424|       |
 3425|       |static JSValue js_sub_string(JSContext *ctx, JSString *p, int start, int end)
 3426|      0|{
 3427|      0|    int len = end - start;
 3428|      0|    if (start == 0 && end == p->len) {
 3429|      0|        return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));
 3430|      0|    }
 3431|      0|    if (p->is_wide_char && len > 0) {
 3432|      0|        JSString *str;
 3433|      0|        int i;
 3434|      0|        uint16_t c = 0;
 3435|      0|        for (i = start; i < end; i++) {
 3436|      0|            c |= p->u.str16[i];
 3437|      0|        }
 3438|      0|        if (c > 0xFF)
 3439|      0|            return js_new_string16_len(ctx, p->u.str16 + start, len);
 3440|       |
 3441|      0|        str = js_alloc_string(ctx, len, 0);
 3442|      0|        if (!str)
 3443|      0|            return JS_EXCEPTION;
 3444|      0|        for (i = 0; i < len; i++) {
 3445|      0|            str->u.str8[i] = p->u.str16[start + i];
 3446|      0|        }
 3447|      0|        str->u.str8[len] = '\0';
 3448|      0|        return JS_MKPTR(JS_TAG_STRING, str);
 3449|      0|    } else {
 3450|      0|        return js_new_string8_len(ctx, (const char *)(p->u.str8 + start), len);
 3451|      0|    }
 3452|      0|}
 3453|       |
 3454|       |typedef struct StringBuffer {
 3455|       |    JSContext *ctx;
 3456|       |    JSString *str;
 3457|       |    int len;
 3458|       |    int size;
 3459|       |    int is_wide_char;
 3460|       |    int error_status;
 3461|       |} StringBuffer;
 3462|       |
 3463|       |/* It is valid to call string_buffer_end() and all string_buffer functions even
 3464|       |   if string_buffer_init() or another string_buffer function returns an error.
 3465|       |   If the error_status is set, string_buffer_end() returns JS_EXCEPTION.
 3466|       | */
 3467|       |static int string_buffer_init2(JSContext *ctx, StringBuffer *s, int size,
 3468|       |                               int is_wide)
 3469|  4.32M|{
 3470|  4.32M|    s->ctx = ctx;
 3471|  4.32M|    s->size = size;
 3472|  4.32M|    s->len = 0;
 3473|  4.32M|    s->is_wide_char = is_wide;
 3474|  4.32M|    s->error_status = 0;
 3475|  4.32M|    s->str = js_alloc_string(ctx, size, is_wide);
 3476|  4.32M|    if (unlikely(!s->str)) {
 3477|      0|        s->size = 0;
 3478|      0|        return s->error_status = -1;
 3479|      0|    }
 3480|       |#ifdef DUMP_LEAKS
 3481|       |    /* the StringBuffer may reallocate the JSString, only link it at the end */
 3482|       |    list_del(&s->str->link);
 3483|       |#endif
 3484|  4.32M|    return 0;
 3485|  4.32M|}
 3486|       |
 3487|       |static inline int string_buffer_init(JSContext *ctx, StringBuffer *s, int size)
 3488|  3.43M|{
 3489|  3.43M|    return string_buffer_init2(ctx, s, size, 0);
 3490|  3.43M|}
 3491|       |
 3492|       |static void string_buffer_free(StringBuffer *s)
 3493|  31.1k|{
 3494|  31.1k|    js_free(s->ctx, s->str);
 3495|  31.1k|    s->str = NULL;
 3496|  31.1k|}
 3497|       |
 3498|       |static int string_buffer_set_error(StringBuffer *s)
 3499|      8|{
 3500|      8|    js_free(s->ctx, s->str);
 3501|      8|    s->str = NULL;
 3502|      8|    s->size = 0;
 3503|      8|    s->len = 0;
 3504|      8|    return s->error_status = -1;
 3505|      8|}
 3506|       |
 3507|       |static no_inline int string_buffer_widen(StringBuffer *s, int size)
 3508|   227k|{
 3509|   227k|    JSString *str;
 3510|   227k|    size_t slack;
 3511|   227k|    int i;
 3512|       |
 3513|   227k|    if (s->error_status)
 3514|      0|        return -1;
 3515|       |
 3516|   227k|    str = js_realloc2(s->ctx, s->str, sizeof(JSString) + (size << 1), &slack);
 3517|   227k|    if (!str)
 3518|      0|        return string_buffer_set_error(s);
 3519|   227k|    size += slack >> 1;
 3520|  5.26M|    for(i = s->len; i-- > 0;) {
 3521|  5.03M|        str->u.str16[i] = str->u.str8[i];
 3522|  5.03M|    }
 3523|   227k|    s->is_wide_char = 1;
 3524|   227k|    s->size = size;
 3525|   227k|    s->str = str;
 3526|   227k|    return 0;
 3527|   227k|}
 3528|       |
 3529|       |static no_inline int string_buffer_realloc(StringBuffer *s, int new_len, int c)
 3530|  1.77M|{
 3531|  1.77M|    JSString *new_str;
 3532|  1.77M|    int new_size;
 3533|  1.77M|    size_t new_size_bytes, slack;
 3534|       |
 3535|  1.77M|    if (s->error_status)
 3536|      0|        return -1;
 3537|       |
 3538|  1.77M|    if (new_len > JS_STRING_LEN_MAX) {
 3539|      0|        JS_ThrowInternalError(s->ctx, "string too long");
 3540|      0|        return string_buffer_set_error(s);
 3541|      0|    }
 3542|  1.77M|    new_size = min_int(max_int(new_len, s->size * 3 / 2), JS_STRING_LEN_MAX);
 3543|  1.77M|    if (!s->is_wide_char && c >= 0x100) {
 3544|  15.3k|        return string_buffer_widen(s, new_size);
 3545|  15.3k|    }
 3546|  1.76M|    new_size_bytes = sizeof(JSString) + (new_size << s->is_wide_char) + 1 - s->is_wide_char;
 3547|  1.76M|    new_str = js_realloc2(s->ctx, s->str, new_size_bytes, &slack);
 3548|  1.76M|    if (!new_str)
 3549|      0|        return string_buffer_set_error(s);
 3550|  1.76M|    new_size = min_int(new_size + (slack >> s->is_wide_char), JS_STRING_LEN_MAX);
 3551|  1.76M|    s->size = new_size;
 3552|  1.76M|    s->str = new_str;
 3553|  1.76M|    return 0;
 3554|  1.76M|}
 3555|       |
 3556|       |static no_inline int string_buffer_putc_slow(StringBuffer *s, uint32_t c)
 3557|   423k|{
 3558|   423k|    if (unlikely(s->len >= s->size)) {
 3559|   347k|        if (string_buffer_realloc(s, s->len + 1, c))
 3560|      0|            return -1;
 3561|   347k|    }
 3562|   423k|    if (s->is_wide_char) {
 3563|  14.9k|        s->str->u.str16[s->len++] = c;
 3564|   408k|    } else if (c < 0x100) {
 3565|   332k|        s->str->u.str8[s->len++] = c;
 3566|   332k|    } else {
 3567|  76.1k|        if (string_buffer_widen(s, s->size))
 3568|      0|            return -1;
 3569|  76.1k|        s->str->u.str16[s->len++] = c;
 3570|  76.1k|    }
 3571|   423k|    return 0;
 3572|   423k|}
 3573|       |
 3574|       |/* 0 <= c <= 0xff */
 3575|       |static int string_buffer_putc8(StringBuffer *s, uint32_t c)
 3576|  9.64M|{
 3577|  9.64M|    if (unlikely(s->len >= s->size)) {
 3578|  1.31M|        if (string_buffer_realloc(s, s->len + 1, c))
 3579|      0|            return -1;
 3580|  1.31M|    }
 3581|  9.64M|    if (s->is_wide_char) {
 3582|  2.69M|        s->str->u.str16[s->len++] = c;
 3583|  6.95M|    } else {
 3584|  6.95M|        s->str->u.str8[s->len++] = c;
 3585|  6.95M|    }
 3586|  9.64M|    return 0;
 3587|  9.64M|}
 3588|       |
 3589|       |/* 0 <= c <= 0xffff */
 3590|       |static int string_buffer_putc16(StringBuffer *s, uint32_t c)
 3591|  47.3M|{
 3592|  47.3M|    if (likely(s->len < s->size)) {
 3593|  47.0M|        if (s->is_wide_char) {
 3594|  2.78M|            s->str->u.str16[s->len++] = c;
 3595|  2.78M|            return 0;
 3596|  44.2M|        } else if (c < 0x100) {
 3597|  44.1M|            s->str->u.str8[s->len++] = c;
 3598|  44.1M|            return 0;
 3599|  44.1M|        }
 3600|  47.0M|    }
 3601|   423k|    return string_buffer_putc_slow(s, c);
 3602|  47.3M|}
 3603|       |
 3604|       |/* 0 <= c <= 0x10ffff */
 3605|       |static int string_buffer_putc(StringBuffer *s, uint32_t c)
 3606|  31.6M|{
 3607|  31.6M|    if (unlikely(c >= 0x10000)) {
 3608|       |        /* surrogate pair */
 3609|  8.15k|        if (string_buffer_putc16(s, get_hi_surrogate(c)))
 3610|      0|            return -1;
 3611|  8.15k|        c = get_lo_surrogate(c);
 3612|  8.15k|    }
 3613|  31.6M|    return string_buffer_putc16(s, c);
 3614|  31.6M|}
 3615|       |
 3616|       |static int string_getc(const JSString *p, int *pidx)
 3617|  5.46k|{
 3618|  5.46k|    int idx, c, c1;
 3619|  5.46k|    idx = *pidx;
 3620|  5.46k|    if (p->is_wide_char) {
 3621|  2.61k|        c = p->u.str16[idx++];
 3622|  2.61k|        if (is_hi_surrogate(c) && idx < p->len) {
 3623|      0|            c1 = p->u.str16[idx];
 3624|      0|            if (is_lo_surrogate(c1)) {
 3625|      0|                c = from_surrogate(c, c1);
 3626|      0|                idx++;
 3627|      0|            }
 3628|      0|        }
 3629|  2.85k|    } else {
 3630|  2.85k|        c = p->u.str8[idx++];
 3631|  2.85k|    }
 3632|  5.46k|    *pidx = idx;
 3633|  5.46k|    return c;
 3634|  5.46k|}
 3635|       |
 3636|       |static int string_buffer_write8(StringBuffer *s, const uint8_t *p, int len)
 3637|  2.30M|{
 3638|  2.30M|    int i;
 3639|       |
 3640|  2.30M|    if (s->len + len > s->size) {
 3641|  94.6k|        if (string_buffer_realloc(s, s->len + len, 0))
 3642|      0|            return -1;
 3643|  94.6k|    }
 3644|  2.30M|    if (s->is_wide_char) {
 3645|  27.0M|        for (i = 0; i < len; i++) {
 3646|  27.0M|            s->str->u.str16[s->len + i] = p[i];
 3647|  27.0M|        }
 3648|  44.9k|        s->len += len;
 3649|  2.25M|    } else {
 3650|  2.25M|        memcpy(&s->str->u.str8[s->len], p, len);
 3651|  2.25M|        s->len += len;
 3652|  2.25M|    }
 3653|  2.30M|    return 0;
 3654|  2.30M|}
 3655|       |
 3656|       |static int string_buffer_write16(StringBuffer *s, const uint16_t *p, int len)
 3657|   179k|{
 3658|   179k|    int c = 0, i;
 3659|       |
 3660|  22.0M|    for (i = 0; i < len; i++) {
 3661|  21.8M|        c |= p[i];
 3662|  21.8M|    }
 3663|   179k|    if (s->len + len > s->size) {
 3664|  15.0k|        if (string_buffer_realloc(s, s->len + len, c))
 3665|      0|            return -1;
 3666|   164k|    } else if (!s->is_wide_char && c >= 0x100) {
 3667|   136k|        if (string_buffer_widen(s, s->size))
 3668|      0|            return -1;
 3669|   136k|    }
 3670|   179k|    if (s->is_wide_char) {
 3671|   179k|        memcpy(&s->str->u.str16[s->len], p, len << 1);
 3672|   179k|        s->len += len;
 3673|   179k|    } else {
 3674|      0|        for (i = 0; i < len; i++) {
 3675|      0|            s->str->u.str8[s->len + i] = p[i];
 3676|      0|        }
 3677|      0|        s->len += len;
 3678|      0|    }
 3679|   179k|    return 0;
 3680|   179k|}
 3681|       |
 3682|       |/* appending an ASCII string */
 3683|       |static int string_buffer_puts8(StringBuffer *s, const char *str)
 3684|      0|{
 3685|      0|    return string_buffer_write8(s, (const uint8_t *)str, strlen(str));
 3686|      0|}
 3687|       |
 3688|       |static int string_buffer_concat(StringBuffer *s, const JSString *p,
 3689|       |                                uint32_t from, uint32_t to)
 3690|  3.07M|{
 3691|  3.07M|    if (to <= from)
 3692|   794k|        return 0;
 3693|  2.27M|    if (p->is_wide_char)
 3694|   179k|        return string_buffer_write16(s, p->u.str16 + from, to - from);
 3695|  2.09M|    else
 3696|  2.09M|        return string_buffer_write8(s, p->u.str8 + from, to - from);
 3697|  2.27M|}
 3698|       |
 3699|       |static int string_buffer_concat_value(StringBuffer *s, JSValueConst v)
 3700|   113k|{
 3701|   113k|    JSString *p;
 3702|   113k|    JSValue v1;
 3703|   113k|    int res;
 3704|       |
 3705|   113k|    if (s->error_status) {
 3706|       |        /* prevent exception overload */
 3707|      0|        return -1;
 3708|      0|    }
 3709|   113k|    if (unlikely(JS_VALUE_GET_TAG(v) != JS_TAG_STRING)) {
 3710|  48.4k|        if (JS_VALUE_GET_TAG(v) == JS_TAG_STRING_ROPE) {
 3711|  48.4k|            JSStringRope *r = JS_VALUE_GET_STRING_ROPE(v);
 3712|       |            /* recursion is acceptable because the rope depth is bounded */
 3713|  48.4k|            if (string_buffer_concat_value(s, r->left))
 3714|      0|                return -1;
 3715|  48.4k|            return string_buffer_concat_value(s, r->right);
 3716|  48.4k|        } else {
 3717|      0|            v1 = JS_ToString(s->ctx, v);
 3718|      0|            if (JS_IsException(v1))
 3719|      0|                return string_buffer_set_error(s);
 3720|      0|            p = JS_VALUE_GET_STRING(v1);
 3721|      0|            res = string_buffer_concat(s, p, 0, p->len);
 3722|      0|            JS_FreeValue(s->ctx, v1);
 3723|      0|            return res;
 3724|      0|        }
 3725|  48.4k|    }
 3726|  65.4k|    p = JS_VALUE_GET_STRING(v);
 3727|  65.4k|    return string_buffer_concat(s, p, 0, p->len);
 3728|   113k|}
 3729|       |
 3730|       |static int string_buffer_concat_value_free(StringBuffer *s, JSValue v)
 3731|  2.91M|{
 3732|  2.91M|    JSString *p;
 3733|  2.91M|    int res;
 3734|       |
 3735|  2.91M|    if (s->error_status) {
 3736|       |        /* prevent exception overload */
 3737|      0|        JS_FreeValue(s->ctx, v);
 3738|      0|        return -1;
 3739|      0|    }
 3740|  2.91M|    if (unlikely(JS_VALUE_GET_TAG(v) != JS_TAG_STRING)) {
 3741|  1.33M|        v = JS_ToStringFree(s->ctx, v);
 3742|  1.33M|        if (JS_IsException(v))
 3743|      8|            return string_buffer_set_error(s);
 3744|  1.33M|    }
 3745|  2.91M|    p = JS_VALUE_GET_STRING(v);
 3746|  2.91M|    res = string_buffer_concat(s, p, 0, p->len);
 3747|  2.91M|    JS_FreeValue(s->ctx, v);
 3748|  2.91M|    return res;
 3749|  2.91M|}
 3750|       |
 3751|       |static int string_buffer_fill(StringBuffer *s, int c, int count)
 3752|      0|{
 3753|       |    /* XXX: optimize */
 3754|      0|    if (s->len + count > s->size) {
 3755|      0|        if (string_buffer_realloc(s, s->len + count, c))
 3756|      0|            return -1;
 3757|      0|    }
 3758|      0|    while (count-- > 0) {
 3759|      0|        if (string_buffer_putc16(s, c))
 3760|      0|            return -1;
 3761|      0|    }
 3762|      0|    return 0;
 3763|      0|}
 3764|       |
 3765|       |static JSValue string_buffer_end(StringBuffer *s)
 3766|  4.29M|{
 3767|  4.29M|    JSString *str;
 3768|  4.29M|    str = s->str;
 3769|  4.29M|    if (s->error_status)
 3770|      0|        return JS_EXCEPTION;
 3771|  4.29M|    if (s->len == 0) {
 3772|  2.09M|        js_free(s->ctx, str);
 3773|  2.09M|        s->str = NULL;
 3774|  2.09M|        return JS_AtomToString(s->ctx, JS_ATOM_empty_string);
 3775|  2.09M|    }
 3776|  2.20M|    if (s->len < s->size) {
 3777|       |        /* smaller size so js_realloc should not fail, but OK if it does */
 3778|       |        /* XXX: should add some slack to avoid unnecessary calls */
 3779|       |        /* XXX: might need to use malloc+free to ensure smaller size */
 3780|  1.30M|        str = js_realloc_rt(s->ctx->rt, str, sizeof(JSString) +
 3781|  1.30M|                            (s->len << s->is_wide_char) + 1 - s->is_wide_char);
 3782|  1.30M|        if (str == NULL)
 3783|      0|            str = s->str;
 3784|  1.30M|        s->str = str;
 3785|  1.30M|    }
 3786|  2.20M|    if (!s->is_wide_char)
 3787|  1.81M|        str->u.str8[s->len] = 0;
 3788|       |#ifdef DUMP_LEAKS
 3789|       |    list_add_tail(&str->link, &s->ctx->rt->string_list);
 3790|       |#endif
 3791|  2.20M|    str->is_wide_char = s->is_wide_char;
 3792|  2.20M|    str->len = s->len;
 3793|  2.20M|    s->str = NULL;
 3794|  2.20M|    return JS_MKPTR(JS_TAG_STRING, str);
 3795|  4.29M|}
 3796|       |
 3797|       |/* create a string from a UTF-8 buffer */
 3798|       |JSValue JS_NewStringLen(JSContext *ctx, const char *buf, size_t buf_len)
 3799|  8.02M|{
 3800|  8.02M|    const uint8_t *p, *p_end, *p_start, *p_next;
 3801|  8.02M|    uint32_t c;
 3802|  8.02M|    StringBuffer b_s, *b = &b_s;
 3803|  8.02M|    size_t len1;
 3804|       |
 3805|  8.02M|    p_start = (const uint8_t *)buf;
 3806|  8.02M|    p_end = p_start + buf_len;
 3807|  8.02M|    len1 = count_ascii(p_start, buf_len);
 3808|  8.02M|    p = p_start + len1;
 3809|  8.02M|    if (len1 > JS_STRING_LEN_MAX)
 3810|      0|        return JS_ThrowInternalError(ctx, "string too long");
 3811|  8.02M|    if (p == p_end) {
 3812|       |        /* ASCII string */
 3813|  8.01M|        return js_new_string8_len(ctx, buf, buf_len);
 3814|  8.01M|    } else {
 3815|  18.0k|        if (string_buffer_init(ctx, b, buf_len))
 3816|      0|            goto fail;
 3817|  18.0k|        string_buffer_write8(b, p_start, len1);
 3818|  2.54M|        while (p < p_end) {
 3819|  2.52M|            if (*p < 128) {
 3820|  2.48M|                string_buffer_putc8(b, *p++);
 3821|  2.48M|            } else {
 3822|       |                /* parse utf-8 sequence, return 0xFFFFFFFF for error */
 3823|  39.5k|                c = unicode_from_utf8(p, p_end - p, &p_next);
 3824|  39.5k|                if (c < 0x10000) {
 3825|  33.6k|                    p = p_next;
 3826|  33.6k|                } else if (c <= 0x10FFFF) {
 3827|  5.31k|                    p = p_next;
 3828|       |                    /* surrogate pair */
 3829|  5.31k|                    string_buffer_putc16(b, get_hi_surrogate(c));
 3830|  5.31k|                    c = get_lo_surrogate(c);
 3831|  5.31k|                } else {
 3832|       |                    /* invalid char */
 3833|    581|                    c = 0xfffd;
 3834|       |                    /* skip the invalid chars */
 3835|       |                    /* XXX: seems incorrect. Why not just use c = *p++; ? */
 3836|   218k|                    while (p < p_end && (*p >= 0x80 && *p < 0xc0))
 3837|   217k|                        p++;
 3838|    581|                    if (p < p_end) {
 3839|    581|                        p++;
 3840|  31.1k|                        while (p < p_end && (*p >= 0x80 && *p < 0xc0))
 3841|  30.5k|                            p++;
 3842|    581|                    }
 3843|    581|                }
 3844|  39.5k|                string_buffer_putc16(b, c);
 3845|  39.5k|            }
 3846|  2.52M|        }
 3847|  18.0k|    }
 3848|  18.0k|    return string_buffer_end(b);
 3849|       |
 3850|      0| fail:
 3851|      0|    string_buffer_free(b);
 3852|      0|    return JS_EXCEPTION;
 3853|  8.02M|}
 3854|       |
 3855|       |static JSValue JS_ConcatString3(JSContext *ctx, const char *str1,
 3856|       |                                JSValue str2, const char *str3)
 3857|  94.3k|{
 3858|  94.3k|    StringBuffer b_s, *b = &b_s;
 3859|  94.3k|    int len1, len3;
 3860|  94.3k|    JSString *p;
 3861|       |
 3862|  94.3k|    if (unlikely(JS_VALUE_GET_TAG(str2) != JS_TAG_STRING)) {
 3863|      0|        str2 = JS_ToStringFree(ctx, str2);
 3864|      0|        if (JS_IsException(str2))
 3865|      0|            goto fail;
 3866|      0|    }
 3867|  94.3k|    p = JS_VALUE_GET_STRING(str2);
 3868|  94.3k|    len1 = strlen(str1);
 3869|  94.3k|    len3 = strlen(str3);
 3870|       |
 3871|  94.3k|    if (string_buffer_init2(ctx, b, len1 + p->len + len3, p->is_wide_char))
 3872|      0|        goto fail;
 3873|       |
 3874|  94.3k|    string_buffer_write8(b, (const uint8_t *)str1, len1);
 3875|  94.3k|    string_buffer_concat(b, p, 0, p->len);
 3876|  94.3k|    string_buffer_write8(b, (const uint8_t *)str3, len3);
 3877|       |
 3878|  94.3k|    JS_FreeValue(ctx, str2);
 3879|  94.3k|    return string_buffer_end(b);
 3880|       |
 3881|      0| fail:
 3882|      0|    JS_FreeValue(ctx, str2);
 3883|      0|    return JS_EXCEPTION;
 3884|  94.3k|}
 3885|       |
 3886|       |JSValue JS_NewAtomString(JSContext *ctx, const char *str)
 3887|   142k|{
 3888|   142k|    JSAtom atom = JS_NewAtom(ctx, str);
 3889|   142k|    if (atom == JS_ATOM_NULL)
 3890|      0|        return JS_EXCEPTION;
 3891|   142k|    JSValue val = JS_AtomToString(ctx, atom);
 3892|   142k|    JS_FreeAtom(ctx, atom);
 3893|   142k|    return val;
 3894|   142k|}
 3895|       |
 3896|       |/* return (NULL, 0) if exception. */
 3897|       |/* return pointer into a JSString with a live ref_count */
 3898|       |/* cesu8 determines if non-BMP1 codepoints are encoded as 1 or 2 utf-8 sequences */
 3899|       |const char *JS_ToCStringLen2(JSContext *ctx, size_t *plen, JSValueConst val1, BOOL cesu8)
 3900|  2.58M|{
 3901|  2.58M|    JSValue val;
 3902|  2.58M|    JSString *str, *str_new;
 3903|  2.58M|    int pos, len, c, c1;
 3904|  2.58M|    uint8_t *q;
 3905|       |
 3906|  2.58M|    if (JS_VALUE_GET_TAG(val1) != JS_TAG_STRING) {
 3907|  51.8k|        val = JS_ToString(ctx, val1);
 3908|  51.8k|        if (JS_IsException(val))
 3909|      0|            goto fail;
 3910|  2.53M|    } else {
 3911|  2.53M|        val = JS_DupValue(ctx, val1);
 3912|  2.53M|    }
 3913|       |
 3914|  2.58M|    str = JS_VALUE_GET_STRING(val);
 3915|  2.58M|    len = str->len;
 3916|  2.58M|    if (!str->is_wide_char) {
 3917|  2.23M|        const uint8_t *src = str->u.str8;
 3918|  2.23M|        int count;
 3919|       |
 3920|       |        /* count the number of non-ASCII characters */
 3921|       |        /* Scanning the whole string is required for ASCII strings,
 3922|       |           and computing the number of non-ASCII bytes is less expensive
 3923|       |           than testing each byte, hence this method is faster for ASCII
 3924|       |           strings, which is the most common case.
 3925|       |         */
 3926|  2.23M|        count = 0;
 3927|   137M|        for (pos = 0; pos < len; pos++) {
 3928|   135M|            count += src[pos] >> 7;
 3929|   135M|        }
 3930|  2.23M|        if (count == 0) {
 3931|  2.16M|            if (plen)
 3932|  1.85M|                *plen = len;
 3933|  2.16M|            return (const char *)src;
 3934|  2.16M|        }
 3935|  66.9k|        str_new = js_alloc_string(ctx, len + count, 0);
 3936|  66.9k|        if (!str_new)
 3937|      0|            goto fail;
 3938|  66.9k|        q = str_new->u.str8;
 3939|  7.12M|        for (pos = 0; pos < len; pos++) {
 3940|  7.05M|            c = src[pos];
 3941|  7.05M|            if (c < 0x80) {
 3942|  6.90M|                *q++ = c;
 3943|  6.90M|            } else {
 3944|   148k|                *q++ = (c >> 6) | 0xc0;
 3945|   148k|                *q++ = (c & 0x3f) | 0x80;
 3946|   148k|            }
 3947|  7.05M|        }
 3948|   351k|    } else {
 3949|   351k|        const uint16_t *src = str->u.str16;
 3950|       |        /* Allocate 3 bytes per 16 bit code point. Surrogate pairs may
 3951|       |           produce 4 bytes but use 2 code points.
 3952|       |         */
 3953|   351k|        str_new = js_alloc_string(ctx, len * 3, 0);
 3954|   351k|        if (!str_new)
 3955|      0|            goto fail;
 3956|   351k|        q = str_new->u.str8;
 3957|   351k|        pos = 0;
 3958|  78.1M|        while (pos < len) {
 3959|  77.8M|            c = src[pos++];
 3960|  77.8M|            if (c < 0x80) {
 3961|  77.2M|                *q++ = c;
 3962|  77.2M|            } else {
 3963|   568k|                if (is_hi_surrogate(c)) {
 3964|  33.1k|                    if (pos < len && !cesu8) {
 3965|  30.4k|                        c1 = src[pos];
 3966|  30.4k|                        if (is_lo_surrogate(c1)) {
 3967|  30.4k|                            pos++;
 3968|  30.4k|                            c = from_surrogate(c, c1);
 3969|  30.4k|                        } else {
 3970|       |                            /* Keep unmatched surrogate code points */
 3971|       |                            /* c = 0xfffd; */ /* error */
 3972|      0|                        }
 3973|  30.4k|                    } else {
 3974|       |                        /* Keep unmatched surrogate code points */
 3975|       |                        /* c = 0xfffd; */ /* error */
 3976|  2.72k|                    }
 3977|  33.1k|                }
 3978|   568k|                q += unicode_to_utf8(q, c);
 3979|   568k|            }
 3980|  77.8M|        }
 3981|   351k|    }
 3982|       |
 3983|   417k|    *q = '\0';
 3984|   417k|    str_new->len = q - str_new->u.str8;
 3985|   417k|    JS_FreeValue(ctx, val);
 3986|   417k|    if (plen)
 3987|   409k|        *plen = str_new->len;
 3988|   417k|    return (const char *)str_new->u.str8;
 3989|      0| fail:
 3990|      0|    if (plen)
 3991|      0|        *plen = 0;
 3992|      0|    return NULL;
 3993|  2.58M|}
 3994|       |
 3995|       |void JS_FreeCString(JSContext *ctx, const char *ptr)
 3996|  2.58M|{
 3997|  2.58M|    JSString *p;
 3998|  2.58M|    if (!ptr)
 3999|    351|        return;
 4000|       |    /* purposely removing constness */
 4001|  2.58M|    p = container_of(ptr, JSString, u);
 4002|  2.58M|    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, p));
 4003|  2.58M|}
 4004|       |
 4005|       |static int memcmp16_8(const uint16_t *src1, const uint8_t *src2, int len)
 4006|  75.9k|{
 4007|  75.9k|    int c, i;
 4008|   200k|    for(i = 0; i < len; i++) {
 4009|   157k|        c = src1[i] - src2[i];
 4010|   157k|        if (c != 0)
 4011|  33.0k|            return c;
 4012|   157k|    }
 4013|  42.8k|    return 0;
 4014|  75.9k|}
 4015|       |
 4016|       |static int memcmp16(const uint16_t *src1, const uint16_t *src2, int len)
 4017|  57.4k|{
 4018|  57.4k|    int c, i;
 4019|  2.03M|    for(i = 0; i < len; i++) {
 4020|  2.00M|        c = src1[i] - src2[i];
 4021|  2.00M|        if (c != 0)
 4022|  25.2k|            return c;
 4023|  2.00M|    }
 4024|  32.1k|    return 0;
 4025|  57.4k|}
 4026|       |
 4027|       |static int js_string_memcmp(const JSString *p1, int pos1, const JSString *p2,
 4028|       |                            int pos2, int len)
 4029|   560k|{
 4030|   560k|    int res;
 4031|       |
 4032|   560k|    if (likely(!p1->is_wide_char)) {
 4033|   460k|        if (likely(!p2->is_wide_char))
 4034|   427k|            res = memcmp(p1->u.str8 + pos1, p2->u.str8 + pos2, len);
 4035|  33.2k|        else
 4036|  33.2k|            res = -memcmp16_8(p2->u.str16 + pos2, p1->u.str8 + pos1, len);
 4037|   460k|    } else {
 4038|   100k|        if (!p2->is_wide_char)
 4039|  42.7k|            res = memcmp16_8(p1->u.str16 + pos1, p2->u.str8 + pos2, len);
 4040|  57.4k|        else
 4041|  57.4k|            res = memcmp16(p1->u.str16 + pos1, p2->u.str16 + pos2, len);
 4042|   100k|    }
 4043|   560k|    return res;
 4044|   560k|}
 4045|       |
 4046|       |/* return < 0, 0 or > 0 */
 4047|       |static int js_string_compare(JSContext *ctx,
 4048|       |                             const JSString *p1, const JSString *p2)
 4049|   284k|{
 4050|   284k|    int res, len;
 4051|   284k|    len = min_int(p1->len, p2->len);
 4052|   284k|    res = js_string_memcmp(p1, 0, p2, 0, len);
 4053|   284k|    if (res == 0) {
 4054|  23.2k|        if (p1->len == p2->len)
 4055|  3.30k|            res = 0;
 4056|  19.9k|        else if (p1->len < p2->len)
 4057|    472|            res = -1;
 4058|  19.5k|        else
 4059|  19.5k|            res = 1;
 4060|  23.2k|    }
 4061|   284k|    return res;
 4062|   284k|}
 4063|       |
 4064|       |static void copy_str16(uint16_t *dst, const JSString *p, int offset, int len)
 4065|   383k|{
 4066|   383k|    if (p->is_wide_char) {
 4067|   216k|        memcpy(dst, p->u.str16 + offset, len * 2);
 4068|   216k|    } else {
 4069|   167k|        const uint8_t *src1 = p->u.str8 + offset;
 4070|   167k|        int i;
 4071|       |
 4072|  25.3M|        for(i = 0; i < len; i++)
 4073|  25.1M|            dst[i] = src1[i];
 4074|   167k|    }
 4075|   383k|}
 4076|       |
 4077|       |static JSValue JS_ConcatString1(JSContext *ctx,
 4078|       |                                const JSString *p1, const JSString *p2)
 4079|  1.16M|{
 4080|  1.16M|    JSString *p;
 4081|  1.16M|    uint32_t len;
 4082|  1.16M|    int is_wide_char;
 4083|       |
 4084|  1.16M|    len = p1->len + p2->len;
 4085|  1.16M|    if (len > JS_STRING_LEN_MAX)
 4086|      0|        return JS_ThrowInternalError(ctx, "string too long");
 4087|  1.16M|    is_wide_char = p1->is_wide_char | p2->is_wide_char;
 4088|  1.16M|    p = js_alloc_string(ctx, len, is_wide_char);
 4089|  1.16M|    if (!p)
 4090|      0|        return JS_EXCEPTION;
 4091|  1.16M|    if (!is_wide_char) {
 4092|   968k|        memcpy(p->u.str8, p1->u.str8, p1->len);
 4093|   968k|        memcpy(p->u.str8 + p1->len, p2->u.str8, p2->len);
 4094|   968k|        p->u.str8[len] = '\0';
 4095|   968k|    } else {
 4096|   191k|        copy_str16(p->u.str16, p1, 0, p1->len);
 4097|   191k|        copy_str16(p->u.str16 + p1->len, p2, 0, p2->len);
 4098|   191k|    }
 4099|  1.16M|    return JS_MKPTR(JS_TAG_STRING, p);
 4100|  1.16M|}
 4101|       |
 4102|  1.59M|static BOOL JS_ConcatStringInPlace(JSContext *ctx, JSString *p1, JSValueConst op2) {
 4103|  1.59M|    if (JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {
 4104|  1.59M|        JSString *p2 = JS_VALUE_GET_STRING(op2);
 4105|  1.59M|        size_t size1;
 4106|       |
 4107|  1.59M|        if (p2->len == 0)
 4108|      0|            return TRUE;
 4109|  1.59M|        if (p1->header.ref_count != 1)
 4110|  1.01M|            return FALSE;
 4111|   574k|        size1 = js_malloc_usable_size(ctx, p1);
 4112|   574k|        if (p1->is_wide_char) {
 4113|  36.3k|            if (size1 >= sizeof(*p1) + ((p1->len + p2->len) << 1)) {
 4114|  18.4k|                if (p2->is_wide_char) {
 4115|    197|                    memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);
 4116|    197|                    p1->len += p2->len;
 4117|    197|                    return TRUE;
 4118|  18.2k|                } else {
 4119|  18.2k|                    size_t i;
 4120|  75.8k|                    for (i = 0; i < p2->len; i++) {
 4121|  57.5k|                        p1->u.str16[p1->len++] = p2->u.str8[i];
 4122|  57.5k|                    }
 4123|  18.2k|                    return TRUE;
 4124|  18.2k|                }
 4125|  18.4k|            }
 4126|   538k|        } else if (!p2->is_wide_char) {
 4127|   517k|            if (size1 >= sizeof(*p1) + p1->len + p2->len + 1) {
 4128|   414k|                memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);
 4129|   414k|                p1->len += p2->len;
 4130|   414k|                p1->u.str8[p1->len] = '\0';
 4131|   414k|                return TRUE;
 4132|   414k|            }
 4133|   517k|        }
 4134|   574k|    }
 4135|   141k|    return FALSE;
 4136|  1.59M|}
 4137|       |
 4138|       |static JSValue JS_ConcatString2(JSContext *ctx, JSValue op1, JSValue op2)
 4139|  1.59M|{
 4140|  1.59M|    JSValue ret;
 4141|  1.59M|    JSString *p1, *p2;
 4142|  1.59M|    p1 = JS_VALUE_GET_STRING(op1);
 4143|  1.59M|    if (JS_ConcatStringInPlace(ctx, p1, op2)) {
 4144|   432k|        JS_FreeValue(ctx, op2);
 4145|   432k|        return op1;
 4146|   432k|    }
 4147|  1.16M|    p2 = JS_VALUE_GET_STRING(op2);
 4148|  1.16M|    ret = JS_ConcatString1(ctx, p1, p2);
 4149|  1.16M|    JS_FreeValue(ctx, op1);
 4150|  1.16M|    JS_FreeValue(ctx, op2);
 4151|  1.16M|    return ret;
 4152|  1.59M|}
 4153|       |
 4154|       |/* Return the character at position 'idx'. 'val' must be a string or rope */
 4155|       |static int string_rope_get(JSValueConst val, uint32_t idx)
 4156|      0|{
 4157|      0|    if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING) {
 4158|      0|        return string_get(JS_VALUE_GET_STRING(val), idx);
 4159|      0|    } else {
 4160|      0|        JSStringRope *r = JS_VALUE_GET_STRING_ROPE(val);
 4161|      0|        uint32_t len;
 4162|      0|        if (JS_VALUE_GET_TAG(r->left) == JS_TAG_STRING)
 4163|      0|            len = JS_VALUE_GET_STRING(r->left)->len;
 4164|      0|        else
 4165|      0|            len = JS_VALUE_GET_STRING_ROPE(r->left)->len;
 4166|      0|        if (idx < len)
 4167|      0|            return string_rope_get(r->left, idx);
 4168|      0|        else
 4169|      0|            return string_rope_get(r->right, idx - len);
 4170|      0|    }
 4171|      0|}
 4172|       |
 4173|       |typedef struct {
 4174|       |    JSValueConst stack[JS_STRING_ROPE_MAX_DEPTH];
 4175|       |    int stack_len;
 4176|       |} JSStringRopeIter;
 4177|       |
 4178|       |static void string_rope_iter_init(JSStringRopeIter *s, JSValueConst val)
 4179|   157k|{
 4180|   157k|    s->stack_len = 0;
 4181|   157k|    s->stack[s->stack_len++] = val;
 4182|   157k|}
 4183|       |
 4184|       |/* iterate thru a rope and return the strings in order */
 4185|       |static JSString *string_rope_iter_next(JSStringRopeIter *s)
 4186|   209k|{
 4187|   209k|    JSValueConst val;
 4188|   209k|    JSStringRope *r;
 4189|       |
 4190|   209k|    if (s->stack_len == 0)
 4191|  6.61k|        return NULL;
 4192|   202k|    val = s->stack[--s->stack_len];
 4193|   311k|    for(;;) {
 4194|   311k|        if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING)
 4195|   202k|            return JS_VALUE_GET_STRING(val);
 4196|   108k|        r = JS_VALUE_GET_STRING_ROPE(val);
 4197|   108k|        assert(s->stack_len < JS_STRING_ROPE_MAX_DEPTH);
 4198|   108k|        s->stack[s->stack_len++] = r->right;
 4199|   108k|        val = r->left;
 4200|   108k|    }
 4201|   202k|}
 4202|       |
 4203|       |static uint32_t string_rope_get_len(JSValueConst val)
 4204|   164k|{
 4205|   164k|    if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING)
 4206|  78.4k|        return JS_VALUE_GET_STRING(val)->len;
 4207|  85.8k|    else
 4208|  85.8k|        return JS_VALUE_GET_STRING_ROPE(val)->len;
 4209|   164k|}
 4210|       |
 4211|       |static int js_string_rope_compare(JSContext *ctx, JSValueConst op1,
 4212|       |                                  JSValueConst op2, BOOL eq_only)
 4213|  82.1k|{
 4214|  82.1k|    uint32_t len1, len2, len, pos1, pos2, l;
 4215|  82.1k|    int res;
 4216|  82.1k|    JSStringRopeIter it1, it2;
 4217|  82.1k|    JSString *p1, *p2;
 4218|       |    
 4219|  82.1k|    len1 = string_rope_get_len(op1);
 4220|  82.1k|    len2 = string_rope_get_len(op2);
 4221|       |    /* no need to go further for equality test if
 4222|       |       different length */
 4223|  82.1k|    if (eq_only && len1 != len2)
 4224|  3.36k|        return 1; 
 4225|  78.7k|    len = min_uint32(len1, len2);
 4226|  78.7k|    string_rope_iter_init(&it1, op1);
 4227|  78.7k|    string_rope_iter_init(&it2, op2);
 4228|  78.7k|    p1 = string_rope_iter_next(&it1);
 4229|  78.7k|    p2 = string_rope_iter_next(&it2);
 4230|  78.7k|    pos1 = 0;
 4231|  78.7k|    pos2 = 0;
 4232|   130k|    while (len != 0) {
 4233|   111k|        l = min_uint32(p1->len - pos1, p2->len - pos2);
 4234|   111k|        l = min_uint32(l, len);
 4235|   111k|        res = js_string_memcmp(p1, pos1, p2, pos2, l);
 4236|   111k|        if (res != 0)
 4237|  59.3k|            return res;
 4238|  51.7k|        len -= l;
 4239|  51.7k|        pos1 += l;
 4240|  51.7k|        if (pos1 >= p1->len) {
 4241|  48.8k|            p1 = string_rope_iter_next(&it1);
 4242|  48.8k|            pos1 = 0;
 4243|  48.8k|        }
 4244|  51.7k|        pos2 += l;
 4245|  51.7k|        if (pos2 >= p2->len) {
 4246|  2.93k|            p2 = string_rope_iter_next(&it2);
 4247|  2.93k|            pos2 = 0;
 4248|  2.93k|        }
 4249|  51.7k|    }
 4250|       |
 4251|  19.4k|    if (len1 == len2)
 4252|      0|        res = 0;
 4253|  19.4k|    else if (len1 < len2)
 4254|  6.62k|        res = -1;
 4255|  12.7k|    else
 4256|  12.7k|        res = 1;
 4257|  19.4k|    return res;
 4258|  78.7k|}
 4259|       |
 4260|       |/* 'rope' must be a rope. return a string and modify the rope so that
 4261|       |   it won't need to be linearized again. */
 4262|       |static JSValue js_linearize_string_rope(JSContext *ctx, JSValue rope)
 4263|  17.1k|{
 4264|  17.1k|    StringBuffer b_s, *b = &b_s;
 4265|  17.1k|    JSStringRope *r;
 4266|  17.1k|    JSValue ret;
 4267|       |    
 4268|  17.1k|    r = JS_VALUE_GET_STRING_ROPE(rope);
 4269|       |
 4270|       |    /* check whether it is already linearized */
 4271|  17.1k|    if (JS_VALUE_GET_TAG(r->right) == JS_TAG_STRING &&
 4272|  17.1k|        JS_VALUE_GET_STRING(r->right)->len == 0) {
 4273|    153|        ret = JS_DupValue(ctx, r->left);
 4274|    153|        JS_FreeValue(ctx, rope);
 4275|    153|        return ret;
 4276|    153|    }
 4277|  17.0k|    if (string_buffer_init2(ctx, b, r->len, r->is_wide_char))
 4278|      0|        goto fail;
 4279|  17.0k|    if (string_buffer_concat_value(b, rope))
 4280|      0|        goto fail;
 4281|  17.0k|    ret = string_buffer_end(b);
 4282|  17.0k|    if (r->header.ref_count > 1) {
 4283|       |        /* update the rope so that it won't need to be linearized again */
 4284|  17.0k|        JS_FreeValue(ctx, r->left);
 4285|  17.0k|        JS_FreeValue(ctx, r->right);
 4286|  17.0k|        r->left = JS_DupValue(ctx, ret);
 4287|  17.0k|        r->right = JS_AtomToString(ctx, JS_ATOM_empty_string);
 4288|  17.0k|    }
 4289|  17.0k|    JS_FreeValue(ctx, rope);
 4290|  17.0k|    return ret;
 4291|      0| fail:
 4292|      0|    JS_FreeValue(ctx, rope);
 4293|      0|    return JS_EXCEPTION;
 4294|  17.0k|}
 4295|       |
 4296|       |static JSValue js_rebalancee_string_rope(JSContext *ctx, JSValueConst rope);
 4297|       |
 4298|       |/* op1 and op2 must be strings or string ropes */
 4299|       |static JSValue js_new_string_rope(JSContext *ctx, JSValue op1, JSValue op2)
 4300|   247k|{
 4301|   247k|    uint32_t len;
 4302|   247k|    int is_wide_char, depth;
 4303|   247k|    JSStringRope *r;
 4304|   247k|    JSValue res;
 4305|       |    
 4306|   247k|    if (JS_VALUE_GET_TAG(op1) == JS_TAG_STRING) {
 4307|   132k|        JSString *p1 = JS_VALUE_GET_STRING(op1);
 4308|   132k|        len = p1->len;
 4309|   132k|        is_wide_char = p1->is_wide_char;
 4310|   132k|        depth = 0;
 4311|   132k|    } else {
 4312|   114k|        JSStringRope *r1 = JS_VALUE_GET_STRING_ROPE(op1);
 4313|   114k|        len = r1->len;
 4314|   114k|        is_wide_char = r1->is_wide_char;
 4315|   114k|        depth = r1->depth;
 4316|   114k|    }
 4317|       |
 4318|   247k|    if (JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {
 4319|   221k|        JSString *p2 = JS_VALUE_GET_STRING(op2);
 4320|   221k|        len += p2->len;
 4321|   221k|        is_wide_char |= p2->is_wide_char;
 4322|   221k|    } else {
 4323|  25.6k|        JSStringRope *r2 = JS_VALUE_GET_STRING_ROPE(op2);
 4324|  25.6k|        len += r2->len;
 4325|  25.6k|        is_wide_char |= r2->is_wide_char;
 4326|  25.6k|        depth = max_int(depth, r2->depth);
 4327|  25.6k|    }
 4328|   247k|    if (len > JS_STRING_LEN_MAX) {
 4329|      0|        JS_ThrowInternalError(ctx, "string too long");
 4330|      0|        goto fail;
 4331|      0|    }
 4332|   247k|    r = js_malloc(ctx, sizeof(*r));
 4333|   247k|    if (!r)
 4334|      0|        goto fail;
 4335|   247k|    r->header.ref_count = 1;
 4336|   247k|    r->len = len;
 4337|   247k|    r->is_wide_char = is_wide_char;
 4338|   247k|    r->depth = depth + 1;
 4339|   247k|    r->left = op1;
 4340|   247k|    r->right = op2;
 4341|   247k|    res = JS_MKPTR(JS_TAG_STRING_ROPE, r);
 4342|   247k|    if (r->depth > JS_STRING_ROPE_MAX_DEPTH) {
 4343|    354|        JSValue res2;
 4344|       |#ifdef DUMP_ROPE_REBALANCE
 4345|       |        printf("rebalance: initial depth=%d\n", r->depth);
 4346|       |#endif
 4347|    354|        res2 = js_rebalancee_string_rope(ctx, res);
 4348|       |#ifdef DUMP_ROPE_REBALANCE
 4349|       |        if (JS_VALUE_GET_TAG(res2) == JS_TAG_STRING_ROPE) 
 4350|       |            printf("rebalance: final depth=%d\n", JS_VALUE_GET_STRING_ROPE(res2)->depth);
 4351|       |#endif
 4352|    354|        JS_FreeValue(ctx, res);
 4353|    354|        return res2;
 4354|   247k|    } else {
 4355|   247k|        return res;
 4356|   247k|    }
 4357|      0| fail:
 4358|      0|    JS_FreeValue(ctx, op1);
 4359|      0|    JS_FreeValue(ctx, op2);
 4360|      0|    return JS_EXCEPTION;
 4361|   247k|}
 4362|       |
 4363|  31.8k|#define ROPE_N_BUCKETS 44
 4364|       |
 4365|       |/* Fibonacii numbers starting from F_2 */
 4366|       |static const uint32_t rope_bucket_len[ROPE_N_BUCKETS] = {
 4367|       |          1,          2,          3,          5,
 4368|       |          8,         13,         21,         34,
 4369|       |         55,         89,        144,        233,
 4370|       |        377,        610,        987,       1597,
 4371|       |       2584,       4181,       6765,      10946,
 4372|       |      17711,      28657,      46368,      75025,
 4373|       |     121393,     196418,     317811,     514229,
 4374|       |     832040,    1346269,    2178309,    3524578,
 4375|       |    5702887,    9227465,   14930352,   24157817,
 4376|       |   39088169,   63245986,  102334155,  165580141,
 4377|       |  267914296,  433494437,  701408733, 1134903170, /* > JS_STRING_LEN_MAX */
 4378|       |};
 4379|       |
 4380|       |static int js_rebalancee_string_rope_rec(JSContext *ctx, JSValue *buckets,
 4381|       |                                          JSValueConst val)
 4382|   110k|{
 4383|   110k|    if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING) {
 4384|  55.3k|        JSString *p = JS_VALUE_GET_STRING(val);
 4385|  55.3k|        uint32_t len, i;
 4386|  55.3k|        JSValue a, b;
 4387|       |        
 4388|  55.3k|        len = p->len;
 4389|  55.3k|        if (len == 0)
 4390|      1|            return 0; /* nothing to do */
 4391|       |        /* find the bucket i so that rope_bucket_len[i] <= len <
 4392|       |           rope_bucket_len[i + 1] and concatenate the ropes in the
 4393|       |           buckets before */
 4394|  55.3k|        a = JS_NULL;
 4395|  55.3k|        i = 0;
 4396|   745k|        while (len >= rope_bucket_len[i + 1]) {
 4397|   690k|            b = buckets[i];
 4398|   690k|            if (!JS_IsNull(b)) {
 4399|  19.0k|                buckets[i] = JS_NULL;
 4400|  19.0k|                if (JS_IsNull(a)) {
 4401|  13.8k|                    a = b;
 4402|  13.8k|                } else {
 4403|  5.16k|                    a = js_new_string_rope(ctx, b, a);
 4404|  5.16k|                    if (JS_IsException(a))
 4405|      0|                        return -1;
 4406|  5.16k|                }
 4407|  19.0k|            }
 4408|   690k|            i++;
 4409|   690k|        }
 4410|  55.3k|        if (!JS_IsNull(a)) {
 4411|  13.8k|            a = js_new_string_rope(ctx, a, JS_DupValue(ctx, val));
 4412|  13.8k|            if (JS_IsException(a))
 4413|      0|                return -1;
 4414|  41.4k|        } else {
 4415|  41.4k|            a = JS_DupValue(ctx, val);
 4416|  41.4k|        }
 4417|  89.9k|        while (!JS_IsNull(buckets[i])) {
 4418|  34.6k|            a = js_new_string_rope(ctx, buckets[i], a);
 4419|  34.6k|            buckets[i] = JS_NULL;
 4420|  34.6k|            if (JS_IsException(a))
 4421|      0|                return -1;
 4422|  34.6k|            i++;
 4423|  34.6k|        }
 4424|  55.3k|        buckets[i] = a;
 4425|  55.3k|    } else {
 4426|  54.9k|        JSStringRope *r = JS_VALUE_GET_STRING_ROPE(val);
 4427|  54.9k|        js_rebalancee_string_rope_rec(ctx, buckets, r->left);
 4428|  54.9k|        js_rebalancee_string_rope_rec(ctx, buckets, r->right);
 4429|  54.9k|    }
 4430|   110k|    return 0;
 4431|   110k|}
 4432|       |
 4433|       |/* Return a new rope which is balanced. Algorithm from "Ropes: an
 4434|       |   Alternative to Strings", Hans-J. Boehm, Russ Atkinson and Michael
 4435|       |   Plass. */
 4436|       |static JSValue js_rebalancee_string_rope(JSContext *ctx, JSValueConst rope)
 4437|    354|{
 4438|    354|    JSValue buckets[ROPE_N_BUCKETS], a, b;
 4439|    354|    int i;
 4440|       |    
 4441|  15.9k|    for(i = 0; i < ROPE_N_BUCKETS; i++)
 4442|  15.5k|        buckets[i] = JS_NULL;
 4443|    354|    if (js_rebalancee_string_rope_rec(ctx, buckets, rope))
 4444|      0|        goto fail;
 4445|    354|    a = JS_NULL;
 4446|  15.9k|    for(i = 0; i < ROPE_N_BUCKETS; i++) {
 4447|  15.5k|        b = buckets[i];
 4448|  15.5k|        if (!JS_IsNull(b)) {
 4449|  1.65k|            buckets[i] = JS_NULL;
 4450|  1.65k|            if (JS_IsNull(a)) {
 4451|    354|                a = b;
 4452|  1.30k|            } else {
 4453|  1.30k|                a = js_new_string_rope(ctx, b, a);
 4454|  1.30k|                if (JS_IsException(a))
 4455|      0|                    goto fail;
 4456|  1.30k|            }
 4457|  1.65k|        }
 4458|  15.5k|    }
 4459|       |    /* fail safe */
 4460|    354|    if (JS_IsNull(a))
 4461|      0|        return JS_AtomToString(ctx, JS_ATOM_empty_string);
 4462|    354|    else
 4463|    354|        return a;
 4464|      0| fail:
 4465|      0|    for(i = 0; i < ROPE_N_BUCKETS; i++) {
 4466|      0|        JS_FreeValue(ctx, buckets[i]);
 4467|      0|    }
 4468|      0|    return JS_EXCEPTION;
 4469|    354|}
 4470|       |
 4471|       |/* op1 and op2 are converted to strings. For convenience, op1 or op2 =
 4472|       |   JS_EXCEPTION are accepted and return JS_EXCEPTION.  */
 4473|       |static JSValue JS_ConcatString(JSContext *ctx, JSValue op1, JSValue op2)
 4474|  1.75M|{
 4475|  1.75M|    JSString *p1, *p2;
 4476|       |
 4477|  1.75M|    if (unlikely(JS_VALUE_GET_TAG(op1) != JS_TAG_STRING &&
 4478|  1.75M|                 JS_VALUE_GET_TAG(op1) != JS_TAG_STRING_ROPE)) {
 4479|   429k|        op1 = JS_ToStringFree(ctx, op1);
 4480|   429k|        if (JS_IsException(op1)) {
 4481|      0|            JS_FreeValue(ctx, op2);
 4482|      0|            return JS_EXCEPTION;
 4483|      0|        }
 4484|   429k|    }
 4485|  1.75M|    if (unlikely(JS_VALUE_GET_TAG(op2) != JS_TAG_STRING &&
 4486|  1.75M|                 JS_VALUE_GET_TAG(op2) != JS_TAG_STRING_ROPE)) {
 4487|   905k|        op2 = JS_ToStringFree(ctx, op2);
 4488|   905k|        if (JS_IsException(op2)) {
 4489|      0|            JS_FreeValue(ctx, op1);
 4490|      0|            return JS_EXCEPTION;
 4491|      0|        }
 4492|   905k|    }
 4493|       |
 4494|       |    /* normal concatenation for short strings */
 4495|  1.75M|    if (JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {
 4496|  1.75M|        p2 = JS_VALUE_GET_STRING(op2);
 4497|  1.75M|        if (p2->len == 0) {
 4498|    375|            JS_FreeValue(ctx, op2);
 4499|    375|            return op1;
 4500|    375|        }
 4501|  1.75M|        if (p2->len <= JS_STRING_ROPE_SHORT_LEN) {
 4502|  1.64M|            if (JS_VALUE_GET_TAG(op1) == JS_TAG_STRING) {
 4503|  1.57M|                p1 = JS_VALUE_GET_STRING(op1);
 4504|  1.57M|                if (p1->len <= JS_STRING_ROPE_SHORT2_LEN) {
 4505|  1.56M|                    return JS_ConcatString2(ctx, op1, op2);
 4506|  1.56M|                } else {
 4507|  9.03k|                    return js_new_string_rope(ctx, op1, op2);
 4508|  9.03k|                }
 4509|  1.57M|            } else {
 4510|  74.4k|                JSStringRope *r1;
 4511|  74.4k|                r1 = JS_VALUE_GET_STRING_ROPE(op1);
 4512|  74.4k|                if (JS_VALUE_GET_TAG(r1->right) == JS_TAG_STRING &&
 4513|  74.4k|                    JS_VALUE_GET_STRING(r1->right)->len <= JS_STRING_ROPE_SHORT_LEN) {
 4514|  28.7k|                    JSValue val, ret;
 4515|  28.7k|                    val = JS_ConcatString2(ctx, JS_DupValue(ctx, r1->right), op2);
 4516|  28.7k|                    if (JS_IsException(val)) {
 4517|      0|                        JS_FreeValue(ctx, op1);
 4518|      0|                        return JS_EXCEPTION;
 4519|      0|                    }
 4520|  28.7k|                    ret = js_new_string_rope(ctx, JS_DupValue(ctx, r1->left), val);
 4521|  28.7k|                    JS_FreeValue(ctx, op1);
 4522|  28.7k|                    return ret;
 4523|  28.7k|                }
 4524|  74.4k|            }
 4525|  1.64M|        }
 4526|  1.75M|    } else if (JS_VALUE_GET_TAG(op1) == JS_TAG_STRING) {
 4527|      0|        JSStringRope *r2;
 4528|      0|        p1 = JS_VALUE_GET_STRING(op1);
 4529|      0|        if (p1->len == 0) {
 4530|      0|            JS_FreeValue(ctx, op1);
 4531|      0|            return op2;
 4532|      0|        }
 4533|      0|        r2 = JS_VALUE_GET_STRING_ROPE(op2);
 4534|      0|        if (JS_VALUE_GET_TAG(r2->left) == JS_TAG_STRING &&
 4535|      0|            JS_VALUE_GET_STRING(r2->left)->len <= JS_STRING_ROPE_SHORT_LEN) {
 4536|      0|            JSValue val, ret;
 4537|      0|            val = JS_ConcatString2(ctx, op1, JS_DupValue(ctx, r2->left));
 4538|      0|            if (JS_IsException(val)) {
 4539|      0|                JS_FreeValue(ctx, op2);
 4540|      0|                return JS_EXCEPTION;
 4541|      0|            }
 4542|      0|            ret = js_new_string_rope(ctx, val, JS_DupValue(ctx, r2->right));
 4543|      0|            JS_FreeValue(ctx, op2);
 4544|      0|            return ret;
 4545|      0|        }
 4546|      0|    }
 4547|   154k|    return js_new_string_rope(ctx, op1, op2);
 4548|  1.75M|}
 4549|       |
 4550|       |/* Shape support */
 4551|       |
 4552|       |static inline size_t get_shape_size(size_t hash_size, size_t prop_size)
 4553|  13.3M|{
 4554|  13.3M|    return hash_size * sizeof(uint32_t) + sizeof(JSShape) +
 4555|  13.3M|        prop_size * sizeof(JSShapeProperty);
 4556|  13.3M|}
 4557|       |
 4558|       |static inline JSShape *get_shape_from_alloc(void *sh_alloc, size_t hash_size)
 4559|  13.3M|{
 4560|  13.3M|    return (JSShape *)(void *)((uint32_t *)sh_alloc + hash_size);
 4561|  13.3M|}
 4562|       |
 4563|       |static inline uint32_t *prop_hash_end(JSShape *sh)
 4564|   167M|{
 4565|   167M|    return (uint32_t *)sh;
 4566|   167M|}
 4567|       |
 4568|       |static inline void *get_alloc_from_shape(JSShape *sh)
 4569|  15.0M|{
 4570|  15.0M|    return prop_hash_end(sh) - ((intptr_t)sh->prop_hash_mask + 1);
 4571|  15.0M|}
 4572|       |
 4573|       |static inline JSShapeProperty *get_shape_prop(JSShape *sh)
 4574|   136M|{
 4575|   136M|    return sh->prop;
 4576|   136M|}
 4577|       |
 4578|       |static int init_shape_hash(JSRuntime *rt)
 4579|  17.7k|{
 4580|  17.7k|    rt->shape_hash_bits = 4;   /* 16 shapes */
 4581|  17.7k|    rt->shape_hash_size = 1 << rt->shape_hash_bits;
 4582|  17.7k|    rt->shape_hash_count = 0;
 4583|  17.7k|    rt->shape_hash = js_mallocz_rt(rt, sizeof(rt->shape_hash[0]) *
 4584|  17.7k|                                   rt->shape_hash_size);
 4585|  17.7k|    if (!rt->shape_hash)
 4586|      0|        return -1;
 4587|  17.7k|    return 0;
 4588|  17.7k|}
 4589|       |
 4590|       |/* same magic hash multiplier as the Linux kernel */
 4591|       |static uint32_t shape_hash(uint32_t h, uint32_t val)
 4592|  78.5M|{
 4593|  78.5M|    return (h + val) * 0x9e370001;
 4594|  78.5M|}
 4595|       |
 4596|       |/* truncate the shape hash to 'hash_bits' bits */
 4597|       |static uint32_t get_shape_hash(uint32_t h, int hash_bits)
 4598|  59.2M|{
 4599|  59.2M|    return h >> (32 - hash_bits);
 4600|  59.2M|}
 4601|       |
 4602|       |static uint32_t shape_initial_hash(JSObject *proto)
 4603|  13.3M|{
 4604|  13.3M|    uint32_t h;
 4605|  13.3M|    h = shape_hash(1, (uintptr_t)proto);
 4606|  13.3M|    if (sizeof(proto) > 4)
 4607|  13.3M|        h = shape_hash(h, (uint64_t)(uintptr_t)proto >> 32);
 4608|  13.3M|    return h;
 4609|  13.3M|}
 4610|       |
 4611|       |static int resize_shape_hash(JSRuntime *rt, int new_shape_hash_bits)
 4612|  53.3k|{
 4613|  53.3k|    int new_shape_hash_size, i;
 4614|  53.3k|    uint32_t h;
 4615|  53.3k|    JSShape **new_shape_hash, *sh, *sh_next;
 4616|       |
 4617|  53.3k|    new_shape_hash_size = 1 << new_shape_hash_bits;
 4618|  53.3k|    new_shape_hash = js_mallocz_rt(rt, sizeof(rt->shape_hash[0]) *
 4619|  53.3k|                                   new_shape_hash_size);
 4620|  53.3k|    if (!new_shape_hash)
 4621|      0|        return -1;
 4622|  2.04M|    for(i = 0; i < rt->shape_hash_size; i++) {
 4623|  3.00M|        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh_next) {
 4624|  1.01M|            sh_next = sh->shape_hash_next;
 4625|  1.01M|            h = get_shape_hash(sh->hash, new_shape_hash_bits);
 4626|  1.01M|            sh->shape_hash_next = new_shape_hash[h];
 4627|  1.01M|            new_shape_hash[h] = sh;
 4628|  1.01M|        }
 4629|  1.99M|    }
 4630|  53.3k|    js_free_rt(rt, rt->shape_hash);
 4631|  53.3k|    rt->shape_hash_bits = new_shape_hash_bits;
 4632|  53.3k|    rt->shape_hash_size = new_shape_hash_size;
 4633|  53.3k|    rt->shape_hash = new_shape_hash;
 4634|  53.3k|    return 0;
 4635|  53.3k|}
 4636|       |
 4637|       |static void js_shape_hash_link(JSRuntime *rt, JSShape *sh)
 4638|  18.0M|{
 4639|  18.0M|    uint32_t h;
 4640|  18.0M|    h = get_shape_hash(sh->hash, rt->shape_hash_bits);
 4641|  18.0M|    sh->shape_hash_next = rt->shape_hash[h];
 4642|  18.0M|    rt->shape_hash[h] = sh;
 4643|  18.0M|    rt->shape_hash_count++;
 4644|  18.0M|}
 4645|       |
 4646|       |static void js_shape_hash_unlink(JSRuntime *rt, JSShape *sh)
 4647|  18.0M|{
 4648|  18.0M|    uint32_t h;
 4649|  18.0M|    JSShape **psh;
 4650|       |
 4651|  18.0M|    h = get_shape_hash(sh->hash, rt->shape_hash_bits);
 4652|  18.0M|    psh = &rt->shape_hash[h];
 4653|  18.2M|    while (*psh != sh)
 4654|   202k|        psh = &(*psh)->shape_hash_next;
 4655|  18.0M|    *psh = sh->shape_hash_next;
 4656|  18.0M|    rt->shape_hash_count--;
 4657|  18.0M|}
 4658|       |
 4659|       |/* create a new empty shape with prototype 'proto' */
 4660|       |static no_inline JSShape *js_new_shape2(JSContext *ctx, JSObject *proto,
 4661|       |                                        int hash_size, int prop_size)
 4662|  5.70M|{
 4663|  5.70M|    JSRuntime *rt = ctx->rt;
 4664|  5.70M|    void *sh_alloc;
 4665|  5.70M|    JSShape *sh;
 4666|       |
 4667|       |    /* resize the shape hash table if necessary */
 4668|  5.70M|    if (2 * (rt->shape_hash_count + 1) > rt->shape_hash_size) {
 4669|  53.3k|        resize_shape_hash(rt, rt->shape_hash_bits + 1);
 4670|  53.3k|    }
 4671|       |
 4672|  5.70M|    sh_alloc = js_malloc(ctx, get_shape_size(hash_size, prop_size));
 4673|  5.70M|    if (!sh_alloc)
 4674|      0|        return NULL;
 4675|  5.70M|    sh = get_shape_from_alloc(sh_alloc, hash_size);
 4676|  5.70M|    sh->header.ref_count = 1;
 4677|  5.70M|    add_gc_object(rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);
 4678|  5.70M|    if (proto)
 4679|  5.68M|        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, proto));
 4680|  5.70M|    sh->proto = proto;
 4681|  5.70M|    memset(prop_hash_end(sh) - hash_size, 0, sizeof(prop_hash_end(sh)[0]) *
 4682|  5.70M|           hash_size);
 4683|  5.70M|    sh->prop_hash_mask = hash_size - 1;
 4684|  5.70M|    sh->prop_size = prop_size;
 4685|  5.70M|    sh->prop_count = 0;
 4686|  5.70M|    sh->deleted_prop_count = 0;
 4687|       |
 4688|       |    /* insert in the hash table */
 4689|  5.70M|    sh->hash = shape_initial_hash(proto);
 4690|  5.70M|    sh->is_hashed = TRUE;
 4691|  5.70M|    sh->has_small_array_index = FALSE;
 4692|  5.70M|    js_shape_hash_link(ctx->rt, sh);
 4693|  5.70M|    return sh;
 4694|  5.70M|}
 4695|       |
 4696|       |static JSShape *js_new_shape(JSContext *ctx, JSObject *proto)
 4697|  5.69M|{
 4698|  5.69M|    return js_new_shape2(ctx, proto, JS_PROP_INITIAL_HASH_SIZE,
 4699|  5.69M|                         JS_PROP_INITIAL_SIZE);
 4700|  5.69M|}
 4701|       |
 4702|       |/* The shape is cloned. The new shape is not inserted in the shape
 4703|       |   hash table */
 4704|       |static JSShape *js_clone_shape(JSContext *ctx, JSShape *sh1)
 4705|  1.64M|{
 4706|  1.64M|    JSShape *sh;
 4707|  1.64M|    void *sh_alloc, *sh_alloc1;
 4708|  1.64M|    size_t size;
 4709|  1.64M|    JSShapeProperty *pr;
 4710|  1.64M|    uint32_t i, hash_size;
 4711|       |
 4712|  1.64M|    hash_size = sh1->prop_hash_mask + 1;
 4713|  1.64M|    size = get_shape_size(hash_size, sh1->prop_size);
 4714|  1.64M|    sh_alloc = js_malloc(ctx, size);
 4715|  1.64M|    if (!sh_alloc)
 4716|      0|        return NULL;
 4717|  1.64M|    sh_alloc1 = get_alloc_from_shape(sh1);
 4718|  1.64M|    memcpy(sh_alloc, sh_alloc1, size);
 4719|  1.64M|    sh = get_shape_from_alloc(sh_alloc, hash_size);
 4720|  1.64M|    sh->header.ref_count = 1;
 4721|  1.64M|    add_gc_object(ctx->rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);
 4722|  1.64M|    sh->is_hashed = FALSE;
 4723|  1.64M|    if (sh->proto) {
 4724|  1.60M|        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
 4725|  1.60M|    }
 4726|  3.66M|    for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
 4727|  2.02M|        JS_DupAtom(ctx, pr->atom);
 4728|  2.02M|    }
 4729|  1.64M|    return sh;
 4730|  1.64M|}
 4731|       |
 4732|       |static JSShape *js_dup_shape(JSShape *sh)
 4733|  6.34M|{
 4734|  6.34M|    sh->header.ref_count++;
 4735|  6.34M|    return sh;
 4736|  6.34M|}
 4737|       |
 4738|       |static void js_free_shape0(JSRuntime *rt, JSShape *sh)
 4739|  7.32M|{
 4740|  7.32M|    uint32_t i;
 4741|  7.32M|    JSShapeProperty *pr;
 4742|       |
 4743|  7.32M|    assert(sh->header.ref_count == 0);
 4744|  7.32M|    if (sh->is_hashed)
 4745|  5.89M|        js_shape_hash_unlink(rt, sh);
 4746|  7.32M|    if (sh->proto != NULL) {
 4747|  7.27M|        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
 4748|  7.27M|    }
 4749|  7.32M|    pr = get_shape_prop(sh);
 4750|  25.9M|    for(i = 0; i < sh->prop_count; i++) {
 4751|  18.6M|        JS_FreeAtomRT(rt, pr->atom);
 4752|  18.6M|        pr++;
 4753|  18.6M|    }
 4754|  7.32M|    remove_gc_object(&sh->header);
 4755|  7.32M|    js_free_rt(rt, get_alloc_from_shape(sh));
 4756|  7.32M|}
 4757|       |
 4758|       |static void js_free_shape(JSRuntime *rt, JSShape *sh)
 4759|  13.6M|{
 4760|  13.6M|    if (unlikely(--sh->header.ref_count <= 0)) {
 4761|  7.32M|        js_free_shape0(rt, sh);
 4762|  7.32M|    }
 4763|  13.6M|}
 4764|       |
 4765|       |static void js_free_shape_null(JSRuntime *rt, JSShape *sh)
 4766|  17.4k|{
 4767|  17.4k|    if (sh)
 4768|  17.4k|        js_free_shape(rt, sh);
 4769|  17.4k|}
 4770|       |
 4771|       |/* make space to hold at least 'count' properties */
 4772|       |static no_inline int resize_properties(JSContext *ctx, JSShape **psh,
 4773|       |                                       JSObject *p, uint32_t count)
 4774|  6.03M|{
 4775|  6.03M|    JSShape *sh;
 4776|  6.03M|    uint32_t new_size, new_hash_size, new_hash_mask, i;
 4777|  6.03M|    JSShapeProperty *pr;
 4778|  6.03M|    void *sh_alloc;
 4779|  6.03M|    intptr_t h;
 4780|  6.03M|    JSShape *old_sh;
 4781|       |
 4782|  6.03M|    sh = *psh;
 4783|  6.03M|    new_size = max_int(count, sh->prop_size * 3 / 2);
 4784|       |    /* Reallocate prop array first to avoid crash or size inconsistency
 4785|       |       in case of memory allocation failure */
 4786|  6.03M|    if (p) {
 4787|  6.03M|        JSProperty *new_prop;
 4788|  6.03M|        new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);
 4789|  6.03M|        if (unlikely(!new_prop))
 4790|      0|            return -1;
 4791|  6.03M|        p->prop = new_prop;
 4792|  6.03M|    }
 4793|  6.03M|    new_hash_size = sh->prop_hash_mask + 1;
 4794|  7.64M|    while (new_hash_size < new_size)
 4795|  1.60M|        new_hash_size = 2 * new_hash_size;
 4796|       |    /* resize the property shapes. Using js_realloc() is not possible in
 4797|       |       case the GC runs during the allocation */
 4798|  6.03M|    old_sh = sh;
 4799|  6.03M|    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));
 4800|  6.03M|    if (!sh_alloc)
 4801|      0|        return -1;
 4802|  6.03M|    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
 4803|  6.03M|    list_del(&old_sh->header.link);
 4804|       |    /* copy all the shape properties */
 4805|  6.03M|    memcpy(sh, old_sh,
 4806|  6.03M|           sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);
 4807|  6.03M|    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
 4808|       |
 4809|  6.03M|    if (new_hash_size != (sh->prop_hash_mask + 1)) {
 4810|       |        /* resize the hash table and the properties */
 4811|  1.60M|        new_hash_mask = new_hash_size - 1;
 4812|  1.60M|        sh->prop_hash_mask = new_hash_mask;
 4813|  1.60M|        memset(prop_hash_end(sh) - new_hash_size, 0,
 4814|  1.60M|               sizeof(prop_hash_end(sh)[0]) * new_hash_size);
 4815|  14.0M|        for(i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {
 4816|  12.4M|            if (pr->atom != JS_ATOM_NULL) {
 4817|  12.4M|                h = ((uintptr_t)pr->atom & new_hash_mask);
 4818|  12.4M|                pr->hash_next = prop_hash_end(sh)[-h - 1];
 4819|  12.4M|                prop_hash_end(sh)[-h - 1] = i + 1;
 4820|  12.4M|            }
 4821|  12.4M|        }
 4822|  4.42M|    } else {
 4823|       |        /* just copy the previous hash table */
 4824|  4.42M|        memcpy(prop_hash_end(sh) - new_hash_size, prop_hash_end(old_sh) - new_hash_size,
 4825|  4.42M|               sizeof(prop_hash_end(sh)[0]) * new_hash_size);
 4826|  4.42M|    }
 4827|  6.03M|    js_free(ctx, get_alloc_from_shape(old_sh));
 4828|  6.03M|    *psh = sh;
 4829|  6.03M|    sh->prop_size = new_size;
 4830|  6.03M|    return 0;
 4831|  6.03M|}
 4832|       |
 4833|       |/* remove the deleted properties. */
 4834|       |static int compact_properties(JSContext *ctx, JSObject *p)
 4835|      0|{
 4836|      0|    JSShape *sh, *old_sh;
 4837|      0|    void *sh_alloc;
 4838|      0|    intptr_t h;
 4839|      0|    uint32_t new_hash_size, i, j, new_hash_mask, new_size;
 4840|      0|    JSShapeProperty *old_pr, *pr;
 4841|      0|    JSProperty *prop, *new_prop;
 4842|       |
 4843|      0|    sh = p->shape;
 4844|      0|    assert(!sh->is_hashed);
 4845|       |
 4846|      0|    new_size = max_int(JS_PROP_INITIAL_SIZE,
 4847|      0|                       sh->prop_count - sh->deleted_prop_count);
 4848|      0|    assert(new_size <= sh->prop_size);
 4849|       |
 4850|      0|    new_hash_size = sh->prop_hash_mask + 1;
 4851|      0|    while ((new_hash_size / 2) >= new_size)
 4852|      0|        new_hash_size = new_hash_size / 2;
 4853|      0|    new_hash_mask = new_hash_size - 1;
 4854|       |
 4855|       |    /* resize the hash table and the properties */
 4856|      0|    old_sh = sh;
 4857|      0|    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));
 4858|      0|    if (!sh_alloc)
 4859|      0|        return -1;
 4860|      0|    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
 4861|      0|    list_del(&old_sh->header.link);
 4862|      0|    memcpy(sh, old_sh, sizeof(JSShape));
 4863|      0|    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
 4864|       |
 4865|      0|    memset(prop_hash_end(sh) - new_hash_size, 0,
 4866|      0|           sizeof(prop_hash_end(sh)[0]) * new_hash_size);
 4867|       |
 4868|      0|    j = 0;
 4869|      0|    old_pr = old_sh->prop;
 4870|      0|    pr = sh->prop;
 4871|      0|    prop = p->prop;
 4872|      0|    for(i = 0; i < sh->prop_count; i++) {
 4873|      0|        if (old_pr->atom != JS_ATOM_NULL) {
 4874|      0|            pr->atom = old_pr->atom;
 4875|      0|            pr->flags = old_pr->flags;
 4876|      0|            h = ((uintptr_t)old_pr->atom & new_hash_mask);
 4877|      0|            pr->hash_next = prop_hash_end(sh)[-h - 1];
 4878|      0|            prop_hash_end(sh)[-h - 1] = j + 1;
 4879|      0|            prop[j] = prop[i];
 4880|      0|            j++;
 4881|      0|            pr++;
 4882|      0|        }
 4883|      0|        old_pr++;
 4884|      0|    }
 4885|      0|    assert(j == (sh->prop_count - sh->deleted_prop_count));
 4886|      0|    sh->prop_hash_mask = new_hash_mask;
 4887|      0|    sh->prop_size = new_size;
 4888|      0|    sh->deleted_prop_count = 0;
 4889|      0|    sh->prop_count = j;
 4890|       |
 4891|      0|    p->shape = sh;
 4892|      0|    js_free(ctx, get_alloc_from_shape(old_sh));
 4893|       |
 4894|       |    /* reduce the size of the object properties */
 4895|      0|    new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);
 4896|      0|    if (new_prop)
 4897|      0|        p->prop = new_prop;
 4898|      0|    return 0;
 4899|      0|}
 4900|       |
 4901|       |static int add_shape_property(JSContext *ctx, JSShape **psh,
 4902|       |                              JSObject *p, JSAtom atom, int prop_flags)
 4903|  16.8M|{
 4904|  16.8M|    JSRuntime *rt = ctx->rt;
 4905|  16.8M|    JSShape *sh = *psh;
 4906|  16.8M|    JSShapeProperty *pr, *prop;
 4907|  16.8M|    uint32_t hash_mask, new_shape_hash = 0;
 4908|  16.8M|    intptr_t h;
 4909|       |
 4910|       |    /* update the shape hash */
 4911|  16.8M|    if (sh->is_hashed) {
 4912|  11.4M|        js_shape_hash_unlink(rt, sh);
 4913|  11.4M|        new_shape_hash = shape_hash(shape_hash(sh->hash, atom), prop_flags);
 4914|  11.4M|    }
 4915|       |
 4916|  16.8M|    if (unlikely(sh->prop_count >= sh->prop_size)) {
 4917|  6.00M|        if (resize_properties(ctx, psh, p, sh->prop_count + 1)) {
 4918|       |            /* in case of error, reinsert in the hash table.
 4919|       |               sh is still valid if resize_properties() failed */
 4920|      0|            if (sh->is_hashed)
 4921|      0|                js_shape_hash_link(rt, sh);
 4922|      0|            return -1;
 4923|      0|        }
 4924|  6.00M|        sh = *psh;
 4925|  6.00M|    }
 4926|  16.8M|    if (sh->is_hashed) {
 4927|  11.4M|        sh->hash = new_shape_hash;
 4928|  11.4M|        js_shape_hash_link(rt, sh);
 4929|  11.4M|    }
 4930|       |    /* Initialize the new shape property.
 4931|       |       The object property at p->prop[sh->prop_count] is uninitialized */
 4932|  16.8M|    prop = get_shape_prop(sh);
 4933|  16.8M|    pr = &prop[sh->prop_count++];
 4934|  16.8M|    pr->atom = JS_DupAtom(ctx, atom);
 4935|  16.8M|    pr->flags = prop_flags;
 4936|  16.8M|    sh->has_small_array_index |= __JS_AtomIsTaggedInt(atom);
 4937|       |    /* add in hash table */
 4938|  16.8M|    hash_mask = sh->prop_hash_mask;
 4939|  16.8M|    h = atom & hash_mask;
 4940|  16.8M|    pr->hash_next = prop_hash_end(sh)[-h - 1];
 4941|  16.8M|    prop_hash_end(sh)[-h - 1] = sh->prop_count;
 4942|  16.8M|    return 0;
 4943|  16.8M|}
 4944|       |
 4945|       |/* find a hashed empty shape matching the prototype. Return NULL if
 4946|       |   not found */
 4947|       |static JSShape *find_hashed_shape_proto(JSRuntime *rt, JSObject *proto)
 4948|  7.65M|{
 4949|  7.65M|    JSShape *sh1;
 4950|  7.65M|    uint32_t h, h1;
 4951|       |
 4952|  7.65M|    h = shape_initial_hash(proto);
 4953|  7.65M|    h1 = get_shape_hash(h, rt->shape_hash_bits);
 4954|  10.3M|    for(sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {
 4955|  4.62M|        if (sh1->hash == h &&
 4956|  4.62M|            sh1->proto == proto &&
 4957|  4.62M|            sh1->prop_count == 0) {
 4958|  1.96M|            return sh1;
 4959|  1.96M|        }
 4960|  4.62M|    }
 4961|  5.69M|    return NULL;
 4962|  7.65M|}
 4963|       |
 4964|       |/* find a hashed shape matching sh + (prop, prop_flags). Return NULL if
 4965|       |   not found */
 4966|       |static JSShape *find_hashed_shape_prop(JSRuntime *rt, JSShape *sh,
 4967|       |                                       JSAtom atom, int prop_flags)
 4968|  14.4M|{
 4969|  14.4M|    JSShape *sh1;
 4970|  14.4M|    uint32_t h, h1, i, n;
 4971|       |
 4972|  14.4M|    h = sh->hash;
 4973|  14.4M|    h = shape_hash(h, atom);
 4974|  14.4M|    h = shape_hash(h, prop_flags);
 4975|  14.4M|    h1 = get_shape_hash(h, rt->shape_hash_bits);
 4976|  18.9M|    for(sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {
 4977|       |        /* we test the hash first so that the rest is done only if the
 4978|       |           shapes really match */
 4979|  7.44M|        if (sh1->hash == h &&
 4980|  7.44M|            sh1->proto == sh->proto &&
 4981|  7.44M|            sh1->prop_count == ((n = sh->prop_count) + 1)) {
 4982|  6.70M|            for(i = 0; i < n; i++) {
 4983|  3.77M|                if (unlikely(sh1->prop[i].atom != sh->prop[i].atom) ||
 4984|  3.77M|                    unlikely(sh1->prop[i].flags != sh->prop[i].flags))
 4985|      0|                    goto next;
 4986|  3.77M|            }
 4987|  2.93M|            if (unlikely(sh1->prop[n].atom != atom) ||
 4988|  2.93M|                unlikely(sh1->prop[n].flags != prop_flags))
 4989|      0|                goto next;
 4990|  2.93M|            return sh1;
 4991|  2.93M|        }
 4992|  4.50M|    next: ;
 4993|  4.50M|    }
 4994|  11.4M|    return NULL;
 4995|  14.4M|}
 4996|       |
 4997|       |static __maybe_unused void JS_DumpShape(JSRuntime *rt, int i, JSShape *sh)
 4998|      0|{
 4999|      0|    char atom_buf[ATOM_GET_STR_BUF_SIZE];
 5000|      0|    int j;
 5001|      0|
 5002|      0|    /* XXX: should output readable class prototype */
 5003|      0|    printf("%5d %3d%c %14p %5d %5d", i,
 5004|      0|           sh->header.ref_count, " *"[sh->is_hashed],
 5005|      0|           (void *)sh->proto, sh->prop_size, sh->prop_count);
 5006|      0|    for(j = 0; j < sh->prop_count; j++) {
 5007|      0|        printf(" %s", JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),
 5008|      0|                                      sh->prop[j].atom));
 5009|      0|    }
 5010|      0|    printf("\n");
 5011|      0|}
 5012|       |
 5013|       |static __maybe_unused void JS_DumpShapes(JSRuntime *rt)
 5014|      0|{
 5015|      0|    int i;
 5016|      0|    JSShape *sh;
 5017|      0|    struct list_head *el;
 5018|      0|    JSObject *p;
 5019|      0|    JSGCObjectHeader *gp;
 5020|      0|
 5021|      0|    printf("JSShapes: {\n");
 5022|      0|    printf("%5s %4s %14s %5s %5s %s\n", "SLOT", "REFS", "PROTO", "SIZE", "COUNT", "PROPS");
 5023|      0|    for(i = 0; i < rt->shape_hash_size; i++) {
 5024|      0|        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {
 5025|      0|            JS_DumpShape(rt, i, sh);
 5026|      0|            assert(sh->is_hashed);
 5027|      0|        }
 5028|      0|    }
 5029|      0|    /* dump non-hashed shapes */
 5030|      0|    list_for_each(el, &rt->gc_obj_list) {
 5031|      0|        gp = list_entry(el, JSGCObjectHeader, link);
 5032|      0|        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {
 5033|      0|            p = (JSObject *)gp;
 5034|      0|            if (!p->shape->is_hashed) {
 5035|      0|                JS_DumpShape(rt, -1, p->shape);
 5036|      0|            }
 5037|      0|        }
 5038|      0|    }
 5039|      0|    printf("}\n");
 5040|      0|}
 5041|       |
 5042|       |static JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID class_id)
 5043|  9.09M|{
 5044|  9.09M|    JSObject *p;
 5045|       |
 5046|  9.09M|    js_trigger_gc(ctx->rt, sizeof(JSObject));
 5047|  9.09M|    p = js_malloc(ctx, sizeof(JSObject));
 5048|  9.09M|    if (unlikely(!p))
 5049|      0|        goto fail;
 5050|  9.09M|    p->class_id = class_id;
 5051|  9.09M|    p->extensible = TRUE;
 5052|  9.09M|    p->free_mark = 0;
 5053|  9.09M|    p->is_exotic = 0;
 5054|  9.09M|    p->fast_array = 0;
 5055|  9.09M|    p->is_constructor = 0;
 5056|  9.09M|    p->is_uncatchable_error = 0;
 5057|  9.09M|    p->tmp_mark = 0;
 5058|  9.09M|    p->is_HTMLDDA = 0;
 5059|  9.09M|    p->weakref_count = 0;
 5060|  9.09M|    p->u.opaque = NULL;
 5061|  9.09M|    p->shape = sh;
 5062|  9.09M|    p->prop = js_malloc(ctx, sizeof(JSProperty) * sh->prop_size);
 5063|  9.09M|    if (unlikely(!p->prop)) {
 5064|      0|        js_free(ctx, p);
 5065|      0|    fail:
 5066|      0|        js_free_shape(ctx->rt, sh);
 5067|      0|        return JS_EXCEPTION;
 5068|      0|    }
 5069|       |
 5070|  9.09M|    switch(class_id) {
 5071|   991k|    case JS_CLASS_OBJECT:
 5072|   991k|        break;
 5073|  1.46M|    case JS_CLASS_ARRAY:
 5074|  1.46M|        {
 5075|  1.46M|            JSProperty *pr;
 5076|  1.46M|            p->is_exotic = 1;
 5077|  1.46M|            p->fast_array = 1;
 5078|  1.46M|            p->u.array.u.values = NULL;
 5079|  1.46M|            p->u.array.count = 0;
 5080|  1.46M|            p->u.array.u1.size = 0;
 5081|       |            /* the length property is always the first one */
 5082|  1.46M|            if (likely(sh == ctx->array_shape)) {
 5083|  1.44M|                pr = &p->prop[0];
 5084|  1.44M|            } else {
 5085|       |                /* only used for the first array */
 5086|       |                /* cannot fail */
 5087|  17.7k|                pr = add_property(ctx, p, JS_ATOM_length,
 5088|  17.7k|                                  JS_PROP_WRITABLE | JS_PROP_LENGTH);
 5089|  17.7k|            }
 5090|  1.46M|            pr->u.value = JS_NewInt32(ctx, 0);
 5091|  1.46M|        }
 5092|  1.46M|        break;
 5093|  1.74M|    case JS_CLASS_C_FUNCTION:
 5094|  1.74M|        p->prop[0].u.value = JS_UNDEFINED;
 5095|  1.74M|        break;
 5096|      0|    case JS_CLASS_ARGUMENTS:
 5097|      0|    case JS_CLASS_UINT8C_ARRAY:
 5098|      0|    case JS_CLASS_INT8_ARRAY:
 5099|      0|    case JS_CLASS_UINT8_ARRAY:
 5100|      0|    case JS_CLASS_INT16_ARRAY:
 5101|      0|    case JS_CLASS_UINT16_ARRAY:
 5102|      0|    case JS_CLASS_INT32_ARRAY:
 5103|      0|    case JS_CLASS_UINT32_ARRAY:
 5104|      0|    case JS_CLASS_BIG_INT64_ARRAY:
 5105|      0|    case JS_CLASS_BIG_UINT64_ARRAY:
 5106|      0|    case JS_CLASS_FLOAT32_ARRAY:
 5107|      0|    case JS_CLASS_FLOAT64_ARRAY:
 5108|      0|        p->is_exotic = 1;
 5109|      0|        p->fast_array = 1;
 5110|      0|        p->u.array.u.ptr = NULL;
 5111|      0|        p->u.array.count = 0;
 5112|      0|        break;
 5113|      0|    case JS_CLASS_DATAVIEW:
 5114|      0|        p->u.array.u.ptr = NULL;
 5115|      0|        p->u.array.count = 0;
 5116|      0|        break;
 5117|  1.06M|    case JS_CLASS_NUMBER:
 5118|  1.27M|    case JS_CLASS_STRING:
 5119|  1.60M|    case JS_CLASS_BOOLEAN:
 5120|  1.60M|    case JS_CLASS_SYMBOL:
 5121|  1.60M|    case JS_CLASS_DATE:
 5122|  1.92M|    case JS_CLASS_BIG_INT:
 5123|  1.92M|        p->u.object_data = JS_UNDEFINED;
 5124|  1.92M|        goto set_exotic;
 5125|   849k|    case JS_CLASS_REGEXP:
 5126|   849k|        p->u.regexp.pattern = NULL;
 5127|   849k|        p->u.regexp.bytecode = NULL;
 5128|   849k|        goto set_exotic;
 5129|  2.13M|    default:
 5130|  4.90M|    set_exotic:
 5131|  4.90M|        if (ctx->rt->class_array[class_id].exotic) {
 5132|   214k|            p->is_exotic = 1;
 5133|   214k|        }
 5134|  4.90M|        break;
 5135|  9.09M|    }
 5136|  9.09M|    p->header.ref_count = 1;
 5137|  9.09M|    add_gc_object(ctx->rt, &p->header, JS_GC_OBJ_TYPE_JS_OBJECT);
 5138|  9.09M|    return JS_MKPTR(JS_TAG_OBJECT, p);
 5139|  9.09M|}
 5140|       |
 5141|       |static JSObject *get_proto_obj(JSValueConst proto_val)
 5142|  7.67M|{
 5143|  7.67M|    if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_OBJECT)
 5144|  1.95M|        return NULL;
 5145|  5.71M|    else
 5146|  5.71M|        return JS_VALUE_GET_OBJ(proto_val);
 5147|  7.67M|}
 5148|       |
 5149|       |/* WARNING: proto must be an object or JS_NULL */
 5150|       |JSValue JS_NewObjectProtoClass(JSContext *ctx, JSValueConst proto_val,
 5151|       |                               JSClassID class_id)
 5152|  7.65M|{
 5153|  7.65M|    JSShape *sh;
 5154|  7.65M|    JSObject *proto;
 5155|       |
 5156|  7.65M|    proto = get_proto_obj(proto_val);
 5157|  7.65M|    sh = find_hashed_shape_proto(ctx->rt, proto);
 5158|  7.65M|    if (likely(sh)) {
 5159|  1.96M|        sh = js_dup_shape(sh);
 5160|  5.69M|    } else {
 5161|  5.69M|        sh = js_new_shape(ctx, proto);
 5162|  5.69M|        if (!sh)
 5163|      0|            return JS_EXCEPTION;
 5164|  5.69M|    }
 5165|  7.65M|    return JS_NewObjectFromShape(ctx, sh, class_id);
 5166|  7.65M|}
 5167|       |
 5168|       |#if 0
 5169|       |static JSValue JS_GetObjectData(JSContext *ctx, JSValueConst obj)
 5170|       |{
 5171|       |    JSObject *p;
 5172|       |
 5173|       |    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
 5174|       |        p = JS_VALUE_GET_OBJ(obj);
 5175|       |        switch(p->class_id) {
 5176|       |        case JS_CLASS_NUMBER:
 5177|       |        case JS_CLASS_STRING:
 5178|       |        case JS_CLASS_BOOLEAN:
 5179|       |        case JS_CLASS_SYMBOL:
 5180|       |        case JS_CLASS_DATE:
 5181|       |        case JS_CLASS_BIG_INT:
 5182|       |            return JS_DupValue(ctx, p->u.object_data);
 5183|       |        }
 5184|       |    }
 5185|       |    return JS_UNDEFINED;
 5186|       |}
 5187|       |#endif
 5188|       |
 5189|       |static int JS_SetObjectData(JSContext *ctx, JSValueConst obj, JSValue val)
 5190|  1.92M|{
 5191|  1.92M|    JSObject *p;
 5192|       |
 5193|  1.92M|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
 5194|  1.92M|        p = JS_VALUE_GET_OBJ(obj);
 5195|  1.92M|        switch(p->class_id) {
 5196|  1.06M|        case JS_CLASS_NUMBER:
 5197|  1.27M|        case JS_CLASS_STRING:
 5198|  1.60M|        case JS_CLASS_BOOLEAN:
 5199|  1.60M|        case JS_CLASS_SYMBOL:
 5200|  1.60M|        case JS_CLASS_DATE:
 5201|  1.92M|        case JS_CLASS_BIG_INT:
 5202|  1.92M|            JS_FreeValue(ctx, p->u.object_data);
 5203|  1.92M|            p->u.object_data = val; /* for JS_CLASS_STRING, 'val' must
 5204|       |                                       be JS_TAG_STRING (and not a
 5205|       |                                       rope) */
 5206|  1.92M|            return 0;
 5207|  1.92M|        }
 5208|  1.92M|    }
 5209|      0|    JS_FreeValue(ctx, val);
 5210|      0|    if (!JS_IsException(obj))
 5211|      0|        JS_ThrowTypeError(ctx, "invalid object type");
 5212|      0|    return -1;
 5213|  1.92M|}
 5214|       |
 5215|       |JSValue JS_NewObjectClass(JSContext *ctx, int class_id)
 5216|  2.03M|{
 5217|  2.03M|    return JS_NewObjectProtoClass(ctx, ctx->class_proto[class_id], class_id);
 5218|  2.03M|}
 5219|       |
 5220|       |JSValue JS_NewObjectProto(JSContext *ctx, JSValueConst proto)
 5221|   618k|{
 5222|   618k|    return JS_NewObjectProtoClass(ctx, proto, JS_CLASS_OBJECT);
 5223|   618k|}
 5224|       |
 5225|       |JSValue JS_NewArray(JSContext *ctx)
 5226|  1.44M|{
 5227|  1.44M|    return JS_NewObjectFromShape(ctx, js_dup_shape(ctx->array_shape),
 5228|  1.44M|                                 JS_CLASS_ARRAY);
 5229|  1.44M|}
 5230|       |
 5231|       |JSValue JS_NewObject(JSContext *ctx)
 5232|   373k|{
 5233|       |    /* inline JS_NewObjectClass(ctx, JS_CLASS_OBJECT); */
 5234|   373k|    return JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_OBJECT);
 5235|   373k|}
 5236|       |
 5237|       |static void js_function_set_properties(JSContext *ctx, JSValueConst func_obj,
 5238|       |                                       JSAtom name, int len)
 5239|  1.90M|{
 5240|       |    /* ES6 feature non compatible with ES5.1: length is configurable */
 5241|  1.90M|    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length, JS_NewInt32(ctx, len),
 5242|  1.90M|                           JS_PROP_CONFIGURABLE);
 5243|  1.90M|    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name,
 5244|  1.90M|                           JS_AtomToString(ctx, name), JS_PROP_CONFIGURABLE);
 5245|  1.90M|}
 5246|       |
 5247|       |static BOOL js_class_has_bytecode(JSClassID class_id)
 5248|   304k|{
 5249|   304k|    return (class_id == JS_CLASS_BYTECODE_FUNCTION ||
 5250|   304k|            class_id == JS_CLASS_GENERATOR_FUNCTION ||
 5251|   304k|            class_id == JS_CLASS_ASYNC_FUNCTION ||
 5252|   304k|            class_id == JS_CLASS_ASYNC_GENERATOR_FUNCTION);
 5253|   304k|}
 5254|       |
 5255|       |/* return NULL without exception if not a function or no bytecode */
 5256|       |static JSFunctionBytecode *JS_GetFunctionBytecode(JSValueConst val)
 5257|  5.98k|{
 5258|  5.98k|    JSObject *p;
 5259|  5.98k|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
 5260|      0|        return NULL;
 5261|  5.98k|    p = JS_VALUE_GET_OBJ(val);
 5262|  5.98k|    if (!js_class_has_bytecode(p->class_id))
 5263|      8|        return NULL;
 5264|  5.97k|    return p->u.func.function_bytecode;
 5265|  5.98k|}
 5266|       |
 5267|       |static void js_method_set_home_object(JSContext *ctx, JSValueConst func_obj,
 5268|       |                                      JSValueConst home_obj)
 5269|      1|{
 5270|      1|    JSObject *p, *p1;
 5271|      1|    JSFunctionBytecode *b;
 5272|       |
 5273|      1|    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
 5274|      0|        return;
 5275|      1|    p = JS_VALUE_GET_OBJ(func_obj);
 5276|      1|    if (!js_class_has_bytecode(p->class_id))
 5277|      0|        return;
 5278|      1|    b = p->u.func.function_bytecode;
 5279|      1|    if (b->need_home_object) {
 5280|      0|        p1 = p->u.func.home_object;
 5281|      0|        if (p1) {
 5282|      0|            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));
 5283|      0|        }
 5284|      0|        if (JS_VALUE_GET_TAG(home_obj) == JS_TAG_OBJECT)
 5285|      0|            p1 = JS_VALUE_GET_OBJ(JS_DupValue(ctx, home_obj));
 5286|      0|        else
 5287|      0|            p1 = NULL;
 5288|      0|        p->u.func.home_object = p1;
 5289|      0|    }
 5290|      1|}
 5291|       |
 5292|       |static JSValue js_get_function_name(JSContext *ctx, JSAtom name)
 5293|      1|{
 5294|      1|    JSValue name_str;
 5295|       |
 5296|      1|    name_str = JS_AtomToString(ctx, name);
 5297|      1|    if (JS_AtomSymbolHasDescription(ctx, name)) {
 5298|      0|        name_str = JS_ConcatString3(ctx, "[", name_str, "]");
 5299|      0|    }
 5300|      1|    return name_str;
 5301|      1|}
 5302|       |
 5303|       |/* Modify the name of a method according to the atom and
 5304|       |   'flags'. 'flags' is a bitmask of JS_PROP_HAS_GET and
 5305|       |   JS_PROP_HAS_SET. Also set the home object of the method.
 5306|       |   Return < 0 if exception. */
 5307|       |static int js_method_set_properties(JSContext *ctx, JSValueConst func_obj,
 5308|       |                                    JSAtom name, int flags, JSValueConst home_obj)
 5309|      1|{
 5310|      1|    JSValue name_str;
 5311|       |
 5312|      1|    name_str = js_get_function_name(ctx, name);
 5313|      1|    if (flags & JS_PROP_HAS_GET) {
 5314|      0|        name_str = JS_ConcatString3(ctx, "get ", name_str, "");
 5315|      1|    } else if (flags & JS_PROP_HAS_SET) {
 5316|      0|        name_str = JS_ConcatString3(ctx, "set ", name_str, "");
 5317|      0|    }
 5318|      1|    if (JS_IsException(name_str))
 5319|      0|        return -1;
 5320|      1|    if (JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name, name_str,
 5321|      1|                               JS_PROP_CONFIGURABLE) < 0)
 5322|      0|        return -1;
 5323|      1|    js_method_set_home_object(ctx, func_obj, home_obj);
 5324|      1|    return 0;
 5325|      1|}
 5326|       |
 5327|       |/* Note: at least 'length' arguments will be readable in 'argv' */
 5328|       |static JSValue JS_NewCFunction3(JSContext *ctx, JSCFunction *func,
 5329|       |                                const char *name,
 5330|       |                                int length, JSCFunctionEnum cproto, int magic,
 5331|       |                                JSValueConst proto_val)
 5332|  1.74M|{
 5333|  1.74M|    JSValue func_obj;
 5334|  1.74M|    JSObject *p;
 5335|  1.74M|    JSAtom name_atom;
 5336|       |
 5337|  1.74M|    func_obj = JS_NewObjectProtoClass(ctx, proto_val, JS_CLASS_C_FUNCTION);
 5338|  1.74M|    if (JS_IsException(func_obj))
 5339|      0|        return func_obj;
 5340|  1.74M|    p = JS_VALUE_GET_OBJ(func_obj);
 5341|  1.74M|    p->u.cfunc.realm = JS_DupContext(ctx);
 5342|  1.74M|    p->u.cfunc.c_function.generic = func;
 5343|  1.74M|    p->u.cfunc.length = length;
 5344|  1.74M|    p->u.cfunc.cproto = cproto;
 5345|  1.74M|    p->u.cfunc.magic = magic;
 5346|  1.74M|    p->is_constructor = (cproto == JS_CFUNC_constructor ||
 5347|  1.74M|                         cproto == JS_CFUNC_constructor_magic ||
 5348|  1.74M|                         cproto == JS_CFUNC_constructor_or_func ||
 5349|  1.74M|                         cproto == JS_CFUNC_constructor_or_func_magic);
 5350|  1.74M|    if (!name)
 5351|  17.7k|        name = "";
 5352|  1.74M|    name_atom = JS_NewAtom(ctx, name);
 5353|  1.74M|    js_function_set_properties(ctx, func_obj, name_atom, length);
 5354|  1.74M|    JS_FreeAtom(ctx, name_atom);
 5355|  1.74M|    return func_obj;
 5356|  1.74M|}
 5357|       |
 5358|       |/* Note: at least 'length' arguments will be readable in 'argv' */
 5359|       |JSValue JS_NewCFunction2(JSContext *ctx, JSCFunction *func,
 5360|       |                         const char *name,
 5361|       |                         int length, JSCFunctionEnum cproto, int magic)
 5362|  1.35M|{
 5363|  1.35M|    return JS_NewCFunction3(ctx, func, name, length, cproto, magic,
 5364|  1.35M|                            ctx->function_proto);
 5365|  1.35M|}
 5366|       |
 5367|       |typedef struct JSCFunctionDataRecord {
 5368|       |    JSCFunctionData *func;
 5369|       |    uint8_t length;
 5370|       |    uint8_t data_len;
 5371|       |    uint16_t magic;
 5372|       |    JSValue data[0];
 5373|       |} JSCFunctionDataRecord;
 5374|       |
 5375|       |static void js_c_function_data_finalizer(JSRuntime *rt, JSValue val)
 5376|    734|{
 5377|    734|    JSCFunctionDataRecord *s = JS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA);
 5378|    734|    int i;
 5379|       |
 5380|    734|    if (s) {
 5381|  2.20k|        for(i = 0; i < s->data_len; i++) {
 5382|  1.46k|            JS_FreeValueRT(rt, s->data[i]);
 5383|  1.46k|        }
 5384|    734|        js_free_rt(rt, s);
 5385|    734|    }
 5386|    734|}
 5387|       |
 5388|       |static void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,
 5389|       |                                    JS_MarkFunc *mark_func)
 5390|     10|{
 5391|     10|    JSCFunctionDataRecord *s = JS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA);
 5392|     10|    int i;
 5393|       |
 5394|     10|    if (s) {
 5395|     30|        for(i = 0; i < s->data_len; i++) {
 5396|     20|            JS_MarkValue(rt, s->data[i], mark_func);
 5397|     20|        }
 5398|     10|    }
 5399|     10|}
 5400|       |
 5401|       |static JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,
 5402|       |                                       JSValueConst this_val,
 5403|       |                                       int argc, JSValueConst *argv, int flags)
 5404|    734|{
 5405|    734|    JSCFunctionDataRecord *s = JS_GetOpaque(func_obj, JS_CLASS_C_FUNCTION_DATA);
 5406|    734|    JSValueConst *arg_buf;
 5407|    734|    int i;
 5408|       |
 5409|       |    /* XXX: could add the function on the stack for debug */
 5410|    734|    if (unlikely(argc < s->length)) {
 5411|      0|        arg_buf = alloca(sizeof(arg_buf[0]) * s->length);
 5412|      0|        for(i = 0; i < argc; i++)
 5413|      0|            arg_buf[i] = argv[i];
 5414|      0|        for(i = argc; i < s->length; i++)
 5415|      0|            arg_buf[i] = JS_UNDEFINED;
 5416|    734|    } else {
 5417|    734|        arg_buf = argv;
 5418|    734|    }
 5419|       |
 5420|    734|    return s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);
 5421|    734|}
 5422|       |
 5423|       |JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
 5424|       |                            int length, int magic, int data_len,
 5425|       |                            JSValueConst *data)
 5426|    734|{
 5427|    734|    JSCFunctionDataRecord *s;
 5428|    734|    JSValue func_obj;
 5429|    734|    int i;
 5430|       |
 5431|    734|    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,
 5432|    734|                                      JS_CLASS_C_FUNCTION_DATA);
 5433|    734|    if (JS_IsException(func_obj))
 5434|      0|        return func_obj;
 5435|    734|    s = js_malloc(ctx, sizeof(*s) + data_len * sizeof(JSValue));
 5436|    734|    if (!s) {
 5437|      0|        JS_FreeValue(ctx, func_obj);
 5438|      0|        return JS_EXCEPTION;
 5439|      0|    }
 5440|    734|    s->func = func;
 5441|    734|    s->length = length;
 5442|    734|    s->data_len = data_len;
 5443|    734|    s->magic = magic;
 5444|  2.20k|    for(i = 0; i < data_len; i++)
 5445|  1.46k|        s->data[i] = JS_DupValue(ctx, data[i]);
 5446|    734|    JS_SetOpaque(func_obj, s);
 5447|    734|    js_function_set_properties(ctx, func_obj,
 5448|    734|                               JS_ATOM_empty_string, length);
 5449|    734|    return func_obj;
 5450|    734|}
 5451|       |
 5452|       |static JSContext *js_autoinit_get_realm(JSProperty *pr)
 5453|  19.4M|{
 5454|  19.4M|    return (JSContext *)(pr->u.init.realm_and_id & ~3);
 5455|  19.4M|}
 5456|       |
 5457|       |static JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)
 5458|   198k|{
 5459|   198k|    return pr->u.init.realm_and_id & 3;
 5460|   198k|}
 5461|       |
 5462|       |static void js_autoinit_free(JSRuntime *rt, JSProperty *pr)
 5463|  6.30M|{
 5464|  6.30M|    JS_FreeContext(js_autoinit_get_realm(pr));
 5465|  6.30M|}
 5466|       |
 5467|       |static void js_autoinit_mark(JSRuntime *rt, JSProperty *pr,
 5468|       |                             JS_MarkFunc *mark_func)
 5469|  12.9M|{
 5470|  12.9M|    mark_func(rt, &js_autoinit_get_realm(pr)->header);
 5471|  12.9M|}
 5472|       |
 5473|       |static void free_property(JSRuntime *rt, JSProperty *pr, int prop_flags)
 5474|  20.8M|{
 5475|  20.8M|    if (unlikely(prop_flags & JS_PROP_TMASK)) {
 5476|  6.76M|        if ((prop_flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 5477|   627k|            if (pr->u.getset.getter)
 5478|   627k|                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));
 5479|   627k|            if (pr->u.getset.setter)
 5480|  52.2k|                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));
 5481|  6.14M|        } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 5482|  31.5k|            free_var_ref(rt, pr->u.var_ref);
 5483|  6.11M|        } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 5484|  6.11M|            js_autoinit_free(rt, pr);
 5485|  6.11M|        }
 5486|  14.1M|    } else {
 5487|  14.1M|        JS_FreeValueRT(rt, pr->u.value);
 5488|  14.1M|    }
 5489|  20.8M|}
 5490|       |
 5491|       |static force_inline JSShapeProperty *find_own_property1(JSObject *p,
 5492|       |                                                        JSAtom atom)
 5493|  1.22M|{
 5494|  1.22M|    JSShape *sh;
 5495|  1.22M|    JSShapeProperty *pr, *prop;
 5496|  1.22M|    intptr_t h;
 5497|  1.22M|    sh = p->shape;
 5498|  1.22M|    h = (uintptr_t)atom & sh->prop_hash_mask;
 5499|  1.22M|    h = prop_hash_end(sh)[-h - 1];
 5500|  1.22M|    prop = get_shape_prop(sh);
 5501|  2.29M|    while (h) {
 5502|  2.27M|        pr = &prop[h - 1];
 5503|  2.27M|        if (likely(pr->atom == atom)) {
 5504|  1.20M|            return pr;
 5505|  1.20M|        }
 5506|  1.06M|        h = pr->hash_next;
 5507|  1.06M|    }
 5508|  12.8k|    return NULL;
 5509|  1.22M|}
 5510|       |
 5511|       |static force_inline JSShapeProperty *find_own_property(JSProperty **ppr,
 5512|       |                                                       JSObject *p,
 5513|       |                                                       JSAtom atom)
 5514|  76.0M|{
 5515|  76.0M|    JSShape *sh;
 5516|  76.0M|    JSShapeProperty *pr, *prop;
 5517|  76.0M|    intptr_t h;
 5518|  76.0M|    sh = p->shape;
 5519|  76.0M|    h = (uintptr_t)atom & sh->prop_hash_mask;
 5520|  76.0M|    h = prop_hash_end(sh)[-h - 1];
 5521|  76.0M|    prop = get_shape_prop(sh);
 5522|   101M|    while (h) {
 5523|  42.6M|        pr = &prop[h - 1];
 5524|  42.6M|        if (likely(pr->atom == atom)) {
 5525|  17.2M|            *ppr = &p->prop[h - 1];
 5526|       |            /* the compiler should be able to assume that pr != NULL here */
 5527|  17.2M|            return pr;
 5528|  17.2M|        }
 5529|  25.3M|        h = pr->hash_next;
 5530|  25.3M|    }
 5531|  58.7M|    *ppr = NULL;
 5532|  58.7M|    return NULL;
 5533|  76.0M|}
 5534|       |
 5535|       |/* indicate that the object may be part of a function prototype cycle */
 5536|       |static void set_cycle_flag(JSContext *ctx, JSValueConst obj)
 5537|  1.63M|{
 5538|  1.63M|}
 5539|       |
 5540|       |static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref)
 5541|  1.88M|{
 5542|  1.88M|    if (var_ref) {
 5543|   176k|        assert(var_ref->header.ref_count > 0);
 5544|   176k|        if (--var_ref->header.ref_count == 0) {
 5545|  60.8k|            if (var_ref->is_detached) {
 5546|  20.6k|                JS_FreeValueRT(rt, var_ref->value);
 5547|  40.2k|            } else {
 5548|  40.2k|                list_del(&var_ref->var_ref_link); /* still on the stack */
 5549|  40.2k|                if (var_ref->async_func)
 5550|    184|                    async_func_free(rt, var_ref->async_func);
 5551|  40.2k|            }
 5552|  60.8k|            remove_gc_object(&var_ref->header);
 5553|  60.8k|            js_free_rt(rt, var_ref);
 5554|  60.8k|        }
 5555|   176k|    }
 5556|  1.88M|}
 5557|       |
 5558|       |static void js_array_finalizer(JSRuntime *rt, JSValue val)
 5559|  1.46M|{
 5560|  1.46M|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5561|  1.46M|    int i;
 5562|       |
 5563|  1.62M|    for(i = 0; i < p->u.array.count; i++) {
 5564|   167k|        JS_FreeValueRT(rt, p->u.array.u.values[i]);
 5565|   167k|    }
 5566|  1.46M|    js_free_rt(rt, p->u.array.u.values);
 5567|  1.46M|}
 5568|       |
 5569|       |static void js_array_mark(JSRuntime *rt, JSValueConst val,
 5570|       |                          JS_MarkFunc *mark_func)
 5571|  4.51M|{
 5572|  4.51M|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5573|  4.51M|    int i;
 5574|       |
 5575|  4.55M|    for(i = 0; i < p->u.array.count; i++) {
 5576|  36.9k|        JS_MarkValue(rt, p->u.array.u.values[i], mark_func);
 5577|  36.9k|    }
 5578|  4.51M|}
 5579|       |
 5580|       |static void js_object_data_finalizer(JSRuntime *rt, JSValue val)
 5581|  1.92M|{
 5582|  1.92M|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5583|  1.92M|    JS_FreeValueRT(rt, p->u.object_data);
 5584|  1.92M|    p->u.object_data = JS_UNDEFINED;
 5585|  1.92M|}
 5586|       |
 5587|       |static void js_object_data_mark(JSRuntime *rt, JSValueConst val,
 5588|       |                                JS_MarkFunc *mark_func)
 5589|   110k|{
 5590|   110k|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5591|   110k|    JS_MarkValue(rt, p->u.object_data, mark_func);
 5592|   110k|}
 5593|       |
 5594|       |static void js_c_function_finalizer(JSRuntime *rt, JSValue val)
 5595|  1.70M|{
 5596|  1.70M|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5597|       |
 5598|  1.70M|    if (p->u.cfunc.realm)
 5599|  1.70M|        JS_FreeContext(p->u.cfunc.realm);
 5600|  1.70M|}
 5601|       |
 5602|       |static void js_c_function_mark(JSRuntime *rt, JSValueConst val,
 5603|       |                               JS_MarkFunc *mark_func)
 5604|  3.60M|{
 5605|  3.60M|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5606|       |
 5607|  3.60M|    if (p->u.cfunc.realm)
 5608|  3.60M|        mark_func(rt, &p->u.cfunc.realm->header);
 5609|  3.60M|}
 5610|       |
 5611|       |static void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val)
 5612|   156k|{
 5613|   156k|    JSObject *p1, *p = JS_VALUE_GET_OBJ(val);
 5614|   156k|    JSFunctionBytecode *b;
 5615|   156k|    JSVarRef **var_refs;
 5616|   156k|    int i;
 5617|       |
 5618|   156k|    p1 = p->u.func.home_object;
 5619|   156k|    if (p1) {
 5620|      0|        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, p1));
 5621|      0|    }
 5622|   156k|    b = p->u.func.function_bytecode;
 5623|   156k|    if (b) {
 5624|   156k|        var_refs = p->u.func.var_refs;
 5625|   156k|        if (var_refs) {
 5626|   247k|            for(i = 0; i < b->closure_var_count; i++)
 5627|   144k|                free_var_ref(rt, var_refs[i]);
 5628|   102k|            js_free_rt(rt, var_refs);
 5629|   102k|        }
 5630|   156k|        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b));
 5631|   156k|    }
 5632|   156k|}
 5633|       |
 5634|       |static void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,
 5635|       |                                      JS_MarkFunc *mark_func)
 5636|   169k|{
 5637|   169k|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5638|   169k|    JSVarRef **var_refs = p->u.func.var_refs;
 5639|   169k|    JSFunctionBytecode *b = p->u.func.function_bytecode;
 5640|   169k|    int i;
 5641|       |
 5642|   169k|    if (p->u.func.home_object) {
 5643|      0|        JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, p->u.func.home_object),
 5644|      0|                     mark_func);
 5645|      0|    }
 5646|   169k|    if (b) {
 5647|   169k|        if (var_refs) {
 5648|   330k|            for(i = 0; i < b->closure_var_count; i++) {
 5649|   192k|                JSVarRef *var_ref = var_refs[i];
 5650|   192k|                if (var_ref) {
 5651|   192k|                    mark_func(rt, &var_ref->header);
 5652|   192k|                }
 5653|   192k|            }
 5654|   137k|        }
 5655|       |        /* must mark the function bytecode because template objects may be
 5656|       |           part of a cycle */
 5657|   169k|        JS_MarkValue(rt, JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b), mark_func);
 5658|   169k|    }
 5659|   169k|}
 5660|       |
 5661|       |static void js_bound_function_finalizer(JSRuntime *rt, JSValue val)
 5662|      0|{
 5663|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5664|      0|    JSBoundFunction *bf = p->u.bound_function;
 5665|      0|    int i;
 5666|       |
 5667|      0|    JS_FreeValueRT(rt, bf->func_obj);
 5668|      0|    JS_FreeValueRT(rt, bf->this_val);
 5669|      0|    for(i = 0; i < bf->argc; i++) {
 5670|      0|        JS_FreeValueRT(rt, bf->argv[i]);
 5671|      0|    }
 5672|      0|    js_free_rt(rt, bf);
 5673|      0|}
 5674|       |
 5675|       |static void js_bound_function_mark(JSRuntime *rt, JSValueConst val,
 5676|       |                                JS_MarkFunc *mark_func)
 5677|      0|{
 5678|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5679|      0|    JSBoundFunction *bf = p->u.bound_function;
 5680|      0|    int i;
 5681|       |
 5682|      0|    JS_MarkValue(rt, bf->func_obj, mark_func);
 5683|      0|    JS_MarkValue(rt, bf->this_val, mark_func);
 5684|      0|    for(i = 0; i < bf->argc; i++)
 5685|      0|        JS_MarkValue(rt, bf->argv[i], mark_func);
 5686|      0|}
 5687|       |
 5688|       |static void js_for_in_iterator_finalizer(JSRuntime *rt, JSValue val)
 5689|  1.87M|{
 5690|  1.87M|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5691|  1.87M|    JSForInIterator *it = p->u.for_in_iterator;
 5692|  1.87M|    int i;
 5693|       |
 5694|  1.87M|    JS_FreeValueRT(rt, it->obj);
 5695|  1.87M|    if (!it->is_array) {
 5696|  7.04M|        for(i = 0; i < it->atom_count; i++) {
 5697|  5.17M|            JS_FreeAtomRT(rt, it->tab_atom[i].atom);
 5698|  5.17M|        }
 5699|  1.87M|        js_free_rt(rt, it->tab_atom);
 5700|  1.87M|    }
 5701|  1.87M|    js_free_rt(rt, it);
 5702|  1.87M|}
 5703|       |
 5704|       |static void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,
 5705|       |                                JS_MarkFunc *mark_func)
 5706|     28|{
 5707|     28|    JSObject *p = JS_VALUE_GET_OBJ(val);
 5708|     28|    JSForInIterator *it = p->u.for_in_iterator;
 5709|     28|    JS_MarkValue(rt, it->obj, mark_func);
 5710|     28|}
 5711|       |
 5712|       |static void free_object(JSRuntime *rt, JSObject *p)
 5713|  9.04M|{
 5714|  9.04M|    int i;
 5715|  9.04M|    JSClassFinalizer *finalizer;
 5716|  9.04M|    JSShape *sh;
 5717|  9.04M|    JSShapeProperty *pr;
 5718|       |
 5719|  9.04M|    p->free_mark = 1; /* used to tell the object is invalid when
 5720|       |                         freeing cycles */
 5721|       |    /* free all the fields */
 5722|  9.04M|    sh = p->shape;
 5723|  9.04M|    pr = get_shape_prop(sh);
 5724|  29.9M|    for(i = 0; i < sh->prop_count; i++) {
 5725|  20.8M|        free_property(rt, &p->prop[i], pr->flags);
 5726|  20.8M|        pr++;
 5727|  20.8M|    }
 5728|  9.04M|    js_free_rt(rt, p->prop);
 5729|       |    /* as an optimization we destroy the shape immediately without
 5730|       |       putting it in gc_zero_ref_count_list */
 5731|  9.04M|    js_free_shape(rt, sh);
 5732|       |
 5733|       |    /* fail safe */
 5734|  9.04M|    p->shape = NULL;
 5735|  9.04M|    p->prop = NULL;
 5736|       |
 5737|  9.04M|    finalizer = rt->class_array[p->class_id].finalizer;
 5738|  9.04M|    if (finalizer)
 5739|  7.97M|        (*finalizer)(rt, JS_MKPTR(JS_TAG_OBJECT, p));
 5740|       |
 5741|       |    /* fail safe */
 5742|  9.04M|    p->class_id = 0;
 5743|  9.04M|    p->u.opaque = NULL;
 5744|  9.04M|    p->u.func.var_refs = NULL;
 5745|  9.04M|    p->u.func.home_object = NULL;
 5746|       |
 5747|  9.04M|    remove_gc_object(&p->header);
 5748|  9.04M|    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES) {
 5749|  2.79M|        if (p->header.ref_count == 0 && p->weakref_count == 0) {
 5750|  1.04M|            js_free_rt(rt, p);
 5751|  1.75M|        } else {
 5752|       |            /* keep the object structure because there are may be
 5753|       |               references to it */
 5754|  1.75M|            list_add_tail(&p->header.link, &rt->gc_zero_ref_count_list);
 5755|  1.75M|        }
 5756|  6.24M|    } else {
 5757|       |        /* keep the object structure in case there are weak references to it */
 5758|  6.24M|        if (p->weakref_count == 0) {
 5759|  6.24M|            js_free_rt(rt, p);
 5760|  6.24M|        } else {
 5761|      0|            p->header.mark = 0; /* reset the mark so that the weakref can be freed */
 5762|      0|        }
 5763|  6.24M|    }
 5764|  9.04M|}
 5765|       |
 5766|       |static void free_gc_object(JSRuntime *rt, JSGCObjectHeader *gp)
 5767|  9.14M|{
 5768|  9.14M|    switch(gp->gc_obj_type) {
 5769|  9.04M|    case JS_GC_OBJ_TYPE_JS_OBJECT:
 5770|  9.04M|        free_object(rt, (JSObject *)gp);
 5771|  9.04M|        break;
 5772|   102k|    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
 5773|   102k|        free_function_bytecode(rt, (JSFunctionBytecode *)gp);
 5774|   102k|        break;
 5775|     15|    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
 5776|     15|        __async_func_free(rt, (JSAsyncFunctionState *)gp);
 5777|     15|        break;
 5778|      0|    default:
 5779|      0|        abort();
 5780|  9.14M|    }
 5781|  9.14M|}
 5782|       |
 5783|       |static void free_zero_refcount(JSRuntime *rt)
 5784|  3.74M|{
 5785|  3.74M|    struct list_head *el;
 5786|  3.74M|    JSGCObjectHeader *p;
 5787|       |
 5788|  3.74M|    rt->gc_phase = JS_GC_PHASE_DECREF;
 5789|  10.0M|    for(;;) {
 5790|  10.0M|        el = rt->gc_zero_ref_count_list.next;
 5791|  10.0M|        if (el == &rt->gc_zero_ref_count_list)
 5792|  3.74M|            break;
 5793|  6.32M|        p = list_entry(el, JSGCObjectHeader, link);
 5794|  6.32M|        assert(p->ref_count == 0);
 5795|  6.32M|        free_gc_object(rt, p);
 5796|  6.32M|    }
 5797|  3.74M|    rt->gc_phase = JS_GC_PHASE_NONE;
 5798|  3.74M|}
 5799|       |
 5800|       |/* called with the ref_count of 'v' reaches zero. */
 5801|       |void __JS_FreeValueRT(JSRuntime *rt, JSValue v)
 5802|  23.4M|{
 5803|  23.4M|    uint32_t tag = JS_VALUE_GET_TAG(v);
 5804|       |
 5805|       |#ifdef DUMP_FREE
 5806|       |    {
 5807|       |        printf("Freeing ");
 5808|       |        if (tag == JS_TAG_OBJECT) {
 5809|       |            JS_DumpObject(rt, JS_VALUE_GET_OBJ(v));
 5810|       |        } else {
 5811|       |            JS_DumpValueShort(rt, v);
 5812|       |            printf("\n");
 5813|       |        }
 5814|       |    }
 5815|       |#endif
 5816|       |
 5817|  23.4M|    switch(tag) {
 5818|  12.2M|    case JS_TAG_STRING:
 5819|  12.2M|        {
 5820|  12.2M|            JSString *p = JS_VALUE_GET_STRING(v);
 5821|  12.2M|            if (p->atom_type) {
 5822|   574k|                JS_FreeAtomStruct(rt, p);
 5823|  11.6M|            } else {
 5824|       |#ifdef DUMP_LEAKS
 5825|       |                list_del(&p->link);
 5826|       |#endif
 5827|  11.6M|                js_free_rt(rt, p);
 5828|  11.6M|            }
 5829|  12.2M|        }
 5830|  12.2M|        break;
 5831|   247k|    case JS_TAG_STRING_ROPE:
 5832|       |        /* Note: recursion is acceptable because the rope depth is bounded */
 5833|   247k|        {
 5834|   247k|            JSStringRope *p = JS_VALUE_GET_STRING_ROPE(v);
 5835|   247k|            JS_FreeValueRT(rt, p->left);
 5836|   247k|            JS_FreeValueRT(rt, p->right);
 5837|   247k|            js_free_rt(rt, p);
 5838|   247k|        }
 5839|   247k|        break;
 5840|  9.04M|    case JS_TAG_OBJECT:
 5841|  9.14M|    case JS_TAG_FUNCTION_BYTECODE:
 5842|  9.14M|        {
 5843|  9.14M|            JSGCObjectHeader *p = JS_VALUE_GET_PTR(v);
 5844|  9.14M|            if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {
 5845|  6.32M|                list_del(&p->link);
 5846|  6.32M|                list_add(&p->link, &rt->gc_zero_ref_count_list);
 5847|  6.32M|                p->mark = 1; /* indicate that the object is about to be freed */
 5848|  6.32M|                if (rt->gc_phase == JS_GC_PHASE_NONE) {
 5849|  3.74M|                    free_zero_refcount(rt);
 5850|  3.74M|                }
 5851|  6.32M|            }
 5852|  9.14M|        }
 5853|  9.14M|        break;
 5854|      0|    case JS_TAG_MODULE:
 5855|      0|        abort(); /* never freed here */
 5856|      0|        break;
 5857|  1.87M|    case JS_TAG_BIG_INT:
 5858|  1.87M|        {
 5859|  1.87M|            JSBigInt *p = JS_VALUE_GET_PTR(v);
 5860|  1.87M|            js_free_rt(rt, p);
 5861|  1.87M|        }
 5862|  1.87M|        break;
 5863|      0|    case JS_TAG_SYMBOL:
 5864|      0|        {
 5865|      0|            JSAtomStruct *p = JS_VALUE_GET_PTR(v);
 5866|      0|            JS_FreeAtomStruct(rt, p);
 5867|      0|        }
 5868|      0|        break;
 5869|      0|    default:
 5870|      0|        abort();
 5871|  23.4M|    }
 5872|  23.4M|}
 5873|       |
 5874|       |void __JS_FreeValue(JSContext *ctx, JSValue v)
 5875|  18.0M|{
 5876|  18.0M|    __JS_FreeValueRT(ctx->rt, v);
 5877|  18.0M|}
 5878|       |
 5879|       |/* garbage collection */
 5880|       |
 5881|       |static void gc_remove_weak_objects(JSRuntime *rt)
 5882|    976|{
 5883|    976|    struct list_head *el;
 5884|       |
 5885|       |    /* add the freed objects to rt->gc_zero_ref_count_list so that
 5886|       |       rt->weakref_list is not modified while we traverse it */
 5887|    976|    rt->gc_phase = JS_GC_PHASE_DECREF; 
 5888|       |        
 5889|    976|    list_for_each(el, &rt->weakref_list) {
 5890|      0|        JSWeakRefHeader *wh = list_entry(el, JSWeakRefHeader, link);
 5891|      0|        switch(wh->weakref_type) {
 5892|      0|        case JS_WEAKREF_TYPE_MAP:
 5893|      0|            map_delete_weakrefs(rt, wh);
 5894|      0|            break;
 5895|      0|        case JS_WEAKREF_TYPE_WEAKREF:
 5896|      0|            weakref_delete_weakref(rt, wh);
 5897|      0|            break;
 5898|      0|        case JS_WEAKREF_TYPE_FINREC:
 5899|      0|            finrec_delete_weakref(rt, wh);
 5900|      0|            break;
 5901|      0|        default:
 5902|      0|            abort();
 5903|      0|        }
 5904|      0|    }
 5905|       |
 5906|    976|    rt->gc_phase = JS_GC_PHASE_NONE;
 5907|       |    /* free the freed objects here. */
 5908|    976|    free_zero_refcount(rt);
 5909|    976|}
 5910|       |
 5911|       |static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
 5912|       |                          JSGCObjectTypeEnum type)
 5913|  16.6M|{
 5914|  16.6M|    h->mark = 0;
 5915|  16.6M|    h->gc_obj_type = type;
 5916|  16.6M|    list_add_tail(&h->link, &rt->gc_obj_list);
 5917|  16.6M|}
 5918|       |
 5919|       |static void remove_gc_object(JSGCObjectHeader *h)
 5920|  16.5M|{
 5921|  16.5M|    list_del(&h->link);
 5922|  16.5M|}
 5923|       |
 5924|       |void JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)
 5925|  31.6M|{
 5926|  31.6M|    if (JS_VALUE_HAS_REF_COUNT(val)) {
 5927|  20.4M|        switch(JS_VALUE_GET_TAG(val)) {
 5928|  10.6M|        case JS_TAG_OBJECT:
 5929|  10.9M|        case JS_TAG_FUNCTION_BYTECODE:
 5930|  10.9M|            mark_func(rt, JS_VALUE_GET_PTR(val));
 5931|  10.9M|            break;
 5932|  9.45M|        default:
 5933|  9.45M|            break;
 5934|  20.4M|        }
 5935|  20.4M|    }
 5936|  31.6M|}
 5937|       |
 5938|       |static void mark_children(JSRuntime *rt, JSGCObjectHeader *gp,
 5939|       |                          JS_MarkFunc *mark_func)
 5940|  17.2M|{
 5941|  17.2M|    switch(gp->gc_obj_type) {
 5942|  10.4M|    case JS_GC_OBJ_TYPE_JS_OBJECT:
 5943|  10.4M|        {
 5944|  10.4M|            JSObject *p = (JSObject *)gp;
 5945|  10.4M|            JSShapeProperty *prs;
 5946|  10.4M|            JSShape *sh;
 5947|  10.4M|            int i;
 5948|  10.4M|            sh = p->shape;
 5949|  10.4M|            mark_func(rt, &sh->header);
 5950|       |            /* mark all the fields */
 5951|  10.4M|            prs = get_shape_prop(sh);
 5952|  52.5M|            for(i = 0; i < sh->prop_count; i++) {
 5953|  42.0M|                JSProperty *pr = &p->prop[i];
 5954|  42.0M|                if (prs->atom != JS_ATOM_NULL) {
 5955|  42.0M|                    if (prs->flags & JS_PROP_TMASK) {
 5956|  14.3M|                        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 5957|  1.32M|                            if (pr->u.getset.getter)
 5958|  1.32M|                                mark_func(rt, &pr->u.getset.getter->header);
 5959|  1.32M|                            if (pr->u.getset.setter)
 5960|   110k|                                mark_func(rt, &pr->u.getset.setter->header);
 5961|  12.9M|                        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 5962|       |                            /* Note: the tag does not matter
 5963|       |                               provided it is a GC object */
 5964|  78.2k|                            mark_func(rt, &pr->u.var_ref->header);
 5965|  12.9M|                        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 5966|  12.9M|                            js_autoinit_mark(rt, pr, mark_func);
 5967|  12.9M|                        }
 5968|  27.7M|                    } else {
 5969|  27.7M|                        JS_MarkValue(rt, pr->u.value, mark_func);
 5970|  27.7M|                    }
 5971|  42.0M|                }
 5972|  42.0M|                prs++;
 5973|  42.0M|            }
 5974|       |
 5975|  10.4M|            if (p->class_id != JS_CLASS_OBJECT) {
 5976|  8.40M|                JSClassGCMark *gc_mark;
 5977|  8.40M|                gc_mark = rt->class_array[p->class_id].gc_mark;
 5978|  8.40M|                if (gc_mark)
 5979|  8.40M|                    gc_mark(rt, JS_MKPTR(JS_TAG_OBJECT, p), mark_func);
 5980|  8.40M|            }
 5981|  10.4M|        }
 5982|  10.4M|        break;
 5983|   129k|    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
 5984|       |        /* the template objects can be part of a cycle */
 5985|   129k|        {
 5986|   129k|            JSFunctionBytecode *b = (JSFunctionBytecode *)gp;
 5987|   129k|            int i;
 5988|   373k|            for(i = 0; i < b->cpool_count; i++) {
 5989|   243k|                JS_MarkValue(rt, b->cpool[i], mark_func);
 5990|   243k|            }
 5991|   129k|            if (b->realm)
 5992|   129k|                mark_func(rt, &b->realm->header);
 5993|   129k|        }
 5994|   129k|        break;
 5995|   116k|    case JS_GC_OBJ_TYPE_VAR_REF:
 5996|   116k|        {
 5997|   116k|            JSVarRef *var_ref = (JSVarRef *)gp;
 5998|   116k|            if (var_ref->is_detached) {
 5999|  37.8k|                JS_MarkValue(rt, *var_ref->pvalue, mark_func);
 6000|  78.7k|            } else if (var_ref->async_func) {
 6001|      0|                mark_func(rt, &var_ref->async_func->header);
 6002|      0|            }
 6003|   116k|        }
 6004|   116k|        break;
 6005|     10|    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
 6006|     10|        {
 6007|     10|            JSAsyncFunctionState *s = (JSAsyncFunctionState *)gp;
 6008|     10|            JSStackFrame *sf = &s->frame;
 6009|     10|            JSValue *sp;
 6010|       |
 6011|     10|            if (!s->is_completed) {
 6012|     10|                JS_MarkValue(rt, sf->cur_func, mark_func);
 6013|     10|                JS_MarkValue(rt, s->this_val, mark_func);
 6014|       |                /* sf->cur_sp = NULL if the function is running */
 6015|     10|                if (sf->cur_sp) {
 6016|       |                    /* if the function is running, cur_sp is not known so we
 6017|       |                       cannot mark the stack. Marking the variables is not needed
 6018|       |                       because a running function cannot be part of a removable
 6019|       |                       cycle */
 6020|  1.24k|                    for(sp = sf->arg_buf; sp < sf->cur_sp; sp++)
 6021|  1.23k|                        JS_MarkValue(rt, *sp, mark_func);
 6022|     10|                }
 6023|     10|            }
 6024|     10|            JS_MarkValue(rt, s->resolving_funcs[0], mark_func);
 6025|     10|            JS_MarkValue(rt, s->resolving_funcs[1], mark_func);
 6026|     10|        }
 6027|     10|        break;
 6028|  6.50M|    case JS_GC_OBJ_TYPE_SHAPE:
 6029|  6.50M|        {
 6030|  6.50M|            JSShape *sh = (JSShape *)gp;
 6031|  6.50M|            if (sh->proto != NULL) {
 6032|  6.39M|                mark_func(rt, &sh->proto->header);
 6033|  6.39M|            }
 6034|  6.50M|        }
 6035|  6.50M|        break;
 6036|  36.7k|    case JS_GC_OBJ_TYPE_JS_CONTEXT:
 6037|  36.7k|        {
 6038|  36.7k|            JSContext *ctx = (JSContext *)gp;
 6039|  36.7k|            JS_MarkContext(rt, ctx, mark_func);
 6040|  36.7k|        }
 6041|  36.7k|        break;
 6042|      0|    default:
 6043|      0|        abort();
 6044|  17.2M|    }
 6045|  17.2M|}
 6046|       |
 6047|       |static void gc_decref_child(JSRuntime *rt, JSGCObjectHeader *p)
 6048|  23.1M|{
 6049|  23.1M|    assert(p->ref_count > 0);
 6050|  23.1M|    p->ref_count--;
 6051|  23.1M|    if (p->ref_count == 0 && p->mark == 1) {
 6052|  1.38M|        list_del(&p->link);
 6053|  1.38M|        list_add_tail(&p->link, &rt->tmp_obj_list);
 6054|  1.38M|    }
 6055|  23.1M|}
 6056|       |
 6057|       |static void gc_decref(JSRuntime *rt)
 6058|  18.3k|{
 6059|  18.3k|    struct list_head *el, *el1;
 6060|  18.3k|    JSGCObjectHeader *p;
 6061|       |
 6062|  18.3k|    init_list_head(&rt->tmp_obj_list);
 6063|       |
 6064|       |    /* decrement the refcount of all the children of all the GC
 6065|       |       objects and move the GC objects with zero refcount to
 6066|       |       tmp_obj_list */
 6067|  8.62M|    list_for_each_safe(el, el1, &rt->gc_obj_list) {
 6068|  8.62M|        p = list_entry(el, JSGCObjectHeader, link);
 6069|  8.62M|        assert(p->mark == 0);
 6070|  8.62M|        mark_children(rt, p, gc_decref_child);
 6071|  8.62M|        p->mark = 1;
 6072|  8.62M|        if (p->ref_count == 0) {
 6073|  6.04M|            list_del(&p->link);
 6074|  6.04M|            list_add_tail(&p->link, &rt->tmp_obj_list);
 6075|  6.04M|        }
 6076|  8.62M|    }
 6077|  18.3k|}
 6078|       |
 6079|       |static void gc_scan_incref_child(JSRuntime *rt, JSGCObjectHeader *p)
 6080|  6.73M|{
 6081|  6.73M|    p->ref_count++;
 6082|  6.73M|    if (p->ref_count == 1) {
 6083|       |        /* ref_count was 0: remove from tmp_obj_list and add at the
 6084|       |           end of gc_obj_list */
 6085|  3.56M|        list_del(&p->link);
 6086|  3.56M|        list_add_tail(&p->link, &rt->gc_obj_list);
 6087|  3.56M|        p->mark = 0; /* reset the mark for the next GC call */
 6088|  3.56M|    }
 6089|  6.73M|}
 6090|       |
 6091|       |static void gc_scan_incref_child2(JSRuntime *rt, JSGCObjectHeader *p)
 6092|  16.3M|{
 6093|  16.3M|    p->ref_count++;
 6094|  16.3M|}
 6095|       |
 6096|       |static void gc_scan(JSRuntime *rt)
 6097|  18.3k|{
 6098|  18.3k|    struct list_head *el;
 6099|  18.3k|    JSGCObjectHeader *p;
 6100|       |
 6101|       |    /* keep the objects with a refcount > 0 and their children. */
 6102|  4.76M|    list_for_each(el, &rt->gc_obj_list) {
 6103|  4.76M|        p = list_entry(el, JSGCObjectHeader, link);
 6104|  4.76M|        assert(p->ref_count > 0);
 6105|  4.76M|        p->mark = 0; /* reset the mark for the next GC call */
 6106|  4.76M|        mark_children(rt, p, gc_scan_incref_child);
 6107|  4.76M|    }
 6108|       |
 6109|       |    /* restore the refcount of the objects to be deleted. */
 6110|  3.86M|    list_for_each(el, &rt->tmp_obj_list) {
 6111|  3.86M|        p = list_entry(el, JSGCObjectHeader, link);
 6112|  3.86M|        mark_children(rt, p, gc_scan_incref_child2);
 6113|  3.86M|    }
 6114|  18.3k|}
 6115|       |
 6116|       |static void gc_free_cycles(JSRuntime *rt)
 6117|  18.3k|{
 6118|  18.3k|    struct list_head *el, *el1;
 6119|  18.3k|    JSGCObjectHeader *p;
 6120|       |#ifdef DUMP_GC_FREE
 6121|       |    BOOL header_done = FALSE;
 6122|       |#endif
 6123|       |
 6124|  18.3k|    rt->gc_phase = JS_GC_PHASE_REMOVE_CYCLES;
 6125|       |
 6126|  3.43M|    for(;;) {
 6127|  3.43M|        el = rt->tmp_obj_list.next;
 6128|  3.43M|        if (el == &rt->tmp_obj_list)
 6129|  18.3k|            break;
 6130|  3.41M|        p = list_entry(el, JSGCObjectHeader, link);
 6131|       |        /* Only need to free the GC object associated with JS values
 6132|       |           or async functions. The rest will be automatically removed
 6133|       |           because they must be referenced by them. */
 6134|  3.41M|        switch(p->gc_obj_type) {
 6135|  2.79M|        case JS_GC_OBJ_TYPE_JS_OBJECT:
 6136|  2.81M|        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
 6137|  2.81M|        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
 6138|       |#ifdef DUMP_GC_FREE
 6139|       |            if (!header_done) {
 6140|       |                printf("Freeing cycles:\n");
 6141|       |                JS_DumpObjectHeader(rt);
 6142|       |                header_done = TRUE;
 6143|       |            }
 6144|       |            JS_DumpGCObject(rt, p);
 6145|       |#endif
 6146|  2.81M|            free_gc_object(rt, p);
 6147|  2.81M|            break;
 6148|   603k|        default:
 6149|   603k|            list_del(&p->link);
 6150|   603k|            list_add_tail(&p->link, &rt->gc_zero_ref_count_list);
 6151|   603k|            break;
 6152|  3.41M|        }
 6153|  3.41M|    }
 6154|  18.3k|    rt->gc_phase = JS_GC_PHASE_NONE;
 6155|       |
 6156|  1.76M|    list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {
 6157|  1.76M|        p = list_entry(el, JSGCObjectHeader, link);
 6158|  1.76M|        assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||
 6159|  1.76M|               p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE ||
 6160|  1.76M|               p->gc_obj_type == JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
 6161|  1.76M|        if (p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT &&
 6162|  1.76M|            ((JSObject *)p)->weakref_count != 0) {
 6163|       |            /* keep the object because there are weak references to it */
 6164|      0|            p->mark = 0;
 6165|  1.76M|        } else {
 6166|  1.76M|            js_free_rt(rt, p);
 6167|  1.76M|        }
 6168|  1.76M|    }
 6169|       |
 6170|  18.3k|    init_list_head(&rt->gc_zero_ref_count_list);
 6171|  18.3k|}
 6172|       |
 6173|       |static void JS_RunGCInternal(JSRuntime *rt, BOOL remove_weak_objects)
 6174|  18.3k|{
 6175|  18.3k|    if (remove_weak_objects) {
 6176|       |        /* free the weakly referenced object or symbol structures, delete
 6177|       |           the associated Map/Set entries and queue the finalization
 6178|       |           registry callbacks. */
 6179|    976|        gc_remove_weak_objects(rt);
 6180|    976|    }
 6181|       |    
 6182|       |    /* decrement the reference of the children of each object. mark =
 6183|       |       1 after this pass. */
 6184|  18.3k|    gc_decref(rt);
 6185|       |
 6186|       |    /* keep the GC objects with a non zero refcount and their childs */
 6187|  18.3k|    gc_scan(rt);
 6188|       |
 6189|       |    /* free the GC objects in a cycle */
 6190|  18.3k|    gc_free_cycles(rt);
 6191|  18.3k|}
 6192|       |
 6193|       |void JS_RunGC(JSRuntime *rt)
 6194|    976|{
 6195|    976|    JS_RunGCInternal(rt, TRUE);
 6196|    976|}
 6197|       |
 6198|       |/* Return false if not an object or if the object has already been
 6199|       |   freed (zombie objects are visible in finalizers when freeing
 6200|       |   cycles). */
 6201|       |BOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj)
 6202|      0|{
 6203|      0|    JSObject *p;
 6204|      0|    if (!JS_IsObject(obj))
 6205|      0|        return FALSE;
 6206|      0|    p = JS_VALUE_GET_OBJ(obj);
 6207|      0|    return !p->free_mark;
 6208|      0|}
 6209|       |
 6210|       |/* Compute memory used by various object types */
 6211|       |/* XXX: poor man's approach to handling multiply referenced objects */
 6212|       |typedef struct JSMemoryUsage_helper {
 6213|       |    double memory_used_count;
 6214|       |    double str_count;
 6215|       |    double str_size;
 6216|       |    int64_t js_func_count;
 6217|       |    double js_func_size;
 6218|       |    int64_t js_func_code_size;
 6219|       |    int64_t js_func_pc2line_count;
 6220|       |    int64_t js_func_pc2line_size;
 6221|       |} JSMemoryUsage_helper;
 6222|       |
 6223|       |static void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp);
 6224|       |
 6225|       |static void compute_jsstring_size(JSString *str, JSMemoryUsage_helper *hp)
 6226|      0|{
 6227|      0|    if (!str->atom_type) {  /* atoms are handled separately */
 6228|      0|        double s_ref_count = str->header.ref_count;
 6229|      0|        hp->str_count += 1 / s_ref_count;
 6230|      0|        hp->str_size += ((sizeof(*str) + (str->len << str->is_wide_char) +
 6231|      0|                          1 - str->is_wide_char) / s_ref_count);
 6232|      0|    }
 6233|      0|}
 6234|       |
 6235|       |static void compute_bytecode_size(JSFunctionBytecode *b, JSMemoryUsage_helper *hp)
 6236|      0|{
 6237|      0|    int memory_used_count, js_func_size, i;
 6238|       |
 6239|      0|    memory_used_count = 0;
 6240|      0|    js_func_size = offsetof(JSFunctionBytecode, debug);
 6241|      0|    if (b->vardefs) {
 6242|      0|        js_func_size += (b->arg_count + b->var_count) * sizeof(*b->vardefs);
 6243|      0|    }
 6244|      0|    if (b->cpool) {
 6245|      0|        js_func_size += b->cpool_count * sizeof(*b->cpool);
 6246|      0|        for (i = 0; i < b->cpool_count; i++) {
 6247|      0|            JSValueConst val = b->cpool[i];
 6248|      0|            compute_value_size(val, hp);
 6249|      0|        }
 6250|      0|    }
 6251|      0|    if (b->closure_var) {
 6252|      0|        js_func_size += b->closure_var_count * sizeof(*b->closure_var);
 6253|      0|    }
 6254|      0|    if (!b->read_only_bytecode && b->byte_code_buf) {
 6255|      0|        hp->js_func_code_size += b->byte_code_len;
 6256|      0|    }
 6257|      0|    if (b->has_debug) {
 6258|      0|        js_func_size += sizeof(*b) - offsetof(JSFunctionBytecode, debug);
 6259|      0|        if (b->debug.source) {
 6260|      0|            memory_used_count++;
 6261|      0|            js_func_size += b->debug.source_len + 1;
 6262|      0|        }
 6263|      0|        if (b->debug.pc2line_len) {
 6264|      0|            memory_used_count++;
 6265|      0|            hp->js_func_pc2line_count += 1;
 6266|      0|            hp->js_func_pc2line_size += b->debug.pc2line_len;
 6267|      0|        }
 6268|      0|    }
 6269|      0|    hp->js_func_size += js_func_size;
 6270|      0|    hp->js_func_count += 1;
 6271|      0|    hp->memory_used_count += memory_used_count;
 6272|      0|}
 6273|       |
 6274|       |static void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp)
 6275|      0|{
 6276|      0|    switch(JS_VALUE_GET_TAG(val)) {
 6277|      0|    case JS_TAG_STRING:
 6278|      0|        compute_jsstring_size(JS_VALUE_GET_STRING(val), hp);
 6279|      0|        break;
 6280|      0|    case JS_TAG_BIG_INT:
 6281|       |        /* should track JSBigInt usage */
 6282|      0|        break;
 6283|      0|    }
 6284|      0|}
 6285|       |
 6286|       |void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)
 6287|      0|{
 6288|      0|    struct list_head *el, *el1;
 6289|      0|    int i;
 6290|      0|    JSMemoryUsage_helper mem = { 0 }, *hp = &mem;
 6291|       |
 6292|      0|    memset(s, 0, sizeof(*s));
 6293|      0|    s->malloc_count = rt->malloc_state.malloc_count;
 6294|      0|    s->malloc_size = rt->malloc_state.malloc_size;
 6295|      0|    s->malloc_limit = rt->malloc_state.malloc_limit;
 6296|       |
 6297|      0|    s->memory_used_count = 2; /* rt + rt->class_array */
 6298|      0|    s->memory_used_size = sizeof(JSRuntime) + sizeof(JSValue) * rt->class_count;
 6299|       |
 6300|      0|    list_for_each(el, &rt->context_list) {
 6301|      0|        JSContext *ctx = list_entry(el, JSContext, link);
 6302|      0|        JSShape *sh = ctx->array_shape;
 6303|      0|        s->memory_used_count += 2; /* ctx + ctx->class_proto */
 6304|      0|        s->memory_used_size += sizeof(JSContext) +
 6305|      0|            sizeof(JSValue) * rt->class_count;
 6306|      0|        s->binary_object_count += ctx->binary_object_count;
 6307|      0|        s->binary_object_size += ctx->binary_object_size;
 6308|       |
 6309|       |        /* the hashed shapes are counted separately */
 6310|      0|        if (sh && !sh->is_hashed) {
 6311|      0|            int hash_size = sh->prop_hash_mask + 1;
 6312|      0|            s->shape_count++;
 6313|      0|            s->shape_size += get_shape_size(hash_size, sh->prop_size);
 6314|      0|        }
 6315|      0|        list_for_each(el1, &ctx->loaded_modules) {
 6316|      0|            JSModuleDef *m = list_entry(el1, JSModuleDef, link);
 6317|      0|            s->memory_used_count += 1;
 6318|      0|            s->memory_used_size += sizeof(*m);
 6319|      0|            if (m->req_module_entries) {
 6320|      0|                s->memory_used_count += 1;
 6321|      0|                s->memory_used_size += m->req_module_entries_count * sizeof(*m->req_module_entries);
 6322|      0|            }
 6323|      0|            if (m->export_entries) {
 6324|      0|                s->memory_used_count += 1;
 6325|      0|                s->memory_used_size += m->export_entries_count * sizeof(*m->export_entries);
 6326|      0|                for (i = 0; i < m->export_entries_count; i++) {
 6327|      0|                    JSExportEntry *me = &m->export_entries[i];
 6328|      0|                    if (me->export_type == JS_EXPORT_TYPE_LOCAL && me->u.local.var_ref) {
 6329|       |                        /* potential multiple count */
 6330|      0|                        s->memory_used_count += 1;
 6331|      0|                        compute_value_size(me->u.local.var_ref->value, hp);
 6332|      0|                    }
 6333|      0|                }
 6334|      0|            }
 6335|      0|            if (m->star_export_entries) {
 6336|      0|                s->memory_used_count += 1;
 6337|      0|                s->memory_used_size += m->star_export_entries_count * sizeof(*m->star_export_entries);
 6338|      0|            }
 6339|      0|            if (m->import_entries) {
 6340|      0|                s->memory_used_count += 1;
 6341|      0|                s->memory_used_size += m->import_entries_count * sizeof(*m->import_entries);
 6342|      0|            }
 6343|      0|            compute_value_size(m->module_ns, hp);
 6344|      0|            compute_value_size(m->func_obj, hp);
 6345|      0|        }
 6346|      0|    }
 6347|       |
 6348|      0|    list_for_each(el, &rt->gc_obj_list) {
 6349|      0|        JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);
 6350|      0|        JSObject *p;
 6351|      0|        JSShape *sh;
 6352|      0|        JSShapeProperty *prs;
 6353|       |
 6354|       |        /* XXX: could count the other GC object types too */
 6355|      0|        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE) {
 6356|      0|            compute_bytecode_size((JSFunctionBytecode *)gp, hp);
 6357|      0|            continue;
 6358|      0|        } else if (gp->gc_obj_type != JS_GC_OBJ_TYPE_JS_OBJECT) {
 6359|      0|            continue;
 6360|      0|        }
 6361|      0|        p = (JSObject *)gp;
 6362|      0|        sh = p->shape;
 6363|      0|        s->obj_count++;
 6364|      0|        if (p->prop) {
 6365|      0|            s->memory_used_count++;
 6366|      0|            s->prop_size += sh->prop_size * sizeof(*p->prop);
 6367|      0|            s->prop_count += sh->prop_count;
 6368|      0|            prs = get_shape_prop(sh);
 6369|      0|            for(i = 0; i < sh->prop_count; i++) {
 6370|      0|                JSProperty *pr = &p->prop[i];
 6371|      0|                if (prs->atom != JS_ATOM_NULL && !(prs->flags & JS_PROP_TMASK)) {
 6372|      0|                    compute_value_size(pr->u.value, hp);
 6373|      0|                }
 6374|      0|                prs++;
 6375|      0|            }
 6376|      0|        }
 6377|       |        /* the hashed shapes are counted separately */
 6378|      0|        if (!sh->is_hashed) {
 6379|      0|            int hash_size = sh->prop_hash_mask + 1;
 6380|      0|            s->shape_count++;
 6381|      0|            s->shape_size += get_shape_size(hash_size, sh->prop_size);
 6382|      0|        }
 6383|       |
 6384|      0|        switch(p->class_id) {
 6385|      0|        case JS_CLASS_ARRAY:             /* u.array | length */
 6386|      0|        case JS_CLASS_ARGUMENTS:         /* u.array | length */
 6387|      0|            s->array_count++;
 6388|      0|            if (p->fast_array) {
 6389|      0|                s->fast_array_count++;
 6390|      0|                if (p->u.array.u.values) {
 6391|      0|                    s->memory_used_count++;
 6392|      0|                    s->memory_used_size += p->u.array.count *
 6393|      0|                        sizeof(*p->u.array.u.values);
 6394|      0|                    s->fast_array_elements += p->u.array.count;
 6395|      0|                    for (i = 0; i < p->u.array.count; i++) {
 6396|      0|                        compute_value_size(p->u.array.u.values[i], hp);
 6397|      0|                    }
 6398|      0|                }
 6399|      0|            }
 6400|      0|            break;
 6401|      0|        case JS_CLASS_NUMBER:            /* u.object_data */
 6402|      0|        case JS_CLASS_STRING:            /* u.object_data */
 6403|      0|        case JS_CLASS_BOOLEAN:           /* u.object_data */
 6404|      0|        case JS_CLASS_SYMBOL:            /* u.object_data */
 6405|      0|        case JS_CLASS_DATE:              /* u.object_data */
 6406|      0|        case JS_CLASS_BIG_INT:           /* u.object_data */
 6407|      0|            compute_value_size(p->u.object_data, hp);
 6408|      0|            break;
 6409|      0|        case JS_CLASS_C_FUNCTION:        /* u.cfunc */
 6410|      0|            s->c_func_count++;
 6411|      0|            break;
 6412|      0|        case JS_CLASS_BYTECODE_FUNCTION: /* u.func */
 6413|      0|            {
 6414|      0|                JSFunctionBytecode *b = p->u.func.function_bytecode;
 6415|      0|                JSVarRef **var_refs = p->u.func.var_refs;
 6416|       |                /* home_object: object will be accounted for in list scan */
 6417|      0|                if (var_refs) {
 6418|      0|                    s->memory_used_count++;
 6419|      0|                    s->js_func_size += b->closure_var_count * sizeof(*var_refs);
 6420|      0|                    for (i = 0; i < b->closure_var_count; i++) {
 6421|      0|                        if (var_refs[i]) {
 6422|      0|                            double ref_count = var_refs[i]->header.ref_count;
 6423|      0|                            s->memory_used_count += 1 / ref_count;
 6424|      0|                            s->js_func_size += sizeof(*var_refs[i]) / ref_count;
 6425|       |                            /* handle non object closed values */
 6426|      0|                            if (var_refs[i]->pvalue == &var_refs[i]->value) {
 6427|       |                                /* potential multiple count */
 6428|      0|                                compute_value_size(var_refs[i]->value, hp);
 6429|      0|                            }
 6430|      0|                        }
 6431|      0|                    }
 6432|      0|                }
 6433|      0|            }
 6434|      0|            break;
 6435|      0|        case JS_CLASS_BOUND_FUNCTION:    /* u.bound_function */
 6436|      0|            {
 6437|      0|                JSBoundFunction *bf = p->u.bound_function;
 6438|       |                /* func_obj and this_val are objects */
 6439|      0|                for (i = 0; i < bf->argc; i++) {
 6440|      0|                    compute_value_size(bf->argv[i], hp);
 6441|      0|                }
 6442|      0|                s->memory_used_count += 1;
 6443|      0|                s->memory_used_size += sizeof(*bf) + bf->argc * sizeof(*bf->argv);
 6444|      0|            }
 6445|      0|            break;
 6446|      0|        case JS_CLASS_C_FUNCTION_DATA:   /* u.c_function_data_record */
 6447|      0|            {
 6448|      0|                JSCFunctionDataRecord *fd = p->u.c_function_data_record;
 6449|      0|                if (fd) {
 6450|      0|                    for (i = 0; i < fd->data_len; i++) {
 6451|      0|                        compute_value_size(fd->data[i], hp);
 6452|      0|                    }
 6453|      0|                    s->memory_used_count += 1;
 6454|      0|                    s->memory_used_size += sizeof(*fd) + fd->data_len * sizeof(*fd->data);
 6455|      0|                }
 6456|      0|            }
 6457|      0|            break;
 6458|      0|        case JS_CLASS_REGEXP:            /* u.regexp */
 6459|      0|            compute_jsstring_size(p->u.regexp.pattern, hp);
 6460|      0|            compute_jsstring_size(p->u.regexp.bytecode, hp);
 6461|      0|            break;
 6462|       |
 6463|      0|        case JS_CLASS_FOR_IN_ITERATOR:   /* u.for_in_iterator */
 6464|      0|            {
 6465|      0|                JSForInIterator *it = p->u.for_in_iterator;
 6466|      0|                if (it) {
 6467|      0|                    compute_value_size(it->obj, hp);
 6468|      0|                    s->memory_used_count += 1;
 6469|      0|                    s->memory_used_size += sizeof(*it);
 6470|      0|                }
 6471|      0|            }
 6472|      0|            break;
 6473|      0|        case JS_CLASS_ARRAY_BUFFER:      /* u.array_buffer */
 6474|      0|        case JS_CLASS_SHARED_ARRAY_BUFFER: /* u.array_buffer */
 6475|      0|            {
 6476|      0|                JSArrayBuffer *abuf = p->u.array_buffer;
 6477|      0|                if (abuf) {
 6478|      0|                    s->memory_used_count += 1;
 6479|      0|                    s->memory_used_size += sizeof(*abuf);
 6480|      0|                    if (abuf->data) {
 6481|      0|                        s->memory_used_count += 1;
 6482|      0|                        s->memory_used_size += abuf->byte_length;
 6483|      0|                    }
 6484|      0|                }
 6485|      0|            }
 6486|      0|            break;
 6487|      0|        case JS_CLASS_GENERATOR:         /* u.generator_data */
 6488|      0|        case JS_CLASS_UINT8C_ARRAY:      /* u.typed_array / u.array */
 6489|      0|        case JS_CLASS_INT8_ARRAY:        /* u.typed_array / u.array */
 6490|      0|        case JS_CLASS_UINT8_ARRAY:       /* u.typed_array / u.array */
 6491|      0|        case JS_CLASS_INT16_ARRAY:       /* u.typed_array / u.array */
 6492|      0|        case JS_CLASS_UINT16_ARRAY:      /* u.typed_array / u.array */
 6493|      0|        case JS_CLASS_INT32_ARRAY:       /* u.typed_array / u.array */
 6494|      0|        case JS_CLASS_UINT32_ARRAY:      /* u.typed_array / u.array */
 6495|      0|        case JS_CLASS_BIG_INT64_ARRAY:   /* u.typed_array / u.array */
 6496|      0|        case JS_CLASS_BIG_UINT64_ARRAY:  /* u.typed_array / u.array */
 6497|      0|        case JS_CLASS_FLOAT32_ARRAY:     /* u.typed_array / u.array */
 6498|      0|        case JS_CLASS_FLOAT64_ARRAY:     /* u.typed_array / u.array */
 6499|      0|        case JS_CLASS_DATAVIEW:          /* u.typed_array */
 6500|      0|        case JS_CLASS_MAP:               /* u.map_state */
 6501|      0|        case JS_CLASS_SET:               /* u.map_state */
 6502|      0|        case JS_CLASS_WEAKMAP:           /* u.map_state */
 6503|      0|        case JS_CLASS_WEAKSET:           /* u.map_state */
 6504|      0|        case JS_CLASS_MAP_ITERATOR:      /* u.map_iterator_data */
 6505|      0|        case JS_CLASS_SET_ITERATOR:      /* u.map_iterator_data */
 6506|      0|        case JS_CLASS_ARRAY_ITERATOR:    /* u.array_iterator_data */
 6507|      0|        case JS_CLASS_STRING_ITERATOR:   /* u.array_iterator_data */
 6508|      0|        case JS_CLASS_PROXY:             /* u.proxy_data */
 6509|      0|        case JS_CLASS_PROMISE:           /* u.promise_data */
 6510|      0|        case JS_CLASS_PROMISE_RESOLVE_FUNCTION:  /* u.promise_function_data */
 6511|      0|        case JS_CLASS_PROMISE_REJECT_FUNCTION:   /* u.promise_function_data */
 6512|      0|        case JS_CLASS_ASYNC_FUNCTION_RESOLVE:    /* u.async_function_data */
 6513|      0|        case JS_CLASS_ASYNC_FUNCTION_REJECT:     /* u.async_function_data */
 6514|      0|        case JS_CLASS_ASYNC_FROM_SYNC_ITERATOR:  /* u.async_from_sync_iterator_data */
 6515|      0|        case JS_CLASS_ASYNC_GENERATOR:   /* u.async_generator_data */
 6516|       |            /* TODO */
 6517|      0|        default:
 6518|       |            /* XXX: class definition should have an opaque block size */
 6519|      0|            if (p->u.opaque) {
 6520|      0|                s->memory_used_count += 1;
 6521|      0|            }
 6522|      0|            break;
 6523|      0|        }
 6524|      0|    }
 6525|      0|    s->obj_size += s->obj_count * sizeof(JSObject);
 6526|       |
 6527|       |    /* hashed shapes */
 6528|      0|    s->memory_used_count++; /* rt->shape_hash */
 6529|      0|    s->memory_used_size += sizeof(rt->shape_hash[0]) * rt->shape_hash_size;
 6530|      0|    for(i = 0; i < rt->shape_hash_size; i++) {
 6531|      0|        JSShape *sh;
 6532|      0|        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {
 6533|      0|            int hash_size = sh->prop_hash_mask + 1;
 6534|      0|            s->shape_count++;
 6535|      0|            s->shape_size += get_shape_size(hash_size, sh->prop_size);
 6536|      0|        }
 6537|      0|    }
 6538|       |
 6539|       |    /* atoms */
 6540|      0|    s->memory_used_count += 2; /* rt->atom_array, rt->atom_hash */
 6541|      0|    s->atom_count = rt->atom_count;
 6542|      0|    s->atom_size = sizeof(rt->atom_array[0]) * rt->atom_size +
 6543|      0|        sizeof(rt->atom_hash[0]) * rt->atom_hash_size;
 6544|      0|    for(i = 0; i < rt->atom_size; i++) {
 6545|      0|        JSAtomStruct *p = rt->atom_array[i];
 6546|      0|        if (!atom_is_free(p)) {
 6547|      0|            s->atom_size += (sizeof(*p) + (p->len << p->is_wide_char) +
 6548|      0|                             1 - p->is_wide_char);
 6549|      0|        }
 6550|      0|    }
 6551|      0|    s->str_count = round(mem.str_count);
 6552|      0|    s->str_size = round(mem.str_size);
 6553|      0|    s->js_func_count = mem.js_func_count;
 6554|      0|    s->js_func_size = round(mem.js_func_size);
 6555|      0|    s->js_func_code_size = mem.js_func_code_size;
 6556|      0|    s->js_func_pc2line_count = mem.js_func_pc2line_count;
 6557|      0|    s->js_func_pc2line_size = mem.js_func_pc2line_size;
 6558|      0|    s->memory_used_count += round(mem.memory_used_count) +
 6559|      0|        s->atom_count + s->str_count +
 6560|      0|        s->obj_count + s->shape_count +
 6561|      0|        s->js_func_count + s->js_func_pc2line_count;
 6562|      0|    s->memory_used_size += s->atom_size + s->str_size +
 6563|      0|        s->obj_size + s->prop_size + s->shape_size +
 6564|      0|        s->js_func_size + s->js_func_code_size + s->js_func_pc2line_size;
 6565|      0|}
 6566|       |
 6567|       |void JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt)
 6568|      0|{
 6569|      0|    fprintf(fp, "QuickJS memory usage -- " CONFIG_VERSION " version, %d-bit, malloc limit: %"PRId64"\n\n",
 6570|      0|            (int)sizeof(void *) * 8, s->malloc_limit);
 6571|      0|#if 1
 6572|      0|    if (rt) {
 6573|      0|        static const struct {
 6574|      0|            const char *name;
 6575|      0|            size_t size;
 6576|      0|        } object_types[] = {
 6577|      0|            { "JSRuntime", sizeof(JSRuntime) },
 6578|      0|            { "JSContext", sizeof(JSContext) },
 6579|      0|            { "JSObject", sizeof(JSObject) },
 6580|      0|            { "JSString", sizeof(JSString) },
 6581|      0|            { "JSFunctionBytecode", sizeof(JSFunctionBytecode) },
 6582|      0|        };
 6583|      0|        int i, usage_size_ok = 0;
 6584|      0|        for(i = 0; i < countof(object_types); i++) {
 6585|      0|            unsigned int size = object_types[i].size;
 6586|      0|            void *p = js_malloc_rt(rt, size);
 6587|      0|            if (p) {
 6588|      0|                unsigned int size1 = js_malloc_usable_size_rt(rt, p);
 6589|      0|                if (size1 >= size) {
 6590|      0|                    usage_size_ok = 1;
 6591|      0|                    fprintf(fp, "  %3u + %-2u  %s\n",
 6592|      0|                            size, size1 - size, object_types[i].name);
 6593|      0|                }
 6594|      0|                js_free_rt(rt, p);
 6595|      0|            }
 6596|      0|        }
 6597|      0|        if (!usage_size_ok) {
 6598|      0|            fprintf(fp, "  malloc_usable_size unavailable\n");
 6599|      0|        }
 6600|      0|        {
 6601|      0|            int obj_classes[JS_CLASS_INIT_COUNT + 1] = { 0 };
 6602|      0|            int class_id;
 6603|      0|            struct list_head *el;
 6604|      0|            list_for_each(el, &rt->gc_obj_list) {
 6605|      0|                JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);
 6606|      0|                JSObject *p;
 6607|      0|                if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {
 6608|      0|                    p = (JSObject *)gp;
 6609|      0|                    obj_classes[min_uint32(p->class_id, JS_CLASS_INIT_COUNT)]++;
 6610|      0|                }
 6611|      0|            }
 6612|      0|            fprintf(fp, "\n" "JSObject classes\n");
 6613|      0|            if (obj_classes[0])
 6614|      0|                fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[0], 0, "none");
 6615|      0|            for (class_id = 1; class_id < JS_CLASS_INIT_COUNT; class_id++) {
 6616|      0|                if (obj_classes[class_id] && class_id < rt->class_count) {
 6617|      0|                    char buf[ATOM_GET_STR_BUF_SIZE];
 6618|      0|                    fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[class_id], class_id,
 6619|      0|                            JS_AtomGetStrRT(rt, buf, sizeof(buf), rt->class_array[class_id].class_name));
 6620|      0|                }
 6621|      0|            }
 6622|      0|            if (obj_classes[JS_CLASS_INIT_COUNT])
 6623|      0|                fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[JS_CLASS_INIT_COUNT], 0, "other");
 6624|      0|        }
 6625|      0|        fprintf(fp, "\n");
 6626|      0|    }
 6627|      0|#endif
 6628|      0|    fprintf(fp, "%-20s %8s %8s\n", "NAME", "COUNT", "SIZE");
 6629|       |
 6630|      0|    if (s->malloc_count) {
 6631|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per block)\n",
 6632|      0|                "memory allocated", s->malloc_count, s->malloc_size,
 6633|      0|                (double)s->malloc_size / s->malloc_count);
 6634|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%d overhead, %0.1f average slack)\n",
 6635|      0|                "memory used", s->memory_used_count, s->memory_used_size,
 6636|      0|                MALLOC_OVERHEAD, ((double)(s->malloc_size - s->memory_used_size) /
 6637|      0|                                  s->memory_used_count));
 6638|      0|    }
 6639|      0|    if (s->atom_count) {
 6640|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per atom)\n",
 6641|      0|                "atoms", s->atom_count, s->atom_size,
 6642|      0|                (double)s->atom_size / s->atom_count);
 6643|      0|    }
 6644|      0|    if (s->str_count) {
 6645|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per string)\n",
 6646|      0|                "strings", s->str_count, s->str_size,
 6647|      0|                (double)s->str_size / s->str_count);
 6648|      0|    }
 6649|      0|    if (s->obj_count) {
 6650|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per object)\n",
 6651|      0|                "objects", s->obj_count, s->obj_size,
 6652|      0|                (double)s->obj_size / s->obj_count);
 6653|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per object)\n",
 6654|      0|                "  properties", s->prop_count, s->prop_size,
 6655|      0|                (double)s->prop_count / s->obj_count);
 6656|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per shape)\n",
 6657|      0|                "  shapes", s->shape_count, s->shape_size,
 6658|      0|                (double)s->shape_size / s->shape_count);
 6659|      0|    }
 6660|      0|    if (s->js_func_count) {
 6661|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"\n",
 6662|      0|                "bytecode functions", s->js_func_count, s->js_func_size);
 6663|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per function)\n",
 6664|      0|                "  bytecode", s->js_func_count, s->js_func_code_size,
 6665|      0|                (double)s->js_func_code_size / s->js_func_count);
 6666|      0|        if (s->js_func_pc2line_count) {
 6667|      0|            fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per function)\n",
 6668|      0|                    "  pc2line", s->js_func_pc2line_count,
 6669|      0|                    s->js_func_pc2line_size,
 6670|      0|                    (double)s->js_func_pc2line_size / s->js_func_pc2line_count);
 6671|      0|        }
 6672|      0|    }
 6673|      0|    if (s->c_func_count) {
 6674|      0|        fprintf(fp, "%-20s %8"PRId64"\n", "C functions", s->c_func_count);
 6675|      0|    }
 6676|      0|    if (s->array_count) {
 6677|      0|        fprintf(fp, "%-20s %8"PRId64"\n", "arrays", s->array_count);
 6678|      0|        if (s->fast_array_count) {
 6679|      0|            fprintf(fp, "%-20s %8"PRId64"\n", "  fast arrays", s->fast_array_count);
 6680|      0|            fprintf(fp, "%-20s %8"PRId64" %8"PRId64"  (%0.1f per fast array)\n",
 6681|      0|                    "  elements", s->fast_array_elements,
 6682|      0|                    s->fast_array_elements * (int)sizeof(JSValue),
 6683|      0|                    (double)s->fast_array_elements / s->fast_array_count);
 6684|      0|        }
 6685|      0|    }
 6686|      0|    if (s->binary_object_count) {
 6687|      0|        fprintf(fp, "%-20s %8"PRId64" %8"PRId64"\n",
 6688|      0|                "binary objects", s->binary_object_count, s->binary_object_size);
 6689|      0|    }
 6690|      0|}
 6691|       |
 6692|       |JSValue JS_GetGlobalObject(JSContext *ctx)
 6693|  17.7k|{
 6694|  17.7k|    return JS_DupValue(ctx, ctx->global_obj);
 6695|  17.7k|}
 6696|       |
 6697|       |/* WARNING: obj is freed */
 6698|       |JSValue JS_Throw(JSContext *ctx, JSValue obj)
 6699|  89.6k|{
 6700|  89.6k|    JSRuntime *rt = ctx->rt;
 6701|  89.6k|    JS_FreeValue(ctx, rt->current_exception);
 6702|  89.6k|    rt->current_exception = obj;
 6703|  89.6k|    return JS_EXCEPTION;
 6704|  89.6k|}
 6705|       |
 6706|       |/* return the pending exception (cannot be called twice). */
 6707|       |JSValue JS_GetException(JSContext *ctx)
 6708|  14.3k|{
 6709|  14.3k|    JSValue val;
 6710|  14.3k|    JSRuntime *rt = ctx->rt;
 6711|  14.3k|    val = rt->current_exception;
 6712|  14.3k|    rt->current_exception = JS_UNINITIALIZED;
 6713|  14.3k|    return val;
 6714|  14.3k|}
 6715|       |
 6716|       |JS_BOOL JS_HasException(JSContext *ctx)
 6717|      0|{
 6718|      0|    return !JS_IsUninitialized(ctx->rt->current_exception);
 6719|      0|}
 6720|       |
 6721|       |static void dbuf_put_leb128(DynBuf *s, uint32_t v)
 6722|   917k|{
 6723|   917k|    uint32_t a;
 6724|  1.09M|    for(;;) {
 6725|  1.09M|        a = v & 0x7f;
 6726|  1.09M|        v >>= 7;
 6727|  1.09M|        if (v != 0) {
 6728|   174k|            dbuf_putc(s, a | 0x80);
 6729|   917k|        } else {
 6730|   917k|            dbuf_putc(s, a);
 6731|   917k|            break;
 6732|   917k|        }
 6733|  1.09M|    }
 6734|   917k|}
 6735|       |
 6736|       |static void dbuf_put_sleb128(DynBuf *s, int32_t v1)
 6737|   665k|{
 6738|   665k|    uint32_t v = v1;
 6739|   665k|    dbuf_put_leb128(s, (2 * v) ^ -(v >> 31));
 6740|   665k|}
 6741|       |
 6742|       |static int get_leb128(uint32_t *pval, const uint8_t *buf,
 6743|       |                      const uint8_t *buf_end)
 6744|  1.10M|{
 6745|  1.10M|    const uint8_t *ptr = buf;
 6746|  1.10M|    uint32_t v, a, i;
 6747|  1.10M|    v = 0;
 6748|  1.26M|    for(i = 0; i < 5; i++) {
 6749|  1.26M|        if (unlikely(ptr >= buf_end))
 6750|      0|            break;
 6751|  1.26M|        a = *ptr++;
 6752|  1.26M|        v |= (a & 0x7f) << (i * 7);
 6753|  1.26M|        if (!(a & 0x80)) {
 6754|  1.10M|            *pval = v;
 6755|  1.10M|            return ptr - buf;
 6756|  1.10M|        }
 6757|  1.26M|    }
 6758|      0|    *pval = 0;
 6759|      0|    return -1;
 6760|  1.10M|}
 6761|       |
 6762|       |static int get_sleb128(int32_t *pval, const uint8_t *buf,
 6763|       |                       const uint8_t *buf_end)
 6764|   797k|{
 6765|   797k|    int ret;
 6766|   797k|    uint32_t val;
 6767|   797k|    ret = get_leb128(&val, buf, buf_end);
 6768|   797k|    if (ret < 0) {
 6769|      0|        *pval = 0;
 6770|      0|        return -1;
 6771|      0|    }
 6772|   797k|    *pval = (val >> 1) ^ -(val & 1);
 6773|   797k|    return ret;
 6774|   797k|}
 6775|       |
 6776|       |/* use pc_value = -1 to get the position of the function definition */
 6777|       |static int find_line_num(JSContext *ctx, JSFunctionBytecode *b,
 6778|       |                         uint32_t pc_value, int *pcol_num)
 6779|   144k|{
 6780|   144k|    const uint8_t *p_end, *p;
 6781|   144k|    int new_line_num, line_num, pc, v, ret, new_col_num, col_num;
 6782|   144k|    uint32_t val;
 6783|   144k|    unsigned int op;
 6784|       |
 6785|   144k|    if (!b->has_debug || !b->debug.pc2line_buf)
 6786|      0|        goto fail; /* function was stripped */
 6787|       |
 6788|   144k|    p = b->debug.pc2line_buf;
 6789|   144k|    p_end = p + b->debug.pc2line_len;
 6790|       |
 6791|       |    /* get the function line and column numbers */
 6792|   144k|    ret = get_leb128(&val, p, p_end);
 6793|   144k|    if (ret < 0)
 6794|      0|        goto fail;
 6795|   144k|    p += ret;
 6796|   144k|    line_num = val + 1;
 6797|       |
 6798|   144k|    ret = get_leb128(&val, p, p_end);
 6799|   144k|    if (ret < 0)
 6800|      0|        goto fail;
 6801|   144k|    p += ret;
 6802|   144k|    col_num = val + 1;
 6803|       |
 6804|   144k|    if (pc_value != -1) {
 6805|   144k|        pc = 0;
 6806|   790k|        while (p < p_end) {
 6807|   782k|            op = *p++;
 6808|   782k|            if (op == 0) {
 6809|  15.5k|                ret = get_leb128(&val, p, p_end);
 6810|  15.5k|                if (ret < 0)
 6811|      0|                    goto fail;
 6812|  15.5k|                pc += val;
 6813|  15.5k|                p += ret;
 6814|  15.5k|                ret = get_sleb128(&v, p, p_end);
 6815|  15.5k|                if (ret < 0)
 6816|      0|                    goto fail;
 6817|  15.5k|                p += ret;
 6818|  15.5k|                new_line_num = line_num + v;
 6819|   766k|            } else {
 6820|   766k|                op -= PC2LINE_OP_FIRST;
 6821|   766k|                pc += (op / PC2LINE_RANGE);
 6822|   766k|                new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;
 6823|   766k|            }
 6824|   782k|            ret = get_sleb128(&v, p, p_end);
 6825|   782k|            if (ret < 0)
 6826|      0|                goto fail;
 6827|   782k|            p += ret;
 6828|   782k|            new_col_num = col_num + v;
 6829|       |            
 6830|   782k|            if (pc_value < pc)
 6831|   136k|                goto done;
 6832|   646k|            line_num = new_line_num;
 6833|   646k|            col_num = new_col_num;
 6834|   646k|        }
 6835|   144k|    }
 6836|   144k| done:
 6837|   144k|    *pcol_num = col_num;
 6838|   144k|    return line_num;
 6839|      0| fail:
 6840|      0|    *pcol_num = 0;
 6841|      0|    return 0;
 6842|   144k|}
 6843|       |
 6844|       |/* in order to avoid executing arbitrary code during the stack trace
 6845|       |   generation, we only look at simple 'name' properties containing a
 6846|       |   string. */
 6847|       |static const char *get_func_name(JSContext *ctx, JSValueConst func)
 6848|   144k|{
 6849|   144k|    JSProperty *pr;
 6850|   144k|    JSShapeProperty *prs;
 6851|   144k|    JSValueConst val;
 6852|       |
 6853|   144k|    if (JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)
 6854|      0|        return NULL;
 6855|   144k|    prs = find_own_property(&pr, JS_VALUE_GET_OBJ(func), JS_ATOM_name);
 6856|   144k|    if (!prs)
 6857|    351|        return NULL;
 6858|   144k|    if ((prs->flags & JS_PROP_TMASK) != JS_PROP_NORMAL)
 6859|      0|        return NULL;
 6860|   144k|    val = pr->u.value;
 6861|   144k|    if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)
 6862|      0|        return NULL;
 6863|   144k|    return JS_ToCString(ctx, val);
 6864|   144k|}
 6865|       |
 6866|   144k|#define JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL (1 << 0)
 6867|       |
 6868|       |/* if filename != NULL, an additional level is added with the filename
 6869|       |   and line number information (used for parse error). */
 6870|       |static void build_backtrace(JSContext *ctx, JSValueConst error_obj,
 6871|       |                            const char *filename, int line_num, int col_num,
 6872|       |                            int backtrace_flags)
 6873|  90.3k|{
 6874|  90.3k|    JSStackFrame *sf;
 6875|  90.3k|    JSValue str;
 6876|  90.3k|    DynBuf dbuf;
 6877|  90.3k|    const char *func_name_str;
 6878|  90.3k|    const char *str1;
 6879|  90.3k|    JSObject *p;
 6880|       |
 6881|  90.3k|    js_dbuf_init(ctx, &dbuf);
 6882|  90.3k|    if (filename) {
 6883|  83.2k|        dbuf_printf(&dbuf, "    at %s", filename);
 6884|  83.2k|        if (line_num != -1)
 6885|  83.2k|            dbuf_printf(&dbuf, ":%d:%d", line_num, col_num);
 6886|  83.2k|        dbuf_putc(&dbuf, '\n');
 6887|  83.2k|        str = JS_NewString(ctx, filename);
 6888|       |        /* Note: SpiderMonkey does that, could update once there is a standard */
 6889|  83.2k|        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_fileName, str,
 6890|  83.2k|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 6891|  83.2k|        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_lineNumber, JS_NewInt32(ctx, line_num),
 6892|  83.2k|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 6893|  83.2k|        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_columnNumber, JS_NewInt32(ctx, col_num),
 6894|  83.2k|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 6895|  83.2k|    }
 6896|   235k|    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
 6897|   144k|        if (sf->js_mode & JS_MODE_BACKTRACE_BARRIER)
 6898|      0|            break;
 6899|   144k|        if (backtrace_flags & JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL) {
 6900|      0|            backtrace_flags &= ~JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL;
 6901|      0|            continue;
 6902|      0|        }
 6903|   144k|        func_name_str = get_func_name(ctx, sf->cur_func);
 6904|   144k|        if (!func_name_str || func_name_str[0] == '\0')
 6905|  42.6k|            str1 = "<anonymous>";
 6906|   102k|        else
 6907|   102k|            str1 = func_name_str;
 6908|   144k|        dbuf_printf(&dbuf, "    at %s", str1);
 6909|   144k|        JS_FreeCString(ctx, func_name_str);
 6910|       |
 6911|   144k|        p = JS_VALUE_GET_OBJ(sf->cur_func);
 6912|   144k|        if (js_class_has_bytecode(p->class_id)) {
 6913|   144k|            JSFunctionBytecode *b;
 6914|   144k|            const char *atom_str;
 6915|   144k|            int line_num1, col_num1;
 6916|       |
 6917|   144k|            b = p->u.func.function_bytecode;
 6918|   144k|            if (b->has_debug) {
 6919|   144k|                line_num1 = find_line_num(ctx, b,
 6920|   144k|                                          sf->cur_pc - b->byte_code_buf - 1, &col_num1);
 6921|   144k|                atom_str = JS_AtomToCString(ctx, b->debug.filename);
 6922|   144k|                dbuf_printf(&dbuf, " (%s",
 6923|   144k|                            atom_str ? atom_str : "<null>");
 6924|   144k|                JS_FreeCString(ctx, atom_str);
 6925|   144k|                if (line_num1 != 0)
 6926|   144k|                    dbuf_printf(&dbuf, ":%d:%d", line_num1, col_num1);
 6927|   144k|                dbuf_putc(&dbuf, ')');
 6928|   144k|            }
 6929|   144k|        } else {
 6930|     16|            dbuf_printf(&dbuf, " (native)");
 6931|     16|        }
 6932|   144k|        dbuf_putc(&dbuf, '\n');
 6933|   144k|    }
 6934|  90.3k|    dbuf_putc(&dbuf, '\0');
 6935|  90.3k|    if (dbuf_error(&dbuf))
 6936|      0|        str = JS_NULL;
 6937|  90.3k|    else
 6938|  90.3k|        str = JS_NewString(ctx, (char *)dbuf.buf);
 6939|  90.3k|    dbuf_free(&dbuf);
 6940|  90.3k|    JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_stack, str,
 6941|  90.3k|                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 6942|  90.3k|}
 6943|       |
 6944|       |/* Note: it is important that no exception is returned by this function */
 6945|       |static BOOL is_backtrace_needed(JSContext *ctx, JSValueConst obj)
 6946|   144k|{
 6947|   144k|    JSObject *p;
 6948|   144k|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
 6949|     26|        return FALSE;
 6950|   144k|    p = JS_VALUE_GET_OBJ(obj);
 6951|   144k|    if (p->class_id != JS_CLASS_ERROR)
 6952|      2|        return FALSE;
 6953|   144k|    if (find_own_property1(p, JS_ATOM_stack))
 6954|   138k|        return FALSE;
 6955|  5.80k|    return TRUE;
 6956|   144k|}
 6957|       |
 6958|       |JSValue JS_NewError(JSContext *ctx)
 6959|      0|{
 6960|      0|    return JS_NewObjectClass(ctx, JS_CLASS_ERROR);
 6961|      0|}
 6962|       |
 6963|       |static JSValue JS_ThrowError2(JSContext *ctx, JSErrorEnum error_num,
 6964|       |                              const char *fmt, va_list ap, BOOL add_backtrace)
 6965|  89.3k|{
 6966|  89.3k|    char buf[256];
 6967|  89.3k|    JSValue obj, ret;
 6968|       |
 6969|  89.3k|    vsnprintf(buf, sizeof(buf), fmt, ap);
 6970|  89.3k|    obj = JS_NewObjectProtoClass(ctx, ctx->native_error_proto[error_num],
 6971|  89.3k|                                 JS_CLASS_ERROR);
 6972|  89.3k|    if (unlikely(JS_IsException(obj))) {
 6973|       |        /* out of memory: throw JS_NULL to avoid recursing */
 6974|      0|        obj = JS_NULL;
 6975|  89.3k|    } else {
 6976|  89.3k|        JS_DefinePropertyValue(ctx, obj, JS_ATOM_message,
 6977|  89.3k|                               JS_NewString(ctx, buf),
 6978|  89.3k|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 6979|  89.3k|    }
 6980|  89.3k|    if (add_backtrace) {
 6981|  1.34k|        build_backtrace(ctx, obj, NULL, 0, 0, 0);
 6982|  1.34k|    }
 6983|  89.3k|    ret = JS_Throw(ctx, obj);
 6984|  89.3k|    return ret;
 6985|  89.3k|}
 6986|       |
 6987|       |static JSValue JS_ThrowError(JSContext *ctx, JSErrorEnum error_num,
 6988|       |                             const char *fmt, va_list ap)
 6989|  7.32k|{
 6990|  7.32k|    JSRuntime *rt = ctx->rt;
 6991|  7.32k|    JSStackFrame *sf;
 6992|  7.32k|    BOOL add_backtrace;
 6993|       |
 6994|       |    /* the backtrace is added later if called from a bytecode function */
 6995|  7.32k|    sf = rt->current_stack_frame;
 6996|  7.32k|    add_backtrace = !rt->in_out_of_memory &&
 6997|  7.32k|        (!sf || (JS_GetFunctionBytecode(sf->cur_func) == NULL));
 6998|  7.32k|    return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
 6999|  7.32k|}
 7000|       |
 7001|       |JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
 7002|  1.21k|{
 7003|  1.21k|    JSValue val;
 7004|  1.21k|    va_list ap;
 7005|       |
 7006|  1.21k|    va_start(ap, fmt);
 7007|  1.21k|    val = JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);
 7008|  1.21k|    va_end(ap);
 7009|  1.21k|    return val;
 7010|  1.21k|}
 7011|       |
 7012|       |JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
 7013|  1.59k|{
 7014|  1.59k|    JSValue val;
 7015|  1.59k|    va_list ap;
 7016|       |
 7017|  1.59k|    va_start(ap, fmt);
 7018|  1.59k|    val = JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);
 7019|  1.59k|    va_end(ap);
 7020|  1.59k|    return val;
 7021|  1.59k|}
 7022|       |
 7023|       |static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
 7024|  35.3k|{
 7025|  35.3k|    va_list ap;
 7026|       |
 7027|  35.3k|    if ((flags & JS_PROP_THROW) ||
 7028|  35.3k|        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
 7029|      1|        va_start(ap, fmt);
 7030|      1|        JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);
 7031|      1|        va_end(ap);
 7032|      1|        return -1;
 7033|  35.3k|    } else {
 7034|  35.3k|        return FALSE;
 7035|  35.3k|    }
 7036|  35.3k|}
 7037|       |
 7038|       |/* never use it directly */
 7039|       |static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 7040|    233|{
 7041|    233|    char buf[ATOM_GET_STR_BUF_SIZE];
 7042|    233|    return JS_ThrowTypeError(ctx, fmt,
 7043|    233|                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
 7044|    233|}
 7045|       |
 7046|       |/* never use it directly */
 7047|       |static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 7048|     71|{
 7049|     71|    char buf[ATOM_GET_STR_BUF_SIZE];
 7050|     71|    return JS_ThrowSyntaxError(ctx, fmt,
 7051|     71|                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
 7052|     71|}
 7053|       |
 7054|       |/* %s is replaced by 'atom'. The macro is used so that gcc can check
 7055|       |    the format string. */
 7056|    233|#define JS_ThrowTypeErrorAtom(ctx, fmt, atom) __JS_ThrowTypeErrorAtom(ctx, atom, fmt, "")
 7057|     71|#define JS_ThrowSyntaxErrorAtom(ctx, fmt, atom) __JS_ThrowSyntaxErrorAtom(ctx, atom, fmt, "")
 7058|       |
 7059|       |static int JS_ThrowTypeErrorReadOnly(JSContext *ctx, int flags, JSAtom atom)
 7060|     12|{
 7061|     12|    if ((flags & JS_PROP_THROW) ||
 7062|     12|        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
 7063|     12|        JS_ThrowTypeErrorAtom(ctx, "'%s' is read-only", atom);
 7064|     12|        return -1;
 7065|     12|    } else {
 7066|      0|        return FALSE;
 7067|      0|    }
 7068|     12|}
 7069|       |
 7070|       |JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
 7071|  4.31k|{
 7072|  4.31k|    JSValue val;
 7073|  4.31k|    va_list ap;
 7074|       |
 7075|  4.31k|    va_start(ap, fmt);
 7076|  4.31k|    val = JS_ThrowError(ctx, JS_REFERENCE_ERROR, fmt, ap);
 7077|  4.31k|    va_end(ap);
 7078|  4.31k|    return val;
 7079|  4.31k|}
 7080|       |
 7081|       |JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
 7082|     56|{
 7083|     56|    JSValue val;
 7084|     56|    va_list ap;
 7085|       |
 7086|     56|    va_start(ap, fmt);
 7087|     56|    val = JS_ThrowError(ctx, JS_RANGE_ERROR, fmt, ap);
 7088|     56|    va_end(ap);
 7089|     56|    return val;
 7090|     56|}
 7091|       |
 7092|       |JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
 7093|    140|{
 7094|    140|    JSValue val;
 7095|    140|    va_list ap;
 7096|       |
 7097|    140|    va_start(ap, fmt);
 7098|    140|    val = JS_ThrowError(ctx, JS_INTERNAL_ERROR, fmt, ap);
 7099|    140|    va_end(ap);
 7100|    140|    return val;
 7101|    140|}
 7102|       |
 7103|       |JSValue JS_ThrowOutOfMemory(JSContext *ctx)
 7104|      0|{
 7105|      0|    JSRuntime *rt = ctx->rt;
 7106|      0|    if (!rt->in_out_of_memory) {
 7107|      0|        rt->in_out_of_memory = TRUE;
 7108|      0|        JS_ThrowInternalError(ctx, "out of memory");
 7109|      0|        rt->in_out_of_memory = FALSE;
 7110|      0|    }
 7111|      0|    return JS_EXCEPTION;
 7112|      0|}
 7113|       |
 7114|       |static JSValue JS_ThrowStackOverflow(JSContext *ctx)
 7115|    139|{
 7116|    139|    return JS_ThrowInternalError(ctx, "stack overflow");
 7117|    139|}
 7118|       |
 7119|       |static JSValue JS_ThrowTypeErrorNotAnObject(JSContext *ctx)
 7120|      0|{
 7121|      0|    return JS_ThrowTypeError(ctx, "not an object");
 7122|      0|}
 7123|       |
 7124|       |static JSValue JS_ThrowTypeErrorNotASymbol(JSContext *ctx)
 7125|      0|{
 7126|      0|    return JS_ThrowTypeError(ctx, "not a symbol");
 7127|      0|}
 7128|       |
 7129|       |static JSValue JS_ThrowReferenceErrorNotDefined(JSContext *ctx, JSAtom name)
 7130|  4.17k|{
 7131|  4.17k|    char buf[ATOM_GET_STR_BUF_SIZE];
 7132|  4.17k|    return JS_ThrowReferenceError(ctx, "'%s' is not defined",
 7133|  4.17k|                                  JS_AtomGetStr(ctx, buf, sizeof(buf), name));
 7134|  4.17k|}
 7135|       |
 7136|       |static JSValue JS_ThrowReferenceErrorUninitialized(JSContext *ctx, JSAtom name)
 7137|     28|{
 7138|     28|    char buf[ATOM_GET_STR_BUF_SIZE];
 7139|     28|    return JS_ThrowReferenceError(ctx, "%s is not initialized",
 7140|     28|                                  name == JS_ATOM_NULL ? "lexical variable" :
 7141|     28|                                  JS_AtomGetStr(ctx, buf, sizeof(buf), name));
 7142|     28|}
 7143|       |
 7144|       |static JSValue JS_ThrowReferenceErrorUninitialized2(JSContext *ctx,
 7145|       |                                                    JSFunctionBytecode *b,
 7146|       |                                                    int idx, BOOL is_ref)
 7147|     15|{
 7148|     15|    JSAtom atom = JS_ATOM_NULL;
 7149|     15|    if (is_ref) {
 7150|      6|        atom = b->closure_var[idx].var_name;
 7151|      9|    } else {
 7152|       |        /* not present if the function is stripped and contains no eval() */
 7153|      9|        if (b->vardefs)
 7154|      9|            atom = b->vardefs[b->arg_count + idx].var_name;
 7155|      9|    }
 7156|     15|    return JS_ThrowReferenceErrorUninitialized(ctx, atom);
 7157|     15|}
 7158|       |
 7159|       |static JSValue JS_ThrowTypeErrorInvalidClass(JSContext *ctx, int class_id)
 7160|      0|{
 7161|      0|    JSRuntime *rt = ctx->rt;
 7162|      0|    JSAtom name;
 7163|      0|    name = rt->class_array[class_id].class_name;
 7164|      0|    return JS_ThrowTypeErrorAtom(ctx, "%s object expected", name);
 7165|      0|}
 7166|       |
 7167|       |static void JS_ThrowInterrupted(JSContext *ctx)
 7168|      0|{
 7169|      0|    JS_ThrowInternalError(ctx, "interrupted");
 7170|      0|    JS_SetUncatchableError(ctx, ctx->rt->current_exception, TRUE);
 7171|      0|}
 7172|       |
 7173|       |static no_inline __exception int __js_poll_interrupts(JSContext *ctx)
 7174|  19.6k|{
 7175|  19.6k|    JSRuntime *rt = ctx->rt;
 7176|  19.6k|    ctx->interrupt_counter = JS_INTERRUPT_COUNTER_INIT;
 7177|  19.6k|    if (rt->interrupt_handler) {
 7178|      0|        if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {
 7179|      0|            JS_ThrowInterrupted(ctx);
 7180|      0|            return -1;
 7181|      0|        }
 7182|      0|    }
 7183|  19.6k|    return 0;
 7184|  19.6k|}
 7185|       |
 7186|       |static inline __exception int js_poll_interrupts(JSContext *ctx)
 7187|  23.6M|{
 7188|  23.6M|    if (unlikely(--ctx->interrupt_counter <= 0)) {
 7189|  19.6k|        return __js_poll_interrupts(ctx);
 7190|  23.6M|    } else {
 7191|  23.6M|        return 0;
 7192|  23.6M|    }
 7193|  23.6M|}
 7194|       |
 7195|       |/* return -1 (exception) or TRUE/FALSE */
 7196|       |static int JS_SetPrototypeInternal(JSContext *ctx, JSValueConst obj,
 7197|       |                                   JSValueConst proto_val,
 7198|       |                                   BOOL throw_flag)
 7199|      0|{
 7200|      0|    JSObject *proto, *p, *p1;
 7201|      0|    JSShape *sh;
 7202|       |
 7203|      0|    if (throw_flag) {
 7204|      0|        if (JS_VALUE_GET_TAG(obj) == JS_TAG_NULL ||
 7205|      0|            JS_VALUE_GET_TAG(obj) == JS_TAG_UNDEFINED)
 7206|      0|            goto not_obj;
 7207|      0|    } else {
 7208|      0|        if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
 7209|      0|            goto not_obj;
 7210|      0|    }
 7211|      0|    p = JS_VALUE_GET_OBJ(obj);
 7212|      0|    if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_OBJECT) {
 7213|      0|        if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_NULL) {
 7214|      0|        not_obj:
 7215|      0|            JS_ThrowTypeErrorNotAnObject(ctx);
 7216|      0|            return -1;
 7217|      0|        }
 7218|      0|        proto = NULL;
 7219|      0|    } else {
 7220|      0|        proto = JS_VALUE_GET_OBJ(proto_val);
 7221|      0|    }
 7222|       |
 7223|      0|    if (throw_flag && JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
 7224|      0|        return TRUE;
 7225|       |
 7226|      0|    if (unlikely(p->class_id == JS_CLASS_PROXY))
 7227|      0|        return js_proxy_setPrototypeOf(ctx, obj, proto_val, throw_flag);
 7228|      0|    sh = p->shape;
 7229|      0|    if (sh->proto == proto)
 7230|      0|        return TRUE;
 7231|      0|    if (!p->extensible) {
 7232|      0|        if (throw_flag) {
 7233|      0|            JS_ThrowTypeError(ctx, "object is not extensible");
 7234|      0|            return -1;
 7235|      0|        } else {
 7236|      0|            return FALSE;
 7237|      0|        }
 7238|      0|    }
 7239|      0|    if (proto) {
 7240|       |        /* check if there is a cycle */
 7241|      0|        p1 = proto;
 7242|      0|        do {
 7243|      0|            if (p1 == p) {
 7244|      0|                if (throw_flag) {
 7245|      0|                    JS_ThrowTypeError(ctx, "circular prototype chain");
 7246|      0|                    return -1;
 7247|      0|                } else {
 7248|      0|                    return FALSE;
 7249|      0|                }
 7250|      0|            }
 7251|       |            /* Note: for Proxy objects, proto is NULL */
 7252|      0|            p1 = p1->shape->proto;
 7253|      0|        } while (p1 != NULL);
 7254|      0|        JS_DupValue(ctx, proto_val);
 7255|      0|    }
 7256|       |
 7257|      0|    if (js_shape_prepare_update(ctx, p, NULL))
 7258|      0|        return -1;
 7259|      0|    sh = p->shape;
 7260|      0|    if (sh->proto)
 7261|      0|        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
 7262|      0|    sh->proto = proto;
 7263|      0|    return TRUE;
 7264|      0|}
 7265|       |
 7266|       |/* return -1 (exception) or TRUE/FALSE */
 7267|       |int JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val)
 7268|      0|{
 7269|      0|    return JS_SetPrototypeInternal(ctx, obj, proto_val, TRUE);
 7270|      0|}
 7271|       |
 7272|       |/* Only works for primitive types, otherwise return JS_NULL. */
 7273|       |static JSValueConst JS_GetPrototypePrimitive(JSContext *ctx, JSValueConst val)
 7274|   348k|{
 7275|   348k|    switch(JS_VALUE_GET_NORM_TAG(val)) {
 7276|  37.6k|    case JS_TAG_SHORT_BIG_INT:
 7277|  43.3k|    case JS_TAG_BIG_INT:
 7278|  43.3k|        val = ctx->class_proto[JS_CLASS_BIG_INT];
 7279|  43.3k|        break;
 7280|    794|    case JS_TAG_INT:
 7281|  7.18k|    case JS_TAG_FLOAT64:
 7282|  7.18k|        val = ctx->class_proto[JS_CLASS_NUMBER];
 7283|  7.18k|        break;
 7284|  1.56k|    case JS_TAG_BOOL:
 7285|  1.56k|        val = ctx->class_proto[JS_CLASS_BOOLEAN];
 7286|  1.56k|        break;
 7287|   296k|    case JS_TAG_STRING:
 7288|   296k|    case JS_TAG_STRING_ROPE:
 7289|   296k|        val = ctx->class_proto[JS_CLASS_STRING];
 7290|   296k|        break;
 7291|      0|    case JS_TAG_SYMBOL:
 7292|      0|        val = ctx->class_proto[JS_CLASS_SYMBOL];
 7293|      0|        break;
 7294|      0|    case JS_TAG_OBJECT:
 7295|      0|    case JS_TAG_NULL:
 7296|      0|    case JS_TAG_UNDEFINED:
 7297|      0|    default:
 7298|      0|        val = JS_NULL;
 7299|      0|        break;
 7300|   348k|    }
 7301|   348k|    return val;
 7302|   348k|}
 7303|       |
 7304|       |/* Return an Object, JS_NULL or JS_EXCEPTION in case of Proxy object. */
 7305|       |JSValue JS_GetPrototype(JSContext *ctx, JSValueConst obj)
 7306|  5.61M|{
 7307|  5.61M|    JSValue val;
 7308|  5.61M|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
 7309|  5.61M|        JSObject *p;
 7310|  5.61M|        p = JS_VALUE_GET_OBJ(obj);
 7311|  5.61M|        if (unlikely(p->class_id == JS_CLASS_PROXY)) {
 7312|      0|            val = js_proxy_getPrototypeOf(ctx, obj);
 7313|  5.61M|        } else {
 7314|  5.61M|            p = p->shape->proto;
 7315|  5.61M|            if (!p)
 7316|  1.87M|                val = JS_NULL;
 7317|  3.74M|            else
 7318|  3.74M|                val = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 7319|  5.61M|        }
 7320|  5.61M|    } else {
 7321|      0|        val = JS_DupValue(ctx, JS_GetPrototypePrimitive(ctx, obj));
 7322|      0|    }
 7323|  5.61M|    return val;
 7324|  5.61M|}
 7325|       |
 7326|       |static JSValue JS_GetPrototypeFree(JSContext *ctx, JSValue obj)
 7327|  5.61M|{
 7328|  5.61M|    JSValue obj1;
 7329|  5.61M|    obj1 = JS_GetPrototype(ctx, obj);
 7330|  5.61M|    JS_FreeValue(ctx, obj);
 7331|  5.61M|    return obj1;
 7332|  5.61M|}
 7333|       |
 7334|       |/* return TRUE, FALSE or (-1) in case of exception */
 7335|       |static int JS_OrdinaryIsInstanceOf(JSContext *ctx, JSValueConst val,
 7336|       |                                   JSValueConst obj)
 7337|      0|{
 7338|      0|    JSValue obj_proto;
 7339|      0|    JSObject *proto;
 7340|      0|    const JSObject *p, *proto1;
 7341|      0|    BOOL ret;
 7342|       |
 7343|      0|    if (!JS_IsFunction(ctx, obj))
 7344|      0|        return FALSE;
 7345|      0|    p = JS_VALUE_GET_OBJ(obj);
 7346|      0|    if (p->class_id == JS_CLASS_BOUND_FUNCTION) {
 7347|      0|        JSBoundFunction *s = p->u.bound_function;
 7348|      0|        return JS_IsInstanceOf(ctx, val, s->func_obj);
 7349|      0|    }
 7350|       |
 7351|       |    /* Only explicitly boxed values are instances of constructors */
 7352|      0|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
 7353|      0|        return FALSE;
 7354|      0|    obj_proto = JS_GetProperty(ctx, obj, JS_ATOM_prototype);
 7355|      0|    if (JS_VALUE_GET_TAG(obj_proto) != JS_TAG_OBJECT) {
 7356|      0|        if (!JS_IsException(obj_proto))
 7357|      0|            JS_ThrowTypeError(ctx, "operand 'prototype' property is not an object");
 7358|      0|        ret = -1;
 7359|      0|        goto done;
 7360|      0|    }
 7361|      0|    proto = JS_VALUE_GET_OBJ(obj_proto);
 7362|      0|    p = JS_VALUE_GET_OBJ(val);
 7363|      0|    for(;;) {
 7364|      0|        proto1 = p->shape->proto;
 7365|      0|        if (!proto1) {
 7366|       |            /* slow case if proxy in the prototype chain */
 7367|      0|            if (unlikely(p->class_id == JS_CLASS_PROXY)) {
 7368|      0|                JSValue obj1;
 7369|      0|                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, (JSObject *)p));
 7370|      0|                for(;;) {
 7371|      0|                    obj1 = JS_GetPrototypeFree(ctx, obj1);
 7372|      0|                    if (JS_IsException(obj1)) {
 7373|      0|                        ret = -1;
 7374|      0|                        break;
 7375|      0|                    }
 7376|      0|                    if (JS_IsNull(obj1)) {
 7377|      0|                        ret = FALSE;
 7378|      0|                        break;
 7379|      0|                    }
 7380|      0|                    if (proto == JS_VALUE_GET_OBJ(obj1)) {
 7381|      0|                        JS_FreeValue(ctx, obj1);
 7382|      0|                        ret = TRUE;
 7383|      0|                        break;
 7384|      0|                    }
 7385|       |                    /* must check for timeout to avoid infinite loop */
 7386|      0|                    if (js_poll_interrupts(ctx)) {
 7387|      0|                        JS_FreeValue(ctx, obj1);
 7388|      0|                        ret = -1;
 7389|      0|                        break;
 7390|      0|                    }
 7391|      0|                }
 7392|      0|            } else {
 7393|      0|                ret = FALSE;
 7394|      0|            }
 7395|      0|            break;
 7396|      0|        }
 7397|      0|        p = proto1;
 7398|      0|        if (proto == p) {
 7399|      0|            ret = TRUE;
 7400|      0|            break;
 7401|      0|        }
 7402|      0|    }
 7403|      0|done:
 7404|      0|    JS_FreeValue(ctx, obj_proto);
 7405|      0|    return ret;
 7406|      0|}
 7407|       |
 7408|       |/* return TRUE, FALSE or (-1) in case of exception */
 7409|       |int JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj)
 7410|      0|{
 7411|      0|    JSValue method;
 7412|       |
 7413|      0|    if (!JS_IsObject(obj))
 7414|      0|        goto fail;
 7415|      0|    method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_hasInstance);
 7416|      0|    if (JS_IsException(method))
 7417|      0|        return -1;
 7418|      0|    if (!JS_IsNull(method) && !JS_IsUndefined(method)) {
 7419|      0|        JSValue ret;
 7420|      0|        ret = JS_CallFree(ctx, method, obj, 1, &val);
 7421|      0|        return JS_ToBoolFree(ctx, ret);
 7422|      0|    }
 7423|       |
 7424|       |    /* legacy case */
 7425|      0|    if (!JS_IsFunction(ctx, obj)) {
 7426|      0|    fail:
 7427|      0|        JS_ThrowTypeError(ctx, "invalid 'instanceof' right operand");
 7428|      0|        return -1;
 7429|      0|    }
 7430|      0|    return JS_OrdinaryIsInstanceOf(ctx, val, obj);
 7431|      0|}
 7432|       |
 7433|       |/* return the value associated to the autoinit property or an exception */
 7434|       |typedef JSValue JSAutoInitFunc(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);
 7435|       |
 7436|       |static JSAutoInitFunc *js_autoinit_func_table[] = {
 7437|       |    js_instantiate_prototype, /* JS_AUTOINIT_ID_PROTOTYPE */
 7438|       |    js_module_ns_autoinit, /* JS_AUTOINIT_ID_MODULE_NS */
 7439|       |    JS_InstantiateFunctionListItem2, /* JS_AUTOINIT_ID_PROP */
 7440|       |};
 7441|       |
 7442|       |/* warning: 'prs' is reallocated after it */
 7443|       |static int JS_AutoInitProperty(JSContext *ctx, JSObject *p, JSAtom prop,
 7444|       |                               JSProperty *pr, JSShapeProperty *prs)
 7445|   198k|{
 7446|   198k|    JSValue val;
 7447|   198k|    JSContext *realm;
 7448|   198k|    JSAutoInitFunc *func;
 7449|   198k|    JSAutoInitIDEnum id;
 7450|       |    
 7451|   198k|    if (js_shape_prepare_update(ctx, p, &prs))
 7452|      0|        return -1;
 7453|       |
 7454|   198k|    realm = js_autoinit_get_realm(pr);
 7455|   198k|    id = js_autoinit_get_id(pr);
 7456|   198k|    func = js_autoinit_func_table[id];
 7457|       |    /* 'func' shall not modify the object properties 'pr' */
 7458|   198k|    val = func(realm, p, prop, pr->u.init.opaque);
 7459|   198k|    js_autoinit_free(ctx->rt, pr);
 7460|   198k|    prs->flags &= ~JS_PROP_TMASK;
 7461|   198k|    pr->u.value = JS_UNDEFINED;
 7462|   198k|    if (JS_IsException(val))
 7463|      0|        return -1;
 7464|   198k|    if (id == JS_AUTOINIT_ID_MODULE_NS &&
 7465|   198k|        JS_VALUE_GET_TAG(val) == JS_TAG_STRING) {
 7466|       |        /* WARNING: a varref is returned as a string  ! */
 7467|      0|        prs->flags |= JS_PROP_VARREF;
 7468|      0|        pr->u.var_ref = JS_VALUE_GET_PTR(val);
 7469|      0|        pr->u.var_ref->header.ref_count++;
 7470|   198k|    } else {
 7471|   198k|        pr->u.value = val;
 7472|   198k|    }
 7473|   198k|    return 0;
 7474|   198k|}
 7475|       |
 7476|       |JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
 7477|       |                               JSAtom prop, JSValueConst this_obj,
 7478|       |                               BOOL throw_ref_error)
 7479|  17.6M|{
 7480|  17.6M|    JSObject *p;
 7481|  17.6M|    JSProperty *pr;
 7482|  17.6M|    JSShapeProperty *prs;
 7483|  17.6M|    uint32_t tag;
 7484|       |
 7485|  17.6M|    tag = JS_VALUE_GET_TAG(obj);
 7486|  17.6M|    if (unlikely(tag != JS_TAG_OBJECT)) {
 7487|   313k|        switch(tag) {
 7488|      0|        case JS_TAG_NULL:
 7489|      0|            return JS_ThrowTypeErrorAtom(ctx, "cannot read property '%s' of null", prop);
 7490|    200|        case JS_TAG_UNDEFINED:
 7491|    200|            return JS_ThrowTypeErrorAtom(ctx, "cannot read property '%s' of undefined", prop);
 7492|      0|        case JS_TAG_EXCEPTION:
 7493|      0|            return JS_EXCEPTION;
 7494|   273k|        case JS_TAG_STRING:
 7495|   273k|            {
 7496|   273k|                JSString *p1 = JS_VALUE_GET_STRING(obj);
 7497|   273k|                if (__JS_AtomIsTaggedInt(prop)) {
 7498|      2|                    uint32_t idx;
 7499|      2|                    idx = __JS_AtomToUInt32(prop);
 7500|      2|                    if (idx < p1->len) {
 7501|      0|                        return js_new_string_char(ctx, string_get(p1, idx));
 7502|      0|                    }
 7503|   273k|                } else if (prop == JS_ATOM_length) {
 7504|      0|                    return JS_NewInt32(ctx, p1->len);
 7505|      0|                }
 7506|   273k|            }
 7507|   273k|            break;
 7508|   273k|        case JS_TAG_STRING_ROPE:
 7509|    339|            {
 7510|    339|                JSStringRope *p1 = JS_VALUE_GET_STRING_ROPE(obj);
 7511|    339|                if (__JS_AtomIsTaggedInt(prop)) {
 7512|      0|                    uint32_t idx;
 7513|      0|                    idx = __JS_AtomToUInt32(prop);
 7514|      0|                    if (idx < p1->len) {
 7515|      0|                        return js_new_string_char(ctx, string_rope_get(obj, idx));
 7516|      0|                    }
 7517|    339|                } else if (prop == JS_ATOM_length) {
 7518|      0|                    return JS_NewInt32(ctx, p1->len);
 7519|      0|                }
 7520|    339|            }
 7521|    339|            break;
 7522|  38.8k|        default:
 7523|  38.8k|            break;
 7524|   313k|        }
 7525|       |        /* cannot raise an exception */
 7526|   313k|        p = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));
 7527|   313k|        if (!p)
 7528|      0|            return JS_UNDEFINED;
 7529|  17.3M|    } else {
 7530|  17.3M|        p = JS_VALUE_GET_OBJ(obj);
 7531|  17.3M|    }
 7532|       |
 7533|  40.2M|    for(;;) {
 7534|  40.2M|        prs = find_own_property(&pr, p, prop);
 7535|  40.2M|        if (prs) {
 7536|       |            /* found */
 7537|  11.9M|            if (unlikely(prs->flags & JS_PROP_TMASK)) {
 7538|  7.25M|                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 7539|  7.02M|                    if (unlikely(!pr->u.getset.getter)) {
 7540|      0|                        return JS_UNDEFINED;
 7541|  7.02M|                    } else {
 7542|  7.02M|                        JSValue func = JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter);
 7543|       |                        /* Note: the field could be removed in the getter */
 7544|  7.02M|                        func = JS_DupValue(ctx, func);
 7545|  7.02M|                        return JS_CallFree(ctx, func, this_obj, 0, NULL);
 7546|  7.02M|                    }
 7547|  7.02M|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 7548|  31.4k|                    JSValue val = *pr->u.var_ref->pvalue;
 7549|  31.4k|                    if (unlikely(JS_IsUninitialized(val)))
 7550|      0|                        return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
 7551|  31.4k|                    return JS_DupValue(ctx, val);
 7552|   198k|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 7553|       |                    /* Instantiate property and retry */
 7554|   198k|                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
 7555|      0|                        return JS_EXCEPTION;
 7556|   198k|                    continue;
 7557|   198k|                }
 7558|  7.25M|            } else {
 7559|  4.69M|                return JS_DupValue(ctx, pr->u.value);
 7560|  4.69M|            }
 7561|  11.9M|        }
 7562|  28.3M|        if (unlikely(p->is_exotic)) {
 7563|       |            /* exotic behaviors */
 7564|  10.4M|            if (p->fast_array) {
 7565|  5.27M|                if (__JS_AtomIsTaggedInt(prop)) {
 7566|  4.48M|                    uint32_t idx = __JS_AtomToUInt32(prop);
 7567|  4.48M|                    if (idx < p->u.array.count) {
 7568|       |                        /* we avoid duplicating the code */
 7569|  18.2k|                        return JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);
 7570|  4.46M|                    } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
 7571|  4.46M|                               p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 7572|      0|                        return JS_UNDEFINED;
 7573|      0|                    }
 7574|  4.48M|                } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
 7575|   783k|                           p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 7576|      0|                    int ret;
 7577|      0|                    ret = JS_AtomIsNumericIndex(ctx, prop);
 7578|      0|                    if (ret != 0) {
 7579|      0|                        if (ret < 0)
 7580|      0|                            return JS_EXCEPTION;
 7581|      0|                        return JS_UNDEFINED;
 7582|      0|                    }
 7583|      0|                }
 7584|  5.27M|            } else {
 7585|  5.16M|                const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
 7586|  5.16M|                if (em) {
 7587|  46.6k|                    if (em->get_property) {
 7588|      0|                        JSValue obj1, retval;
 7589|       |                        /* XXX: should pass throw_ref_error */
 7590|       |                        /* Note: if 'p' is a prototype, it can be
 7591|       |                           freed in the called function */
 7592|      0|                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 7593|      0|                        retval = em->get_property(ctx, obj1, prop, this_obj);
 7594|      0|                        JS_FreeValue(ctx, obj1);
 7595|      0|                        return retval;
 7596|      0|                    }
 7597|  46.6k|                    if (em->get_own_property) {
 7598|  46.6k|                        JSPropertyDescriptor desc;
 7599|  46.6k|                        int ret;
 7600|  46.6k|                        JSValue obj1;
 7601|       |
 7602|       |                        /* Note: if 'p' is a prototype, it can be
 7603|       |                           freed in the called function */
 7604|  46.6k|                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 7605|  46.6k|                        ret = em->get_own_property(ctx, &desc, obj1, prop);
 7606|  46.6k|                        JS_FreeValue(ctx, obj1);
 7607|  46.6k|                        if (ret < 0)
 7608|      0|                            return JS_EXCEPTION;
 7609|  46.6k|                        if (ret) {
 7610|      0|                            if (desc.flags & JS_PROP_GETSET) {
 7611|      0|                                JS_FreeValue(ctx, desc.setter);
 7612|      0|                                return JS_CallFree(ctx, desc.getter, this_obj, 0, NULL);
 7613|      0|                            } else {
 7614|      0|                                return desc.value;
 7615|      0|                            }
 7616|      0|                        }
 7617|  46.6k|                    }
 7618|  46.6k|                }
 7619|  5.16M|            }
 7620|  10.4M|        }
 7621|  28.2M|        p = p->shape->proto;
 7622|  28.2M|        if (!p)
 7623|  5.87M|            break;
 7624|  28.2M|    }
 7625|  5.87M|    if (unlikely(throw_ref_error)) {
 7626|  3.94k|        return JS_ThrowReferenceErrorNotDefined(ctx, prop);
 7627|  5.87M|    } else {
 7628|  5.87M|        return JS_UNDEFINED;
 7629|  5.87M|    }
 7630|  5.87M|}
 7631|       |
 7632|       |static JSValue JS_ThrowTypeErrorPrivateNotFound(JSContext *ctx, JSAtom atom)
 7633|      0|{
 7634|      0|    return JS_ThrowTypeErrorAtom(ctx, "private class field '%s' does not exist",
 7635|      0|                                 atom);
 7636|      0|}
 7637|       |
 7638|       |/* Private fields can be added even on non extensible objects or
 7639|       |   Proxies */
 7640|       |static int JS_DefinePrivateField(JSContext *ctx, JSValueConst obj,
 7641|       |                                 JSValueConst name, JSValue val)
 7642|      0|{
 7643|      0|    JSObject *p;
 7644|      0|    JSShapeProperty *prs;
 7645|      0|    JSProperty *pr;
 7646|      0|    JSAtom prop;
 7647|       |
 7648|      0|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {
 7649|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 7650|      0|        goto fail;
 7651|      0|    }
 7652|       |    /* safety check */
 7653|      0|    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL)) {
 7654|      0|        JS_ThrowTypeErrorNotASymbol(ctx);
 7655|      0|        goto fail;
 7656|      0|    }
 7657|      0|    prop = js_symbol_to_atom(ctx, (JSValue)name);
 7658|      0|    p = JS_VALUE_GET_OBJ(obj);
 7659|      0|    prs = find_own_property(&pr, p, prop);
 7660|      0|    if (prs) {
 7661|      0|        JS_ThrowTypeErrorAtom(ctx, "private class field '%s' already exists",
 7662|      0|                              prop);
 7663|      0|        goto fail;
 7664|      0|    }
 7665|      0|    pr = add_property(ctx, p, prop, JS_PROP_C_W_E);
 7666|      0|    if (unlikely(!pr)) {
 7667|      0|    fail:
 7668|      0|        JS_FreeValue(ctx, val);
 7669|      0|        return -1;
 7670|      0|    }
 7671|      0|    pr->u.value = val;
 7672|      0|    return 0;
 7673|      0|}
 7674|       |
 7675|       |static JSValue JS_GetPrivateField(JSContext *ctx, JSValueConst obj,
 7676|       |                                  JSValueConst name)
 7677|      0|{
 7678|      0|    JSObject *p;
 7679|      0|    JSShapeProperty *prs;
 7680|      0|    JSProperty *pr;
 7681|      0|    JSAtom prop;
 7682|       |
 7683|      0|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
 7684|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
 7685|       |    /* safety check */
 7686|      0|    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))
 7687|      0|        return JS_ThrowTypeErrorNotASymbol(ctx);
 7688|      0|    prop = js_symbol_to_atom(ctx, (JSValue)name);
 7689|      0|    p = JS_VALUE_GET_OBJ(obj);
 7690|      0|    prs = find_own_property(&pr, p, prop);
 7691|      0|    if (!prs) {
 7692|      0|        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);
 7693|      0|        return JS_EXCEPTION;
 7694|      0|    }
 7695|      0|    return JS_DupValue(ctx, pr->u.value);
 7696|      0|}
 7697|       |
 7698|       |static int JS_SetPrivateField(JSContext *ctx, JSValueConst obj,
 7699|       |                              JSValueConst name, JSValue val)
 7700|      0|{
 7701|      0|    JSObject *p;
 7702|      0|    JSShapeProperty *prs;
 7703|      0|    JSProperty *pr;
 7704|      0|    JSAtom prop;
 7705|       |
 7706|      0|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {
 7707|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 7708|      0|        goto fail;
 7709|      0|    }
 7710|       |    /* safety check */
 7711|      0|    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL)) {
 7712|      0|        JS_ThrowTypeErrorNotASymbol(ctx);
 7713|      0|        goto fail;
 7714|      0|    }
 7715|      0|    prop = js_symbol_to_atom(ctx, (JSValue)name);
 7716|      0|    p = JS_VALUE_GET_OBJ(obj);
 7717|      0|    prs = find_own_property(&pr, p, prop);
 7718|      0|    if (!prs) {
 7719|      0|        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);
 7720|      0|    fail:
 7721|      0|        JS_FreeValue(ctx, val);
 7722|      0|        return -1;
 7723|      0|    }
 7724|      0|    set_value(ctx, &pr->u.value, val);
 7725|      0|    return 0;
 7726|      0|}
 7727|       |
 7728|       |/* add a private brand field to 'home_obj' if not already present and
 7729|       |   if obj is != null add a private brand to it */
 7730|       |static int JS_AddBrand(JSContext *ctx, JSValueConst obj, JSValueConst home_obj)
 7731|      0|{
 7732|      0|    JSObject *p, *p1;
 7733|      0|    JSShapeProperty *prs;
 7734|      0|    JSProperty *pr;
 7735|      0|    JSValue brand;
 7736|      0|    JSAtom brand_atom;
 7737|       |
 7738|      0|    if (unlikely(JS_VALUE_GET_TAG(home_obj) != JS_TAG_OBJECT)) {
 7739|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 7740|      0|        return -1;
 7741|      0|    }
 7742|      0|    p = JS_VALUE_GET_OBJ(home_obj);
 7743|      0|    prs = find_own_property(&pr, p, JS_ATOM_Private_brand);
 7744|      0|    if (!prs) {
 7745|       |        /* if the brand is not present, add it */
 7746|      0|        brand = JS_NewSymbolFromAtom(ctx, JS_ATOM_brand, JS_ATOM_TYPE_PRIVATE);
 7747|      0|        if (JS_IsException(brand))
 7748|      0|            return -1;
 7749|      0|        pr = add_property(ctx, p, JS_ATOM_Private_brand, JS_PROP_C_W_E);
 7750|      0|        if (!pr) {
 7751|      0|            JS_FreeValue(ctx, brand);
 7752|      0|            return -1;
 7753|      0|        }
 7754|      0|        pr->u.value = JS_DupValue(ctx, brand);
 7755|      0|    } else {
 7756|      0|        brand = JS_DupValue(ctx, pr->u.value);
 7757|      0|    }
 7758|      0|    brand_atom = js_symbol_to_atom(ctx, brand);
 7759|       |
 7760|      0|    if (JS_IsObject(obj)) {
 7761|      0|        p1 = JS_VALUE_GET_OBJ(obj);
 7762|      0|        prs = find_own_property(&pr, p1, brand_atom);
 7763|      0|        if (unlikely(prs)) {
 7764|      0|            JS_FreeAtom(ctx, brand_atom);
 7765|      0|            JS_ThrowTypeError(ctx, "private method is already present");
 7766|      0|            return -1;
 7767|      0|        }
 7768|      0|        pr = add_property(ctx, p1, brand_atom, JS_PROP_C_W_E);
 7769|      0|        JS_FreeAtom(ctx, brand_atom);
 7770|      0|        if (!pr)
 7771|      0|            return -1;
 7772|      0|        pr->u.value = JS_UNDEFINED;
 7773|      0|    } else {
 7774|      0|        JS_FreeAtom(ctx, brand_atom);
 7775|      0|    }
 7776|      0|    return 0;
 7777|      0|}
 7778|       |
 7779|       |/* return a boolean telling if the brand of the home object of 'func'
 7780|       |   is present on 'obj' or -1 in case of exception */
 7781|       |static int JS_CheckBrand(JSContext *ctx, JSValueConst obj, JSValueConst func)
 7782|      0|{
 7783|      0|    JSObject *p, *p1, *home_obj;
 7784|      0|    JSShapeProperty *prs;
 7785|      0|    JSProperty *pr;
 7786|      0|    JSValueConst brand;
 7787|       |
 7788|       |    /* get the home object of 'func' */
 7789|      0|    if (unlikely(JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT))
 7790|      0|        goto not_obj;
 7791|      0|    p1 = JS_VALUE_GET_OBJ(func);
 7792|      0|    if (!js_class_has_bytecode(p1->class_id))
 7793|      0|        goto not_obj;
 7794|      0|    home_obj = p1->u.func.home_object;
 7795|      0|    if (!home_obj)
 7796|      0|        goto not_obj;
 7797|      0|    prs = find_own_property(&pr, home_obj, JS_ATOM_Private_brand);
 7798|      0|    if (!prs) {
 7799|      0|        JS_ThrowTypeError(ctx, "expecting <brand> private field");
 7800|      0|        return -1;
 7801|      0|    }
 7802|      0|    brand = pr->u.value;
 7803|       |    /* safety check */
 7804|      0|    if (unlikely(JS_VALUE_GET_TAG(brand) != JS_TAG_SYMBOL))
 7805|      0|        goto not_obj;
 7806|       |
 7807|       |    /* get the brand array of 'obj' */
 7808|      0|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {
 7809|      0|    not_obj:
 7810|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 7811|      0|        return -1;
 7812|      0|    }
 7813|      0|    p = JS_VALUE_GET_OBJ(obj);
 7814|      0|    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));
 7815|      0|    return (prs != NULL);
 7816|      0|}
 7817|       |
 7818|       |static uint32_t js_string_obj_get_length(JSContext *ctx,
 7819|       |                                         JSValueConst obj)
 7820|   785k|{
 7821|   785k|    JSObject *p;
 7822|   785k|    uint32_t len = 0;
 7823|       |
 7824|       |    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */
 7825|   785k|    p = JS_VALUE_GET_OBJ(obj);
 7826|   785k|    if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {
 7827|   785k|        JSString *p1 = JS_VALUE_GET_STRING(p->u.object_data);
 7828|   785k|        len = p1->len;
 7829|   785k|    }
 7830|   785k|    return len;
 7831|   785k|}
 7832|       |
 7833|       |static int num_keys_cmp(const void *p1, const void *p2, void *opaque)
 7834|      0|{
 7835|      0|    JSContext *ctx = opaque;
 7836|      0|    JSAtom atom1 = ((const JSPropertyEnum *)p1)->atom;
 7837|      0|    JSAtom atom2 = ((const JSPropertyEnum *)p2)->atom;
 7838|      0|    uint32_t v1, v2;
 7839|      0|    BOOL atom1_is_integer, atom2_is_integer;
 7840|       |
 7841|      0|    atom1_is_integer = JS_AtomIsArrayIndex(ctx, &v1, atom1);
 7842|      0|    atom2_is_integer = JS_AtomIsArrayIndex(ctx, &v2, atom2);
 7843|      0|    assert(atom1_is_integer && atom2_is_integer);
 7844|      0|    if (v1 < v2)
 7845|      0|        return -1;
 7846|      0|    else if (v1 == v2)
 7847|      0|        return 0;
 7848|      0|    else
 7849|      0|        return 1;
 7850|      0|}
 7851|       |
 7852|       |static void js_free_prop_enum(JSContext *ctx, JSPropertyEnum *tab, uint32_t len)
 7853|  3.76M|{
 7854|  3.76M|    uint32_t i;
 7855|  3.76M|    if (tab) {
 7856|  3.79M|        for(i = 0; i < len; i++)
 7857|  35.5k|            JS_FreeAtom(ctx, tab[i].atom);
 7858|  3.76M|        js_free(ctx, tab);
 7859|  3.76M|    }
 7860|  3.76M|}
 7861|       |
 7862|       |/* return < 0 in case if exception, 0 if OK. ptab and its atoms must
 7863|       |   be freed by the user. */
 7864|       |static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
 7865|       |                                                      JSPropertyEnum **ptab,
 7866|       |                                                      uint32_t *plen,
 7867|       |                                                      JSObject *p, int flags)
 7868|  5.63M|{
 7869|  5.63M|    int i, j;
 7870|  5.63M|    JSShape *sh;
 7871|  5.63M|    JSShapeProperty *prs;
 7872|  5.63M|    JSPropertyEnum *tab_atom, *tab_exotic;
 7873|  5.63M|    JSAtom atom;
 7874|  5.63M|    uint32_t num_keys_count, str_keys_count, sym_keys_count, atom_count;
 7875|  5.63M|    uint32_t num_index, str_index, sym_index, exotic_count, exotic_keys_count;
 7876|  5.63M|    BOOL is_enumerable, num_sorted;
 7877|  5.63M|    uint32_t num_key;
 7878|  5.63M|    JSAtomKindEnum kind;
 7879|       |
 7880|       |    /* clear pointer for consistency in case of failure */
 7881|  5.63M|    *ptab = NULL;
 7882|  5.63M|    *plen = 0;
 7883|       |
 7884|       |    /* compute the number of returned properties */
 7885|  5.63M|    num_keys_count = 0;
 7886|  5.63M|    str_keys_count = 0;
 7887|  5.63M|    sym_keys_count = 0;
 7888|  5.63M|    exotic_keys_count = 0;
 7889|  5.63M|    exotic_count = 0;
 7890|  5.63M|    tab_exotic = NULL;
 7891|  5.63M|    sh = p->shape;
 7892|  48.5M|    for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
 7893|  42.8M|        atom = prs->atom;
 7894|  42.8M|        if (atom != JS_ATOM_NULL) {
 7895|  42.8M|            is_enumerable = ((prs->flags & JS_PROP_ENUMERABLE) != 0);
 7896|  42.8M|            kind = JS_AtomGetKind(ctx, atom);
 7897|  42.8M|            if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&
 7898|  42.8M|                ((flags >> kind) & 1) != 0) {
 7899|       |                /* need to raise an exception in case of the module
 7900|       |                   name space (implicit GetOwnProperty) */
 7901|   240k|                if (unlikely((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) &&
 7902|   240k|                    (flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY))) {
 7903|      0|                    JSVarRef *var_ref = p->prop[i].u.var_ref;
 7904|      0|                    if (unlikely(JS_IsUninitialized(*var_ref->pvalue))) {
 7905|      0|                        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
 7906|      0|                        return -1;
 7907|      0|                    }
 7908|      0|                }
 7909|   240k|                if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
 7910|      0|                    num_keys_count++;
 7911|   240k|                } else if (kind == JS_ATOM_KIND_STRING) {
 7912|   240k|                    str_keys_count++;
 7913|   240k|                } else {
 7914|      0|                    sym_keys_count++;
 7915|      0|                }
 7916|   240k|            }
 7917|  42.8M|        }
 7918|  42.8M|    }
 7919|       |
 7920|  5.63M|    if (p->is_exotic) {
 7921|   392k|        if (p->fast_array) {
 7922|      0|            if (flags & JS_GPN_STRING_MASK) {
 7923|      0|                num_keys_count += p->u.array.count;
 7924|      0|            }
 7925|   392k|        } else if (p->class_id == JS_CLASS_STRING) {
 7926|   392k|            if (flags & JS_GPN_STRING_MASK) {
 7927|   392k|                num_keys_count += js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 7928|   392k|            }
 7929|   392k|        } else {
 7930|      0|            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
 7931|      0|            if (em && em->get_own_property_names) {
 7932|      0|                if (em->get_own_property_names(ctx, &tab_exotic, &exotic_count,
 7933|      0|                                               JS_MKPTR(JS_TAG_OBJECT, p)))
 7934|      0|                    return -1;
 7935|      0|                for(i = 0; i < exotic_count; i++) {
 7936|      0|                    atom = tab_exotic[i].atom;
 7937|      0|                    kind = JS_AtomGetKind(ctx, atom);
 7938|      0|                    if (((flags >> kind) & 1) != 0) {
 7939|      0|                        is_enumerable = FALSE;
 7940|      0|                        if (flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY)) {
 7941|      0|                            JSPropertyDescriptor desc;
 7942|      0|                            int res;
 7943|       |                            /* set the "is_enumerable" field if necessary */
 7944|      0|                            res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);
 7945|      0|                            if (res < 0) {
 7946|      0|                                js_free_prop_enum(ctx, tab_exotic, exotic_count);
 7947|      0|                                return -1;
 7948|      0|                            }
 7949|      0|                            if (res) {
 7950|      0|                                is_enumerable =
 7951|      0|                                    ((desc.flags & JS_PROP_ENUMERABLE) != 0);
 7952|      0|                                js_free_desc(ctx, &desc);
 7953|      0|                            }
 7954|      0|                            tab_exotic[i].is_enumerable = is_enumerable;
 7955|      0|                        }
 7956|      0|                        if (!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) {
 7957|      0|                            exotic_keys_count++;
 7958|      0|                        }
 7959|      0|                    }
 7960|      0|                }
 7961|      0|            }
 7962|      0|        }
 7963|   392k|    }
 7964|       |
 7965|       |    /* fill them */
 7966|       |
 7967|  5.63M|    atom_count = num_keys_count + str_keys_count;
 7968|  5.63M|    if (atom_count < str_keys_count)
 7969|      0|        goto add_overflow;
 7970|  5.63M|    atom_count += sym_keys_count;
 7971|  5.63M|    if (atom_count < sym_keys_count)
 7972|      0|        goto add_overflow;
 7973|  5.63M|    atom_count += exotic_keys_count;
 7974|  5.63M|    if (atom_count < exotic_keys_count || atom_count > INT32_MAX) {
 7975|      0|    add_overflow:
 7976|      0|        JS_ThrowOutOfMemory(ctx);
 7977|      0|        js_free_prop_enum(ctx, tab_exotic, exotic_count);
 7978|      0|        return -1;
 7979|      0|    }
 7980|       |    /* XXX: need generic way to test for js_malloc(ctx, a * b) overflow */
 7981|       |    
 7982|       |    /* avoid allocating 0 bytes */
 7983|  5.63M|    tab_atom = js_malloc(ctx, sizeof(tab_atom[0]) * max_int(atom_count, 1));
 7984|  5.63M|    if (!tab_atom) {
 7985|      0|        js_free_prop_enum(ctx, tab_exotic, exotic_count);
 7986|      0|        return -1;
 7987|      0|    }
 7988|       |
 7989|  5.63M|    num_index = 0;
 7990|  5.63M|    str_index = num_keys_count;
 7991|  5.63M|    sym_index = str_index + str_keys_count;
 7992|       |
 7993|  5.63M|    num_sorted = TRUE;
 7994|  5.63M|    sh = p->shape;
 7995|  48.5M|    for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
 7996|  42.8M|        atom = prs->atom;
 7997|  42.8M|        if (atom != JS_ATOM_NULL) {
 7998|  42.8M|            is_enumerable = ((prs->flags & JS_PROP_ENUMERABLE) != 0);
 7999|  42.8M|            kind = JS_AtomGetKind(ctx, atom);
 8000|  42.8M|            if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&
 8001|  42.8M|                ((flags >> kind) & 1) != 0) {
 8002|   240k|                if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
 8003|      0|                    j = num_index++;
 8004|      0|                    num_sorted = FALSE;
 8005|   240k|                } else if (kind == JS_ATOM_KIND_STRING) {
 8006|   240k|                    j = str_index++;
 8007|   240k|                } else {
 8008|      0|                    j = sym_index++;
 8009|      0|                }
 8010|   240k|                tab_atom[j].atom = JS_DupAtom(ctx, atom);
 8011|   240k|                tab_atom[j].is_enumerable = is_enumerable;
 8012|   240k|            }
 8013|  42.8M|        }
 8014|  42.8M|    }
 8015|       |
 8016|  5.63M|    if (p->is_exotic) {
 8017|   392k|        int len;
 8018|   392k|        if (p->fast_array) {
 8019|      0|            if (flags & JS_GPN_STRING_MASK) {
 8020|      0|                len = p->u.array.count;
 8021|      0|                goto add_array_keys;
 8022|      0|            }
 8023|   392k|        } else if (p->class_id == JS_CLASS_STRING) {
 8024|   392k|            if (flags & JS_GPN_STRING_MASK) {
 8025|   392k|                len = js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 8026|   392k|            add_array_keys:
 8027|  5.36M|                for(i = 0; i < len; i++) {
 8028|  4.96M|                    tab_atom[num_index].atom = __JS_AtomFromUInt32(i);
 8029|  4.96M|                    if (tab_atom[num_index].atom == JS_ATOM_NULL) {
 8030|      0|                        js_free_prop_enum(ctx, tab_atom, num_index);
 8031|      0|                        return -1;
 8032|      0|                    }
 8033|  4.96M|                    tab_atom[num_index].is_enumerable = TRUE;
 8034|  4.96M|                    num_index++;
 8035|  4.96M|                }
 8036|   392k|            }
 8037|   392k|        } else {
 8038|       |            /* Note: exotic keys are not reordered and comes after the object own properties. */
 8039|      0|            for(i = 0; i < exotic_count; i++) {
 8040|      0|                atom = tab_exotic[i].atom;
 8041|      0|                is_enumerable = tab_exotic[i].is_enumerable;
 8042|      0|                kind = JS_AtomGetKind(ctx, atom);
 8043|      0|                if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&
 8044|      0|                    ((flags >> kind) & 1) != 0) {
 8045|      0|                    tab_atom[sym_index].atom = atom;
 8046|      0|                    tab_atom[sym_index].is_enumerable = is_enumerable;
 8047|      0|                    sym_index++;
 8048|      0|                } else {
 8049|      0|                    JS_FreeAtom(ctx, atom);
 8050|      0|                }
 8051|      0|            }
 8052|      0|            js_free(ctx, tab_exotic);
 8053|      0|        }
 8054|   392k|    }
 8055|       |
 8056|  5.63M|    assert(num_index == num_keys_count);
 8057|  5.63M|    assert(str_index == num_keys_count + str_keys_count);
 8058|  5.63M|    assert(sym_index == atom_count);
 8059|       |
 8060|  5.63M|    if (num_keys_count != 0 && !num_sorted) {
 8061|      0|        rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp,
 8062|      0|               ctx);
 8063|      0|    }
 8064|  5.63M|    *ptab = tab_atom;
 8065|  5.63M|    *plen = atom_count;
 8066|  5.63M|    return 0;
 8067|  5.63M|}
 8068|       |
 8069|       |int JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,
 8070|       |                           uint32_t *plen, JSValueConst obj, int flags)
 8071|      0|{
 8072|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {
 8073|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 8074|      0|        return -1;
 8075|      0|    }
 8076|      0|    return JS_GetOwnPropertyNamesInternal(ctx, ptab, plen,
 8077|      0|                                          JS_VALUE_GET_OBJ(obj), flags);
 8078|      0|}
 8079|       |
 8080|       |/* Return -1 if exception,
 8081|       |   FALSE if the property does not exist, TRUE if it exists. If TRUE is
 8082|       |   returned, the property descriptor 'desc' is filled present. */
 8083|       |static int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,
 8084|       |                                     JSObject *p, JSAtom prop)
 8085|  5.41M|{
 8086|  5.41M|    JSShapeProperty *prs;
 8087|  5.41M|    JSProperty *pr;
 8088|       |
 8089|  5.41M|retry:
 8090|  5.41M|    prs = find_own_property(&pr, p, prop);
 8091|  5.41M|    if (prs) {
 8092|  96.5k|        if (desc) {
 8093|  35.5k|            desc->flags = prs->flags & JS_PROP_C_W_E;
 8094|  35.5k|            desc->getter = JS_UNDEFINED;
 8095|  35.5k|            desc->setter = JS_UNDEFINED;
 8096|  35.5k|            desc->value = JS_UNDEFINED;
 8097|  35.5k|            if (unlikely(prs->flags & JS_PROP_TMASK)) {
 8098|      0|                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 8099|      0|                    desc->flags |= JS_PROP_GETSET;
 8100|      0|                    if (pr->u.getset.getter)
 8101|      0|                        desc->getter = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));
 8102|      0|                    if (pr->u.getset.setter)
 8103|      0|                        desc->setter = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));
 8104|      0|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 8105|      0|                    JSValue val = *pr->u.var_ref->pvalue;
 8106|      0|                    if (unlikely(JS_IsUninitialized(val))) {
 8107|      0|                        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
 8108|      0|                        return -1;
 8109|      0|                    }
 8110|      0|                    desc->value = JS_DupValue(ctx, val);
 8111|      0|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 8112|       |                    /* Instantiate property and retry */
 8113|      0|                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
 8114|      0|                        return -1;
 8115|      0|                    goto retry;
 8116|      0|                }
 8117|  35.5k|            } else {
 8118|  35.5k|                desc->value = JS_DupValue(ctx, pr->u.value);
 8119|  35.5k|            }
 8120|  61.0k|        } else {
 8121|       |            /* for consistency, send the exception even if desc is NULL */
 8122|  61.0k|            if (unlikely((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF)) {
 8123|  31.6k|                if (unlikely(JS_IsUninitialized(*pr->u.var_ref->pvalue))) {
 8124|      3|                    JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
 8125|      3|                    return -1;
 8126|      3|                }
 8127|  31.6k|            } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 8128|       |                /* nothing to do: delay instantiation until actual value and/or attributes are read */
 8129|      0|            }
 8130|  61.0k|        }
 8131|  96.5k|        return TRUE;
 8132|  96.5k|    }
 8133|  5.32M|    if (p->is_exotic) {
 8134|  4.89M|        if (p->fast_array) {
 8135|       |            /* specific case for fast arrays */
 8136|      6|            if (__JS_AtomIsTaggedInt(prop)) {
 8137|      0|                uint32_t idx;
 8138|      0|                idx = __JS_AtomToUInt32(prop);
 8139|      0|                if (idx < p->u.array.count) {
 8140|      0|                    if (desc) {
 8141|      0|                        desc->flags = JS_PROP_WRITABLE | JS_PROP_ENUMERABLE |
 8142|      0|                            JS_PROP_CONFIGURABLE;
 8143|      0|                        desc->getter = JS_UNDEFINED;
 8144|      0|                        desc->setter = JS_UNDEFINED;
 8145|      0|                        desc->value = JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);
 8146|      0|                    }
 8147|      0|                    return TRUE;
 8148|      0|                }
 8149|      0|            }
 8150|  4.89M|        } else {
 8151|  4.89M|            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
 8152|  4.89M|            if (em && em->get_own_property) {
 8153|  4.89M|                return em->get_own_property(ctx, desc,
 8154|  4.89M|                                            JS_MKPTR(JS_TAG_OBJECT, p), prop);
 8155|  4.89M|            }
 8156|  4.89M|        }
 8157|  4.89M|    }
 8158|   425k|    return FALSE;
 8159|  5.32M|}
 8160|       |
 8161|       |int JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,
 8162|       |                      JSValueConst obj, JSAtom prop)
 8163|      0|{
 8164|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {
 8165|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 8166|      0|        return -1;
 8167|      0|    }
 8168|      0|    return JS_GetOwnPropertyInternal(ctx, desc, JS_VALUE_GET_OBJ(obj), prop);
 8169|      0|}
 8170|       |
 8171|       |/* return -1 if exception (Proxy object only) or TRUE/FALSE */
 8172|       |int JS_IsExtensible(JSContext *ctx, JSValueConst obj)
 8173|      0|{
 8174|      0|    JSObject *p;
 8175|       |
 8176|      0|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
 8177|      0|        return FALSE;
 8178|      0|    p = JS_VALUE_GET_OBJ(obj);
 8179|      0|    if (unlikely(p->class_id == JS_CLASS_PROXY))
 8180|      0|        return js_proxy_isExtensible(ctx, obj);
 8181|      0|    else
 8182|      0|        return p->extensible;
 8183|      0|}
 8184|       |
 8185|       |/* return -1 if exception (Proxy object only) or TRUE/FALSE */
 8186|       |int JS_PreventExtensions(JSContext *ctx, JSValueConst obj)
 8187|  17.7k|{
 8188|  17.7k|    JSObject *p;
 8189|       |
 8190|  17.7k|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
 8191|      0|        return FALSE;
 8192|  17.7k|    p = JS_VALUE_GET_OBJ(obj);
 8193|  17.7k|    if (unlikely(p->class_id == JS_CLASS_PROXY))
 8194|      0|        return js_proxy_preventExtensions(ctx, obj);
 8195|  17.7k|    p->extensible = FALSE;
 8196|  17.7k|    return TRUE;
 8197|  17.7k|}
 8198|       |
 8199|       |/* return -1 if exception otherwise TRUE or FALSE */
 8200|       |int JS_HasProperty(JSContext *ctx, JSValueConst obj, JSAtom prop)
 8201|   203k|{
 8202|   203k|    JSObject *p;
 8203|   203k|    int ret;
 8204|   203k|    JSValue obj1;
 8205|       |
 8206|   203k|    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
 8207|      0|        return FALSE;
 8208|   203k|    p = JS_VALUE_GET_OBJ(obj);
 8209|   486k|    for(;;) {
 8210|   486k|        if (p->is_exotic) {
 8211|      6|            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
 8212|      6|            if (em && em->has_property) {
 8213|       |                /* has_property can free the prototype */
 8214|      0|                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 8215|      0|                ret = em->has_property(ctx, obj1, prop);
 8216|      0|                JS_FreeValue(ctx, obj1);
 8217|      0|                return ret;
 8218|      0|            }
 8219|      6|        }
 8220|       |        /* JS_GetOwnPropertyInternal can free the prototype */
 8221|   486k|        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 8222|   486k|        ret = JS_GetOwnPropertyInternal(ctx, NULL, p, prop);
 8223|   486k|        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 8224|   486k|        if (ret != 0)
 8225|  61.0k|            return ret;
 8226|   425k|        if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
 8227|   425k|            p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 8228|      0|            ret = JS_AtomIsNumericIndex(ctx, prop);
 8229|      0|            if (ret != 0) {
 8230|      0|                if (ret < 0)
 8231|      0|                    return -1;
 8232|      0|                return FALSE;
 8233|      0|            }
 8234|      0|        }
 8235|   425k|        p = p->shape->proto;
 8236|   425k|        if (!p)
 8237|   142k|            break;
 8238|   425k|    }
 8239|   142k|    return FALSE;
 8240|   203k|}
 8241|       |
 8242|       |/* val must be a symbol */
 8243|       |static JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val)
 8244|      0|{
 8245|      0|    JSAtomStruct *p = JS_VALUE_GET_PTR(val);
 8246|      0|    return js_get_atom_index(ctx->rt, p);
 8247|      0|}
 8248|       |
 8249|       |/* return JS_ATOM_NULL in case of exception */
 8250|       |JSAtom JS_ValueToAtom(JSContext *ctx, JSValueConst val)
 8251|  7.17M|{
 8252|  7.17M|    JSAtom atom;
 8253|  7.17M|    uint32_t tag;
 8254|  7.17M|    tag = JS_VALUE_GET_TAG(val);
 8255|  7.17M|    if (tag == JS_TAG_INT &&
 8256|  7.17M|        (uint32_t)JS_VALUE_GET_INT(val) <= JS_ATOM_MAX_INT) {
 8257|       |        /* fast path for integer values */
 8258|  6.89M|        atom = __JS_AtomFromUInt32(JS_VALUE_GET_INT(val));
 8259|  6.89M|    } else if (tag == JS_TAG_SYMBOL) {
 8260|      0|        JSAtomStruct *p = JS_VALUE_GET_PTR(val);
 8261|      0|        atom = JS_DupAtom(ctx, js_get_atom_index(ctx->rt, p));
 8262|   276k|    } else {
 8263|   276k|        JSValue str;
 8264|   276k|        str = JS_ToPropertyKey(ctx, val);
 8265|   276k|        if (JS_IsException(str))
 8266|      0|            return JS_ATOM_NULL;
 8267|   276k|        if (JS_VALUE_GET_TAG(str) == JS_TAG_SYMBOL) {
 8268|      0|            atom = js_symbol_to_atom(ctx, str);
 8269|   276k|        } else {
 8270|   276k|            atom = JS_NewAtomStr(ctx, JS_VALUE_GET_STRING(str));
 8271|   276k|        }
 8272|   276k|    }
 8273|  7.17M|    return atom;
 8274|  7.17M|}
 8275|       |
 8276|       |static JSValue JS_GetPropertyValue(JSContext *ctx, JSValueConst this_obj,
 8277|       |                                   JSValue prop)
 8278|  5.94M|{
 8279|  5.94M|    JSAtom atom;
 8280|  5.94M|    JSValue ret;
 8281|       |
 8282|  5.94M|    if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&
 8283|  5.94M|               JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {
 8284|  5.81M|        JSObject *p;
 8285|  5.81M|        uint32_t idx;
 8286|       |        /* fast path for array access */
 8287|  5.81M|        p = JS_VALUE_GET_OBJ(this_obj);
 8288|  5.81M|        idx = JS_VALUE_GET_INT(prop);
 8289|  5.81M|        switch(p->class_id) {
 8290|  5.81M|        case JS_CLASS_ARRAY:
 8291|  5.81M|        case JS_CLASS_ARGUMENTS:
 8292|  5.81M|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8293|  74.8k|            return JS_DupValue(ctx, p->u.array.u.values[idx]);
 8294|      0|        case JS_CLASS_INT8_ARRAY:
 8295|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8296|      0|            return JS_NewInt32(ctx, p->u.array.u.int8_ptr[idx]);
 8297|      0|        case JS_CLASS_UINT8C_ARRAY:
 8298|      0|        case JS_CLASS_UINT8_ARRAY:
 8299|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8300|      0|            return JS_NewInt32(ctx, p->u.array.u.uint8_ptr[idx]);
 8301|      0|        case JS_CLASS_INT16_ARRAY:
 8302|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8303|      0|            return JS_NewInt32(ctx, p->u.array.u.int16_ptr[idx]);
 8304|      0|        case JS_CLASS_UINT16_ARRAY:
 8305|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8306|      0|            return JS_NewInt32(ctx, p->u.array.u.uint16_ptr[idx]);
 8307|      0|        case JS_CLASS_INT32_ARRAY:
 8308|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8309|      0|            return JS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);
 8310|      0|        case JS_CLASS_UINT32_ARRAY:
 8311|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8312|      0|            return JS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);
 8313|      0|        case JS_CLASS_BIG_INT64_ARRAY:
 8314|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8315|      0|            return JS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);
 8316|      0|        case JS_CLASS_BIG_UINT64_ARRAY:
 8317|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8318|      0|            return JS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);
 8319|      0|        case JS_CLASS_FLOAT32_ARRAY:
 8320|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8321|      0|            return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);
 8322|      0|        case JS_CLASS_FLOAT64_ARRAY:
 8323|      0|            if (unlikely(idx >= p->u.array.count)) goto slow_path;
 8324|      0|            return __JS_NewFloat64(ctx, p->u.array.u.double_ptr[idx]);
 8325|     12|        default:
 8326|     12|            goto slow_path;
 8327|  5.81M|        }
 8328|  5.81M|    } else {
 8329|  5.87M|    slow_path:
 8330|       |        /* ToObject() must be done before ToPropertyKey() */
 8331|  5.87M|        if (JS_IsNull(this_obj) || JS_IsUndefined(this_obj)) {
 8332|      5|            JS_FreeValue(ctx, prop);
 8333|      5|            return JS_ThrowTypeError(ctx, "cannot read property of %s", JS_IsNull(this_obj) ? "null" : "undefined");
 8334|      5|        }
 8335|  5.87M|        atom = JS_ValueToAtom(ctx, prop);
 8336|  5.87M|        JS_FreeValue(ctx, prop);
 8337|  5.87M|        if (unlikely(atom == JS_ATOM_NULL))
 8338|      0|            return JS_EXCEPTION;
 8339|  5.87M|        ret = JS_GetProperty(ctx, this_obj, atom);
 8340|  5.87M|        JS_FreeAtom(ctx, atom);
 8341|  5.87M|        return ret;
 8342|  5.87M|    }
 8343|  5.94M|}
 8344|       |
 8345|       |JSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
 8346|       |                             uint32_t idx)
 8347|  5.77M|{
 8348|  5.77M|    return JS_GetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx));
 8349|  5.77M|}
 8350|       |
 8351|       |/* Check if an object has a generalized numeric property. Return value:
 8352|       |   -1 for exception,
 8353|       |   TRUE if property exists, stored into *pval,
 8354|       |   FALSE if proprty does not exist.
 8355|       | */
 8356|       |static int JS_TryGetPropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx, JSValue *pval)
 8357|      0|{
 8358|      0|    JSValue val = JS_UNDEFINED;
 8359|      0|    JSAtom prop;
 8360|      0|    int present;
 8361|       |
 8362|      0|    if (likely((uint64_t)idx <= JS_ATOM_MAX_INT)) {
 8363|       |        /* fast path */
 8364|      0|        present = JS_HasProperty(ctx, obj, __JS_AtomFromUInt32(idx));
 8365|      0|        if (present > 0) {
 8366|      0|            val = JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx));
 8367|      0|            if (unlikely(JS_IsException(val)))
 8368|      0|                present = -1;
 8369|      0|        }
 8370|      0|    } else {
 8371|      0|        prop = JS_NewAtomInt64(ctx, idx);
 8372|      0|        present = -1;
 8373|      0|        if (likely(prop != JS_ATOM_NULL)) {
 8374|      0|            present = JS_HasProperty(ctx, obj, prop);
 8375|      0|            if (present > 0) {
 8376|      0|                val = JS_GetProperty(ctx, obj, prop);
 8377|      0|                if (unlikely(JS_IsException(val)))
 8378|      0|                    present = -1;
 8379|      0|            }
 8380|      0|            JS_FreeAtom(ctx, prop);
 8381|      0|        }
 8382|      0|    }
 8383|      0|    *pval = val;
 8384|      0|    return present;
 8385|      0|}
 8386|       |
 8387|       |static JSValue JS_GetPropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx)
 8388|      0|{
 8389|      0|    JSAtom prop;
 8390|      0|    JSValue val;
 8391|       |
 8392|      0|    if ((uint64_t)idx <= INT32_MAX) {
 8393|       |        /* fast path for fast arrays */
 8394|      0|        return JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx));
 8395|      0|    }
 8396|      0|    prop = JS_NewAtomInt64(ctx, idx);
 8397|      0|    if (prop == JS_ATOM_NULL)
 8398|      0|        return JS_EXCEPTION;
 8399|       |
 8400|      0|    val = JS_GetProperty(ctx, obj, prop);
 8401|      0|    JS_FreeAtom(ctx, prop);
 8402|      0|    return val;
 8403|      0|}
 8404|       |
 8405|       |JSValue JS_GetPropertyStr(JSContext *ctx, JSValueConst this_obj,
 8406|       |                          const char *prop)
 8407|  3.91M|{
 8408|  3.91M|    JSAtom atom;
 8409|  3.91M|    JSValue ret;
 8410|  3.91M|    atom = JS_NewAtom(ctx, prop);
 8411|  3.91M|    ret = JS_GetProperty(ctx, this_obj, atom);
 8412|  3.91M|    JS_FreeAtom(ctx, atom);
 8413|  3.91M|    return ret;
 8414|  3.91M|}
 8415|       |
 8416|       |/* Note: the property value is not initialized. Return NULL if memory
 8417|       |   error. */
 8418|       |static JSProperty *add_property(JSContext *ctx,
 8419|       |                                JSObject *p, JSAtom prop, int prop_flags)
 8420|  19.7M|{
 8421|  19.7M|    JSShape *sh, *new_sh;
 8422|       |
 8423|  19.7M|    sh = p->shape;
 8424|  19.7M|    if (sh->is_hashed) {
 8425|       |        /* try to find an existing shape */
 8426|  14.4M|        new_sh = find_hashed_shape_prop(ctx->rt, sh, prop, prop_flags);
 8427|  14.4M|        if (new_sh) {
 8428|       |            /* matching shape found: use it */
 8429|       |            /*  the property array may need to be resized */
 8430|  2.93M|            if (new_sh->prop_size != sh->prop_size) {
 8431|   846k|                JSProperty *new_prop;
 8432|   846k|                new_prop = js_realloc(ctx, p->prop, sizeof(p->prop[0]) *
 8433|   846k|                                      new_sh->prop_size);
 8434|   846k|                if (!new_prop)
 8435|      0|                    return NULL;
 8436|   846k|                p->prop = new_prop;
 8437|   846k|            }
 8438|  2.93M|            p->shape = js_dup_shape(new_sh);
 8439|  2.93M|            js_free_shape(ctx->rt, sh);
 8440|  2.93M|            return &p->prop[new_sh->prop_count - 1];
 8441|  11.4M|        } else if (sh->header.ref_count != 1) {
 8442|       |            /* if the shape is shared, clone it */
 8443|   896k|            new_sh = js_clone_shape(ctx, sh);
 8444|   896k|            if (!new_sh)
 8445|      0|                return NULL;
 8446|       |            /* hash the cloned shape */
 8447|   896k|            new_sh->is_hashed = TRUE;
 8448|   896k|            js_shape_hash_link(ctx->rt, new_sh);
 8449|   896k|            js_free_shape(ctx->rt, p->shape);
 8450|   896k|            p->shape = new_sh;
 8451|   896k|        }
 8452|  14.4M|    }
 8453|  16.8M|    assert(p->shape->header.ref_count == 1);
 8454|  16.8M|    if (add_shape_property(ctx, &p->shape, p, prop, prop_flags))
 8455|      0|        return NULL;
 8456|  16.8M|    return &p->prop[p->shape->prop_count - 1];
 8457|  16.8M|}
 8458|       |
 8459|       |/* can be called on Array or Arguments objects. return < 0 if
 8460|       |   memory alloc error. */
 8461|       |static no_inline __exception int convert_fast_array_to_array(JSContext *ctx,
 8462|       |                                                             JSObject *p)
 8463|  1.27M|{
 8464|  1.27M|    JSProperty *pr;
 8465|  1.27M|    JSShape *sh;
 8466|  1.27M|    JSValue *tab;
 8467|  1.27M|    uint32_t i, len, new_count;
 8468|       |
 8469|  1.27M|    if (js_shape_prepare_update(ctx, p, NULL))
 8470|      0|        return -1;
 8471|  1.27M|    len = p->u.array.count;
 8472|       |    /* resize the properties once to simplify the error handling */
 8473|  1.27M|    sh = p->shape;
 8474|  1.27M|    new_count = sh->prop_count + len;
 8475|  1.27M|    if (new_count > sh->prop_size) {
 8476|  34.8k|        if (resize_properties(ctx, &p->shape, p, new_count))
 8477|      0|            return -1;
 8478|  34.8k|    }
 8479|       |
 8480|  1.27M|    tab = p->u.array.u.values;
 8481|  1.31M|    for(i = 0; i < len; i++) {
 8482|       |        /* add_property cannot fail here but
 8483|       |           __JS_AtomFromUInt32(i) fails for i > INT32_MAX */
 8484|  41.5k|        pr = add_property(ctx, p, __JS_AtomFromUInt32(i), JS_PROP_C_W_E);
 8485|  41.5k|        pr->u.value = *tab++;
 8486|  41.5k|    }
 8487|  1.27M|    js_free(ctx, p->u.array.u.values);
 8488|  1.27M|    p->u.array.count = 0;
 8489|  1.27M|    p->u.array.u.values = NULL; /* fail safe */
 8490|  1.27M|    p->u.array.u1.size = 0;
 8491|  1.27M|    p->fast_array = 0;
 8492|  1.27M|    return 0;
 8493|  1.27M|}
 8494|       |
 8495|       |static int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)
 8496|      0|{
 8497|      0|    JSShape *sh;
 8498|      0|    JSShapeProperty *pr, *lpr, *prop;
 8499|      0|    JSProperty *pr1;
 8500|      0|    uint32_t lpr_idx;
 8501|      0|    intptr_t h, h1;
 8502|       |
 8503|      0| redo:
 8504|      0|    sh = p->shape;
 8505|      0|    h1 = atom & sh->prop_hash_mask;
 8506|      0|    h = prop_hash_end(sh)[-h1 - 1];
 8507|      0|    prop = get_shape_prop(sh);
 8508|      0|    lpr = NULL;
 8509|      0|    lpr_idx = 0;   /* prevent warning */
 8510|      0|    while (h != 0) {
 8511|      0|        pr = &prop[h - 1];
 8512|      0|        if (likely(pr->atom == atom)) {
 8513|       |            /* found ! */
 8514|      0|            if (!(pr->flags & JS_PROP_CONFIGURABLE))
 8515|      0|                return FALSE;
 8516|       |            /* realloc the shape if needed */
 8517|      0|            if (lpr)
 8518|      0|                lpr_idx = lpr - get_shape_prop(sh);
 8519|      0|            if (js_shape_prepare_update(ctx, p, &pr))
 8520|      0|                return -1;
 8521|      0|            sh = p->shape;
 8522|       |            /* remove property */
 8523|      0|            if (lpr) {
 8524|      0|                lpr = get_shape_prop(sh) + lpr_idx;
 8525|      0|                lpr->hash_next = pr->hash_next;
 8526|      0|            } else {
 8527|      0|                prop_hash_end(sh)[-h1 - 1] = pr->hash_next;
 8528|      0|            }
 8529|      0|            sh->deleted_prop_count++;
 8530|       |            /* free the entry */
 8531|      0|            pr1 = &p->prop[h - 1];
 8532|      0|            free_property(ctx->rt, pr1, pr->flags);
 8533|      0|            JS_FreeAtom(ctx, pr->atom);
 8534|       |            /* put default values */
 8535|      0|            pr->flags = 0;
 8536|      0|            pr->atom = JS_ATOM_NULL;
 8537|      0|            pr1->u.value = JS_UNDEFINED;
 8538|       |
 8539|       |            /* compact the properties if too many deleted properties */
 8540|      0|            if (sh->deleted_prop_count >= 8 &&
 8541|      0|                sh->deleted_prop_count >= ((unsigned)sh->prop_count / 2)) {
 8542|      0|                compact_properties(ctx, p);
 8543|      0|            }
 8544|      0|            return TRUE;
 8545|      0|        }
 8546|      0|        lpr = pr;
 8547|      0|        h = pr->hash_next;
 8548|      0|    }
 8549|       |
 8550|      0|    if (p->is_exotic) {
 8551|      0|        if (p->fast_array) {
 8552|      0|            uint32_t idx;
 8553|      0|            if (JS_AtomIsArrayIndex(ctx, &idx, atom) &&
 8554|      0|                idx < p->u.array.count) {
 8555|      0|                if (p->class_id == JS_CLASS_ARRAY ||
 8556|      0|                    p->class_id == JS_CLASS_ARGUMENTS) {
 8557|       |                    /* Special case deleting the last element of a fast Array */
 8558|      0|                    if (idx == p->u.array.count - 1) {
 8559|      0|                        JS_FreeValue(ctx, p->u.array.u.values[idx]);
 8560|      0|                        p->u.array.count = idx;
 8561|      0|                        return TRUE;
 8562|      0|                    }
 8563|      0|                    if (convert_fast_array_to_array(ctx, p))
 8564|      0|                        return -1;
 8565|      0|                    goto redo;
 8566|      0|                } else {
 8567|      0|                    return FALSE;
 8568|      0|                }
 8569|      0|            }
 8570|      0|        } else {
 8571|      0|            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
 8572|      0|            if (em && em->delete_property) {
 8573|      0|                return em->delete_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p), atom);
 8574|      0|            }
 8575|      0|        }
 8576|      0|    }
 8577|       |    /* not found */
 8578|      0|    return TRUE;
 8579|      0|}
 8580|       |
 8581|       |static int call_setter(JSContext *ctx, JSObject *setter,
 8582|       |                       JSValueConst this_obj, JSValue val, int flags)
 8583|      0|{
 8584|      0|    JSValue ret, func;
 8585|      0|    if (likely(setter)) {
 8586|      0|        func = JS_MKPTR(JS_TAG_OBJECT, setter);
 8587|       |        /* Note: the field could be removed in the setter */
 8588|      0|        func = JS_DupValue(ctx, func);
 8589|      0|        ret = JS_CallFree(ctx, func, this_obj, 1, (JSValueConst *)&val);
 8590|      0|        JS_FreeValue(ctx, val);
 8591|      0|        if (JS_IsException(ret))
 8592|      0|            return -1;
 8593|      0|        JS_FreeValue(ctx, ret);
 8594|      0|        return TRUE;
 8595|      0|    } else {
 8596|      0|        JS_FreeValue(ctx, val);
 8597|      0|        if ((flags & JS_PROP_THROW) ||
 8598|      0|            ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
 8599|      0|            JS_ThrowTypeError(ctx, "no setter for property");
 8600|      0|            return -1;
 8601|      0|        }
 8602|      0|        return FALSE;
 8603|      0|    }
 8604|      0|}
 8605|       |
 8606|       |/* set the array length and remove the array elements if necessary. */
 8607|       |static int set_array_length(JSContext *ctx, JSObject *p, JSValue val,
 8608|       |                            int flags)
 8609|   171k|{
 8610|   171k|    uint32_t len, idx, cur_len;
 8611|   171k|    int i, ret;
 8612|       |
 8613|       |    /* Note: this call can reallocate the properties of 'p' */
 8614|   171k|    ret = JS_ToArrayLengthFree(ctx, &len, val, FALSE);
 8615|   171k|    if (ret)
 8616|      0|        return -1;
 8617|       |    /* JS_ToArrayLengthFree() must be done before the read-only test */
 8618|   171k|    if (unlikely(!(p->shape->prop[0].flags & JS_PROP_WRITABLE)))
 8619|      0|        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);
 8620|       |
 8621|   171k|    if (likely(p->fast_array)) {
 8622|  1.28k|        uint32_t old_len = p->u.array.count;
 8623|  1.28k|        if (len < old_len) {
 8624|      0|            for(i = len; i < old_len; i++) {
 8625|      0|                JS_FreeValue(ctx, p->u.array.u.values[i]);
 8626|      0|            }
 8627|      0|            p->u.array.count = len;
 8628|      0|        }
 8629|  1.28k|        p->prop[0].u.value = JS_NewUint32(ctx, len);
 8630|   170k|    } else {
 8631|       |        /* Note: length is always a uint32 because the object is an
 8632|       |           array */
 8633|   170k|        JS_ToUint32(ctx, &cur_len, p->prop[0].u.value);
 8634|   170k|        if (len < cur_len) {
 8635|      0|            uint32_t d;
 8636|      0|            JSShape *sh;
 8637|      0|            JSShapeProperty *pr;
 8638|       |
 8639|      0|            d = cur_len - len;
 8640|      0|            sh = p->shape;
 8641|      0|            if (d <= sh->prop_count) {
 8642|      0|                JSAtom atom;
 8643|       |
 8644|       |                /* faster to iterate */
 8645|      0|                while (cur_len > len) {
 8646|      0|                    atom = JS_NewAtomUInt32(ctx, cur_len - 1);
 8647|      0|                    ret = delete_property(ctx, p, atom);
 8648|      0|                    JS_FreeAtom(ctx, atom);
 8649|      0|                    if (unlikely(!ret)) {
 8650|       |                        /* unlikely case: property is not
 8651|       |                           configurable */
 8652|      0|                        break;
 8653|      0|                    }
 8654|      0|                    cur_len--;
 8655|      0|                }
 8656|      0|            } else {
 8657|       |                /* faster to iterate thru all the properties. Need two
 8658|       |                   passes in case one of the property is not
 8659|       |                   configurable */
 8660|      0|                cur_len = len;
 8661|      0|                for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count;
 8662|      0|                    i++, pr++) {
 8663|      0|                    if (pr->atom != JS_ATOM_NULL &&
 8664|      0|                        JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {
 8665|      0|                        if (idx >= cur_len &&
 8666|      0|                            !(pr->flags & JS_PROP_CONFIGURABLE)) {
 8667|      0|                            cur_len = idx + 1;
 8668|      0|                        }
 8669|      0|                    }
 8670|      0|                }
 8671|       |
 8672|      0|                for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count;
 8673|      0|                    i++, pr++) {
 8674|      0|                    if (pr->atom != JS_ATOM_NULL &&
 8675|      0|                        JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {
 8676|      0|                        if (idx >= cur_len) {
 8677|       |                            /* remove the property */
 8678|      0|                            delete_property(ctx, p, pr->atom);
 8679|       |                            /* WARNING: the shape may have been modified */
 8680|      0|                            sh = p->shape;
 8681|      0|                            pr = get_shape_prop(sh) + i;
 8682|      0|                        }
 8683|      0|                    }
 8684|      0|                }
 8685|      0|            }
 8686|   170k|        } else {
 8687|   170k|            cur_len = len;
 8688|   170k|        }
 8689|   170k|        set_value(ctx, &p->prop[0].u.value, JS_NewUint32(ctx, cur_len));
 8690|   170k|        if (unlikely(cur_len > len)) {
 8691|      0|            return JS_ThrowTypeErrorOrFalse(ctx, flags, "not configurable");
 8692|      0|        }
 8693|   170k|    }
 8694|   171k|    return TRUE;
 8695|   171k|}
 8696|       |
 8697|       |/* return -1 if exception */
 8698|       |static int expand_fast_array(JSContext *ctx, JSObject *p, uint32_t new_len)
 8699|   206k|{
 8700|   206k|    uint32_t new_size;
 8701|   206k|    size_t slack;
 8702|   206k|    JSValue *new_array_prop;
 8703|       |    /* XXX: potential arithmetic overflow */
 8704|   206k|    new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);
 8705|   206k|    new_array_prop = js_realloc2(ctx, p->u.array.u.values, sizeof(JSValue) * new_size, &slack);
 8706|   206k|    if (!new_array_prop)
 8707|      0|        return -1;
 8708|   206k|    new_size += slack / sizeof(*new_array_prop);
 8709|   206k|    p->u.array.u.values = new_array_prop;
 8710|   206k|    p->u.array.u1.size = new_size;
 8711|   206k|    return 0;
 8712|   206k|}
 8713|       |
 8714|       |/* Preconditions: 'p' must be of class JS_CLASS_ARRAY, p->fast_array =
 8715|       |   TRUE and p->extensible = TRUE */
 8716|       |static int add_fast_array_element(JSContext *ctx, JSObject *p,
 8717|       |                                  JSValue val, int flags)
 8718|   209k|{
 8719|   209k|    uint32_t new_len, array_len;
 8720|       |    /* extend the array by one */
 8721|       |    /* XXX: convert to slow array if new_len > 2^31-1 elements */
 8722|   209k|    new_len = p->u.array.count + 1;
 8723|       |    /* update the length if necessary. We assume that if the length is
 8724|       |       not an integer, then if it >= 2^31.  */
 8725|   209k|    if (likely(JS_VALUE_GET_TAG(p->prop[0].u.value) == JS_TAG_INT)) {
 8726|   209k|        array_len = JS_VALUE_GET_INT(p->prop[0].u.value);
 8727|   209k|        if (new_len > array_len) {
 8728|   209k|            if (unlikely(!(get_shape_prop(p->shape)->flags & JS_PROP_WRITABLE))) {
 8729|      0|                JS_FreeValue(ctx, val);
 8730|      0|                return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);
 8731|      0|            }
 8732|   209k|            p->prop[0].u.value = JS_NewInt32(ctx, new_len);
 8733|   209k|        }
 8734|   209k|    }
 8735|   209k|    if (unlikely(new_len > p->u.array.u1.size)) {
 8736|   206k|        if (expand_fast_array(ctx, p, new_len)) {
 8737|      0|            JS_FreeValue(ctx, val);
 8738|      0|            return -1;
 8739|      0|        }
 8740|   206k|    }
 8741|   209k|    p->u.array.u.values[new_len - 1] = val;
 8742|   209k|    p->u.array.count = new_len;
 8743|   209k|    return TRUE;
 8744|   209k|}
 8745|       |
 8746|       |/* Allocate a new fast array. Its 'length' property is set to zero. It
 8747|       |   maximum size is 2^31-1 elements. For convenience, 'len' is a 64 bit
 8748|       |   integer. WARNING: the content of the array is not initialized. */
 8749|       |static JSValue js_allocate_fast_array(JSContext *ctx, int64_t len)
 8750|      0|{
 8751|      0|    JSValue arr;
 8752|      0|    JSObject *p;
 8753|       |
 8754|      0|    if (len > INT32_MAX)
 8755|      0|        return JS_ThrowRangeError(ctx, "invalid array length");
 8756|      0|    arr = JS_NewArray(ctx);
 8757|      0|    if (JS_IsException(arr))
 8758|      0|        return arr;
 8759|      0|    if (len > 0) {
 8760|      0|        p = JS_VALUE_GET_OBJ(arr);
 8761|      0|        if (expand_fast_array(ctx, p, len) < 0) {
 8762|      0|            JS_FreeValue(ctx, arr);
 8763|      0|            return JS_EXCEPTION;
 8764|      0|        }
 8765|      0|        p->u.array.count = len;
 8766|      0|    }
 8767|      0|    return arr;
 8768|      0|}
 8769|       |
 8770|       |static void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc)
 8771|  35.5k|{
 8772|  35.5k|    JS_FreeValue(ctx, desc->getter);
 8773|  35.5k|    JS_FreeValue(ctx, desc->setter);
 8774|  35.5k|    JS_FreeValue(ctx, desc->value);
 8775|  35.5k|}
 8776|       |
 8777|       |/* return -1 in case of exception or TRUE or FALSE. Warning: 'val' is
 8778|       |   freed by the function. 'flags' is a bitmask of JS_PROP_NO_ADD,
 8779|       |   JS_PROP_THROW or JS_PROP_THROW_STRICT. If JS_PROP_NO_ADD is set,
 8780|       |   the new property is not added and an error is raised. 'this_obj' is
 8781|       |   the receiver. If obj != this_obj, then obj must be an object
 8782|       |   (Reflect.set case). */
 8783|       |int JS_SetPropertyInternal(JSContext *ctx, JSValueConst obj,
 8784|       |                           JSAtom prop, JSValue val, JSValueConst this_obj, int flags)
 8785|  5.09M|{
 8786|  5.09M|    JSObject *p, *p1;
 8787|  5.09M|    JSShapeProperty *prs;
 8788|  5.09M|    JSProperty *pr;
 8789|  5.09M|    uint32_t tag;
 8790|  5.09M|    JSPropertyDescriptor desc;
 8791|  5.09M|    int ret;
 8792|       |#if 0
 8793|       |    printf("JS_SetPropertyInternal: "); print_atom(ctx, prop); printf("\n");
 8794|       |#endif
 8795|  5.09M|    tag = JS_VALUE_GET_TAG(this_obj);
 8796|  5.09M|    if (unlikely(tag != JS_TAG_OBJECT)) {
 8797|  35.3k|        if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
 8798|      0|            p = NULL;
 8799|      0|            p1 = JS_VALUE_GET_OBJ(obj);
 8800|      0|            goto prototype_lookup;
 8801|  35.3k|        } else {
 8802|  35.3k|            switch(tag) {
 8803|      0|            case JS_TAG_NULL:
 8804|      0|                JS_FreeValue(ctx, val);
 8805|      0|                JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of null", prop);
 8806|      0|                return -1;
 8807|     21|            case JS_TAG_UNDEFINED:
 8808|     21|                JS_FreeValue(ctx, val);
 8809|     21|                JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of undefined", prop);
 8810|     21|                return -1;
 8811|  35.3k|            default:
 8812|       |                /* even on a primitive type we can have setters on the prototype */
 8813|  35.3k|                p = NULL;
 8814|  35.3k|                p1 = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));
 8815|  35.3k|                goto prototype_lookup;
 8816|  35.3k|            }
 8817|  35.3k|        }
 8818|  5.06M|    } else {
 8819|  5.06M|        p = JS_VALUE_GET_OBJ(this_obj);
 8820|  5.06M|        p1 = JS_VALUE_GET_OBJ(obj);
 8821|  5.06M|        if (unlikely(p != p1))
 8822|      0|            goto retry2;
 8823|  5.06M|    }
 8824|       |
 8825|       |    /* fast path if obj == this_obj */
 8826|  5.06M| retry:
 8827|  5.06M|    prs = find_own_property(&pr, p1, prop);
 8828|  5.06M|    if (prs) {
 8829|  4.89M|        if (likely((prs->flags & (JS_PROP_TMASK | JS_PROP_WRITABLE |
 8830|  4.89M|                                  JS_PROP_LENGTH)) == JS_PROP_WRITABLE)) {
 8831|       |            /* fast case */
 8832|  4.71M|            set_value(ctx, &pr->u.value, val);
 8833|  4.71M|            return TRUE;
 8834|  4.71M|        } else if (prs->flags & JS_PROP_LENGTH) {
 8835|   171k|            assert(p->class_id == JS_CLASS_ARRAY);
 8836|   171k|            assert(prop == JS_ATOM_length);
 8837|   171k|            return set_array_length(ctx, p, val, flags);
 8838|   171k|        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 8839|      0|            return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
 8840|    166|        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 8841|       |            /* JS_PROP_WRITABLE is always true for variable
 8842|       |               references, but they are write protected in module name
 8843|       |               spaces. */
 8844|    166|            if (p->class_id == JS_CLASS_MODULE_NS)
 8845|      0|                goto read_only_prop;
 8846|    166|            set_value(ctx, pr->u.var_ref->pvalue, val);
 8847|    166|            return TRUE;
 8848|    166|        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 8849|       |            /* Instantiate property and retry (potentially useless) */
 8850|      0|            if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) {
 8851|      0|                JS_FreeValue(ctx, val);
 8852|      0|                return -1;
 8853|      0|            }
 8854|      0|            goto retry;
 8855|      0|        } else {
 8856|      0|            goto read_only_prop;
 8857|      0|        }
 8858|  4.89M|    }
 8859|       |
 8860|   445k|    for(;;) {
 8861|   445k|        if (p1->is_exotic) {
 8862|  73.2k|            if (p1->fast_array) {
 8863|  52.2k|                if (__JS_AtomIsTaggedInt(prop)) {
 8864|  11.7k|                    uint32_t idx = __JS_AtomToUInt32(prop);
 8865|  11.7k|                    if (idx < p1->u.array.count) {
 8866|    123|                        if (unlikely(p == p1))
 8867|    123|                            return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), val, flags);
 8868|      0|                        else
 8869|      0|                            break;
 8870|  11.6k|                    } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&
 8871|  11.6k|                               p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 8872|      0|                        goto typed_array_oob;
 8873|      0|                    }
 8874|  40.4k|                } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&
 8875|  40.4k|                           p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 8876|      0|                    ret = JS_AtomIsNumericIndex(ctx, prop);
 8877|      0|                    if (ret != 0) {
 8878|      0|                        if (ret < 0) {
 8879|      0|                            JS_FreeValue(ctx, val);
 8880|      0|                            return -1;
 8881|      0|                        }
 8882|      0|                    typed_array_oob:
 8883|      0|                        if (p == p1) {
 8884|       |                            /* must convert the argument even if out of bound access */
 8885|      0|                            if (p1->class_id == JS_CLASS_BIG_INT64_ARRAY ||
 8886|      0|                                p1->class_id == JS_CLASS_BIG_UINT64_ARRAY) {
 8887|      0|                                int64_t v;
 8888|      0|                                if (JS_ToBigInt64Free(ctx, &v, val))
 8889|      0|                                    return -1;
 8890|      0|                            } else {
 8891|      0|                                val = JS_ToNumberFree(ctx, val);
 8892|      0|                                JS_FreeValue(ctx, val);
 8893|      0|                                if (JS_IsException(val))
 8894|      0|                                    return -1;
 8895|      0|                            }
 8896|      0|                        } else {
 8897|      0|                            JS_FreeValue(ctx, val);
 8898|      0|                        }
 8899|      0|                        return TRUE;
 8900|      0|                    }
 8901|      0|                }
 8902|  52.2k|            } else {
 8903|  20.9k|                const JSClassExoticMethods *em = ctx->rt->class_array[p1->class_id].exotic;
 8904|  20.9k|                if (em) {
 8905|  20.6k|                    JSValue obj1;
 8906|  20.6k|                    if (em->set_property) {
 8907|       |                        /* set_property can free the prototype */
 8908|      0|                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));
 8909|      0|                        ret = em->set_property(ctx, obj1, prop,
 8910|      0|                                               val, this_obj, flags);
 8911|      0|                        JS_FreeValue(ctx, obj1);
 8912|      0|                        JS_FreeValue(ctx, val);
 8913|      0|                        return ret;
 8914|      0|                    }
 8915|  20.6k|                    if (em->get_own_property) {
 8916|       |                        /* get_own_property can free the prototype */
 8917|  20.6k|                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));
 8918|  20.6k|                        ret = em->get_own_property(ctx, &desc,
 8919|  20.6k|                                                   obj1, prop);
 8920|  20.6k|                        JS_FreeValue(ctx, obj1);
 8921|  20.6k|                        if (ret < 0) {
 8922|      0|                            JS_FreeValue(ctx, val);
 8923|      0|                            return ret;
 8924|      0|                        }
 8925|  20.6k|                        if (ret) {
 8926|      0|                            if (desc.flags & JS_PROP_GETSET) {
 8927|      0|                                JSObject *setter;
 8928|      0|                                if (JS_IsUndefined(desc.setter))
 8929|      0|                                    setter = NULL;
 8930|      0|                                else
 8931|      0|                                    setter = JS_VALUE_GET_OBJ(desc.setter);
 8932|      0|                                ret = call_setter(ctx, setter, this_obj, val, flags);
 8933|      0|                                JS_FreeValue(ctx, desc.getter);
 8934|      0|                                JS_FreeValue(ctx, desc.setter);
 8935|      0|                                return ret;
 8936|      0|                            } else {
 8937|      0|                                JS_FreeValue(ctx, desc.value);
 8938|      0|                                if (!(desc.flags & JS_PROP_WRITABLE))
 8939|      0|                                    goto read_only_prop;
 8940|      0|                                if (likely(p == p1)) {
 8941|      0|                                    ret = JS_DefineProperty(ctx, this_obj, prop, val,
 8942|      0|                                                            JS_UNDEFINED, JS_UNDEFINED,
 8943|      0|                                                            JS_PROP_HAS_VALUE);
 8944|      0|                                    JS_FreeValue(ctx, val);
 8945|      0|                                    return ret;
 8946|      0|                                } else {
 8947|      0|                                    break;
 8948|      0|                                }
 8949|      0|                            }
 8950|      0|                        }
 8951|  20.6k|                    }
 8952|  20.6k|                }
 8953|  20.9k|            }
 8954|  73.2k|        }
 8955|   445k|        p1 = p1->shape->proto;
 8956|   480k|    prototype_lookup:
 8957|   480k|        if (!p1)
 8958|   203k|            break;
 8959|       |
 8960|   276k|    retry2:
 8961|   276k|        prs = find_own_property(&pr, p1, prop);
 8962|   276k|        if (prs) {
 8963|  1.54k|            if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 8964|      0|                return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
 8965|  1.54k|            } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 8966|       |                /* Instantiate property and retry (potentially useless) */
 8967|      8|                if (JS_AutoInitProperty(ctx, p1, prop, pr, prs))
 8968|      0|                    return -1;
 8969|      8|                goto retry2;
 8970|  1.53k|            } else if (!(prs->flags & JS_PROP_WRITABLE)) {
 8971|      0|                goto read_only_prop;
 8972|  1.53k|            } else {
 8973|  1.53k|                break;
 8974|  1.53k|            }
 8975|  1.54k|        }
 8976|   276k|    }
 8977|       |
 8978|   205k|    if (unlikely(flags & JS_PROP_NO_ADD)) {
 8979|      0|        JS_FreeValue(ctx, val);
 8980|      0|        JS_ThrowReferenceErrorNotDefined(ctx, prop);
 8981|      0|        return -1;
 8982|      0|    }
 8983|       |
 8984|   205k|    if (unlikely(!p)) {
 8985|  35.3k|        JS_FreeValue(ctx, val);
 8986|  35.3k|        return JS_ThrowTypeErrorOrFalse(ctx, flags, "not an object");
 8987|  35.3k|    }
 8988|       |
 8989|   170k|    if (unlikely(!p->extensible)) {
 8990|      0|        JS_FreeValue(ctx, val);
 8991|      0|        return JS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
 8992|      0|    }
 8993|       |
 8994|   170k|    if (likely(p == JS_VALUE_GET_OBJ(obj))) {
 8995|   170k|        if (p->is_exotic) {
 8996|  26.2k|            if (p->class_id == JS_CLASS_ARRAY && p->fast_array &&
 8997|  26.2k|                __JS_AtomIsTaggedInt(prop)) {
 8998|  5.80k|                uint32_t idx = __JS_AtomToUInt32(prop);
 8999|  5.80k|                if (idx == p->u.array.count) {
 9000|       |                    /* fast case */
 9001|      1|                    return add_fast_array_element(ctx, p, val, flags);
 9002|  5.80k|                } else {
 9003|  5.80k|                    goto generic_create_prop;
 9004|  5.80k|                }
 9005|  20.4k|            } else {
 9006|  20.4k|                goto generic_create_prop;
 9007|  20.4k|            }
 9008|   143k|        } else {
 9009|   143k|            pr = add_property(ctx, p, prop, JS_PROP_C_W_E);
 9010|   143k|            if (unlikely(!pr)) {
 9011|      0|                JS_FreeValue(ctx, val);
 9012|      0|                return -1;
 9013|      0|            }
 9014|   143k|            pr->u.value = val;
 9015|   143k|            return TRUE;
 9016|   143k|        }
 9017|   170k|    } else {
 9018|       |        /* generic case: modify the property in this_obj if it already exists */
 9019|      0|        ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
 9020|      0|        if (ret < 0) {
 9021|      0|            JS_FreeValue(ctx, val);
 9022|      0|            return ret;
 9023|      0|        }
 9024|      0|        if (ret) {
 9025|      0|            if (desc.flags & JS_PROP_GETSET) {
 9026|      0|                JS_FreeValue(ctx, desc.getter);
 9027|      0|                JS_FreeValue(ctx, desc.setter);
 9028|      0|                JS_FreeValue(ctx, val);
 9029|      0|                return JS_ThrowTypeErrorOrFalse(ctx, flags, "setter is forbidden");
 9030|      0|            } else {
 9031|      0|                JS_FreeValue(ctx, desc.value);
 9032|      0|                if (!(desc.flags & JS_PROP_WRITABLE) ||
 9033|      0|                    p->class_id == JS_CLASS_MODULE_NS) {
 9034|      0|                read_only_prop:
 9035|      0|                    JS_FreeValue(ctx, val);
 9036|      0|                    return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
 9037|      0|                }
 9038|      0|            }
 9039|      0|            ret = JS_DefineProperty(ctx, this_obj, prop, val,
 9040|      0|                                    JS_UNDEFINED, JS_UNDEFINED,
 9041|      0|                                    JS_PROP_HAS_VALUE);
 9042|      0|            JS_FreeValue(ctx, val);
 9043|      0|            return ret;
 9044|      0|        } else {
 9045|  26.2k|        generic_create_prop:
 9046|  26.2k|            ret = JS_CreateProperty(ctx, p, prop, val, JS_UNDEFINED, JS_UNDEFINED,
 9047|  26.2k|                                    flags |
 9048|  26.2k|                                    JS_PROP_HAS_VALUE |
 9049|  26.2k|                                    JS_PROP_HAS_ENUMERABLE |
 9050|  26.2k|                                    JS_PROP_HAS_WRITABLE |
 9051|  26.2k|                                    JS_PROP_HAS_CONFIGURABLE |
 9052|  26.2k|                                    JS_PROP_C_W_E);
 9053|  26.2k|            JS_FreeValue(ctx, val);
 9054|  26.2k|            return ret;
 9055|      0|        }
 9056|      0|    }
 9057|   170k|}
 9058|       |
 9059|       |/* flags can be JS_PROP_THROW or JS_PROP_THROW_STRICT */
 9060|       |static int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,
 9061|       |                               JSValue prop, JSValue val, int flags)
 9062|  57.1k|{
 9063|  57.1k|    if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&
 9064|  57.1k|               JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {
 9065|  23.7k|        JSObject *p;
 9066|  23.7k|        uint32_t idx;
 9067|  23.7k|        double d;
 9068|  23.7k|        int32_t v;
 9069|       |
 9070|       |        /* fast path for array access */
 9071|  23.7k|        p = JS_VALUE_GET_OBJ(this_obj);
 9072|  23.7k|        idx = JS_VALUE_GET_INT(prop);
 9073|  23.7k|        switch(p->class_id) {
 9074|  23.6k|        case JS_CLASS_ARRAY:
 9075|  23.6k|            if (unlikely(idx >= (uint32_t)p->u.array.count)) {
 9076|  23.5k|                JSObject *p1;
 9077|  23.5k|                JSShape *sh1;
 9078|       |
 9079|       |                /* fast path to add an element to the array */
 9080|  23.5k|                if (idx != (uint32_t)p->u.array.count ||
 9081|  23.5k|                    !p->fast_array || !p->extensible)
 9082|  5.80k|                    goto slow_path;
 9083|       |                /* check if prototype chain has a numeric property */
 9084|  17.7k|                p1 = p->shape->proto;
 9085|  53.3k|                while (p1 != NULL) {
 9086|  35.5k|                    sh1 = p1->shape;
 9087|  35.5k|                    if (p1->class_id == JS_CLASS_ARRAY) {
 9088|  17.7k|                        if (unlikely(!p1->fast_array))
 9089|      0|                            goto slow_path;
 9090|  17.7k|                    } else if (p1->class_id == JS_CLASS_OBJECT) {
 9091|  17.7k|                        if (unlikely(sh1->has_small_array_index))
 9092|      0|                            goto slow_path;
 9093|  17.7k|                    } else {
 9094|      0|                        goto slow_path;
 9095|      0|                    }
 9096|  35.5k|                    p1 = sh1->proto;
 9097|  35.5k|                }
 9098|       |                /* add element */
 9099|  17.7k|                return add_fast_array_element(ctx, p, val, flags);
 9100|  17.7k|            }
 9101|    123|            set_value(ctx, &p->u.array.u.values[idx], val);
 9102|    123|            break;
 9103|      0|        case JS_CLASS_ARGUMENTS:
 9104|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count))
 9105|      0|                goto slow_path;
 9106|      0|            set_value(ctx, &p->u.array.u.values[idx], val);
 9107|      0|            break;
 9108|      0|        case JS_CLASS_UINT8C_ARRAY:
 9109|      0|            if (JS_ToUint8ClampFree(ctx, &v, val))
 9110|      0|                return -1;
 9111|       |            /* Note: the conversion can detach the typed array, so the
 9112|       |               array bound check must be done after */
 9113|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count))
 9114|      0|                goto ta_out_of_bound;
 9115|      0|            p->u.array.u.uint8_ptr[idx] = v;
 9116|      0|            break;
 9117|      0|        case JS_CLASS_INT8_ARRAY:
 9118|      0|        case JS_CLASS_UINT8_ARRAY:
 9119|      0|            if (JS_ToInt32Free(ctx, &v, val))
 9120|      0|                return -1;
 9121|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count))
 9122|      0|                goto ta_out_of_bound;
 9123|      0|            p->u.array.u.uint8_ptr[idx] = v;
 9124|      0|            break;
 9125|      0|        case JS_CLASS_INT16_ARRAY:
 9126|      0|        case JS_CLASS_UINT16_ARRAY:
 9127|      0|            if (JS_ToInt32Free(ctx, &v, val))
 9128|      0|                return -1;
 9129|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count))
 9130|      0|                goto ta_out_of_bound;
 9131|      0|            p->u.array.u.uint16_ptr[idx] = v;
 9132|      0|            break;
 9133|      0|        case JS_CLASS_INT32_ARRAY:
 9134|      0|        case JS_CLASS_UINT32_ARRAY:
 9135|      0|            if (JS_ToInt32Free(ctx, &v, val))
 9136|      0|                return -1;
 9137|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count))
 9138|      0|                goto ta_out_of_bound;
 9139|      0|            p->u.array.u.uint32_ptr[idx] = v;
 9140|      0|            break;
 9141|      0|        case JS_CLASS_BIG_INT64_ARRAY:
 9142|      0|        case JS_CLASS_BIG_UINT64_ARRAY:
 9143|       |            /* XXX: need specific conversion function */
 9144|      0|            {
 9145|      0|                int64_t v;
 9146|      0|                if (JS_ToBigInt64Free(ctx, &v, val))
 9147|      0|                    return -1;
 9148|      0|                if (unlikely(idx >= (uint32_t)p->u.array.count))
 9149|      0|                    goto ta_out_of_bound;
 9150|      0|                p->u.array.u.uint64_ptr[idx] = v;
 9151|      0|            }
 9152|      0|            break;
 9153|      0|        case JS_CLASS_FLOAT32_ARRAY:
 9154|      0|            if (JS_ToFloat64Free(ctx, &d, val))
 9155|      0|                return -1;
 9156|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count))
 9157|      0|                goto ta_out_of_bound;
 9158|      0|            p->u.array.u.float_ptr[idx] = d;
 9159|      0|            break;
 9160|      0|        case JS_CLASS_FLOAT64_ARRAY:
 9161|      0|            if (JS_ToFloat64Free(ctx, &d, val))
 9162|      0|                return -1;
 9163|      0|            if (unlikely(idx >= (uint32_t)p->u.array.count)) {
 9164|      0|            ta_out_of_bound:
 9165|      0|                return TRUE;
 9166|      0|            }
 9167|      0|            p->u.array.u.double_ptr[idx] = d;
 9168|      0|            break;
 9169|      4|        default:
 9170|      4|            goto slow_path;
 9171|  23.7k|        }
 9172|    123|        return TRUE;
 9173|  33.4k|    } else {
 9174|  33.4k|        JSAtom atom;
 9175|  33.4k|        int ret;
 9176|  39.2k|    slow_path:
 9177|  39.2k|        atom = JS_ValueToAtom(ctx, prop);
 9178|  39.2k|        JS_FreeValue(ctx, prop);
 9179|  39.2k|        if (unlikely(atom == JS_ATOM_NULL)) {
 9180|      0|            JS_FreeValue(ctx, val);
 9181|      0|            return -1;
 9182|      0|        }
 9183|  39.2k|        ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, this_obj, flags);
 9184|  39.2k|        JS_FreeAtom(ctx, atom);
 9185|  39.2k|        return ret;
 9186|  39.2k|    }
 9187|  57.1k|}
 9188|       |
 9189|       |int JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
 9190|       |                         uint32_t idx, JSValue val)
 9191|  17.7k|{
 9192|  17.7k|    return JS_SetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx), val,
 9193|  17.7k|                               JS_PROP_THROW);
 9194|  17.7k|}
 9195|       |
 9196|       |int JS_SetPropertyInt64(JSContext *ctx, JSValueConst this_obj,
 9197|       |                        int64_t idx, JSValue val)
 9198|      0|{
 9199|      0|    JSAtom prop;
 9200|      0|    int res;
 9201|       |
 9202|      0|    if ((uint64_t)idx <= INT32_MAX) {
 9203|       |        /* fast path for fast arrays */
 9204|      0|        return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), val,
 9205|      0|                                   JS_PROP_THROW);
 9206|      0|    }
 9207|      0|    prop = JS_NewAtomInt64(ctx, idx);
 9208|      0|    if (prop == JS_ATOM_NULL) {
 9209|      0|        JS_FreeValue(ctx, val);
 9210|      0|        return -1;
 9211|      0|    }
 9212|      0|    res = JS_SetProperty(ctx, this_obj, prop, val);
 9213|      0|    JS_FreeAtom(ctx, prop);
 9214|      0|    return res;
 9215|      0|}
 9216|       |
 9217|       |int JS_SetPropertyStr(JSContext *ctx, JSValueConst this_obj,
 9218|       |                      const char *prop, JSValue val)
 9219|   124k|{
 9220|   124k|    JSAtom atom;
 9221|   124k|    int ret;
 9222|   124k|    atom = JS_NewAtom(ctx, prop);
 9223|   124k|    ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, this_obj, JS_PROP_THROW);
 9224|   124k|    JS_FreeAtom(ctx, atom);
 9225|   124k|    return ret;
 9226|   124k|}
 9227|       |
 9228|       |/* compute the property flags. For each flag: (JS_PROP_HAS_x forces
 9229|       |   it, otherwise def_flags is used)
 9230|       |   Note: makes assumption about the bit pattern of the flags
 9231|       |*/
 9232|       |static int get_prop_flags(int flags, int def_flags)
 9233|  1.26M|{
 9234|  1.26M|    int mask;
 9235|  1.26M|    mask = (flags >> JS_PROP_HAS_SHIFT) & JS_PROP_C_W_E;
 9236|  1.26M|    return (flags & mask) | (def_flags & ~mask);
 9237|  1.26M|}
 9238|       |
 9239|       |static int JS_CreateProperty(JSContext *ctx, JSObject *p,
 9240|       |                             JSAtom prop, JSValueConst val,
 9241|       |                             JSValueConst getter, JSValueConst setter,
 9242|       |                             int flags)
 9243|  13.5M|{
 9244|  13.5M|    JSProperty *pr;
 9245|  13.5M|    int ret, prop_flags;
 9246|       |
 9247|       |    /* add a new property or modify an existing exotic one */
 9248|  13.5M|    if (p->is_exotic) {
 9249|  3.92M|        if (p->class_id == JS_CLASS_ARRAY) {
 9250|  3.39M|            uint32_t idx, len;
 9251|       |
 9252|  3.39M|            if (p->fast_array) {
 9253|  2.07M|                if (__JS_AtomIsTaggedInt(prop)) {
 9254|  1.47M|                    idx = __JS_AtomToUInt32(prop);
 9255|  1.47M|                    if (idx == p->u.array.count) {
 9256|  1.26M|                        if (!p->extensible)
 9257|      0|                            goto not_extensible;
 9258|  1.26M|                        if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET))
 9259|      0|                            goto convert_to_array;
 9260|  1.26M|                        prop_flags = get_prop_flags(flags, 0);
 9261|  1.26M|                        if (prop_flags != JS_PROP_C_W_E)
 9262|  1.06M|                            goto convert_to_array;
 9263|   192k|                        return add_fast_array_element(ctx, p,
 9264|   192k|                                                      JS_DupValue(ctx, val), flags);
 9265|  1.26M|                    } else {
 9266|   208k|                        goto convert_to_array;
 9267|   208k|                    }
 9268|  1.47M|                } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {
 9269|       |                    /* convert the fast array to normal array */
 9270|  1.27M|                convert_to_array:
 9271|  1.27M|                    if (convert_fast_array_to_array(ctx, p))
 9272|      0|                        return -1;
 9273|  1.27M|                    goto generic_array;
 9274|  1.27M|                }
 9275|  2.07M|            } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {
 9276|  1.31M|                JSProperty *plen;
 9277|  1.31M|                JSShapeProperty *pslen;
 9278|  2.58M|            generic_array:
 9279|       |                /* update the length field */
 9280|  2.58M|                plen = &p->prop[0];
 9281|  2.58M|                JS_ToUint32(ctx, &len, plen->u.value);
 9282|  2.58M|                if ((idx + 1) > len) {
 9283|  2.58M|                    pslen = get_shape_prop(p->shape);
 9284|  2.58M|                    if (unlikely(!(pslen->flags & JS_PROP_WRITABLE)))
 9285|      0|                        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);
 9286|       |                    /* XXX: should update the length after defining
 9287|       |                       the property */
 9288|  2.58M|                    len = idx + 1;
 9289|  2.58M|                    set_value(ctx, &plen->u.value, JS_NewUint32(ctx, len));
 9290|  2.58M|                }
 9291|  2.58M|            }
 9292|  3.39M|        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
 9293|   535k|                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 9294|      0|            ret = JS_AtomIsNumericIndex(ctx, prop);
 9295|      0|            if (ret != 0) {
 9296|      0|                if (ret < 0)
 9297|      0|                    return -1;
 9298|      0|                return JS_ThrowTypeErrorOrFalse(ctx, flags, "cannot create numeric index in typed array");
 9299|      0|            }
 9300|   535k|        } else if (!(flags & JS_PROP_NO_EXOTIC)) {
 9301|   267k|            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
 9302|   267k|            if (em) {
 9303|   267k|                if (em->define_own_property) {
 9304|   267k|                    return em->define_own_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p),
 9305|   267k|                                                   prop, val, getter, setter, flags);
 9306|   267k|                }
 9307|      0|                ret = JS_IsExtensible(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
 9308|      0|                if (ret < 0)
 9309|      0|                    return -1;
 9310|      0|                if (!ret)
 9311|      0|                    goto not_extensible;
 9312|      0|            }
 9313|   267k|        }
 9314|  3.92M|    }
 9315|       |
 9316|  13.0M|    if (!p->extensible) {
 9317|      0|    not_extensible:
 9318|      0|        return JS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
 9319|      0|    }
 9320|       |
 9321|  13.0M|    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
 9322|   639k|        prop_flags = (flags & (JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE)) |
 9323|   639k|            JS_PROP_GETSET;
 9324|  12.4M|    } else {
 9325|  12.4M|        prop_flags = flags & JS_PROP_C_W_E;
 9326|  12.4M|    }
 9327|  13.0M|    pr = add_property(ctx, p, prop, prop_flags);
 9328|  13.0M|    if (unlikely(!pr))
 9329|      0|        return -1;
 9330|  13.0M|    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
 9331|   639k|        pr->u.getset.getter = NULL;
 9332|   639k|        if ((flags & JS_PROP_HAS_GET) && JS_IsFunction(ctx, getter)) {
 9333|   639k|            pr->u.getset.getter =
 9334|   639k|                JS_VALUE_GET_OBJ(JS_DupValue(ctx, getter));
 9335|   639k|        }
 9336|   639k|        pr->u.getset.setter = NULL;
 9337|   639k|        if ((flags & JS_PROP_HAS_SET) && JS_IsFunction(ctx, setter)) {
 9338|  53.3k|            pr->u.getset.setter =
 9339|  53.3k|                JS_VALUE_GET_OBJ(JS_DupValue(ctx, setter));
 9340|  53.3k|        }
 9341|  12.4M|    } else {
 9342|  12.4M|        if (flags & JS_PROP_HAS_VALUE) {
 9343|  12.4M|            pr->u.value = JS_DupValue(ctx, val);
 9344|  12.4M|        } else {
 9345|      0|            pr->u.value = JS_UNDEFINED;
 9346|      0|        }
 9347|  12.4M|    }
 9348|  13.0M|    return TRUE;
 9349|  13.0M|}
 9350|       |
 9351|       |/* return FALSE if not OK */
 9352|       |static BOOL check_define_prop_flags(int prop_flags, int flags)
 9353|   110k|{
 9354|   110k|    BOOL has_accessor, is_getset;
 9355|       |
 9356|   110k|    if (!(prop_flags & JS_PROP_CONFIGURABLE)) {
 9357|      0|        if ((flags & (JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE)) ==
 9358|      0|            (JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE)) {
 9359|      0|            return FALSE;
 9360|      0|        }
 9361|      0|        if ((flags & JS_PROP_HAS_ENUMERABLE) &&
 9362|      0|            (flags & JS_PROP_ENUMERABLE) != (prop_flags & JS_PROP_ENUMERABLE))
 9363|      0|            return FALSE;
 9364|      0|    }
 9365|   110k|    if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |
 9366|   110k|                 JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
 9367|  74.5k|        if (!(prop_flags & JS_PROP_CONFIGURABLE)) {
 9368|      0|            has_accessor = ((flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) != 0);
 9369|      0|            is_getset = ((prop_flags & JS_PROP_TMASK) == JS_PROP_GETSET);
 9370|      0|            if (has_accessor != is_getset)
 9371|      0|                return FALSE;
 9372|      0|            if (!has_accessor && !is_getset && !(prop_flags & JS_PROP_WRITABLE)) {
 9373|       |                /* not writable: cannot set the writable bit */
 9374|      0|                if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==
 9375|      0|                    (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE))
 9376|      0|                    return FALSE;
 9377|      0|            }
 9378|      0|        }
 9379|  74.5k|    }
 9380|   110k|    return TRUE;
 9381|   110k|}
 9382|       |
 9383|       |/* ensure that the shape can be safely modified */
 9384|       |static int js_shape_prepare_update(JSContext *ctx, JSObject *p,
 9385|       |                                   JSShapeProperty **pprs)
 9386|  2.58M|{
 9387|  2.58M|    JSShape *sh;
 9388|  2.58M|    uint32_t idx = 0;    /* prevent warning */
 9389|       |
 9390|  2.58M|    sh = p->shape;
 9391|  2.58M|    if (sh->is_hashed) {
 9392|  1.43M|        if (sh->header.ref_count != 1) {
 9393|   743k|            if (pprs)
 9394|    225|                idx = *pprs - get_shape_prop(sh);
 9395|       |            /* clone the shape (the resulting one is no longer hashed) */
 9396|   743k|            sh = js_clone_shape(ctx, sh);
 9397|   743k|            if (!sh)
 9398|      0|                return -1;
 9399|   743k|            js_free_shape(ctx->rt, p->shape);
 9400|   743k|            p->shape = sh;
 9401|   743k|            if (pprs)
 9402|    225|                *pprs = get_shape_prop(sh) + idx;
 9403|   743k|        } else {
 9404|   696k|            js_shape_hash_unlink(ctx->rt, sh);
 9405|   696k|            sh->is_hashed = FALSE;
 9406|   696k|        }
 9407|  1.43M|    }
 9408|  2.58M|    return 0;
 9409|  2.58M|}
 9410|       |
 9411|       |static int js_update_property_flags(JSContext *ctx, JSObject *p,
 9412|       |                                    JSShapeProperty **pprs, int flags)
 9413|  1.25M|{
 9414|  1.25M|    if (flags != (*pprs)->flags) {
 9415|  1.10M|        if (js_shape_prepare_update(ctx, p, pprs))
 9416|      0|            return -1;
 9417|  1.10M|        (*pprs)->flags = flags;
 9418|  1.10M|    }
 9419|  1.25M|    return 0;
 9420|  1.25M|}
 9421|       |
 9422|       |/* allowed flags:
 9423|       |   JS_PROP_CONFIGURABLE, JS_PROP_WRITABLE, JS_PROP_ENUMERABLE
 9424|       |   JS_PROP_HAS_GET, JS_PROP_HAS_SET, JS_PROP_HAS_VALUE,
 9425|       |   JS_PROP_HAS_CONFIGURABLE, JS_PROP_HAS_WRITABLE, JS_PROP_HAS_ENUMERABLE,
 9426|       |   JS_PROP_THROW, JS_PROP_NO_EXOTIC.
 9427|       |   If JS_PROP_THROW is set, return an exception instead of FALSE.
 9428|       |   if JS_PROP_NO_EXOTIC is set, do not call the exotic
 9429|       |   define_own_property callback.
 9430|       |   return -1 (exception), FALSE or TRUE.
 9431|       |*/
 9432|       |int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
 9433|       |                      JSAtom prop, JSValueConst val,
 9434|       |                      JSValueConst getter, JSValueConst setter, int flags)
 9435|  13.6M|{
 9436|  13.6M|    JSObject *p;
 9437|  13.6M|    JSShapeProperty *prs;
 9438|  13.6M|    JSProperty *pr;
 9439|  13.6M|    int mask, res;
 9440|       |
 9441|  13.6M|    if (JS_VALUE_GET_TAG(this_obj) != JS_TAG_OBJECT) {
 9442|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
 9443|      0|        return -1;
 9444|      0|    }
 9445|  13.6M|    p = JS_VALUE_GET_OBJ(this_obj);
 9446|       |
 9447|  13.6M| redo_prop_update:
 9448|  13.6M|    prs = find_own_property(&pr, p, prop);
 9449|  13.6M|    if (prs) {
 9450|       |        /* the range of the Array length property is always tested before */
 9451|   110k|        if ((prs->flags & JS_PROP_LENGTH) && (flags & JS_PROP_HAS_VALUE)) {
 9452|      0|            uint32_t array_length;
 9453|      0|            if (JS_ToArrayLengthFree(ctx, &array_length,
 9454|      0|                                     JS_DupValue(ctx, val), FALSE)) {
 9455|      0|                return -1;
 9456|      0|            }
 9457|       |            /* this code relies on the fact that Uint32 are never allocated */
 9458|      0|            val = (JSValueConst)JS_NewUint32(ctx, array_length);
 9459|       |            /* prs may have been modified */
 9460|      0|            prs = find_own_property(&pr, p, prop);
 9461|      0|            assert(prs != NULL);
 9462|      0|        }
 9463|       |        /* property already exists */
 9464|   110k|        if (!check_define_prop_flags(prs->flags, flags)) {
 9465|      0|        not_configurable:
 9466|      0|            return JS_ThrowTypeErrorOrFalse(ctx, flags, "property is not configurable");
 9467|      0|        }
 9468|       |
 9469|   110k|        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
 9470|       |            /* Instantiate property and retry */
 9471|      0|            if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
 9472|      0|                return -1;
 9473|      0|            goto redo_prop_update;
 9474|      0|        }
 9475|       |
 9476|   110k|        if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |
 9477|   110k|                     JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
 9478|  74.5k|            if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
 9479|      0|                JSObject *new_getter, *new_setter;
 9480|       |
 9481|      0|                if (JS_IsFunction(ctx, getter)) {
 9482|      0|                    new_getter = JS_VALUE_GET_OBJ(getter);
 9483|      0|                } else {
 9484|      0|                    new_getter = NULL;
 9485|      0|                }
 9486|      0|                if (JS_IsFunction(ctx, setter)) {
 9487|      0|                    new_setter = JS_VALUE_GET_OBJ(setter);
 9488|      0|                } else {
 9489|      0|                    new_setter = NULL;
 9490|      0|                }
 9491|       |
 9492|      0|                if ((prs->flags & JS_PROP_TMASK) != JS_PROP_GETSET) {
 9493|      0|                    if (js_shape_prepare_update(ctx, p, &prs))
 9494|      0|                        return -1;
 9495|       |                    /* convert to getset */
 9496|      0|                    if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 9497|      0|                        free_var_ref(ctx->rt, pr->u.var_ref);
 9498|      0|                    } else {
 9499|      0|                        JS_FreeValue(ctx, pr->u.value);
 9500|      0|                    }
 9501|      0|                    prs->flags = (prs->flags &
 9502|      0|                                  (JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE)) |
 9503|      0|                        JS_PROP_GETSET;
 9504|      0|                    pr->u.getset.getter = NULL;
 9505|      0|                    pr->u.getset.setter = NULL;
 9506|      0|                } else {
 9507|      0|                    if (!(prs->flags & JS_PROP_CONFIGURABLE)) {
 9508|      0|                        if ((flags & JS_PROP_HAS_GET) &&
 9509|      0|                            new_getter != pr->u.getset.getter) {
 9510|      0|                            goto not_configurable;
 9511|      0|                        }
 9512|      0|                        if ((flags & JS_PROP_HAS_SET) &&
 9513|      0|                            new_setter != pr->u.getset.setter) {
 9514|      0|                            goto not_configurable;
 9515|      0|                        }
 9516|      0|                    }
 9517|      0|                }
 9518|      0|                if (flags & JS_PROP_HAS_GET) {
 9519|      0|                    if (pr->u.getset.getter)
 9520|      0|                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));
 9521|      0|                    if (new_getter)
 9522|      0|                        JS_DupValue(ctx, getter);
 9523|      0|                    pr->u.getset.getter = new_getter;
 9524|      0|                }
 9525|      0|                if (flags & JS_PROP_HAS_SET) {
 9526|      0|                    if (pr->u.getset.setter)
 9527|      0|                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));
 9528|      0|                    if (new_setter)
 9529|      0|                        JS_DupValue(ctx, setter);
 9530|      0|                    pr->u.getset.setter = new_setter;
 9531|      0|                }
 9532|  74.5k|            } else {
 9533|  74.5k|                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
 9534|       |                    /* convert to data descriptor */
 9535|      0|                    if (js_shape_prepare_update(ctx, p, &prs))
 9536|      0|                        return -1;
 9537|      0|                    if (pr->u.getset.getter)
 9538|      0|                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));
 9539|      0|                    if (pr->u.getset.setter)
 9540|      0|                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));
 9541|      0|                    prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);
 9542|      0|                    pr->u.value = JS_UNDEFINED;
 9543|  74.5k|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 9544|       |                    /* Note: JS_PROP_VARREF is always writable */
 9545|  74.5k|                } else {
 9546|  74.5k|                    if ((prs->flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0 &&
 9547|  74.5k|                        (flags & JS_PROP_HAS_VALUE)) {
 9548|      0|                        if (!js_same_value(ctx, val, pr->u.value)) {
 9549|      0|                            goto not_configurable;
 9550|      0|                        } else {
 9551|      0|                            return TRUE;
 9552|      0|                        }
 9553|      0|                    }
 9554|  74.5k|                }
 9555|  74.5k|                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
 9556|      0|                    if (flags & JS_PROP_HAS_VALUE) {
 9557|      0|                        if (p->class_id == JS_CLASS_MODULE_NS) {
 9558|       |                            /* JS_PROP_WRITABLE is always true for variable
 9559|       |                               references, but they are write protected in module name
 9560|       |                               spaces. */
 9561|      0|                            if (!js_same_value(ctx, val, *pr->u.var_ref->pvalue))
 9562|      0|                                goto not_configurable;
 9563|      0|                        } else {
 9564|       |                            /* update the reference */
 9565|      0|                            set_value(ctx, pr->u.var_ref->pvalue,
 9566|      0|                                      JS_DupValue(ctx, val));
 9567|      0|                        }
 9568|      0|                    }
 9569|       |                    /* if writable is set to false, no longer a
 9570|       |                       reference (for mapped arguments) */
 9571|      0|                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) == JS_PROP_HAS_WRITABLE) {
 9572|      0|                        JSValue val1;
 9573|      0|                        if (p->class_id == JS_CLASS_MODULE_NS) {
 9574|      0|                            return JS_ThrowTypeErrorOrFalse(ctx, flags, "module namespace properties have writable = false");
 9575|      0|                        }
 9576|      0|                        if (js_shape_prepare_update(ctx, p, &prs))
 9577|      0|                            return -1;
 9578|      0|                        val1 = JS_DupValue(ctx, *pr->u.var_ref->pvalue);
 9579|      0|                        free_var_ref(ctx->rt, pr->u.var_ref);
 9580|      0|                        pr->u.value = val1;
 9581|      0|                        prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);
 9582|      0|                    }
 9583|  74.5k|                } else if (prs->flags & JS_PROP_LENGTH) {
 9584|      0|                    if (flags & JS_PROP_HAS_VALUE) {
 9585|       |                        /* Note: no JS code is executable because
 9586|       |                           'val' is guaranted to be a Uint32 */
 9587|      0|                        res = set_array_length(ctx, p, JS_DupValue(ctx, val),
 9588|      0|                                               flags);
 9589|      0|                    } else {
 9590|      0|                        res = TRUE;
 9591|      0|                    }
 9592|       |                    /* still need to reset the writable flag if
 9593|       |                       needed.  The JS_PROP_LENGTH is kept because the
 9594|       |                       Uint32 test is still done if the length
 9595|       |                       property is read-only. */
 9596|      0|                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==
 9597|      0|                        JS_PROP_HAS_WRITABLE) {
 9598|      0|                        prs = get_shape_prop(p->shape);
 9599|      0|                        if (js_update_property_flags(ctx, p, &prs,
 9600|      0|                                                     prs->flags & ~JS_PROP_WRITABLE))
 9601|      0|                            return -1;
 9602|      0|                    }
 9603|      0|                    return res;
 9604|  74.5k|                } else {
 9605|  74.5k|                    if (flags & JS_PROP_HAS_VALUE) {
 9606|  74.5k|                        JS_FreeValue(ctx, pr->u.value);
 9607|  74.5k|                        pr->u.value = JS_DupValue(ctx, val);
 9608|  74.5k|                    }
 9609|  74.5k|                    if (flags & JS_PROP_HAS_WRITABLE) {
 9610|  74.5k|                        if (js_update_property_flags(ctx, p, &prs,
 9611|  74.5k|                                                     (prs->flags & ~JS_PROP_WRITABLE) |
 9612|  74.5k|                                                     (flags & JS_PROP_WRITABLE)))
 9613|      0|                            return -1;
 9614|  74.5k|                    }
 9615|  74.5k|                }
 9616|  74.5k|            }
 9617|  74.5k|        }
 9618|   110k|        mask = 0;
 9619|   110k|        if (flags & JS_PROP_HAS_CONFIGURABLE)
 9620|   110k|            mask |= JS_PROP_CONFIGURABLE;
 9621|   110k|        if (flags & JS_PROP_HAS_ENUMERABLE)
 9622|  74.5k|            mask |= JS_PROP_ENUMERABLE;
 9623|   110k|        if (js_update_property_flags(ctx, p, &prs,
 9624|   110k|                                     (prs->flags & ~mask) | (flags & mask)))
 9625|      0|            return -1;
 9626|   110k|        return TRUE;
 9627|   110k|    }
 9628|       |
 9629|       |    /* handle modification of fast array elements */
 9630|  13.5M|    if (p->fast_array) {
 9631|  2.05M|        uint32_t idx;
 9632|  2.05M|        uint32_t prop_flags;
 9633|  2.05M|        if (p->class_id == JS_CLASS_ARRAY) {
 9634|  2.05M|            if (__JS_AtomIsTaggedInt(prop)) {
 9635|  1.46M|                idx = __JS_AtomToUInt32(prop);
 9636|  1.46M|                if (idx < p->u.array.count) {
 9637|      0|                    prop_flags = get_prop_flags(flags, JS_PROP_C_W_E);
 9638|      0|                    if (prop_flags != JS_PROP_C_W_E)
 9639|      0|                        goto convert_to_slow_array;
 9640|      0|                    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
 9641|      0|                    convert_to_slow_array:
 9642|      0|                        if (convert_fast_array_to_array(ctx, p))
 9643|      0|                            return -1;
 9644|      0|                        else
 9645|      0|                            goto redo_prop_update;
 9646|      0|                    }
 9647|      0|                    if (flags & JS_PROP_HAS_VALUE) {
 9648|      0|                        set_value(ctx, &p->u.array.u.values[idx], JS_DupValue(ctx, val));
 9649|      0|                    }
 9650|      0|                    return TRUE;
 9651|      0|                }
 9652|  1.46M|            }
 9653|  2.05M|        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
 9654|      0|                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
 9655|      0|            JSValue num;
 9656|      0|            int ret;
 9657|       |
 9658|      0|            if (!__JS_AtomIsTaggedInt(prop)) {
 9659|       |                /* slow path with to handle all numeric indexes */
 9660|      0|                num = JS_AtomIsNumericIndex1(ctx, prop);
 9661|      0|                if (JS_IsUndefined(num))
 9662|      0|                    goto typed_array_done;
 9663|      0|                if (JS_IsException(num))
 9664|      0|                    return -1;
 9665|      0|                ret = JS_NumberIsInteger(ctx, num);
 9666|      0|                if (ret < 0) {
 9667|      0|                    JS_FreeValue(ctx, num);
 9668|      0|                    return -1;
 9669|      0|                }
 9670|      0|                if (!ret) {
 9671|      0|                    JS_FreeValue(ctx, num);
 9672|      0|                    return JS_ThrowTypeErrorOrFalse(ctx, flags, "non integer index in typed array");
 9673|      0|                }
 9674|      0|                ret = JS_NumberIsNegativeOrMinusZero(ctx, num);
 9675|      0|                JS_FreeValue(ctx, num);
 9676|      0|                if (ret) {
 9677|      0|                    return JS_ThrowTypeErrorOrFalse(ctx, flags, "negative index in typed array");
 9678|      0|                }
 9679|      0|                if (!__JS_AtomIsTaggedInt(prop))
 9680|      0|                    goto typed_array_oob;
 9681|      0|            }
 9682|      0|            idx = __JS_AtomToUInt32(prop);
 9683|       |            /* if the typed array is detached, p->u.array.count = 0 */
 9684|      0|            if (idx >= p->u.array.count) {
 9685|      0|            typed_array_oob:
 9686|      0|                return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound index in typed array");
 9687|      0|            }
 9688|      0|            prop_flags = get_prop_flags(flags, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 9689|      0|            if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET) ||
 9690|      0|                prop_flags != (JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE)) {
 9691|      0|                return JS_ThrowTypeErrorOrFalse(ctx, flags, "invalid descriptor flags");
 9692|      0|            }
 9693|      0|            if (flags & JS_PROP_HAS_VALUE) {
 9694|      0|                return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), JS_DupValue(ctx, val), flags);
 9695|      0|            }
 9696|      0|            return TRUE;
 9697|      0|        typed_array_done: ;
 9698|      0|        }
 9699|  2.05M|    }
 9700|       |
 9701|  13.5M|    return JS_CreateProperty(ctx, p, prop, val, getter, setter, flags);
 9702|  13.5M|}
 9703|       |
 9704|       |static int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,
 9705|       |                                     JSAtom prop, JSAutoInitIDEnum id,
 9706|       |                                     void *opaque, int flags)
 9707|  6.43M|{
 9708|  6.43M|    JSObject *p;
 9709|  6.43M|    JSProperty *pr;
 9710|       |
 9711|  6.43M|    if (JS_VALUE_GET_TAG(this_obj) != JS_TAG_OBJECT)
 9712|      0|        return FALSE;
 9713|       |
 9714|  6.43M|    p = JS_VALUE_GET_OBJ(this_obj);
 9715|       |
 9716|  6.43M|    if (find_own_property(&pr, p, prop)) {
 9717|       |        /* property already exists */
 9718|      0|        abort();
 9719|      0|        return FALSE;
 9720|      0|    }
 9721|       |
 9722|       |    /* Specialized CreateProperty */
 9723|  6.43M|    pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);
 9724|  6.43M|    if (unlikely(!pr))
 9725|      0|        return -1;
 9726|  6.43M|    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);
 9727|  6.43M|    assert((pr->u.init.realm_and_id & 3) == 0);
 9728|  6.43M|    assert(id <= 3);
 9729|  6.43M|    pr->u.init.realm_and_id |= id;
 9730|  6.43M|    pr->u.init.opaque = opaque;
 9731|  6.43M|    return TRUE;
 9732|  6.43M|}
 9733|       |
 9734|       |/* shortcut to add or redefine a new property value */
 9735|       |int JS_DefinePropertyValue(JSContext *ctx, JSValueConst this_obj,
 9736|       |                           JSAtom prop, JSValue val, int flags)
 9737|  12.6M|{
 9738|  12.6M|    int ret;
 9739|  12.6M|    ret = JS_DefineProperty(ctx, this_obj, prop, val, JS_UNDEFINED, JS_UNDEFINED,
 9740|  12.6M|                            flags | JS_PROP_HAS_VALUE | JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_WRITABLE | JS_PROP_HAS_ENUMERABLE);
 9741|  12.6M|    JS_FreeValue(ctx, val);
 9742|  12.6M|    return ret;
 9743|  12.6M|}
 9744|       |
 9745|       |int JS_DefinePropertyValueValue(JSContext *ctx, JSValueConst this_obj,
 9746|       |                                JSValue prop, JSValue val, int flags)
 9747|  1.06M|{
 9748|  1.06M|    JSAtom atom;
 9749|  1.06M|    int ret;
 9750|  1.06M|    atom = JS_ValueToAtom(ctx, prop);
 9751|  1.06M|    JS_FreeValue(ctx, prop);
 9752|  1.06M|    if (unlikely(atom == JS_ATOM_NULL)) {
 9753|      0|        JS_FreeValue(ctx, val);
 9754|      0|        return -1;
 9755|      0|    }
 9756|  1.06M|    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);
 9757|  1.06M|    JS_FreeAtom(ctx, atom);
 9758|  1.06M|    return ret;
 9759|  1.06M|}
 9760|       |
 9761|       |int JS_DefinePropertyValueUint32(JSContext *ctx, JSValueConst this_obj,
 9762|       |                                 uint32_t idx, JSValue val, int flags)
 9763|  1.06M|{
 9764|  1.06M|    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewUint32(ctx, idx),
 9765|  1.06M|                                       val, flags);
 9766|  1.06M|}
 9767|       |
 9768|       |int JS_DefinePropertyValueInt64(JSContext *ctx, JSValueConst this_obj,
 9769|       |                                int64_t idx, JSValue val, int flags)
 9770|      0|{
 9771|      0|    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx),
 9772|      0|                                       val, flags);
 9773|      0|}
 9774|       |
 9775|       |int JS_DefinePropertyValueStr(JSContext *ctx, JSValueConst this_obj,
 9776|       |                              const char *prop, JSValue val, int flags)
 9777|  1.63M|{
 9778|  1.63M|    JSAtom atom;
 9779|  1.63M|    int ret;
 9780|  1.63M|    atom = JS_NewAtom(ctx, prop);
 9781|  1.63M|    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);
 9782|  1.63M|    JS_FreeAtom(ctx, atom);
 9783|  1.63M|    return ret;
 9784|  1.63M|}
 9785|       |
 9786|       |/* shortcut to add getter & setter */
 9787|       |int JS_DefinePropertyGetSet(JSContext *ctx, JSValueConst this_obj,
 9788|       |                            JSAtom prop, JSValue getter, JSValue setter,
 9789|       |                            int flags)
 9790|   604k|{
 9791|   604k|    int ret;
 9792|   604k|    ret = JS_DefineProperty(ctx, this_obj, prop, JS_UNDEFINED, getter, setter,
 9793|   604k|                            flags | JS_PROP_HAS_GET | JS_PROP_HAS_SET |
 9794|   604k|                            JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_ENUMERABLE);
 9795|   604k|    JS_FreeValue(ctx, getter);
 9796|   604k|    JS_FreeValue(ctx, setter);
 9797|   604k|    return ret;
 9798|   604k|}
 9799|       |
 9800|       |static int JS_CreateDataPropertyUint32(JSContext *ctx, JSValueConst this_obj,
 9801|       |                                       int64_t idx, JSValue val, int flags)
 9802|      0|{
 9803|      0|    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx),
 9804|      0|                                       val, flags | JS_PROP_CONFIGURABLE |
 9805|      0|                                       JS_PROP_ENUMERABLE | JS_PROP_WRITABLE);
 9806|      0|}
 9807|       |
 9808|       |
 9809|       |/* return TRUE if 'obj' has a non empty 'name' string */
 9810|       |static BOOL js_object_has_name(JSContext *ctx, JSValueConst obj)
 9811|  73.3k|{
 9812|  73.3k|    JSProperty *pr;
 9813|  73.3k|    JSShapeProperty *prs;
 9814|  73.3k|    JSValueConst val;
 9815|  73.3k|    JSString *p;
 9816|       |
 9817|  73.3k|    prs = find_own_property(&pr, JS_VALUE_GET_OBJ(obj), JS_ATOM_name);
 9818|  73.3k|    if (!prs)
 9819|      0|        return FALSE;
 9820|  73.3k|    if ((prs->flags & JS_PROP_TMASK) != JS_PROP_NORMAL)
 9821|      0|        return TRUE;
 9822|  73.3k|    val = pr->u.value;
 9823|  73.3k|    if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)
 9824|      0|        return TRUE;
 9825|  73.3k|    p = JS_VALUE_GET_STRING(val);
 9826|  73.3k|    return (p->len != 0);
 9827|  73.3k|}
 9828|       |
 9829|       |static int JS_DefineObjectName(JSContext *ctx, JSValueConst obj,
 9830|       |                               JSAtom name, int flags)
 9831|  73.3k|{
 9832|  73.3k|    if (name != JS_ATOM_NULL
 9833|  73.3k|    &&  JS_IsObject(obj)
 9834|  73.3k|    &&  !js_object_has_name(ctx, obj)
 9835|  73.3k|    &&  JS_DefinePropertyValue(ctx, obj, JS_ATOM_name, JS_AtomToString(ctx, name), flags) < 0) {
 9836|      0|        return -1;
 9837|      0|    }
 9838|  73.3k|    return 0;
 9839|  73.3k|}
 9840|       |
 9841|       |static int JS_DefineObjectNameComputed(JSContext *ctx, JSValueConst obj,
 9842|       |                                       JSValueConst str, int flags)
 9843|      0|{
 9844|      0|    if (JS_IsObject(obj) &&
 9845|      0|        !js_object_has_name(ctx, obj)) {
 9846|      0|        JSAtom prop;
 9847|      0|        JSValue name_str;
 9848|      0|        prop = JS_ValueToAtom(ctx, str);
 9849|      0|        if (prop == JS_ATOM_NULL)
 9850|      0|            return -1;
 9851|      0|        name_str = js_get_function_name(ctx, prop);
 9852|      0|        JS_FreeAtom(ctx, prop);
 9853|      0|        if (JS_IsException(name_str))
 9854|      0|            return -1;
 9855|      0|        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_name, name_str, flags) < 0)
 9856|      0|            return -1;
 9857|      0|    }
 9858|      0|    return 0;
 9859|      0|}
 9860|       |
 9861|  7.36k|#define DEFINE_GLOBAL_LEX_VAR (1 << 7)
 9862|  1.83k|#define DEFINE_GLOBAL_FUNC_VAR (1 << 6)
 9863|       |
 9864|       |static JSValue JS_ThrowSyntaxErrorVarRedeclaration(JSContext *ctx, JSAtom prop)
 9865|      0|{
 9866|      0|    return JS_ThrowSyntaxErrorAtom(ctx, "redeclaration of '%s'", prop);
 9867|      0|}
 9868|       |
 9869|       |/* flags is 0, DEFINE_GLOBAL_LEX_VAR or DEFINE_GLOBAL_FUNC_VAR */
 9870|       |/* XXX: could support exotic global object. */
 9871|       |static int JS_CheckDefineGlobalVar(JSContext *ctx, JSAtom prop, int flags)
 9872|  2.75k|{
 9873|  2.75k|    JSObject *p;
 9874|  2.75k|    JSShapeProperty *prs;
 9875|       |
 9876|  2.75k|    p = JS_VALUE_GET_OBJ(ctx->global_obj);
 9877|  2.75k|    prs = find_own_property1(p, prop);
 9878|       |    /* XXX: should handle JS_PROP_AUTOINIT */
 9879|  2.75k|    if (flags & DEFINE_GLOBAL_LEX_VAR) {
 9880|    926|        if (prs && !(prs->flags & JS_PROP_CONFIGURABLE))
 9881|      0|            goto fail_redeclaration;
 9882|  1.83k|    } else {
 9883|  1.83k|        if (!prs && !p->extensible)
 9884|      0|            goto define_error;
 9885|  1.83k|        if (flags & DEFINE_GLOBAL_FUNC_VAR) {
 9886|      0|            if (prs) {
 9887|      0|                if (!(prs->flags & JS_PROP_CONFIGURABLE) &&
 9888|      0|                    ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET ||
 9889|      0|                     ((prs->flags & (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)) !=
 9890|      0|                      (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)))) {
 9891|      0|                define_error:
 9892|      0|                    JS_ThrowTypeErrorAtom(ctx, "cannot define variable '%s'",
 9893|      0|                                          prop);
 9894|      0|                    return -1;
 9895|      0|                }
 9896|      0|            }
 9897|      0|        }
 9898|  1.83k|    }
 9899|       |    /* check if there already is a lexical declaration */
 9900|  2.75k|    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);
 9901|  2.75k|    prs = find_own_property1(p, prop);
 9902|  2.75k|    if (prs) {
 9903|      0|    fail_redeclaration:
 9904|      0|        JS_ThrowSyntaxErrorVarRedeclaration(ctx, prop);
 9905|      0|        return -1;
 9906|      0|    }
 9907|  2.75k|    return 0;
 9908|  2.75k|}
 9909|       |
 9910|       |/* def_flags is (0, DEFINE_GLOBAL_LEX_VAR) |
 9911|       |   JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE */
 9912|       |/* XXX: could support exotic global object. */
 9913|       |static int JS_DefineGlobalVar(JSContext *ctx, JSAtom prop, int def_flags)
 9914|  2.75k|{
 9915|  2.75k|    JSObject *p;
 9916|  2.75k|    JSShapeProperty *prs;
 9917|  2.75k|    JSProperty *pr;
 9918|  2.75k|    JSValue val;
 9919|  2.75k|    int flags;
 9920|       |
 9921|  2.75k|    if (def_flags & DEFINE_GLOBAL_LEX_VAR) {
 9922|    926|        p = JS_VALUE_GET_OBJ(ctx->global_var_obj);
 9923|    926|        flags = JS_PROP_ENUMERABLE | (def_flags & JS_PROP_WRITABLE) |
 9924|    926|            JS_PROP_CONFIGURABLE;
 9925|    926|        val = JS_UNINITIALIZED;
 9926|  1.83k|    } else {
 9927|  1.83k|        p = JS_VALUE_GET_OBJ(ctx->global_obj);
 9928|  1.83k|        flags = JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |
 9929|  1.83k|            (def_flags & JS_PROP_CONFIGURABLE);
 9930|  1.83k|        val = JS_UNDEFINED;
 9931|  1.83k|    }
 9932|  2.75k|    prs = find_own_property1(p, prop);
 9933|  2.75k|    if (prs)
 9934|  1.58k|        return 0;
 9935|  1.16k|    if (!p->extensible)
 9936|      0|        return 0;
 9937|  1.16k|    pr = add_property(ctx, p, prop, flags);
 9938|  1.16k|    if (unlikely(!pr))
 9939|      0|        return -1;
 9940|  1.16k|    pr->u.value = val;
 9941|  1.16k|    return 0;
 9942|  1.16k|}
 9943|       |
 9944|       |/* 'def_flags' is 0 or JS_PROP_CONFIGURABLE. */
 9945|       |/* XXX: could support exotic global object. */
 9946|       |static int JS_DefineGlobalFunction(JSContext *ctx, JSAtom prop,
 9947|       |                                   JSValueConst func, int def_flags)
 9948|      0|{
 9949|       |
 9950|      0|    JSObject *p;
 9951|      0|    JSShapeProperty *prs;
 9952|      0|    int flags;
 9953|       |
 9954|      0|    p = JS_VALUE_GET_OBJ(ctx->global_obj);
 9955|      0|    prs = find_own_property1(p, prop);
 9956|      0|    flags = JS_PROP_HAS_VALUE | JS_PROP_THROW;
 9957|      0|    if (!prs || (prs->flags & JS_PROP_CONFIGURABLE)) {
 9958|      0|        flags |= JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | def_flags |
 9959|      0|            JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_WRITABLE | JS_PROP_HAS_ENUMERABLE;
 9960|      0|    }
 9961|      0|    if (JS_DefineProperty(ctx, ctx->global_obj, prop, func,
 9962|      0|                          JS_UNDEFINED, JS_UNDEFINED, flags) < 0)
 9963|      0|        return -1;
 9964|      0|    return 0;
 9965|      0|}
 9966|       |
 9967|       |static JSValue JS_GetGlobalVar(JSContext *ctx, JSAtom prop,
 9968|       |                               BOOL throw_ref_error)
 9969|  55.4k|{
 9970|  55.4k|    JSObject *p;
 9971|  55.4k|    JSShapeProperty *prs;
 9972|  55.4k|    JSProperty *pr;
 9973|       |
 9974|       |    /* no exotic behavior is possible in global_var_obj */
 9975|  55.4k|    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);
 9976|  55.4k|    prs = find_own_property(&pr, p, prop);
 9977|  55.4k|    if (prs) {
 9978|       |        /* XXX: should handle JS_PROP_TMASK properties */
 9979|    396|        if (unlikely(JS_IsUninitialized(pr->u.value)))
 9980|      6|            return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
 9981|    390|        return JS_DupValue(ctx, pr->u.value);
 9982|    396|    }
 9983|  55.0k|    return JS_GetPropertyInternal(ctx, ctx->global_obj, prop,
 9984|  55.0k|                                 ctx->global_obj, throw_ref_error);
 9985|  55.4k|}
 9986|       |
 9987|       |/* construct a reference to a global variable */
 9988|       |static int JS_GetGlobalVarRef(JSContext *ctx, JSAtom prop, JSValue *sp)
 9989|  15.5k|{
 9990|  15.5k|    JSObject *p;
 9991|  15.5k|    JSShapeProperty *prs;
 9992|  15.5k|    JSProperty *pr;
 9993|       |
 9994|       |    /* no exotic behavior is possible in global_var_obj */
 9995|  15.5k|    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);
 9996|  15.5k|    prs = find_own_property(&pr, p, prop);
 9997|  15.5k|    if (prs) {
 9998|       |        /* XXX: should handle JS_PROP_AUTOINIT properties? */
 9999|       |        /* XXX: conformance: do these tests in
10000|       |           OP_put_var_ref/OP_get_var_ref ? */
10001|     58|        if (unlikely(JS_IsUninitialized(pr->u.value))) {
10002|      2|            JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
10003|      2|            return -1;
10004|      2|        }
10005|     56|        if (unlikely(!(prs->flags & JS_PROP_WRITABLE))) {
10006|      0|            return JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, prop);
10007|      0|        }
10008|     56|        sp[0] = JS_DupValue(ctx, ctx->global_var_obj);
10009|  15.4k|    } else {
10010|  15.4k|        int ret;
10011|  15.4k|        ret = JS_HasProperty(ctx, ctx->global_obj, prop);
10012|  15.4k|        if (ret < 0)
10013|      0|            return -1;
10014|  15.4k|        if (ret) {
10015|  14.6k|            sp[0] = JS_DupValue(ctx, ctx->global_obj);
10016|  14.6k|        } else {
10017|    838|            sp[0] = JS_UNDEFINED;
10018|    838|        }
10019|  15.4k|    }
10020|  15.5k|    sp[1] = JS_AtomToValue(ctx, prop);
10021|  15.5k|    return 0;
10022|  15.5k|}
10023|       |
10024|       |/* use for strict variable access: test if the variable exists */
10025|       |static int JS_CheckGlobalVar(JSContext *ctx, JSAtom prop)
10026|    365|{
10027|    365|    JSObject *p;
10028|    365|    JSShapeProperty *prs;
10029|    365|    int ret;
10030|       |
10031|       |    /* no exotic behavior is possible in global_var_obj */
10032|    365|    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);
10033|    365|    prs = find_own_property1(p, prop);
10034|    365|    if (prs) {
10035|      0|        ret = TRUE;
10036|    365|    } else {
10037|    365|        ret = JS_HasProperty(ctx, ctx->global_obj, prop);
10038|    365|        if (ret < 0)
10039|      0|            return -1;
10040|    365|    }
10041|    365|    return ret;
10042|    365|}
10043|       |
10044|       |/* flag = 0: normal variable write
10045|       |   flag = 1: initialize lexical variable
10046|       |   flag = 2: normal variable write, strict check was done before
10047|       |*/
10048|       |static int JS_SetGlobalVar(JSContext *ctx, JSAtom prop, JSValue val,
10049|       |                           int flag)
10050|  4.71M|{
10051|  4.71M|    JSObject *p;
10052|  4.71M|    JSShapeProperty *prs;
10053|  4.71M|    JSProperty *pr;
10054|  4.71M|    int flags;
10055|       |
10056|       |    /* no exotic behavior is possible in global_var_obj */
10057|  4.71M|    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);
10058|  4.71M|    prs = find_own_property(&pr, p, prop);
10059|  4.71M|    if (prs) {
10060|       |        /* XXX: should handle JS_PROP_AUTOINIT properties? */
10061|  2.08k|        if (flag != 1) {
10062|  1.48k|            if (unlikely(JS_IsUninitialized(pr->u.value))) {
10063|      2|                JS_FreeValue(ctx, val);
10064|      2|                JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
10065|      2|                return -1;
10066|      2|            }
10067|  1.48k|            if (unlikely(!(prs->flags & JS_PROP_WRITABLE))) {
10068|      1|                JS_FreeValue(ctx, val);
10069|      1|                return JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, prop);
10070|      1|            }
10071|  1.48k|        }
10072|  2.07k|        set_value(ctx, &pr->u.value, val);
10073|  2.07k|        return 0;
10074|  2.08k|    }
10075|       |    /* XXX: add a fast path where the property exists and the object
10076|       |       is not exotic. Otherwise do as in OP_put_ref_value and remove
10077|       |       JS_PROP_NO_ADD which is no longer necessary */
10078|  4.71M|    flags = JS_PROP_THROW_STRICT;
10079|  4.71M|    if (is_strict_mode(ctx))
10080|      0|        flags |= JS_PROP_NO_ADD;
10081|  4.71M|    return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, ctx->global_obj, flags);
10082|  4.71M|}
10083|       |
10084|       |/* return -1, FALSE or TRUE. return FALSE if not configurable or
10085|       |   invalid object. return -1 in case of exception.
10086|       |   flags can be 0, JS_PROP_THROW or JS_PROP_THROW_STRICT */
10087|       |int JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags)
10088|      0|{
10089|      0|    JSValue obj1;
10090|      0|    JSObject *p;
10091|      0|    int res;
10092|       |
10093|      0|    obj1 = JS_ToObject(ctx, obj);
10094|      0|    if (JS_IsException(obj1))
10095|      0|        return -1;
10096|      0|    p = JS_VALUE_GET_OBJ(obj1);
10097|      0|    res = delete_property(ctx, p, prop);
10098|      0|    JS_FreeValue(ctx, obj1);
10099|      0|    if (res != FALSE)
10100|      0|        return res;
10101|      0|    if ((flags & JS_PROP_THROW) ||
10102|      0|        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
10103|      0|        JS_ThrowTypeError(ctx, "could not delete property");
10104|      0|        return -1;
10105|      0|    }
10106|      0|    return FALSE;
10107|      0|}
10108|       |
10109|       |int JS_DeletePropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx, int flags)
10110|      0|{
10111|      0|    JSAtom prop;
10112|      0|    int res;
10113|       |
10114|      0|    if ((uint64_t)idx <= JS_ATOM_MAX_INT) {
10115|       |        /* fast path for fast arrays */
10116|      0|        return JS_DeleteProperty(ctx, obj, __JS_AtomFromUInt32(idx), flags);
10117|      0|    }
10118|      0|    prop = JS_NewAtomInt64(ctx, idx);
10119|      0|    if (prop == JS_ATOM_NULL)
10120|      0|        return -1;
10121|      0|    res = JS_DeleteProperty(ctx, obj, prop, flags);
10122|      0|    JS_FreeAtom(ctx, prop);
10123|      0|    return res;
10124|      0|}
10125|       |
10126|       |BOOL JS_IsFunction(JSContext *ctx, JSValueConst val)
10127|  3.97M|{
10128|  3.97M|    JSObject *p;
10129|  3.97M|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10130|   586k|        return FALSE;
10131|  3.39M|    p = JS_VALUE_GET_OBJ(val);
10132|  3.39M|    switch(p->class_id) {
10133|  74.0k|    case JS_CLASS_BYTECODE_FUNCTION:
10134|  74.0k|        return TRUE;
10135|      0|    case JS_CLASS_PROXY:
10136|      0|        return p->u.proxy_data->is_func;
10137|  3.31M|    default:
10138|  3.31M|        return (ctx->rt->class_array[p->class_id].call != NULL);
10139|  3.39M|    }
10140|  3.39M|}
10141|       |
10142|       |BOOL JS_IsCFunction(JSContext *ctx, JSValueConst val, JSCFunction *func, int magic)
10143|      2|{
10144|      2|    JSObject *p;
10145|      2|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10146|      2|        return FALSE;
10147|      0|    p = JS_VALUE_GET_OBJ(val);
10148|      0|    if (p->class_id == JS_CLASS_C_FUNCTION)
10149|      0|        return (p->u.cfunc.c_function.generic == func && p->u.cfunc.magic == magic);
10150|      0|    else
10151|      0|        return FALSE;
10152|      0|}
10153|       |
10154|       |BOOL JS_IsConstructor(JSContext *ctx, JSValueConst val)
10155|      0|{
10156|      0|    JSObject *p;
10157|      0|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10158|      0|        return FALSE;
10159|      0|    p = JS_VALUE_GET_OBJ(val);
10160|      0|    return p->is_constructor;
10161|      0|}
10162|       |
10163|       |BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, BOOL val)
10164|  17.7k|{
10165|  17.7k|    JSObject *p;
10166|  17.7k|    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
10167|      0|        return FALSE;
10168|  17.7k|    p = JS_VALUE_GET_OBJ(func_obj);
10169|  17.7k|    p->is_constructor = val;
10170|  17.7k|    return TRUE;
10171|  17.7k|}
10172|       |
10173|       |BOOL JS_IsError(JSContext *ctx, JSValueConst val)
10174|  14.3k|{
10175|  14.3k|    JSObject *p;
10176|  14.3k|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10177|     27|        return FALSE;
10178|  14.2k|    p = JS_VALUE_GET_OBJ(val);
10179|  14.2k|    return (p->class_id == JS_CLASS_ERROR);
10180|  14.3k|}
10181|       |
10182|       |/* used to avoid catching interrupt exceptions */
10183|       |BOOL JS_IsUncatchableError(JSContext *ctx, JSValueConst val)
10184|   144k|{
10185|   144k|    JSObject *p;
10186|   144k|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10187|     26|        return FALSE;
10188|   144k|    p = JS_VALUE_GET_OBJ(val);
10189|   144k|    return p->class_id == JS_CLASS_ERROR && p->is_uncatchable_error;
10190|   144k|}
10191|       |
10192|       |void JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag)
10193|      0|{
10194|      0|    JSObject *p;
10195|      0|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10196|      0|        return;
10197|      0|    p = JS_VALUE_GET_OBJ(val);
10198|      0|    if (p->class_id == JS_CLASS_ERROR)
10199|      0|        p->is_uncatchable_error = flag;
10200|      0|}
10201|       |
10202|       |void JS_ResetUncatchableError(JSContext *ctx)
10203|      0|{
10204|      0|    JS_SetUncatchableError(ctx, ctx->rt->current_exception, FALSE);
10205|      0|}
10206|       |
10207|       |void JS_SetOpaque(JSValue obj, void *opaque)
10208|  10.4k|{
10209|  10.4k|   JSObject *p;
10210|  10.4k|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
10211|  10.4k|        p = JS_VALUE_GET_OBJ(obj);
10212|  10.4k|        p->u.opaque = opaque;
10213|  10.4k|    }
10214|  10.4k|}
10215|       |
10216|       |/* return NULL if not an object of class class_id */
10217|       |void *JS_GetOpaque(JSValueConst obj, JSClassID class_id)
10218|  11.6k|{
10219|  11.6k|    JSObject *p;
10220|  11.6k|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
10221|    518|        return NULL;
10222|  11.1k|    p = JS_VALUE_GET_OBJ(obj);
10223|  11.1k|    if (p->class_id != class_id)
10224|      0|        return NULL;
10225|  11.1k|    return p->u.opaque;
10226|  11.1k|}
10227|       |
10228|       |void *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id)
10229|  8.44k|{
10230|  8.44k|    void *p = JS_GetOpaque(obj, class_id);
10231|  8.44k|    if (unlikely(!p)) {
10232|      0|        JS_ThrowTypeErrorInvalidClass(ctx, class_id);
10233|      0|    }
10234|  8.44k|    return p;
10235|  8.44k|}
10236|       |
10237|       |void *JS_GetAnyOpaque(JSValueConst obj, JSClassID *class_id)
10238|      0|{
10239|      0|    JSObject *p;
10240|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {
10241|      0|        *class_id = 0;
10242|      0|        return NULL;
10243|      0|    }
10244|      0|    p = JS_VALUE_GET_OBJ(obj);
10245|      0|    *class_id = p->class_id;
10246|      0|    return p->u.opaque;
10247|      0|}
10248|       |
10249|       |static JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint)
10250|  8.07M|{
10251|  8.07M|    int i;
10252|  8.07M|    BOOL force_ordinary;
10253|       |
10254|  8.07M|    JSAtom method_name;
10255|  8.07M|    JSValue method, ret;
10256|  8.07M|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
10257|  6.89M|        return val;
10258|  1.18M|    force_ordinary = hint & HINT_FORCE_ORDINARY;
10259|  1.18M|    hint &= ~HINT_FORCE_ORDINARY;
10260|  1.18M|    if (!force_ordinary) {
10261|  1.18M|        method = JS_GetProperty(ctx, val, JS_ATOM_Symbol_toPrimitive);
10262|  1.18M|        if (JS_IsException(method))
10263|      0|            goto exception;
10264|       |        /* ECMA says *If exoticToPrim is not undefined* but tests in
10265|       |           test262 use null as a non callable converter */
10266|  1.18M|        if (!JS_IsUndefined(method) && !JS_IsNull(method)) {
10267|      0|            JSAtom atom;
10268|      0|            JSValue arg;
10269|      0|            switch(hint) {
10270|      0|            case HINT_STRING:
10271|      0|                atom = JS_ATOM_string;
10272|      0|                break;
10273|      0|            case HINT_NUMBER:
10274|      0|                atom = JS_ATOM_number;
10275|      0|                break;
10276|      0|            default:
10277|      0|            case HINT_NONE:
10278|      0|                atom = JS_ATOM_default;
10279|      0|                break;
10280|      0|            }
10281|      0|            arg = JS_AtomToString(ctx, atom);
10282|      0|            ret = JS_CallFree(ctx, method, val, 1, (JSValueConst *)&arg);
10283|      0|            JS_FreeValue(ctx, arg);
10284|      0|            if (JS_IsException(ret))
10285|      0|                goto exception;
10286|      0|            JS_FreeValue(ctx, val);
10287|      0|            if (JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT)
10288|      0|                return ret;
10289|      0|            JS_FreeValue(ctx, ret);
10290|      0|            return JS_ThrowTypeError(ctx, "toPrimitive");
10291|      0|        }
10292|  1.18M|    }
10293|  1.18M|    if (hint != HINT_STRING)
10294|  1.12M|        hint = HINT_NUMBER;
10295|  2.30M|    for(i = 0; i < 2; i++) {
10296|  2.30M|        if ((i ^ hint) == 0) {
10297|  1.18M|            method_name = JS_ATOM_toString;
10298|  1.18M|        } else {
10299|  1.12M|            method_name = JS_ATOM_valueOf;
10300|  1.12M|        }
10301|  2.30M|        method = JS_GetProperty(ctx, val, method_name);
10302|  2.30M|        if (JS_IsException(method))
10303|      0|            goto exception;
10304|  2.30M|        if (JS_IsFunction(ctx, method)) {
10305|  2.30M|            ret = JS_CallFree(ctx, method, val, 0, NULL);
10306|  2.30M|            if (JS_IsException(ret))
10307|     59|                goto exception;
10308|  2.30M|            if (JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {
10309|  1.18M|                JS_FreeValue(ctx, val);
10310|  1.18M|                return ret;
10311|  1.18M|            }
10312|  1.12M|            JS_FreeValue(ctx, ret);
10313|  1.12M|        } else {
10314|      0|            JS_FreeValue(ctx, method);
10315|      0|        }
10316|  2.30M|    }
10317|      0|    JS_ThrowTypeError(ctx, "toPrimitive");
10318|     59|exception:
10319|     59|    JS_FreeValue(ctx, val);
10320|     59|    return JS_EXCEPTION;
10321|      0|}
10322|       |
10323|       |static JSValue JS_ToPrimitive(JSContext *ctx, JSValueConst val, int hint)
10324|  60.4k|{
10325|  60.4k|    return JS_ToPrimitiveFree(ctx, JS_DupValue(ctx, val), hint);
10326|  60.4k|}
10327|       |
10328|       |void JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj)
10329|      0|{
10330|      0|    JSObject *p;
10331|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
10332|      0|        return;
10333|      0|    p = JS_VALUE_GET_OBJ(obj);
10334|      0|    p->is_HTMLDDA = TRUE;
10335|      0|}
10336|       |
10337|       |static inline BOOL JS_IsHTMLDDA(JSContext *ctx, JSValueConst obj)
10338|  23.3k|{
10339|  23.3k|    JSObject *p;
10340|  23.3k|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
10341|  19.7k|        return FALSE;
10342|  3.63k|    p = JS_VALUE_GET_OBJ(obj);
10343|  3.63k|    return p->is_HTMLDDA;
10344|  23.3k|}
10345|       |
10346|       |static int JS_ToBoolFree(JSContext *ctx, JSValue val)
10347|  6.43M|{
10348|  6.43M|    uint32_t tag = JS_VALUE_GET_TAG(val);
10349|  6.43M|    switch(tag) {
10350|      0|    case JS_TAG_INT:
10351|      0|        return JS_VALUE_GET_INT(val) != 0;
10352|  5.46M|    case JS_TAG_BOOL:
10353|  5.46M|    case JS_TAG_NULL:
10354|  5.46M|    case JS_TAG_UNDEFINED:
10355|  5.46M|        return JS_VALUE_GET_INT(val);
10356|      8|    case JS_TAG_EXCEPTION:
10357|      8|        return -1;
10358|  4.41k|    case JS_TAG_STRING:
10359|  4.41k|        {
10360|  4.41k|            BOOL ret = JS_VALUE_GET_STRING(val)->len != 0;
10361|  4.41k|            JS_FreeValue(ctx, val);
10362|  4.41k|            return ret;
10363|  5.46M|        }
10364|      1|    case JS_TAG_STRING_ROPE:
10365|      1|        {
10366|      1|            BOOL ret = JS_VALUE_GET_STRING_ROPE(val)->len != 0;
10367|      1|            JS_FreeValue(ctx, val);
10368|      1|            return ret;
10369|  5.46M|        }
10370|   508k|    case JS_TAG_SHORT_BIG_INT:
10371|   508k|        return JS_VALUE_GET_SHORT_BIG_INT(val) != 0;
10372|  32.7k|    case JS_TAG_BIG_INT:
10373|  32.7k|        {
10374|  32.7k|            JSBigInt *p = JS_VALUE_GET_PTR(val);
10375|  32.7k|            BOOL ret;
10376|  32.7k|            int i;
10377|       |            
10378|       |            /* fail safe: we assume it is not necessarily
10379|       |               normalized. Beginning from the MSB ensures that the
10380|       |               test is fast. */
10381|  32.7k|            ret = FALSE;
10382|  36.5k|            for(i = p->len - 1; i >= 0; i--) {
10383|  36.5k|                if (p->tab[i] != 0) {
10384|  32.7k|                    ret = TRUE;
10385|  32.7k|                    break;
10386|  32.7k|                }
10387|  36.5k|            }
10388|  32.7k|            JS_FreeValue(ctx, val);
10389|  32.7k|            return ret;
10390|  5.46M|        }
10391|  1.66k|    case JS_TAG_OBJECT:
10392|  1.66k|        {
10393|  1.66k|            JSObject *p = JS_VALUE_GET_OBJ(val);
10394|  1.66k|            BOOL ret;
10395|  1.66k|            ret = !p->is_HTMLDDA;
10396|  1.66k|            JS_FreeValue(ctx, val);
10397|  1.66k|            return ret;
10398|  5.46M|        }
10399|      0|        break;
10400|   417k|    default:
10401|   417k|        if (JS_TAG_IS_FLOAT64(tag)) {
10402|   417k|            double d = JS_VALUE_GET_FLOAT64(val);
10403|   417k|            return !isnan(d) && d != 0;
10404|   417k|        } else {
10405|      0|            JS_FreeValue(ctx, val);
10406|      0|            return TRUE;
10407|      0|        }
10408|  6.43M|    }
10409|  6.43M|}
10410|       |
10411|       |int JS_ToBool(JSContext *ctx, JSValueConst val)
10412|      0|{
10413|      0|    return JS_ToBoolFree(ctx, JS_DupValue(ctx, val));
10414|      0|}
10415|       |
10416|       |static int skip_spaces(const char *pc)
10417|  4.25M|{
10418|  4.25M|    const uint8_t *p, *p_next, *p_start;
10419|  4.25M|    uint32_t c;
10420|       |
10421|  4.25M|    p = p_start = (const uint8_t *)pc;
10422|  4.50M|    for (;;) {
10423|  4.50M|        c = *p;
10424|  4.50M|        if (c < 128) {
10425|  4.33M|            if (!((c >= 0x09 && c <= 0x0d) || (c == 0x20)))
10426|  4.09M|                break;
10427|   236k|            p++;
10428|   236k|        } else {
10429|   168k|            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
10430|   168k|            if (!lre_is_space(c))
10431|   156k|                break;
10432|  12.1k|            p = p_next;
10433|  12.1k|        }
10434|  4.50M|    }
10435|  4.25M|    return p - p_start;
10436|  4.25M|}
10437|       |
10438|       |static inline int to_digit(int c)
10439|  33.8M|{
10440|  33.8M|    if (c >= '0' && c <= '9')
10441|  30.5M|        return c - '0';
10442|  3.28M|    else if (c >= 'A' && c <= 'Z')
10443|  27.2k|        return c - 'A' + 10;
10444|  3.26M|    else if (c >= 'a' && c <= 'z')
10445|  1.16M|        return c - 'a' + 10;
10446|  2.09M|    else
10447|  2.09M|        return 36;
10448|  33.8M|}
10449|       |
10450|       |/* bigint support */
10451|       |
10452|  3.59M|#define JS_BIGINT_MAX_SIZE ((1024 * 1024) / JS_LIMB_BITS) /* in limbs */
10453|       |
10454|       |/* it is currently assumed that JS_SHORT_BIG_INT_BITS = JS_LIMB_BITS */
10455|       |#if JS_SHORT_BIG_INT_BITS == 32
10456|       |#define JS_SHORT_BIG_INT_MIN INT32_MIN
10457|       |#define JS_SHORT_BIG_INT_MAX INT32_MAX
10458|       |#elif JS_SHORT_BIG_INT_BITS == 64
10459|   777k|#define JS_SHORT_BIG_INT_MIN INT64_MIN
10460|      4|#define JS_SHORT_BIG_INT_MAX INT64_MAX
10461|       |#else
10462|       |#error unsupported
10463|       |#endif
10464|       |
10465|  3.80M|#define ADDC(res, carry_out, op1, op2, carry_in)        \
10466|  3.80M|do {                                                    \
10467|  3.80M|    js_limb_t __v, __a, __k, __k1;                      \
10468|  3.80M|    __v = (op1);                                        \
10469|  3.80M|    __a = __v + (op2);                                  \
10470|  3.80M|    __k1 = __a < __v;                                   \
10471|  3.80M|    __k = (carry_in);                                   \
10472|  3.80M|    __a = __a + __k;                                    \
10473|  3.80M|    carry_out = (__a < __k) | __k1;                     \
10474|  3.80M|    res = __a;                                          \
10475|  3.80M|} while (0)
10476|       |
10477|       |#if JS_LIMB_BITS == 32
10478|       |/* a != 0 */
10479|       |static inline js_limb_t js_limb_clz(js_limb_t a)
10480|       |{
10481|       |    return clz32(a);
10482|       |}
10483|       |#else
10484|       |static inline js_limb_t js_limb_clz(js_limb_t a)
10485|   967k|{
10486|   967k|    return clz64(a);
10487|   967k|}
10488|       |#endif
10489|       |
10490|       |static js_limb_t mp_add(js_limb_t *res, const js_limb_t *op1, const js_limb_t *op2,
10491|       |                     js_limb_t n, js_limb_t carry)
10492|   219k|{
10493|   219k|    int i;
10494|  1.08M|    for(i = 0;i < n; i++) {
10495|   868k|        ADDC(res[i], carry, op1[i], op2[i], carry);
10496|   868k|    }
10497|   219k|    return carry;
10498|   219k|}
10499|       |
10500|       |static js_limb_t mp_sub(js_limb_t *res, const js_limb_t *op1, const js_limb_t *op2,
10501|       |                        int n, js_limb_t carry)
10502|  70.5k|{
10503|  70.5k|    int i;
10504|  70.5k|    js_limb_t k, a, v, k1;
10505|       |
10506|  70.5k|    k = carry;
10507|   978k|    for(i=0;i<n;i++) {
10508|   908k|        v = op1[i];
10509|   908k|        a = v - op2[i];
10510|   908k|        k1 = a > v;
10511|   908k|        v = a - k;
10512|   908k|        k = (v > a) | k1;
10513|   908k|        res[i] = v;
10514|   908k|    }
10515|  70.5k|    return k;
10516|  70.5k|}
10517|       |
10518|       |/* compute 0 - op2. carry = 0 or 1. */
10519|       |static js_limb_t mp_neg(js_limb_t *res, const js_limb_t *op2, int n)
10520|  1.54M|{
10521|  1.54M|    int i;
10522|  1.54M|    js_limb_t v, carry;
10523|       |
10524|  1.54M|    carry = 1;
10525|  14.0M|    for(i=0;i<n;i++) {
10526|  12.4M|        v = ~op2[i] + carry;
10527|  12.4M|        carry = v < carry;
10528|  12.4M|        res[i] = v;
10529|  12.4M|    }
10530|  1.54M|    return carry;
10531|  1.54M|}
10532|       |
10533|       |/* tabr[] = taba[] * b + l. Return the high carry */
10534|       |static js_limb_t mp_mul1(js_limb_t *tabr, const js_limb_t *taba, js_limb_t n,
10535|       |                      js_limb_t b, js_limb_t l)
10536|   646k|{
10537|   646k|    js_limb_t i;
10538|   646k|    js_dlimb_t t;
10539|       |
10540|  19.9M|    for(i = 0; i < n; i++) {
10541|  19.2M|        t = (js_dlimb_t)taba[i] * (js_dlimb_t)b + l;
10542|  19.2M|        tabr[i] = t;
10543|  19.2M|        l = t >> JS_LIMB_BITS;
10544|  19.2M|    }
10545|   646k|    return l;
10546|   646k|}
10547|       |
10548|       |static js_limb_t mp_div1(js_limb_t *tabr, const js_limb_t *taba, js_limb_t n,
10549|       |                      js_limb_t b, js_limb_t r)
10550|   474k|{
10551|   474k|    js_slimb_t i;
10552|   474k|    js_dlimb_t a1;
10553|  22.7M|    for(i = n - 1; i >= 0; i--) {
10554|  22.2M|        a1 = ((js_dlimb_t)r << JS_LIMB_BITS) | taba[i];
10555|  22.2M|        tabr[i] = a1 / b;
10556|  22.2M|        r = a1 % b;
10557|  22.2M|    }
10558|   474k|    return r;
10559|   474k|}
10560|       |
10561|       |/* tabr[] += taba[] * b, return the high word. */
10562|       |static js_limb_t mp_add_mul1(js_limb_t *tabr, const js_limb_t *taba, js_limb_t n,
10563|       |                          js_limb_t b)
10564|   901k|{
10565|   901k|    js_limb_t i, l;
10566|   901k|    js_dlimb_t t;
10567|       |
10568|   901k|    l = 0;
10569|  45.4M|    for(i = 0; i < n; i++) {
10570|  44.5M|        t = (js_dlimb_t)taba[i] * (js_dlimb_t)b + l + tabr[i];
10571|  44.5M|        tabr[i] = t;
10572|  44.5M|        l = t >> JS_LIMB_BITS;
10573|  44.5M|    }
10574|   901k|    return l;
10575|   901k|}
10576|       |
10577|       |/* size of the result : op1_size + op2_size. */
10578|       |static void mp_mul_basecase(js_limb_t *result,
10579|       |                            const js_limb_t *op1, js_limb_t op1_size,
10580|       |                            const js_limb_t *op2, js_limb_t op2_size)
10581|   173k|{
10582|   173k|    int i;
10583|   173k|    js_limb_t r;
10584|       |    
10585|   173k|    result[op1_size] = mp_mul1(result, op1, op1_size, op2[0], 0);
10586|  1.07M|    for(i=1;i<op2_size;i++) {
10587|   901k|        r = mp_add_mul1(result + i, op1, op1_size, op2[i]);
10588|   901k|        result[i + op1_size] = r;
10589|   901k|    }
10590|   173k|}
10591|       |
10592|       |/* tabr[] -= taba[] * b. Return the value to substract to the high
10593|       |   word. */
10594|       |static js_limb_t mp_sub_mul1(js_limb_t *tabr, const js_limb_t *taba, js_limb_t n,
10595|       |                          js_limb_t b)
10596|   502k|{
10597|   502k|    js_limb_t i, l;
10598|   502k|    js_dlimb_t t;
10599|       |
10600|   502k|    l = 0;
10601|  2.63M|    for(i = 0; i < n; i++) {
10602|  2.13M|        t = tabr[i] - (js_dlimb_t)taba[i] * (js_dlimb_t)b - l;
10603|  2.13M|        tabr[i] = t;
10604|  2.13M|        l = -(t >> JS_LIMB_BITS);
10605|  2.13M|    }
10606|   502k|    return l;
10607|   502k|}
10608|       |
10609|       |/* WARNING: d must be >= 2^(JS_LIMB_BITS-1) */
10610|       |static inline js_limb_t udiv1norm_init(js_limb_t d)
10611|   875k|{
10612|   875k|    js_limb_t a0, a1;
10613|   875k|    a1 = -d - 1;
10614|   875k|    a0 = -1;
10615|   875k|    return (((js_dlimb_t)a1 << JS_LIMB_BITS) | a0) / d;
10616|   875k|}
10617|       |
10618|       |/* return the quotient and the remainder in '*pr'of 'a1*2^JS_LIMB_BITS+a0
10619|       |   / d' with 0 <= a1 < d. */
10620|       |static inline js_limb_t udiv1norm(js_limb_t *pr, js_limb_t a1, js_limb_t a0,
10621|       |                                js_limb_t d, js_limb_t d_inv)
10622|  10.9M|{
10623|  10.9M|    js_limb_t n1m, n_adj, q, r, ah;
10624|  10.9M|    js_dlimb_t a;
10625|  10.9M|    n1m = ((js_slimb_t)a0 >> (JS_LIMB_BITS - 1));
10626|  10.9M|    n_adj = a0 + (n1m & d);
10627|  10.9M|    a = (js_dlimb_t)d_inv * (a1 - n1m) + n_adj;
10628|  10.9M|    q = (a >> JS_LIMB_BITS) + a1;
10629|       |    /* compute a - q * r and update q so that the remainder is\
10630|       |       between 0 and d - 1 */
10631|  10.9M|    a = ((js_dlimb_t)a1 << JS_LIMB_BITS) | a0;
10632|  10.9M|    a = a - (js_dlimb_t)q * d - d;
10633|  10.9M|    ah = a >> JS_LIMB_BITS;
10634|  10.9M|    q += 1 + ah;
10635|  10.9M|    r = (js_limb_t)a + (ah & d);
10636|  10.9M|    *pr = r;
10637|  10.9M|    return q;
10638|  10.9M|}
10639|       |
10640|   950k|#define UDIV1NORM_THRESHOLD 3
10641|       |
10642|       |/* b must be >= 1 << (JS_LIMB_BITS - 1) */
10643|       |static js_limb_t mp_div1norm(js_limb_t *tabr, const js_limb_t *taba, js_limb_t n,
10644|       |                          js_limb_t b, js_limb_t r)
10645|   870k|{
10646|   870k|    js_slimb_t i;
10647|       |
10648|   870k|    if (n >= UDIV1NORM_THRESHOLD) {
10649|   845k|        js_limb_t b_inv;
10650|   845k|        b_inv = udiv1norm_init(b);
10651|  11.3M|        for(i = n - 1; i >= 0; i--) {
10652|  10.5M|            tabr[i] = udiv1norm(&r, r, taba[i], b, b_inv);
10653|  10.5M|        }
10654|   845k|    } else {
10655|  24.5k|        js_dlimb_t a1;
10656|  73.5k|        for(i = n - 1; i >= 0; i--) {
10657|  49.0k|            a1 = ((js_dlimb_t)r << JS_LIMB_BITS) | taba[i];
10658|  49.0k|            tabr[i] = a1 / b;
10659|  49.0k|            r = a1 % b;
10660|  49.0k|        }
10661|  24.5k|    }
10662|   870k|    return r;
10663|   870k|}
10664|       |
10665|       |/* base case division: divides taba[0..na-1] by tabb[0..nb-1]. tabb[nb
10666|       |   - 1] must be >= 1 << (JS_LIMB_BITS - 1). na - nb must be >= 0. 'taba'
10667|       |   is modified and contains the remainder (nb limbs). tabq[0..na-nb]
10668|       |   contains the quotient with tabq[na - nb] <= 1. */
10669|       |static void mp_divnorm(js_limb_t *tabq, js_limb_t *taba, js_limb_t na,
10670|       |                       const js_limb_t *tabb, js_limb_t nb)
10671|   950k|{
10672|   950k|    js_limb_t r, a, c, q, v, b1, b1_inv, n, dummy_r;
10673|   950k|    int i, j;
10674|       |
10675|   950k|    b1 = tabb[nb - 1];
10676|   950k|    if (nb == 1) {
10677|   870k|        taba[0] = mp_div1norm(tabq, taba, na, b1, 0);
10678|   870k|        return;
10679|   870k|    }
10680|  80.3k|    n = na - nb;
10681|       |
10682|  80.3k|    if (n >= UDIV1NORM_THRESHOLD)
10683|  29.2k|        b1_inv = udiv1norm_init(b1);
10684|  51.0k|    else
10685|  51.0k|        b1_inv = 0;
10686|       |
10687|       |    /* first iteration: the quotient is only 0 or 1 */
10688|  80.3k|    q = 1;
10689|  82.6k|    for(j = nb - 1; j >= 0; j--) {
10690|  81.6k|        if (taba[n + j] != tabb[j]) {
10691|  79.3k|            if (taba[n + j] < tabb[j])
10692|  75.6k|                q = 0;
10693|  79.3k|            break;
10694|  79.3k|        }
10695|  81.6k|    }
10696|  80.3k|    tabq[n] = q;
10697|  80.3k|    if (q) {
10698|  4.76k|        mp_sub(taba + n, taba + n, tabb, nb, 0);
10699|  4.76k|    }
10700|       |
10701|   583k|    for(i = n - 1; i >= 0; i--) {
10702|   502k|        if (unlikely(taba[i + nb] >= b1)) {
10703|    600|            q = -1;
10704|   502k|        } else if (b1_inv) {
10705|   479k|            q = udiv1norm(&dummy_r, taba[i + nb], taba[i + nb - 1], b1, b1_inv);
10706|   479k|        } else {
10707|  23.0k|            js_dlimb_t al;
10708|  23.0k|            al = ((js_dlimb_t)taba[i + nb] << JS_LIMB_BITS) | taba[i + nb - 1];
10709|  23.0k|            q = al / b1;
10710|  23.0k|            r = al % b1;
10711|  23.0k|        }
10712|   502k|        r = mp_sub_mul1(taba + i, tabb, nb, q);
10713|       |
10714|   502k|        v = taba[i + nb];
10715|   502k|        a = v - r;
10716|   502k|        c = (a > v);
10717|   502k|        taba[i + nb] = a;
10718|       |
10719|   502k|        if (c != 0) {
10720|       |            /* negative result */
10721|   219k|            for(;;) {
10722|   219k|                q--;
10723|   219k|                c = mp_add(taba + i, taba + i, tabb, nb, 0);
10724|       |                /* propagate carry and test if positive result */
10725|   219k|                if (c != 0) {
10726|   215k|                    if (++taba[i + nb] == 0) {
10727|   215k|                        break;
10728|   215k|                    }
10729|   215k|                }
10730|   219k|            }
10731|   215k|        }
10732|   502k|        tabq[i] = q;
10733|   502k|    }
10734|  80.3k|}
10735|       |
10736|       |/* 1 <= shift <= JS_LIMB_BITS - 1 */
10737|       |static js_limb_t mp_shl(js_limb_t *tabr, const js_limb_t *taba, int n,
10738|       |                        int shift)
10739|  1.90M|{
10740|  1.90M|    int i;
10741|  1.90M|    js_limb_t l, v;
10742|  1.90M|    l = 0;
10743|  23.2M|    for(i = 0; i < n; i++) {
10744|  21.2M|        v = taba[i];
10745|  21.2M|        tabr[i] = (v << shift) | l;
10746|  21.2M|        l = v >> (JS_LIMB_BITS - shift);
10747|  21.2M|    }
10748|  1.90M|    return l;
10749|  1.90M|}
10750|       |
10751|       |/* r = (a + high*B^n) >> shift. Return the remainder r (0 <= r < 2^shift). 
10752|       |   1 <= shift <= LIMB_BITS - 1 */
10753|       |static js_limb_t mp_shr(js_limb_t *tab_r, const js_limb_t *tab, int n,
10754|       |                        int shift, js_limb_t high)
10755|  90.2k|{
10756|  90.2k|    int i;
10757|  90.2k|    js_limb_t l, a;
10758|       |
10759|  90.2k|    l = high;
10760|  3.63M|    for(i = n - 1; i >= 0; i--) {
10761|  3.54M|        a = tab[i];
10762|  3.54M|        tab_r[i] = (a >> shift) | (l << (JS_LIMB_BITS - shift));
10763|  3.54M|        l = a;
10764|  3.54M|    }
10765|  90.2k|    return l & (((js_limb_t)1 << shift) - 1);
10766|  90.2k|}
10767|       |
10768|       |static JSBigInt *js_bigint_new(JSContext *ctx, int len)
10769|  3.59M|{
10770|  3.59M|    JSBigInt *r;
10771|  3.59M|    if (len > JS_BIGINT_MAX_SIZE) {
10772|     35|        JS_ThrowRangeError(ctx, "BigInt is too large to allocate");
10773|     35|        return NULL;
10774|     35|    }
10775|  3.59M|    r = js_malloc(ctx, sizeof(JSBigInt) + len * sizeof(js_limb_t));
10776|  3.59M|    if (!r)
10777|      0|        return NULL;
10778|  3.59M|    r->header.ref_count = 1;
10779|  3.59M|    r->len = len;
10780|  3.59M|    return r;
10781|  3.59M|}
10782|       |
10783|       |static JSBigInt *js_bigint_set_si(JSBigIntBuf *buf, js_slimb_t a)
10784|  2.08M|{
10785|  2.08M|    JSBigInt *r = (JSBigInt *)buf->big_int_buf;
10786|  2.08M|    r->header.ref_count = 0; /* fail safe */
10787|  2.08M|    r->len = 1;
10788|  2.08M|    r->tab[0] = a;
10789|  2.08M|    return r;
10790|  2.08M|}
10791|       |
10792|       |static JSBigInt *js_bigint_set_si64(JSBigIntBuf *buf, int64_t a)
10793|      0|{
10794|      0|#if JS_LIMB_BITS == 64
10795|      0|    return js_bigint_set_si(buf, a);
10796|       |#else
10797|       |    JSBigInt *r = (JSBigInt *)buf->big_int_buf;
10798|       |    r->header.ref_count = 0; /* fail safe */
10799|       |    if (a >= INT32_MIN && a <= INT32_MAX) {
10800|       |        r->len = 1;
10801|       |        r->tab[0] = a;
10802|       |    } else {
10803|       |        r->len = 2;
10804|       |        r->tab[0] = a;
10805|       |        r->tab[1] = a >> JS_LIMB_BITS;
10806|       |    }
10807|       |    return r;
10808|       |#endif
10809|      0|}
10810|       |
10811|       |/* val must be a short big int */
10812|       |static JSBigInt *js_bigint_set_short(JSBigIntBuf *buf, JSValueConst val)
10813|  1.70M|{
10814|  1.70M|    return js_bigint_set_si(buf, JS_VALUE_GET_SHORT_BIG_INT(val));
10815|  1.70M|}
10816|       |
10817|       |static __maybe_unused void js_bigint_dump1(JSContext *ctx, const char *str,
10818|       |                                           const js_limb_t *tab, int len)
10819|      0|{
10820|      0|    int i;
10821|      0|    printf("%s: ", str);
10822|      0|    for(i = len - 1; i >= 0; i--) {
10823|      0|#if JS_LIMB_BITS == 32
10824|      0|        printf(" %08x", tab[i]);
10825|      0|#else
10826|      0|        printf(" %016" PRIx64, tab[i]);
10827|      0|#endif
10828|      0|    }
10829|      0|    printf("\n");
10830|      0|}
10831|       |
10832|       |static __maybe_unused void js_bigint_dump(JSContext *ctx, const char *str,
10833|       |                                          const JSBigInt *p)
10834|      0|{
10835|      0|    js_bigint_dump1(ctx, str, p->tab, p->len);
10836|      0|}
10837|       |
10838|       |static JSBigInt *js_bigint_new_si(JSContext *ctx, js_slimb_t a)
10839|   141k|{
10840|   141k|    JSBigInt *r;
10841|   141k|    r = js_bigint_new(ctx, 1);
10842|   141k|    if (!r)
10843|      0|        return NULL;
10844|   141k|    r->tab[0] = a;
10845|   141k|    return r;
10846|   141k|}
10847|       |
10848|       |static JSBigInt *js_bigint_new_si64(JSContext *ctx, int64_t a)
10849|      0|{
10850|      0|#if JS_LIMB_BITS == 64
10851|      0|    return js_bigint_new_si(ctx, a);
10852|       |#else
10853|       |    if (a >= INT32_MIN && a <= INT32_MAX) {
10854|       |        return js_bigint_new_si(ctx, a);
10855|       |    } else {
10856|       |        JSBigInt *r;
10857|       |        r = js_bigint_new(ctx, 2);
10858|       |        if (!r)
10859|       |            return NULL;
10860|       |        r->tab[0] = a;
10861|       |        r->tab[1] = a >> 32;
10862|       |        return r;
10863|       |    }
10864|       |#endif
10865|      0|}
10866|       |
10867|       |static JSBigInt *js_bigint_new_ui64(JSContext *ctx, uint64_t a)
10868|      0|{
10869|      0|    if (a <= INT64_MAX) {
10870|      0|        return js_bigint_new_si64(ctx, a);
10871|      0|    } else {
10872|      0|        JSBigInt *r;
10873|      0|        r = js_bigint_new(ctx, (65 + JS_LIMB_BITS - 1) / JS_LIMB_BITS);
10874|      0|        if (!r)
10875|      0|            return NULL;
10876|      0|#if JS_LIMB_BITS == 64
10877|      0|        r->tab[0] = a;
10878|      0|        r->tab[1] = 0;
10879|       |#else
10880|       |        r->tab[0] = a;
10881|       |        r->tab[1] = a >> 32;
10882|       |        r->tab[2] = 0;
10883|       |#endif
10884|      0|        return r;
10885|      0|    }
10886|      0|}
10887|       |
10888|       |static JSBigInt *js_bigint_new_di(JSContext *ctx, js_sdlimb_t a)
10889|  28.5k|{
10890|  28.5k|    JSBigInt *r;
10891|  28.5k|    if (a == (js_slimb_t)a) {
10892|      0|        r = js_bigint_new(ctx, 1);
10893|      0|        if (!r)
10894|      0|            return NULL;
10895|      0|        r->tab[0] = a;
10896|  28.5k|    } else {
10897|  28.5k|        r = js_bigint_new(ctx, 2);
10898|  28.5k|        if (!r)
10899|      0|            return NULL;
10900|  28.5k|        r->tab[0] = a;
10901|  28.5k|        r->tab[1] = a >> JS_LIMB_BITS;
10902|  28.5k|    }
10903|  28.5k|    return r;
10904|  28.5k|}
10905|       |
10906|       |/* Remove redundant high order limbs. Warning: 'a' may be
10907|       |   reallocated. Can never fail.
10908|       |*/
10909|       |static JSBigInt *js_bigint_normalize1(JSContext *ctx, JSBigInt *a, int l)
10910|  2.19M|{
10911|  2.19M|    js_limb_t v;
10912|       |
10913|  2.19M|    assert(a->header.ref_count == 1);
10914|  4.61M|    while (l > 1) {
10915|  4.30M|        v = a->tab[l - 1];
10916|  4.30M|        if ((v != 0 && v != -1) ||
10917|  4.30M|            (v & 1) != (a->tab[l - 2] >> (JS_LIMB_BITS - 1))) {
10918|  1.89M|            break;
10919|  1.89M|        }
10920|  2.41M|        l--;
10921|  2.41M|    }
10922|  2.19M|    if (l != a->len) {
10923|  1.11M|        JSBigInt *a1;
10924|       |        /* realloc to reduce the size */
10925|  1.11M|        a->len = l;
10926|  1.11M|        a1 = js_realloc(ctx, a, sizeof(JSBigInt) + l * sizeof(js_limb_t));
10927|  1.11M|        if (a1)
10928|  1.11M|            a = a1;
10929|  1.11M|    }
10930|  2.19M|    return a;
10931|  2.19M|}
10932|       |
10933|       |static JSBigInt *js_bigint_normalize(JSContext *ctx, JSBigInt *a)
10934|  2.12M|{
10935|  2.12M|    return js_bigint_normalize1(ctx, a, a->len);
10936|  2.12M|}
10937|       |
10938|       |/* return 0 or 1 depending on the sign */
10939|       |static inline int js_bigint_sign(const JSBigInt *a)
10940|  4.68M|{
10941|  4.68M|    return a->tab[a->len - 1] >> (JS_LIMB_BITS - 1);
10942|  4.68M|}
10943|       |
10944|       |static js_slimb_t js_bigint_get_si_sat(const JSBigInt *a)
10945|  63.5k|{
10946|  63.5k|    if (a->len == 1) {
10947|  55.8k|        return a->tab[0];
10948|  55.8k|    } else {
10949|       |#if JS_LIMB_BITS == 32
10950|       |        if (js_bigint_sign(a))
10951|       |            return INT32_MIN;
10952|       |        else
10953|       |            return INT32_MAX;
10954|       |#else
10955|  7.66k|        if (js_bigint_sign(a))
10956|    258|            return INT64_MIN;
10957|  7.40k|        else
10958|  7.40k|            return INT64_MAX;
10959|  7.66k|#endif
10960|  7.66k|    }
10961|  63.5k|}
10962|       |
10963|       |/* add the op1 limb */
10964|       |static JSBigInt *js_bigint_extend(JSContext *ctx, JSBigInt *r,
10965|       |                                  js_limb_t op1)
10966|   619k|{
10967|   619k|    int n2 = r->len;
10968|   619k|    if ((op1 != 0 && op1 != -1) ||
10969|   619k|        (op1 & 1) != r->tab[n2 - 1] >> (JS_LIMB_BITS - 1)) {
10970|  10.2k|        JSBigInt *r1;
10971|  10.2k|        r1 = js_realloc(ctx, r,
10972|  10.2k|                        sizeof(JSBigInt) + (n2 + 1) * sizeof(js_limb_t));
10973|  10.2k|        if (!r1) {
10974|      0|            js_free(ctx, r);
10975|      0|            return NULL;
10976|      0|        }
10977|  10.2k|        r = r1;
10978|  10.2k|        r->len = n2 + 1;
10979|  10.2k|        r->tab[n2] = op1;
10980|   609k|    } else {
10981|       |        /* otherwise still need to normalize the result */
10982|   609k|        r = js_bigint_normalize(ctx, r);
10983|   609k|    }
10984|   619k|    return r;
10985|   619k|}
10986|       |
10987|       |/* return NULL in case of error. Compute a + b (b_neg = 0) or a - b
10988|       |   (b_neg = 1) */
10989|       |/* XXX: optimize */
10990|       |static JSBigInt *js_bigint_add(JSContext *ctx, const JSBigInt *a,
10991|       |                               const JSBigInt *b, int b_neg)
10992|   606k|{
10993|   606k|    JSBigInt *r;
10994|   606k|    int n1, n2, i;
10995|   606k|    js_limb_t carry, op1, op2, a_sign, b_sign;
10996|       |    
10997|   606k|    n2 = max_int(a->len, b->len);
10998|   606k|    n1 = min_int(a->len, b->len);
10999|   606k|    r = js_bigint_new(ctx, n2);
11000|   606k|    if (!r)
11001|      0|        return NULL;
11002|       |    /* XXX: optimize */
11003|       |    /* common part */
11004|   606k|    carry = b_neg;
11005|  1.29M|    for(i = 0; i < n1; i++) {
11006|   687k|        op1 = a->tab[i];
11007|   687k|        op2 = b->tab[i] ^ (-b_neg);
11008|   687k|        ADDC(r->tab[i], carry, op1, op2, carry);
11009|   687k|    }
11010|   606k|    a_sign = -js_bigint_sign(a);
11011|   606k|    b_sign = (-js_bigint_sign(b)) ^ (-b_neg);
11012|       |    /* part with sign extension of one operand  */
11013|   606k|    if (a->len > b->len) {
11014|   453k|        for(i = n1; i < n2; i++) {
11015|   411k|            op1 = a->tab[i];
11016|   411k|            ADDC(r->tab[i], carry, op1, b_sign, carry);
11017|   411k|        }
11018|   564k|    } else if (a->len < b->len) {
11019|  2.37M|        for(i = n1; i < n2; i++) {
11020|  1.83M|            op2 = b->tab[i] ^ (-b_neg);
11021|  1.83M|            ADDC(r->tab[i], carry, a_sign, op2, carry);
11022|  1.83M|        }
11023|   532k|    }
11024|       |
11025|       |    /* part with sign extension for both operands. Extend the result
11026|       |       if necessary */
11027|   606k|    return js_bigint_extend(ctx, r, a_sign + b_sign + carry);
11028|   606k|}
11029|       |
11030|       |/* XXX: optimize */
11031|       |static JSBigInt *js_bigint_neg(JSContext *ctx, const JSBigInt *a)
11032|   288k|{
11033|   288k|    JSBigIntBuf buf;
11034|   288k|    JSBigInt *b;
11035|   288k|    b = js_bigint_set_si(&buf, 0);
11036|   288k|    return js_bigint_add(ctx, b, a, 1);
11037|   288k|}
11038|       |
11039|       |static JSBigInt *js_bigint_mul(JSContext *ctx, const JSBigInt *a,
11040|       |                               const JSBigInt *b)
11041|   173k|{
11042|   173k|    JSBigInt *r;
11043|       |    
11044|   173k|    r = js_bigint_new(ctx, a->len + b->len);
11045|   173k|    if (!r)
11046|      0|        return NULL;
11047|   173k|    mp_mul_basecase(r->tab, a->tab, a->len, b->tab, b->len);
11048|       |    /* correct the result if negative operands (no overflow is
11049|       |       possible) */
11050|   173k|    if (js_bigint_sign(a))
11051|  26.8k|        mp_sub(r->tab + a->len, r->tab + a->len, b->tab, b->len, 0);
11052|   173k|    if (js_bigint_sign(b))
11053|  38.8k|        mp_sub(r->tab + b->len, r->tab + b->len, a->tab, a->len, 0);
11054|   173k|    return js_bigint_normalize(ctx, r);
11055|   173k|}
11056|       |
11057|       |/* return the division or the remainder. 'b' must be != 0. return NULL
11058|       |   in case of exception (division by zero or memory error) */
11059|       |static JSBigInt *js_bigint_divrem(JSContext *ctx, const JSBigInt *a,
11060|       |                                  const JSBigInt *b, BOOL is_rem)
11061|  1.11M|{
11062|  1.11M|    JSBigInt *r, *q;
11063|  1.11M|    js_limb_t *tabb, h;
11064|  1.11M|    int na, nb, a_sign, b_sign, shift;
11065|       |    
11066|  1.11M|    if (b->len == 1 && b->tab[0] == 0) {
11067|      3|        JS_ThrowRangeError(ctx, "BigInt division by zero");
11068|      3|        return NULL;
11069|      3|    }
11070|       |    
11071|  1.11M|    a_sign = js_bigint_sign(a);
11072|  1.11M|    b_sign = js_bigint_sign(b);
11073|  1.11M|    na = a->len;
11074|  1.11M|    nb = b->len;
11075|       |
11076|  1.11M|    r = js_bigint_new(ctx, na + 2); 
11077|  1.11M|    if (!r)
11078|      0|        return NULL;
11079|  1.11M|    if (a_sign) {
11080|   454k|        mp_neg(r->tab, a->tab, na);
11081|   656k|    } else {
11082|   656k|        memcpy(r->tab, a->tab, na * sizeof(a->tab[0]));
11083|   656k|    }
11084|       |    /* normalize */
11085|  1.11M|    while (na > 1 && r->tab[na - 1] == 0)
11086|  5.21k|        na--;
11087|       |
11088|  1.11M|    tabb = js_malloc(ctx, nb * sizeof(tabb[0]));
11089|  1.11M|    if (!tabb) {
11090|      0|        js_free(ctx, r);
11091|      0|        return NULL;
11092|      0|    }
11093|  1.11M|    if (b_sign) {
11094|   588k|        mp_neg(tabb, b->tab, nb);
11095|   588k|    } else {
11096|   522k|        memcpy(tabb, b->tab, nb * sizeof(tabb[0]));
11097|   522k|    }
11098|       |    /* normalize */
11099|  1.11M|    while (nb > 1 && tabb[nb - 1] == 0)
11100|  5.39k|        nb--;
11101|       |
11102|       |    /* trivial case if 'a' is small */
11103|  1.11M|    if (na < nb) {
11104|   159k|        js_free(ctx, r);
11105|   159k|        js_free(ctx, tabb);
11106|   159k|        if (is_rem) {
11107|       |            /* r = a */
11108|  48.3k|            r = js_bigint_new(ctx, a->len);
11109|  48.3k|            if (!r)
11110|      0|                return NULL;
11111|  48.3k|            memcpy(r->tab, a->tab, a->len * sizeof(a->tab[0])); 
11112|  48.3k|            return r;
11113|   111k|        } else {
11114|       |            /* q = 0 */
11115|   111k|            return js_bigint_new_si(ctx, 0);
11116|   111k|        }
11117|   159k|    }
11118|       |
11119|       |    /* normalize 'b' */
11120|   950k|    shift = js_limb_clz(tabb[nb - 1]);
11121|   950k|    if (shift != 0) {
11122|   945k|        mp_shl(tabb, tabb, nb, shift);
11123|   945k|        h = mp_shl(r->tab, r->tab, na, shift);
11124|   945k|        if (h != 0)
11125|   763k|            r->tab[na++] = h;
11126|   945k|    }
11127|       |
11128|   950k|    q = js_bigint_new(ctx, na - nb + 2); /* one more limb for the sign */
11129|   950k|    if (!q) {
11130|      0|        js_free(ctx, r);
11131|      0|        js_free(ctx, tabb);
11132|      0|        return NULL;
11133|      0|    }
11134|       |
11135|       |    //    js_bigint_dump1(ctx, "a", r->tab, na);
11136|       |    //    js_bigint_dump1(ctx, "b", tabb, nb);
11137|   950k|    mp_divnorm(q->tab, r->tab, na, tabb, nb);
11138|   950k|    js_free(ctx, tabb);
11139|       |
11140|   950k|    if (is_rem) {
11141|  76.2k|        js_free(ctx, q);
11142|  76.2k|        if (shift != 0)
11143|  71.1k|            mp_shr(r->tab, r->tab, nb, shift, 0);
11144|  76.2k|        r->tab[nb++] = 0;
11145|  76.2k|        if (a_sign)
11146|  6.48k|            mp_neg(r->tab, r->tab, nb);
11147|  76.2k|        r = js_bigint_normalize1(ctx, r, nb);
11148|  76.2k|        return r;
11149|   874k|    } else {
11150|   874k|        js_free(ctx, r);
11151|   874k|        q->tab[na - nb + 1] = 0;
11152|   874k|        if (a_sign ^ b_sign) {
11153|   494k|            mp_neg(q->tab, q->tab, q->len);
11154|   494k|        }
11155|   874k|        q = js_bigint_normalize(ctx, q);
11156|   874k|        return q;
11157|   874k|    }
11158|   950k|}
11159|       |
11160|       |/* and, or, xor */
11161|       |static JSBigInt *js_bigint_logic(JSContext *ctx, const JSBigInt *a,
11162|       |                                 const JSBigInt *b, OPCodeEnum op)
11163|   198k|{
11164|   198k|    JSBigInt *r;
11165|   198k|    js_limb_t b_sign;
11166|   198k|    int a_len, b_len, i;
11167|       |
11168|   198k|    if (a->len < b->len) {
11169|  48.8k|        const JSBigInt *tmp;
11170|  48.8k|        tmp = a;
11171|  48.8k|        a = b;
11172|  48.8k|        b = tmp;
11173|  48.8k|    }
11174|       |    /* a_len >= b_len */
11175|   198k|    a_len = a->len;
11176|   198k|    b_len = b->len;
11177|   198k|    b_sign = -js_bigint_sign(b);
11178|       |
11179|   198k|    r = js_bigint_new(ctx, a_len);
11180|   198k|    if (!r)
11181|      0|        return NULL;
11182|   198k|    switch(op) {
11183|  40.8k|    case OP_or:
11184|   162k|        for(i = 0; i < b_len; i++) {
11185|   121k|            r->tab[i] = a->tab[i] | b->tab[i];
11186|   121k|        }
11187|   450k|        for(i = b_len; i < a_len; i++) {
11188|   409k|            r->tab[i] = a->tab[i] | b_sign;
11189|   409k|        }
11190|  40.8k|        break;
11191|  33.9k|    case OP_and:
11192|   175k|        for(i = 0; i < b_len; i++) {
11193|   141k|            r->tab[i] = a->tab[i] & b->tab[i];
11194|   141k|        }
11195|   366k|        for(i = b_len; i < a_len; i++) {
11196|   332k|            r->tab[i] = a->tab[i] & b_sign;
11197|   332k|        }
11198|  33.9k|        break;
11199|   123k|    case OP_xor:
11200|   398k|        for(i = 0; i < b_len; i++) {
11201|   274k|            r->tab[i] = a->tab[i] ^ b->tab[i];
11202|   274k|        }
11203|  5.17M|        for(i = b_len; i < a_len; i++) {
11204|  5.05M|            r->tab[i] = a->tab[i] ^ b_sign;
11205|  5.05M|        }
11206|   123k|        break;
11207|      0|    default:
11208|      0|        abort();
11209|   198k|    }
11210|   198k|    return js_bigint_normalize(ctx, r);
11211|   198k|}
11212|       |
11213|       |static JSBigInt *js_bigint_not(JSContext *ctx, const JSBigInt *a)
11214|  24.2k|{
11215|  24.2k|    JSBigInt *r;
11216|  24.2k|    int i;
11217|       |    
11218|  24.2k|    r = js_bigint_new(ctx, a->len);
11219|  24.2k|    if (!r)
11220|      0|        return NULL;
11221|   491k|    for(i = 0; i < a->len; i++) {
11222|   467k|        r->tab[i] = ~a->tab[i];
11223|   467k|    }
11224|       |    /* no normalization is needed */
11225|  24.2k|    return r;
11226|  24.2k|}
11227|       |
11228|       |static JSBigInt *js_bigint_shl(JSContext *ctx, const JSBigInt *a,
11229|       |                               unsigned int shift1)
11230|  16.4k|{
11231|  16.4k|    int d, i, shift;
11232|  16.4k|    JSBigInt *r;
11233|  16.4k|    js_limb_t l;
11234|       |
11235|  16.4k|    if (a->len == 1 && a->tab[0] == 0)
11236|    512|        return js_bigint_new_si(ctx, 0); /* zero case */
11237|  15.9k|    d = shift1 / JS_LIMB_BITS;
11238|  15.9k|    shift = shift1 % JS_LIMB_BITS;
11239|  15.9k|    r = js_bigint_new(ctx, a->len + d);
11240|  15.9k|    if (!r)
11241|     35|        return NULL;
11242|  9.03M|    for(i = 0; i < d; i++)
11243|  9.01M|        r->tab[i] = 0;
11244|  15.8k|    if (shift == 0) {
11245|   158k|        for(i = 0; i < a->len; i++) {
11246|   155k|            r->tab[i + d] = a->tab[i];
11247|   155k|        }
11248|  12.6k|    } else {
11249|  12.6k|        l = mp_shl(r->tab + d, a->tab, a->len, shift);
11250|  12.6k|        if (js_bigint_sign(a))
11251|  2.67k|            l |= (js_limb_t)(-1) << shift;
11252|  12.6k|        r = js_bigint_extend(ctx, r, l);
11253|  12.6k|    }
11254|  15.8k|    return r;
11255|  15.9k|}
11256|       |
11257|       |static JSBigInt *js_bigint_shr(JSContext *ctx, const JSBigInt *a,
11258|       |                               unsigned int shift1)
11259|  47.1k|{
11260|  47.1k|    int d, i, shift, a_sign, n1;
11261|  47.1k|    JSBigInt *r;
11262|       |
11263|  47.1k|    d = shift1 / JS_LIMB_BITS;
11264|  47.1k|    shift = shift1 % JS_LIMB_BITS;
11265|  47.1k|    a_sign = js_bigint_sign(a);
11266|  47.1k|    if (d >= a->len)
11267|  23.3k|        return js_bigint_new_si(ctx, -a_sign);
11268|  23.7k|    n1 = a->len - d;
11269|  23.7k|    r = js_bigint_new(ctx, n1);
11270|  23.7k|    if (!r)
11271|      0|        return NULL;
11272|  23.7k|    if (shift == 0) {
11273|  6.69M|        for(i = 0; i < n1; i++) {
11274|  6.68M|            r->tab[i] = a->tab[i + d];
11275|  6.68M|        }
11276|       |        /* no normalization is needed */
11277|  19.0k|    } else {
11278|  19.0k|        mp_shr(r->tab, a->tab + d, n1, shift, -a_sign);
11279|  19.0k|        r = js_bigint_normalize(ctx, r);
11280|  19.0k|    }
11281|  23.7k|    return r;
11282|  23.7k|}
11283|       |
11284|       |static JSBigInt *js_bigint_pow(JSContext *ctx, const JSBigInt *a, JSBigInt *b)
11285|  19.9k|{
11286|  19.9k|    uint32_t e;
11287|  19.9k|    int n_bits, i;
11288|  19.9k|    JSBigInt *r, *r1;
11289|       |    
11290|       |    /* b must be >= 0 */
11291|  19.9k|    if (js_bigint_sign(b)) {
11292|      2|        JS_ThrowRangeError(ctx, "BigInt negative exponent");
11293|      2|        return NULL;
11294|      2|    }
11295|  19.9k|    if (b->len == 1 && b->tab[0] == 0) {
11296|       |        /* a^0 = 1 */
11297|  2.58k|        return js_bigint_new_si(ctx, 1);
11298|  17.3k|    } else if (a->len == 1) {
11299|  16.4k|        js_limb_t v;
11300|  16.4k|        BOOL is_neg;
11301|       |
11302|  16.4k|        v = a->tab[0];
11303|  16.4k|        if (v <= 1)
11304|  3.57k|            return js_bigint_new_si(ctx, v);
11305|  12.9k|        else if (v == -1)
11306|      0|            return js_bigint_new_si(ctx, 1 - 2 * (b->tab[0] & 1));
11307|  12.9k|        is_neg = (js_slimb_t)v < 0;
11308|  12.9k|        if (is_neg)
11309|      0|            v = -v;
11310|  12.9k|        if ((v & (v - 1)) == 0) {
11311|  1.31k|            uint64_t e1;
11312|  1.31k|            int n;
11313|       |            /* v = 2^n */
11314|  1.31k|            n = JS_LIMB_BITS - 1 - js_limb_clz(v);
11315|  1.31k|            if (b->len > 1)
11316|      1|                goto overflow;
11317|  1.31k|            if (b->tab[0] > INT32_MAX)
11318|      1|                goto overflow;
11319|  1.30k|            e = b->tab[0];
11320|  1.30k|            e1 = (uint64_t)e * n;
11321|  1.30k|            if (e1 > JS_BIGINT_MAX_SIZE * JS_LIMB_BITS)
11322|      1|                goto overflow;
11323|  1.30k|            e = e1;
11324|  1.30k|            if (is_neg)
11325|      0|                is_neg = b->tab[0] & 1;
11326|  1.30k|            r = js_bigint_new(ctx,
11327|  1.30k|                              (e + JS_LIMB_BITS + 1 - is_neg) / JS_LIMB_BITS);
11328|  1.30k|            if (!r)
11329|      0|                return NULL;
11330|  1.30k|            memset(r->tab, 0, sizeof(r->tab[0]) * r->len);
11331|  1.30k|            r->tab[e / JS_LIMB_BITS] =
11332|  1.30k|                (js_limb_t)(1 - 2 * is_neg) << (e % JS_LIMB_BITS);
11333|  1.30k|            return r;
11334|  1.30k|        }
11335|  12.9k|    }
11336|  12.4k|    if (b->len > 1)
11337|      1|        goto overflow;
11338|  12.4k|    if (b->tab[0] > INT32_MAX)
11339|     12|        goto overflow;
11340|  12.4k|    e = b->tab[0];
11341|  12.4k|    n_bits = 32 - clz32(e);
11342|       |
11343|  12.4k|    r = js_bigint_new(ctx, a->len);
11344|  12.4k|    if (!r)
11345|      0|        return NULL;
11346|  12.4k|    memcpy(r->tab, a->tab, a->len * sizeof(a->tab[0]));
11347|  78.8k|    for(i = n_bits - 2; i >= 0; i--) {
11348|  66.4k|        r1 = js_bigint_mul(ctx, r, r);
11349|  66.4k|        if (!r1)
11350|      0|            return NULL;
11351|  66.4k|        js_free(ctx, r);
11352|  66.4k|        r = r1;
11353|  66.4k|        if ((e >> i) & 1) {
11354|  41.8k|            r1 = js_bigint_mul(ctx, r, a);
11355|  41.8k|            if (!r1)
11356|      0|                return NULL;
11357|  41.8k|            js_free(ctx, r);
11358|  41.8k|            r = r1;
11359|  41.8k|        }
11360|  66.4k|    }
11361|  12.4k|    return r;
11362|     16| overflow:
11363|     16|    JS_ThrowRangeError(ctx, "BigInt is too large");
11364|     16|    return NULL;
11365|  12.4k|}
11366|       |
11367|       |/* return (mant, exp) so that abs(a) ~ mant*2^(exp - (limb_bits -
11368|       |   1). a must be != 0. */
11369|       |static uint64_t js_bigint_get_mant_exp(JSContext *ctx,
11370|       |                                       int *pexp, const JSBigInt *a)
11371|  48.6k|{
11372|  48.6k|    js_limb_t t[4 - JS_LIMB_BITS / 32], carry, v, low_bits;
11373|  48.6k|    int n1, n2, sgn, shift, i, j, e;
11374|  48.6k|    uint64_t a1, a0;
11375|       |
11376|  48.6k|    n2 = 4 - JS_LIMB_BITS / 32;
11377|  48.6k|    n1 = a->len - n2;
11378|  48.6k|    sgn = js_bigint_sign(a);
11379|       |
11380|       |    /* low_bits != 0 if there are a non zero low bit in abs(a) */
11381|  48.6k|    low_bits = 0;
11382|  48.6k|    carry = sgn;
11383|   109k|    for(i = 0; i < n1; i++) {
11384|  60.5k|        v = (a->tab[i] ^ (-sgn)) + carry;
11385|  60.5k|        carry = v < carry;
11386|  60.5k|        low_bits |= v;
11387|  60.5k|    }
11388|       |    /* get the n2 high limbs of abs(a) */
11389|   145k|    for(j = 0; j < n2; j++) {
11390|  97.3k|        i = j + n1;
11391|  97.3k|        if (i < 0) {
11392|  19.6k|            v = 0;
11393|  77.6k|        } else {
11394|  77.6k|            v = (a->tab[i] ^ (-sgn)) + carry;
11395|  77.6k|            carry = v < carry;
11396|  77.6k|        }
11397|  97.3k|        t[j] = v;
11398|  97.3k|    }
11399|       |    
11400|       |#if JS_LIMB_BITS == 32
11401|       |    a1 = ((uint64_t)t[2] << 32) | t[1];
11402|       |    a0 = (uint64_t)t[0] << 32;
11403|       |#else
11404|  48.6k|    a1 = t[1];
11405|  48.6k|    a0 = t[0];
11406|  48.6k|#endif
11407|  48.6k|    a0 |= (low_bits != 0);
11408|       |    /* normalize */
11409|  48.6k|    if (a1 == 0) {
11410|       |        /* JS_LIMB_BITS = 64 bit only */
11411|  1.49k|        shift = 64;
11412|  1.49k|        a1 = a0;
11413|  1.49k|        a0 = 0;
11414|  47.1k|    } else {
11415|  47.1k|        shift = clz64(a1);
11416|  47.1k|        if (shift != 0) {
11417|  47.1k|            a1 = (a1 << shift) | (a0 >> (64 - shift));
11418|  47.1k|            a0 <<= shift;
11419|  47.1k|        }
11420|  47.1k|    }
11421|  48.6k|    a1 |= (a0 != 0); /* keep the bits for the final rounding */
11422|       |    /* compute the exponent */
11423|  48.6k|    e = a->len * JS_LIMB_BITS - shift - 1;
11424|  48.6k|    *pexp = e;
11425|  48.6k|    return a1;
11426|  48.6k|}
11427|       |
11428|       |/* shift left with round to nearest, ties to even. n >= 1 */
11429|       |static uint64_t shr_rndn(uint64_t a, int n)
11430|      0|{
11431|      0|    uint64_t addend = ((a >> n) & 1) + ((1 << (n - 1)) - 1);
11432|      0|    return (a + addend) >> n;
11433|      0|}
11434|       |
11435|       |/* convert to float64 with round to nearest, ties to even. Return
11436|       |   +/-infinity if too large. */
11437|       |static double js_bigint_to_float64(JSContext *ctx, const JSBigInt *a)
11438|      0|{
11439|      0|    int sgn, e;
11440|      0|    uint64_t mant;
11441|       |
11442|      0|    if (a->len == 1) {
11443|       |        /* fast case, including zero */
11444|      0|        return (double)(js_slimb_t)a->tab[0];
11445|      0|    }
11446|       |
11447|      0|    sgn = js_bigint_sign(a);
11448|      0|    mant = js_bigint_get_mant_exp(ctx, &e, a);
11449|      0|    if (e > 1023) {
11450|       |        /* overflow: return infinity */
11451|      0|        mant = 0;
11452|      0|        e = 1024;
11453|      0|    } else {
11454|      0|        mant = (mant >> 1) | (mant & 1); /* avoid overflow in rounding */
11455|      0|        mant = shr_rndn(mant, 10);
11456|       |        /* rounding can cause an overflow */
11457|      0|        if (mant >= ((uint64_t)1 << 53)) {
11458|      0|            mant >>= 1;
11459|      0|            e++;
11460|      0|        }
11461|      0|        mant &= (((uint64_t)1 << 52) - 1);
11462|      0|    }
11463|      0|    return uint64_as_float64(((uint64_t)sgn << 63) |
11464|      0|                             ((uint64_t)(e + 1023) << 52) |
11465|      0|                             mant);
11466|      0|}
11467|       |
11468|       |/* return (1, NULL) if not an integer, (2, NULL) if NaN or Infinity,
11469|       |   (0, n) if an integer, (0, NULL) in case of memory error */
11470|       |static JSBigInt *js_bigint_from_float64(JSContext *ctx, int *pres, double a1)
11471|      0|{
11472|      0|    uint64_t a = float64_as_uint64(a1);
11473|      0|    int sgn, e, shift;
11474|      0|    uint64_t mant;
11475|      0|    JSBigIntBuf buf;
11476|      0|    JSBigInt *r;
11477|       |    
11478|      0|    sgn = a >> 63;
11479|      0|    e = (a >> 52) & ((1 << 11) - 1);
11480|      0|    mant = a & (((uint64_t)1 << 52) - 1);
11481|      0|    if (e == 2047) {
11482|       |        /* NaN, Infinity */
11483|      0|        *pres = 2;
11484|      0|        return NULL;
11485|      0|    }
11486|      0|    if (e == 0 && mant == 0) {
11487|       |        /* zero */
11488|      0|        *pres = 0;
11489|      0|        return js_bigint_new_si(ctx, 0);
11490|      0|    }
11491|      0|    e -= 1023;
11492|       |    /* 0 < a < 1 : not an integer */
11493|      0|    if (e < 0)
11494|      0|        goto not_an_integer;
11495|      0|    mant |= (uint64_t)1 << 52;
11496|      0|    if (e < 52) {
11497|      0|        shift = 52 - e;
11498|       |        /* check that there is no fractional part */
11499|      0|        if (mant & (((uint64_t)1 << shift) - 1)) {
11500|      0|        not_an_integer:
11501|      0|            *pres = 1;
11502|      0|            return NULL;
11503|      0|        }
11504|      0|        mant >>= shift;
11505|      0|        e = 0;
11506|      0|    } else {
11507|      0|        e -= 52;
11508|      0|    }
11509|      0|    if (sgn)
11510|      0|        mant = -mant;
11511|       |    /* the integer is mant*2^e */
11512|      0|    r = js_bigint_set_si64(&buf, (int64_t)mant);
11513|      0|    *pres = 0;
11514|      0|    return js_bigint_shl(ctx, r, e);
11515|      0|}
11516|       |
11517|       |/* return -1, 0, 1 or (2) (unordered) */
11518|       |static int js_bigint_float64_cmp(JSContext *ctx, const JSBigInt *a,
11519|       |                                 double b)
11520|   241k|{
11521|   241k|    int b_sign, a_sign, e, f;
11522|   241k|    uint64_t mant, b1, a_mant;
11523|       |    
11524|   241k|    b1 = float64_as_uint64(b);
11525|   241k|    b_sign = b1 >> 63;
11526|   241k|    e = (b1 >> 52) & ((1 << 11) - 1);
11527|   241k|    mant = b1 & (((uint64_t)1 << 52) - 1);
11528|   241k|    a_sign = js_bigint_sign(a);
11529|   241k|    if (e == 2047) {
11530|   120k|        if (mant != 0) {
11531|       |            /* NaN */
11532|   117k|            return 2;
11533|   117k|        } else {
11534|       |            /* +/- infinity */
11535|  3.26k|            return 2 * b_sign - 1;
11536|  3.26k|        }
11537|   120k|    } else if (e == 0 && mant == 0) {
11538|       |        /* b = +/-0 */
11539|  17.0k|        if (a->len == 1 && a->tab[0] == 0)
11540|  4.71k|            return 0;
11541|  12.2k|        else
11542|  12.2k|            return 1 - 2 * a_sign;
11543|   103k|    } else if (a->len == 1 && a->tab[0] == 0) {
11544|       |        /* a = 0, b != 0 */
11545|  15.8k|        return 2 * b_sign - 1;
11546|  87.9k|    } else if (a_sign != b_sign) {
11547|  39.2k|        return 1 - 2 * a_sign;
11548|  48.6k|    } else {
11549|  48.6k|        e -= 1023;
11550|       |        /* Note: handling denormals is not necessary because we
11551|       |           compare to integers hence f >= 0 */
11552|       |        /* compute f so that 2^f <= abs(a) < 2^(f+1) */
11553|  48.6k|        a_mant = js_bigint_get_mant_exp(ctx, &f, a);
11554|  48.6k|        if (f != e) {
11555|  29.8k|            if (f < e)
11556|  1.17k|                return -1;
11557|  28.6k|            else
11558|  28.6k|                return 1;
11559|  29.8k|        } else {
11560|  18.8k|            mant = (mant | ((uint64_t)1 << 52)) << 11; /* align to a_mant */
11561|  18.8k|            if (a_mant < mant)
11562|    520|                return 2 * a_sign - 1;
11563|  18.3k|            else if (a_mant > mant)
11564|    997|                return 1 - 2 * a_sign;
11565|  17.3k|            else
11566|  17.3k|                return 0;
11567|  18.8k|        }
11568|  48.6k|    }
11569|   241k|}
11570|       |
11571|       |/* return -1, 0 or 1 */
11572|       |static int js_bigint_cmp(JSContext *ctx, const JSBigInt *a,
11573|       |                         const JSBigInt *b)
11574|   154k|{
11575|   154k|    int a_sign, b_sign, res, i;
11576|   154k|    a_sign = js_bigint_sign(a);
11577|   154k|    b_sign = js_bigint_sign(b);
11578|   154k|    if (a_sign != b_sign) {
11579|  88.4k|        res = 1 - 2 * a_sign;
11580|  88.4k|    } else {
11581|       |        /* we assume the numbers are normalized */
11582|  66.1k|        if (a->len != b->len) {
11583|  42.0k|            if (a->len < b->len)
11584|  25.0k|                res = 2 * a_sign - 1;
11585|  16.9k|            else
11586|  16.9k|                res = 1 - 2 * a_sign;
11587|  42.0k|        } else {
11588|  24.1k|            res = 0;
11589|  41.2k|            for(i = a->len -1; i >= 0; i--) {
11590|  33.6k|                if (a->tab[i] != b->tab[i]) {
11591|  16.4k|                    if (a->tab[i] < b->tab[i])
11592|  6.17k|                        res = -1;
11593|  10.3k|                    else
11594|  10.3k|                        res = 1;
11595|  16.4k|                    break;
11596|  16.4k|                }
11597|  33.6k|            }
11598|  24.1k|        }
11599|  66.1k|    }
11600|   154k|    return res;
11601|   154k|}
11602|       |
11603|       |/* contains 10^i */
11604|       |static const js_limb_t js_pow_dec[JS_LIMB_DIGITS + 1] = {
11605|       |    1U,
11606|       |    10U,
11607|       |    100U,
11608|       |    1000U,
11609|       |    10000U,
11610|       |    100000U,
11611|       |    1000000U,
11612|       |    10000000U,
11613|       |    100000000U,
11614|       |    1000000000U,
11615|       |#if JS_LIMB_BITS == 64
11616|       |    10000000000U,
11617|       |    100000000000U,
11618|       |    1000000000000U,
11619|       |    10000000000000U,
11620|       |    100000000000000U,
11621|       |    1000000000000000U,
11622|       |    10000000000000000U,
11623|       |    100000000000000000U,
11624|       |    1000000000000000000U,
11625|       |    10000000000000000000U,
11626|       |#endif
11627|       |};
11628|       |
11629|       |/* syntax: [-]digits in base radix. Return NULL if memory error. radix
11630|       |   = 10, 2, 8 or 16. */
11631|       |static JSBigInt *js_bigint_from_string(JSContext *ctx,
11632|       |                                       const char *str, int radix)
11633|   247k|{
11634|   247k|    const char *p = str;
11635|   247k|    int is_neg, n_digits, n_limbs, len, log2_radix, n_bits, i;
11636|   247k|    JSBigInt *r;
11637|   247k|    js_limb_t v, c, h;
11638|       |    
11639|   247k|    is_neg = 0;
11640|   247k|    if (*p == '-') {
11641|  15.5k|        is_neg = 1;
11642|  15.5k|        p++;
11643|  15.5k|    }
11644|   252k|    while (*p == '0')
11645|  4.30k|        p++;
11646|   247k|    n_digits = strlen(p);
11647|   247k|    log2_radix = 32 - clz32(radix - 1); /* ceil(log2(radix)) */
11648|       |    /* compute the maximum number of limbs */
11649|       |    /* XXX: overflow */
11650|   247k|    if (radix == 10) {
11651|   246k|        n_bits = (n_digits * 27 + 7) / 8; /* >= ceil(n_digits * log2(10)) */
11652|   246k|    } else {
11653|  1.63k|        n_bits = n_digits * log2_radix;
11654|  1.63k|    }
11655|       |    /* we add one extra bit for the sign */
11656|   247k|    n_limbs = max_int(1, n_bits / JS_LIMB_BITS + 1);
11657|   247k|    r = js_bigint_new(ctx, n_limbs);
11658|   247k|    if (!r)
11659|      0|        return NULL;
11660|   247k|    if (radix == 10) {
11661|   246k|        int digits_per_limb = JS_LIMB_DIGITS;
11662|   246k|        len = 1;
11663|   246k|        r->tab[0] = 0;
11664|   962k|        for(;;) {
11665|       |            /* XXX: slow */
11666|   962k|            v = 0;
11667|  11.4M|            for(i = 0; i < digits_per_limb; i++) {
11668|  10.9M|                c = to_digit(*p);
11669|  10.9M|                if (c >= radix)
11670|   488k|                    break;
11671|  10.4M|                p++;
11672|  10.4M|                v = v * 10 + c;
11673|  10.4M|            }
11674|   962k|            if (i == 0)
11675|   246k|                break;
11676|   716k|            if (len == 1 && r->tab[0] == 0) {
11677|   243k|                r->tab[0] = v;
11678|   472k|            } else {
11679|   472k|                h = mp_mul1(r->tab, r->tab, len, js_pow_dec[i], v);
11680|   472k|                if (h != 0) {
11681|   467k|                    r->tab[len++] = h;
11682|   467k|                }
11683|   472k|            }
11684|   716k|        }
11685|       |        /* add one extra limb to have the correct sign*/
11686|   246k|        if ((r->tab[len - 1] >> (JS_LIMB_BITS - 1)) != 0)
11687|    871|            r->tab[len++] = 0;
11688|   246k|        r->len = len;
11689|   246k|    } else {
11690|  1.63k|        unsigned int bit_pos, shift, pos;
11691|       |        
11692|       |        /* power of two base: no multiplication is needed */
11693|  1.63k|        r->len = n_limbs;
11694|  1.63k|        memset(r->tab, 0, sizeof(r->tab[0]) * n_limbs);
11695|  25.8k|        for(i = 0; i < n_digits; i++) {
11696|  24.1k|            c = to_digit(p[n_digits - 1 - i]);
11697|  24.1k|            assert(c < radix);
11698|  24.1k|            bit_pos = i * log2_radix;
11699|  24.1k|            shift = bit_pos & (JS_LIMB_BITS - 1);
11700|  24.1k|            pos = bit_pos / JS_LIMB_BITS;
11701|  24.1k|            r->tab[pos] |= c << shift;
11702|       |            /* if log2_radix does not divide JS_LIMB_BITS, needed an
11703|       |               additional op */
11704|  24.1k|            if (shift + log2_radix > JS_LIMB_BITS) {
11705|    384|                r->tab[pos + 1] |= c >> (JS_LIMB_BITS - shift);
11706|    384|            }
11707|  24.1k|        }
11708|  1.63k|    }
11709|   247k|    r = js_bigint_normalize(ctx, r);
11710|       |    /* XXX: could do it in place */
11711|   247k|    if (is_neg) {
11712|  15.5k|        JSBigInt *r1;
11713|  15.5k|        r1 = js_bigint_neg(ctx, r);
11714|  15.5k|        js_free(ctx, r);
11715|  15.5k|        r = r1;
11716|  15.5k|    }
11717|   247k|    return r;
11718|   247k|}
11719|       |
11720|       |/* 2 <= base <= 36 */
11721|       |static char const digits[36] = "0123456789abcdefghijklmnopqrstuvwxyz";
11722|       |
11723|       |/* special version going backwards */
11724|       |/* XXX: use dtoa.c */
11725|       |static char *js_u64toa(char *q, int64_t n, unsigned int base)
11726|  15.1k|{
11727|  15.1k|    int digit;
11728|  15.1k|    if (base == 10) {
11729|       |        /* division by known base uses multiplication */
11730|   151k|        do {
11731|   151k|            digit = (uint64_t)n % 10;
11732|   151k|            n = (uint64_t)n / 10;
11733|   151k|            *--q = '0' + digit;
11734|   151k|        } while (n != 0);
11735|  15.1k|    } else {
11736|      0|        do {
11737|      0|            digit = (uint64_t)n % base;
11738|      0|            n = (uint64_t)n / base;
11739|      0|            *--q = digits[digit];
11740|      0|        } while (n != 0);
11741|      0|    }
11742|  15.1k|    return q;
11743|  15.1k|}
11744|       |
11745|       |/* len >= 1. 2 <= radix <= 36 */
11746|       |static char *limb_to_a(char *q, js_limb_t n, unsigned int radix, int len)
11747|   474k|{
11748|   474k|    int digit, i;
11749|       |
11750|   474k|    if (radix == 10) {
11751|       |        /* specific case with constant divisor */
11752|       |        /* XXX: optimize */
11753|  9.49M|        for(i = 0; i < len; i++) {
11754|  9.01M|            digit = (js_limb_t)n % 10;
11755|  9.01M|            n = (js_limb_t)n / 10;
11756|  9.01M|            *--q = digit + '0';
11757|  9.01M|        }
11758|   474k|    } else {
11759|      0|        for(i = 0; i < len; i++) {
11760|      0|            digit = (js_limb_t)n % radix;
11761|      0|            n = (js_limb_t)n / radix;
11762|      0|            *--q = digits[digit];
11763|      0|        }
11764|      0|    }
11765|   474k|    return q;
11766|   474k|}
11767|       |
11768|       |#define JS_RADIX_MAX 36
11769|       |
11770|       |static const uint8_t digits_per_limb_table[JS_RADIX_MAX - 1] = {
11771|       |#if JS_LIMB_BITS == 32
11772|       |32,20,16,13,12,11,10,10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
11773|       |#else
11774|       |64,40,32,27,24,22,21,20,19,18,17,17,16,16,16,15,15,15,14,14,14,14,13,13,13,13,13,13,13,12,12,12,12,12,12,
11775|       |#endif
11776|       |};
11777|       |
11778|       |static const js_limb_t radix_base_table[JS_RADIX_MAX - 1] = {
11779|       |#if JS_LIMB_BITS == 32
11780|       | 0x00000000, 0xcfd41b91, 0x00000000, 0x48c27395,
11781|       | 0x81bf1000, 0x75db9c97, 0x40000000, 0xcfd41b91,
11782|       | 0x3b9aca00, 0x8c8b6d2b, 0x19a10000, 0x309f1021,
11783|       | 0x57f6c100, 0x98c29b81, 0x00000000, 0x18754571,
11784|       | 0x247dbc80, 0x3547667b, 0x4c4b4000, 0x6b5a6e1d,
11785|       | 0x94ace180, 0xcaf18367, 0x0b640000, 0x0e8d4a51,
11786|       | 0x1269ae40, 0x17179149, 0x1cb91000, 0x23744899,
11787|       | 0x2b73a840, 0x34e63b41, 0x40000000, 0x4cfa3cc1,
11788|       | 0x5c13d840, 0x6d91b519, 0x81bf1000,
11789|       |#else
11790|       | 0x0000000000000000, 0xa8b8b452291fe821, 0x0000000000000000, 0x6765c793fa10079d,
11791|       | 0x41c21cb8e1000000, 0x3642798750226111, 0x8000000000000000, 0xa8b8b452291fe821,
11792|       | 0x8ac7230489e80000, 0x4d28cb56c33fa539, 0x1eca170c00000000, 0x780c7372621bd74d,
11793|       | 0x1e39a5057d810000, 0x5b27ac993df97701, 0x0000000000000000, 0x27b95e997e21d9f1,
11794|       | 0x5da0e1e53c5c8000, 0xd2ae3299c1c4aedb, 0x16bcc41e90000000, 0x2d04b7fdd9c0ef49,
11795|       | 0x5658597bcaa24000, 0xa0e2073737609371, 0x0c29e98000000000, 0x14adf4b7320334b9,
11796|       | 0x226ed36478bfa000, 0x383d9170b85ff80b, 0x5a3c23e39c000000, 0x8e65137388122bcd,
11797|       | 0xdd41bb36d259e000, 0x0aee5720ee830681, 0x1000000000000000, 0x172588ad4f5f0981,
11798|       | 0x211e44f7d02c1000, 0x2ee56725f06e5c71, 0x41c21cb8e1000000,
11799|       |#endif
11800|       |};
11801|       |
11802|       |static JSValue js_bigint_to_string1(JSContext *ctx, JSValueConst val, int radix)
11803|   851k|{
11804|   851k|    if (JS_VALUE_GET_TAG(val) == JS_TAG_SHORT_BIG_INT) {
11805|   835k|        char buf[66];
11806|   835k|        int len;
11807|   835k|        len = i64toa_radix(buf, JS_VALUE_GET_SHORT_BIG_INT(val), radix);
11808|   835k|        return js_new_string8_len(ctx, buf, len);
11809|   835k|    } else {
11810|  15.1k|        JSBigInt *r, *tmp = NULL;
11811|  15.1k|        char *buf, *q, *buf_end;
11812|  15.1k|        int is_neg, n_bits, log2_radix, n_digits;
11813|  15.1k|        BOOL is_binary_radix;
11814|  15.1k|        JSValue res;
11815|       |        
11816|  15.1k|        assert(JS_VALUE_GET_TAG(val) == JS_TAG_BIG_INT);
11817|  15.1k|        r = JS_VALUE_GET_PTR(val);
11818|  15.1k|        if (r->len == 1 && r->tab[0] == 0) {
11819|       |            /* '0' case */
11820|      0|            return js_new_string8_len(ctx, "0", 1);
11821|      0|        }
11822|  15.1k|        is_binary_radix = ((radix & (radix - 1)) == 0);
11823|  15.1k|        is_neg = js_bigint_sign(r);
11824|  15.1k|        if (is_neg) {
11825|  3.08k|            tmp = js_bigint_neg(ctx, r);
11826|  3.08k|            if (!tmp)
11827|      0|                return JS_EXCEPTION;
11828|  3.08k|            r = tmp;
11829|  12.1k|        } else if (!is_binary_radix) {
11830|       |            /* need to modify 'r' */
11831|  12.1k|            tmp = js_bigint_new(ctx, r->len);
11832|  12.1k|            if (!tmp)
11833|      0|                return JS_EXCEPTION;
11834|  12.1k|            memcpy(tmp->tab, r->tab, r->len * sizeof(r->tab[0]));
11835|  12.1k|            r = tmp;
11836|  12.1k|        }
11837|  15.1k|        log2_radix = 31 - clz32(radix); /* floor(log2(radix)) */
11838|  15.1k|        n_bits = r->len * JS_LIMB_BITS - js_limb_clz(r->tab[r->len - 1]);
11839|       |        /* n_digits is exact only if radix is a power of
11840|       |           two. Otherwise it is >= the exact number of digits */
11841|  15.1k|        n_digits = (n_bits + log2_radix - 1) / log2_radix;
11842|       |        /* XXX: could directly build the JSString */
11843|  15.1k|        buf = js_malloc(ctx, n_digits + is_neg + 1);
11844|  15.1k|        if (!buf) {
11845|      0|            js_free(ctx, tmp);
11846|      0|            return JS_EXCEPTION;
11847|      0|        }
11848|  15.1k|        q = buf + n_digits + is_neg + 1;
11849|  15.1k|        *--q = '\0';
11850|  15.1k|        buf_end = q;
11851|  15.1k|        if (!is_binary_radix) {
11852|  15.1k|            int len;
11853|  15.1k|            js_limb_t radix_base, v;
11854|  15.1k|            radix_base = radix_base_table[radix - 2];
11855|  15.1k|            len = r->len;
11856|   489k|            for(;;) {
11857|       |                /* remove leading zero limbs */
11858|   959k|                while (len > 1 && r->tab[len - 1] == 0)
11859|   469k|                    len--;
11860|   489k|                if (len == 1 && r->tab[0] < radix_base) {
11861|  15.1k|                    v = r->tab[0];
11862|  15.1k|                    if (v != 0) {
11863|  15.1k|                        q = js_u64toa(q, v, radix);
11864|  15.1k|                    }
11865|  15.1k|                    break;
11866|   474k|                } else {
11867|   474k|                    v = mp_div1(r->tab, r->tab, len, radix_base, 0);
11868|   474k|                    q = limb_to_a(q, v, radix, digits_per_limb_table[radix - 2]);
11869|   474k|                }
11870|   489k|            }
11871|  15.1k|        } else {
11872|      0|            int i, shift;
11873|      0|            unsigned int bit_pos, pos, c;
11874|       |
11875|       |            /* radix is a power of two */
11876|      0|            for(i = 0; i < n_digits; i++) {
11877|      0|                bit_pos = i * log2_radix;
11878|      0|                pos = bit_pos / JS_LIMB_BITS;
11879|      0|                shift = bit_pos % JS_LIMB_BITS;
11880|      0|                if (likely((shift + log2_radix) <= JS_LIMB_BITS)) {
11881|      0|                    c = r->tab[pos] >> shift;
11882|      0|                } else {
11883|      0|                    c = (r->tab[pos] >> shift) |
11884|      0|                        (r->tab[pos + 1] << (JS_LIMB_BITS - shift));
11885|      0|                }
11886|      0|                c &= (radix - 1);
11887|      0|                *--q = digits[c];
11888|      0|            }
11889|      0|        }
11890|  15.1k|        if (is_neg)
11891|  3.08k|            *--q = '-';
11892|  15.1k|        js_free(ctx, tmp);
11893|  15.1k|        res = js_new_string8_len(ctx, q, buf_end - q);
11894|  15.1k|        js_free(ctx, buf);
11895|  15.1k|        return res;
11896|  15.1k|    }
11897|   851k|}
11898|       |
11899|       |/* if possible transform a BigInt to short big and free it, otherwise
11900|       |   return a normal bigint */
11901|       |static JSValue JS_CompactBigInt(JSContext *ctx, JSBigInt *p)
11902|  2.31M|{
11903|  2.31M|    JSValue res;
11904|  2.31M|    if (p->len == 1) {
11905|   467k|        res = __JS_NewShortBigInt(ctx, (js_slimb_t)p->tab[0]);
11906|   467k|        js_free(ctx, p);
11907|   467k|        return res;
11908|  1.85M|    } else {
11909|  1.85M|        return JS_MKPTR(JS_TAG_BIG_INT, p);
11910|  1.85M|    }
11911|  2.31M|}
11912|       |
11913|  5.96M|#define ATOD_INT_ONLY        (1 << 0)
11914|       |/* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */
11915|  2.75M|#define ATOD_ACCEPT_BIN_OCT  (1 << 2)
11916|       |/* accept O prefix as octal if radix == 0 and properly formed (Annex B) */
11917|   663k|#define ATOD_ACCEPT_LEGACY_OCTAL  (1 << 4)
11918|       |/* accept _ between digits as a digit separator */
11919|  3.41M|#define ATOD_ACCEPT_UNDERSCORES  (1 << 5)
11920|       |/* allow a suffix to override the type */
11921|  1.73M|#define ATOD_ACCEPT_SUFFIX    (1 << 6)
11922|       |/* default type */
11923|  2.75M|#define ATOD_TYPE_MASK        (3 << 7)
11924|  3.46M|#define ATOD_TYPE_FLOAT64     (0 << 7)
11925|   909k|#define ATOD_TYPE_BIG_INT     (1 << 7)
11926|       |/* accept -0x1 */
11927|   110k|#define ATOD_ACCEPT_PREFIX_AFTER_SIGN (1 << 10)
11928|       |
11929|       |/* return an exception in case of memory error. Return JS_NAN if
11930|       |   invalid syntax */
11931|       |/* XXX: directly use js_atod() */
11932|       |static JSValue js_atof(JSContext *ctx, const char *str, const char **pp,
11933|       |                       int radix, int flags)
11934|  2.75M|{
11935|  2.75M|    const char *p, *p_start;
11936|  2.75M|    int sep, is_neg;
11937|  2.75M|    BOOL is_float, has_legacy_octal;
11938|  2.75M|    int atod_type = flags & ATOD_TYPE_MASK;
11939|  2.75M|    char buf1[64], *buf;
11940|  2.75M|    int i, j, len;
11941|  2.75M|    BOOL buf_allocated = FALSE;
11942|  2.75M|    JSValue val;
11943|  2.75M|    JSATODTempMem atod_mem;
11944|       |    
11945|       |    /* optional separator between digits */
11946|  2.75M|    sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;
11947|  2.75M|    has_legacy_octal = FALSE;
11948|       |
11949|  2.75M|    p = str;
11950|  2.75M|    p_start = p;
11951|  2.75M|    is_neg = 0;
11952|  2.75M|    if (p[0] == '+') {
11953|  86.5k|        p++;
11954|  86.5k|        p_start++;
11955|  86.5k|        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))
11956|  86.5k|            goto no_radix_prefix;
11957|  2.66M|    } else if (p[0] == '-') {
11958|  24.1k|        p++;
11959|  24.1k|        p_start++;
11960|  24.1k|        is_neg = 1;
11961|  24.1k|        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))
11962|  24.1k|            goto no_radix_prefix;
11963|  24.1k|    }
11964|  2.64M|    if (p[0] == '0') {
11965|  22.9k|        if ((p[1] == 'x' || p[1] == 'X') &&
11966|  22.9k|            (radix == 0 || radix == 16)) {
11967|  2.87k|            p += 2;
11968|  2.87k|            radix = 16;
11969|  20.0k|        } else if ((p[1] == 'o' || p[1] == 'O') &&
11970|  20.0k|                   radix == 0 && (flags & ATOD_ACCEPT_BIN_OCT)) {
11971|  1.94k|            p += 2;
11972|  1.94k|            radix = 8;
11973|  18.1k|        } else if ((p[1] == 'b' || p[1] == 'B') &&
11974|  18.1k|                   radix == 0 && (flags & ATOD_ACCEPT_BIN_OCT)) {
11975|    744|            p += 2;
11976|    744|            radix = 2;
11977|  17.3k|        } else if ((p[1] >= '0' && p[1] <= '9') &&
11978|  17.3k|                   radix == 0 && (flags & ATOD_ACCEPT_LEGACY_OCTAL)) {
11979|  3.53k|            int i;
11980|  3.53k|            has_legacy_octal = TRUE;
11981|  3.53k|            sep = 256;
11982|   267k|            for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++)
11983|   263k|                continue;
11984|  3.53k|            if (p[i] == '8' || p[i] == '9')
11985|    406|                goto no_prefix;
11986|  3.12k|            p += 1;
11987|  3.12k|            radix = 8;
11988|  13.8k|        } else {
11989|  13.8k|            goto no_prefix;
11990|  13.8k|        }
11991|       |        /* there must be a digit after the prefix */
11992|  8.69k|        if (to_digit((uint8_t)*p) >= radix)
11993|  1.67k|            goto fail;
11994|  21.2k|    no_prefix: ;
11995|  2.61M|    } else {
11996|  2.73M| no_radix_prefix:
11997|  2.73M|        if (!(flags & ATOD_INT_ONLY) &&
11998|  2.73M|            (atod_type == ATOD_TYPE_FLOAT64) &&
11999|  2.73M|            strstart(p, "Infinity", &p)) {
12000|  18.9k|            double d = 1.0 / 0.0;
12001|  18.9k|            if (is_neg)
12002|  7.27k|                d = -d;
12003|  18.9k|            val = JS_NewFloat64(ctx, d);
12004|  18.9k|            goto done;
12005|  18.9k|        }
12006|  2.73M|    }
12007|  2.73M|    if (radix == 0)
12008|  2.72M|        radix = 10;
12009|  2.73M|    is_float = FALSE;
12010|  2.73M|    p_start = p;
12011|  22.2M|    while (to_digit((uint8_t)*p) < radix
12012|  22.2M|           ||  (*p == sep && (radix != 10 ||
12013|  2.21k|                              p != p_start + 1 || p[-1] != '0') &&
12014|  19.5M|                to_digit((uint8_t)p[1]) < radix)) {
12015|  19.5M|        p++;
12016|  19.5M|    }
12017|  2.73M|    if (!(flags & ATOD_INT_ONLY)) {
12018|  2.22M|        if (*p == '.' && (p > p_start || to_digit((uint8_t)p[1]) < radix)) {
12019|  50.5k|            is_float = TRUE;
12020|  50.5k|            p++;
12021|  50.5k|            if (*p == sep)
12022|    571|                goto fail;
12023|   578k|            while (to_digit((uint8_t)*p) < radix ||
12024|   578k|                   (*p == sep && to_digit((uint8_t)p[1]) < radix))
12025|   528k|                p++;
12026|  49.9k|        }
12027|  2.22M|        if (p > p_start &&
12028|  2.22M|            (((*p == 'e' || *p == 'E') && radix == 10) ||
12029|   981k|             ((*p == 'p' || *p == 'P') && (radix == 2 || radix == 8 || radix == 16)))) {
12030|  28.2k|            const char *p1 = p + 1;
12031|  28.2k|            is_float = TRUE;
12032|  28.2k|            if (*p1 == '+') {
12033|  3.14k|                p1++;
12034|  25.0k|            } else if (*p1 == '-') {
12035|  9.91k|                p1++;
12036|  9.91k|            }
12037|  28.2k|            if (is_digit((uint8_t)*p1)) {
12038|  24.4k|                p = p1 + 1;
12039|  92.4k|                while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))
12040|  67.9k|                    p++;
12041|  24.4k|            }
12042|  28.2k|        }
12043|  2.22M|    }
12044|  2.73M|    if (p == p_start)
12045|  1.66M|        goto fail;
12046|       |
12047|  1.07M|    buf = buf1;
12048|  1.07M|    buf_allocated = FALSE;
12049|  1.07M|    len = p - p_start;
12050|  1.07M|    if (unlikely((len + 2) > sizeof(buf1))) {
12051|  38.5k|        buf = js_malloc_rt(ctx->rt, len + 2); /* no exception raised */
12052|  38.5k|        if (!buf)
12053|      0|            goto mem_error;
12054|  38.5k|        buf_allocated = TRUE;
12055|  38.5k|    }
12056|       |    /* remove the separators and the radix prefixes */
12057|  1.07M|    j = 0;
12058|  1.07M|    if (is_neg)
12059|  16.5k|        buf[j++] = '-';
12060|  21.3M|    for (i = 0; i < len; i++) {
12061|  20.2M|        if (p_start[i] != '_')
12062|  20.2M|            buf[j++] = p_start[i];
12063|  20.2M|    }
12064|  1.07M|    buf[j] = '\0';
12065|       |
12066|  1.07M|    if (flags & ATOD_ACCEPT_SUFFIX) {
12067|   657k|        if (*p == 'n') {
12068|   158k|            p++;
12069|   158k|            atod_type = ATOD_TYPE_BIG_INT;
12070|   499k|        } else {
12071|   499k|            if (is_float && radix != 10)
12072|  1.18k|                goto fail;
12073|   499k|        }
12074|   657k|    } else {
12075|   413k|        if (atod_type == ATOD_TYPE_FLOAT64) {
12076|   323k|            if (is_float && radix != 10)
12077|      0|                goto fail;
12078|   323k|        }
12079|   413k|    }
12080|       |
12081|  1.06M|    switch(atod_type) {
12082|   821k|    case ATOD_TYPE_FLOAT64:
12083|   821k|        {
12084|   821k|            double d;
12085|   821k|            d = js_atod(buf,NULL,  radix, is_float ? 0 : JS_ATOD_INT_ONLY,
12086|   821k|                        &atod_mem);
12087|       |            /* return int or float64 */
12088|   821k|            val = JS_NewFloat64(ctx, d);
12089|   821k|        }
12090|   821k|        break;
12091|   248k|    case ATOD_TYPE_BIG_INT:
12092|   248k|        {
12093|   248k|            JSBigInt *r;
12094|   248k|            if (has_legacy_octal || is_float)
12095|    293|                goto fail;
12096|   247k|            r = js_bigint_from_string(ctx, buf, radix);
12097|   247k|            if (!r)
12098|      0|                goto mem_error;
12099|   247k|            val = JS_CompactBigInt(ctx, r);
12100|   247k|        }
12101|      0|        break;
12102|      0|    default:
12103|      0|        abort();
12104|  1.06M|    }
12105|       |
12106|  2.75M|done:
12107|  2.75M|    if (buf_allocated)
12108|  38.5k|        js_free_rt(ctx->rt, buf);
12109|  2.75M|    if (pp)
12110|  2.75M|        *pp = p;
12111|  2.75M|    return val;
12112|  1.66M| fail:
12113|  1.66M|    val = JS_NAN;
12114|  1.66M|    goto done;
12115|      0| mem_error:
12116|      0|    val = JS_ThrowOutOfMemory(ctx);
12117|      0|    goto done;
12118|  1.06M|}
12119|       |
12120|       |typedef enum JSToNumberHintEnum {
12121|       |    TON_FLAG_NUMBER,
12122|       |    TON_FLAG_NUMERIC,
12123|       |} JSToNumberHintEnum;
12124|       |
12125|       |static JSValue JS_ToNumberHintFree(JSContext *ctx, JSValue val,
12126|       |                                   JSToNumberHintEnum flag)
12127|  14.4M|{
12128|  14.4M|    uint32_t tag;
12129|  14.4M|    JSValue ret;
12130|       |
12131|  14.8M| redo:
12132|  14.8M|    tag = JS_VALUE_GET_NORM_TAG(val);
12133|  14.8M|    switch(tag) {
12134|  2.57M|    case JS_TAG_BIG_INT:
12135|  6.24M|    case JS_TAG_SHORT_BIG_INT:
12136|  6.24M|        if (flag != TON_FLAG_NUMERIC) {
12137|  1.10k|            JS_FreeValue(ctx, val);
12138|  1.10k|            return JS_ThrowTypeError(ctx, "cannot convert bigint to number");
12139|  1.10k|        }
12140|  6.24M|        ret = val;
12141|  6.24M|        break;
12142|  1.78M|    case JS_TAG_FLOAT64:
12143|  4.11M|    case JS_TAG_INT:
12144|  4.11M|    case JS_TAG_EXCEPTION:
12145|  4.11M|        ret = val;
12146|  4.11M|        break;
12147|  2.27M|    case JS_TAG_BOOL:
12148|  2.27M|    case JS_TAG_NULL:
12149|  2.27M|        ret = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));
12150|  2.27M|        break;
12151|   187k|    case JS_TAG_UNDEFINED:
12152|   187k|        ret = JS_NAN;
12153|   187k|        break;
12154|   468k|    case JS_TAG_OBJECT:
12155|   468k|        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
12156|   468k|        if (JS_IsException(val))
12157|     50|            return JS_EXCEPTION;
12158|   468k|        goto redo;
12159|  1.58M|    case JS_TAG_STRING:
12160|  1.59M|    case JS_TAG_STRING_ROPE:
12161|  1.59M|        {
12162|  1.59M|            const char *str;
12163|  1.59M|            const char *p;
12164|  1.59M|            size_t len;
12165|       |
12166|  1.59M|            str = JS_ToCStringLen(ctx, &len, val);
12167|  1.59M|            JS_FreeValue(ctx, val);
12168|  1.59M|            if (!str)
12169|      0|                return JS_EXCEPTION;
12170|  1.59M|            p = str;
12171|  1.59M|            p += skip_spaces(p);
12172|  1.59M|            if ((p - str) == len) {
12173|  7.98k|                ret = JS_NewInt32(ctx, 0);
12174|  1.59M|            } else {
12175|  1.59M|                int flags = ATOD_ACCEPT_BIN_OCT;
12176|  1.59M|                ret = js_atof(ctx, p, &p, 0, flags);
12177|  1.59M|                if (!JS_IsException(ret)) {
12178|  1.59M|                    p += skip_spaces(p);
12179|  1.59M|                    if ((p - str) != len) {
12180|  1.54M|                        JS_FreeValue(ctx, ret);
12181|  1.54M|                        ret = JS_NAN;
12182|  1.54M|                    }
12183|  1.59M|                }
12184|  1.59M|            }
12185|  1.59M|            JS_FreeCString(ctx, str);
12186|  1.59M|        }
12187|      0|        break;
12188|      0|    case JS_TAG_SYMBOL:
12189|      0|        JS_FreeValue(ctx, val);
12190|      0|        return JS_ThrowTypeError(ctx, "cannot convert symbol to number");
12191|      0|    default:
12192|      0|        JS_FreeValue(ctx, val);
12193|      0|        ret = JS_NAN;
12194|      0|        break;
12195|  14.8M|    }
12196|  14.4M|    return ret;
12197|  14.8M|}
12198|       |
12199|       |static JSValue JS_ToNumberFree(JSContext *ctx, JSValue val)
12200|  1.10k|{
12201|  1.10k|    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);
12202|  1.10k|}
12203|       |
12204|       |static JSValue JS_ToNumericFree(JSContext *ctx, JSValue val)
12205|  14.4M|{
12206|  14.4M|    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);
12207|  14.4M|}
12208|       |
12209|       |static JSValue JS_ToNumeric(JSContext *ctx, JSValueConst val)
12210|      0|{
12211|      0|    return JS_ToNumericFree(ctx, JS_DupValue(ctx, val));
12212|      0|}
12213|       |
12214|       |static __exception int __JS_ToFloat64Free(JSContext *ctx, double *pres,
12215|       |                                          JSValue val)
12216|    828|{
12217|    828|    double d;
12218|    828|    uint32_t tag;
12219|       |    
12220|    828|    val = JS_ToNumberFree(ctx, val);
12221|    828|    if (JS_IsException(val))
12222|    828|        goto fail;
12223|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
12224|      0|    switch(tag) {
12225|      0|    case JS_TAG_INT:
12226|      0|        d = JS_VALUE_GET_INT(val);
12227|      0|        break;
12228|      0|    case JS_TAG_FLOAT64:
12229|      0|        d = JS_VALUE_GET_FLOAT64(val);
12230|      0|        break;
12231|      0|    default:
12232|      0|        abort();
12233|      0|    }
12234|      0|    *pres = d;
12235|      0|    return 0;
12236|    828| fail:
12237|    828|    *pres = JS_FLOAT64_NAN;
12238|    828|    return -1;
12239|      0|}
12240|       |
12241|       |static inline int JS_ToFloat64Free(JSContext *ctx, double *pres, JSValue val)
12242|  2.48M|{
12243|  2.48M|    uint32_t tag;
12244|       |
12245|  2.48M|    tag = JS_VALUE_GET_TAG(val);
12246|  2.48M|    if (tag <= JS_TAG_NULL) {
12247|  1.11M|        *pres = JS_VALUE_GET_INT(val);
12248|  1.11M|        return 0;
12249|  1.36M|    } else if (JS_TAG_IS_FLOAT64(tag)) {
12250|  1.36M|        *pres = JS_VALUE_GET_FLOAT64(val);
12251|  1.36M|        return 0;
12252|  1.36M|    } else {
12253|    828|        return __JS_ToFloat64Free(ctx, pres, val);
12254|    828|    }
12255|  2.48M|}
12256|       |
12257|       |int JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val)
12258|      0|{
12259|      0|    return JS_ToFloat64Free(ctx, pres, JS_DupValue(ctx, val));
12260|      0|}
12261|       |
12262|       |static JSValue JS_ToNumber(JSContext *ctx, JSValueConst val)
12263|      0|{
12264|      0|    return JS_ToNumberFree(ctx, JS_DupValue(ctx, val));
12265|      0|}
12266|       |
12267|       |/* same as JS_ToNumber() but return 0 in case of NaN/Undefined */
12268|       |static __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)
12269|      0|{
12270|      0|    uint32_t tag;
12271|      0|    JSValue ret;
12272|       |
12273|      0| redo:
12274|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
12275|      0|    switch(tag) {
12276|      0|    case JS_TAG_INT:
12277|      0|    case JS_TAG_BOOL:
12278|      0|    case JS_TAG_NULL:
12279|      0|    case JS_TAG_UNDEFINED:
12280|      0|        ret = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));
12281|      0|        break;
12282|      0|    case JS_TAG_FLOAT64:
12283|      0|        {
12284|      0|            double d = JS_VALUE_GET_FLOAT64(val);
12285|      0|            if (isnan(d)) {
12286|      0|                ret = JS_NewInt32(ctx, 0);
12287|      0|            } else {
12288|       |                /* convert -0 to +0 */
12289|      0|                d = trunc(d) + 0.0;
12290|      0|                ret = JS_NewFloat64(ctx, d);
12291|      0|            }
12292|      0|        }
12293|      0|        break;
12294|      0|    default:
12295|      0|        val = JS_ToNumberFree(ctx, val);
12296|      0|        if (JS_IsException(val))
12297|      0|            return val;
12298|      0|        goto redo;
12299|      0|    }
12300|      0|    return ret;
12301|      0|}
12302|       |
12303|       |/* Note: the integer value is satured to 32 bits */
12304|       |static int JS_ToInt32SatFree(JSContext *ctx, int *pres, JSValue val)
12305|      0|{
12306|      0|    uint32_t tag;
12307|      0|    int ret;
12308|       |
12309|      0| redo:
12310|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
12311|      0|    switch(tag) {
12312|      0|    case JS_TAG_INT:
12313|      0|    case JS_TAG_BOOL:
12314|      0|    case JS_TAG_NULL:
12315|      0|    case JS_TAG_UNDEFINED:
12316|      0|        ret = JS_VALUE_GET_INT(val);
12317|      0|        break;
12318|      0|    case JS_TAG_EXCEPTION:
12319|      0|        *pres = 0;
12320|      0|        return -1;
12321|      0|    case JS_TAG_FLOAT64:
12322|      0|        {
12323|      0|            double d = JS_VALUE_GET_FLOAT64(val);
12324|      0|            if (isnan(d)) {
12325|      0|                ret = 0;
12326|      0|            } else {
12327|      0|                if (d < INT32_MIN)
12328|      0|                    ret = INT32_MIN;
12329|      0|                else if (d > INT32_MAX)
12330|      0|                    ret = INT32_MAX;
12331|      0|                else
12332|      0|                    ret = (int)d;
12333|      0|            }
12334|      0|        }
12335|      0|        break;
12336|      0|    default:
12337|      0|        val = JS_ToNumberFree(ctx, val);
12338|      0|        if (JS_IsException(val)) {
12339|      0|            *pres = 0;
12340|      0|            return -1;
12341|      0|        }
12342|      0|        goto redo;
12343|      0|    }
12344|      0|    *pres = ret;
12345|      0|    return 0;
12346|      0|}
12347|       |
12348|       |int JS_ToInt32Sat(JSContext *ctx, int *pres, JSValueConst val)
12349|      0|{
12350|      0|    return JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));
12351|      0|}
12352|       |
12353|       |int JS_ToInt32Clamp(JSContext *ctx, int *pres, JSValueConst val,
12354|       |                    int min, int max, int min_offset)
12355|      0|{
12356|      0|    int res = JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));
12357|      0|    if (res == 0) {
12358|      0|        if (*pres < min) {
12359|      0|            *pres += min_offset;
12360|      0|            if (*pres < min)
12361|      0|                *pres = min;
12362|      0|        } else {
12363|      0|            if (*pres > max)
12364|      0|                *pres = max;
12365|      0|        }
12366|      0|    }
12367|      0|    return res;
12368|      0|}
12369|       |
12370|       |static int JS_ToInt64SatFree(JSContext *ctx, int64_t *pres, JSValue val)
12371|   232k|{
12372|   232k|    uint32_t tag;
12373|       |
12374|   232k| redo:
12375|   232k|    tag = JS_VALUE_GET_NORM_TAG(val);
12376|   232k|    switch(tag) {
12377|   232k|    case JS_TAG_INT:
12378|   232k|    case JS_TAG_BOOL:
12379|   232k|    case JS_TAG_NULL:
12380|   232k|    case JS_TAG_UNDEFINED:
12381|   232k|        *pres = JS_VALUE_GET_INT(val);
12382|   232k|        return 0;
12383|      0|    case JS_TAG_EXCEPTION:
12384|      0|        *pres = 0;
12385|      0|        return -1;
12386|      0|    case JS_TAG_FLOAT64:
12387|      0|        {
12388|      0|            double d = JS_VALUE_GET_FLOAT64(val);
12389|      0|            if (isnan(d)) {
12390|      0|                *pres = 0;
12391|      0|            } else {
12392|      0|                if (d < INT64_MIN)
12393|      0|                    *pres = INT64_MIN;
12394|      0|                else if (d >= 0x1p63) /* must use INT64_MAX + 1 because INT64_MAX cannot be exactly represented as a double */
12395|      0|                    *pres = INT64_MAX;
12396|      0|                else
12397|      0|                    *pres = (int64_t)d;
12398|      0|            }
12399|      0|        }
12400|      0|        return 0;
12401|      0|    default:
12402|      0|        val = JS_ToNumberFree(ctx, val);
12403|      0|        if (JS_IsException(val)) {
12404|      0|            *pres = 0;
12405|      0|            return -1;
12406|      0|        }
12407|      0|        goto redo;
12408|   232k|    }
12409|   232k|}
12410|       |
12411|       |int JS_ToInt64Sat(JSContext *ctx, int64_t *pres, JSValueConst val)
12412|      0|{
12413|      0|    return JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));
12414|      0|}
12415|       |
12416|       |int JS_ToInt64Clamp(JSContext *ctx, int64_t *pres, JSValueConst val,
12417|       |                    int64_t min, int64_t max, int64_t neg_offset)
12418|   232k|{
12419|   232k|    int res = JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));
12420|   232k|    if (res == 0) {
12421|   232k|        if (*pres < 0)
12422|      0|            *pres += neg_offset;
12423|   232k|        if (*pres < min)
12424|      0|            *pres = min;
12425|   232k|        else if (*pres > max)
12426|      0|            *pres = max;
12427|   232k|    }
12428|   232k|    return res;
12429|   232k|}
12430|       |
12431|       |/* Same as JS_ToInt32Free() but with a 64 bit result. Return (<0, 0)
12432|       |   in case of exception */
12433|       |static int JS_ToInt64Free(JSContext *ctx, int64_t *pres, JSValue val)
12434|      0|{
12435|      0|    uint32_t tag;
12436|      0|    int64_t ret;
12437|       |
12438|      0| redo:
12439|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
12440|      0|    switch(tag) {
12441|      0|    case JS_TAG_INT:
12442|      0|    case JS_TAG_BOOL:
12443|      0|    case JS_TAG_NULL:
12444|      0|    case JS_TAG_UNDEFINED:
12445|      0|        ret = JS_VALUE_GET_INT(val);
12446|      0|        break;
12447|      0|    case JS_TAG_FLOAT64:
12448|      0|        {
12449|      0|            JSFloat64Union u;
12450|      0|            double d;
12451|      0|            int e;
12452|      0|            d = JS_VALUE_GET_FLOAT64(val);
12453|      0|            u.d = d;
12454|       |            /* we avoid doing fmod(x, 2^64) */
12455|      0|            e = (u.u64 >> 52) & 0x7ff;
12456|      0|            if (likely(e <= (1023 + 62))) {
12457|       |                /* fast case */
12458|      0|                ret = (int64_t)d;
12459|      0|            } else if (e <= (1023 + 62 + 53)) {
12460|      0|                uint64_t v;
12461|       |                /* remainder modulo 2^64 */
12462|      0|                v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);
12463|      0|                ret = v << ((e - 1023) - 52);
12464|       |                /* take the sign into account */
12465|      0|                if (u.u64 >> 63)
12466|      0|                    ret = -ret;
12467|      0|            } else {
12468|      0|                ret = 0; /* also handles NaN and +inf */
12469|      0|            }
12470|      0|        }
12471|      0|        break;
12472|      0|    default:
12473|      0|        val = JS_ToNumberFree(ctx, val);
12474|      0|        if (JS_IsException(val)) {
12475|      0|            *pres = 0;
12476|      0|            return -1;
12477|      0|        }
12478|      0|        goto redo;
12479|      0|    }
12480|      0|    *pres = ret;
12481|      0|    return 0;
12482|      0|}
12483|       |
12484|       |int JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
12485|      0|{
12486|      0|    return JS_ToInt64Free(ctx, pres, JS_DupValue(ctx, val));
12487|      0|}
12488|       |
12489|       |int JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val)
12490|      0|{
12491|      0|    if (JS_IsBigInt(ctx, val))
12492|      0|        return JS_ToBigInt64(ctx, pres, val);
12493|      0|    else
12494|      0|        return JS_ToInt64(ctx, pres, val);
12495|      0|}
12496|       |
12497|       |/* return (<0, 0) in case of exception */
12498|       |static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val)
12499|  5.85M|{
12500|  5.85M|    uint32_t tag;
12501|  5.85M|    int32_t ret;
12502|       |
12503|  5.85M| redo:
12504|  5.85M|    tag = JS_VALUE_GET_NORM_TAG(val);
12505|  5.85M|    switch(tag) {
12506|  4.70M|    case JS_TAG_INT:
12507|  4.70M|    case JS_TAG_BOOL:
12508|  4.70M|    case JS_TAG_NULL:
12509|  4.70M|    case JS_TAG_UNDEFINED:
12510|  4.70M|        ret = JS_VALUE_GET_INT(val);
12511|  4.70M|        break;
12512|  1.14M|    case JS_TAG_FLOAT64:
12513|  1.14M|        {
12514|  1.14M|            JSFloat64Union u;
12515|  1.14M|            double d;
12516|  1.14M|            int e;
12517|  1.14M|            d = JS_VALUE_GET_FLOAT64(val);
12518|  1.14M|            u.d = d;
12519|       |            /* we avoid doing fmod(x, 2^32) */
12520|  1.14M|            e = (u.u64 >> 52) & 0x7ff;
12521|  1.14M|            if (likely(e <= (1023 + 30))) {
12522|       |                /* fast case */
12523|   218k|                ret = (int32_t)d;
12524|   931k|            } else if (e <= (1023 + 30 + 53)) {
12525|   189k|                uint64_t v;
12526|       |                /* remainder modulo 2^32 */
12527|   189k|                v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);
12528|   189k|                v = v << ((e - 1023) - 52 + 32);
12529|   189k|                ret = v >> 32;
12530|       |                /* take the sign into account */
12531|   189k|                if (u.u64 >> 63)
12532|   139k|                    ret = -ret;
12533|   741k|            } else {
12534|   741k|                ret = 0; /* also handles NaN and +inf */
12535|   741k|            }
12536|  1.14M|        }
12537|  1.14M|        break;
12538|    272|    default:
12539|    272|        val = JS_ToNumberFree(ctx, val);
12540|    272|        if (JS_IsException(val)) {
12541|    272|            *pres = 0;
12542|    272|            return -1;
12543|    272|        }
12544|      0|        goto redo;
12545|  5.85M|    }
12546|  5.85M|    *pres = ret;
12547|  5.85M|    return 0;
12548|  5.85M|}
12549|       |
12550|       |int JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val)
12551|  2.75M|{
12552|  2.75M|    return JS_ToInt32Free(ctx, pres, JS_DupValue(ctx, val));
12553|  2.75M|}
12554|       |
12555|       |static inline int JS_ToUint32Free(JSContext *ctx, uint32_t *pres, JSValue val)
12556|   136k|{
12557|   136k|    return JS_ToInt32Free(ctx, (int32_t *)pres, val);
12558|   136k|}
12559|       |
12560|       |static int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val)
12561|      0|{
12562|      0|    uint32_t tag;
12563|      0|    int res;
12564|       |
12565|      0| redo:
12566|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
12567|      0|    switch(tag) {
12568|      0|    case JS_TAG_INT:
12569|      0|    case JS_TAG_BOOL:
12570|      0|    case JS_TAG_NULL:
12571|      0|    case JS_TAG_UNDEFINED:
12572|      0|        res = JS_VALUE_GET_INT(val);
12573|      0|        res = max_int(0, min_int(255, res));
12574|      0|        break;
12575|      0|    case JS_TAG_FLOAT64:
12576|      0|        {
12577|      0|            double d = JS_VALUE_GET_FLOAT64(val);
12578|      0|            if (isnan(d)) {
12579|      0|                res = 0;
12580|      0|            } else {
12581|      0|                if (d < 0)
12582|      0|                    res = 0;
12583|      0|                else if (d > 255)
12584|      0|                    res = 255;
12585|      0|                else
12586|      0|                    res = lrint(d);
12587|      0|            }
12588|      0|        }
12589|      0|        break;
12590|      0|    default:
12591|      0|        val = JS_ToNumberFree(ctx, val);
12592|      0|        if (JS_IsException(val)) {
12593|      0|            *pres = 0;
12594|      0|            return -1;
12595|      0|        }
12596|      0|        goto redo;
12597|      0|    }
12598|      0|    *pres = res;
12599|      0|    return 0;
12600|      0|}
12601|       |
12602|       |static __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,
12603|       |                                            JSValue val, BOOL is_array_ctor)
12604|   171k|{
12605|   171k|    uint32_t tag, len;
12606|       |
12607|   171k|    tag = JS_VALUE_GET_TAG(val);
12608|   171k|    switch(tag) {
12609|   171k|    case JS_TAG_INT:
12610|   171k|    case JS_TAG_BOOL:
12611|   171k|    case JS_TAG_NULL:
12612|   171k|        {
12613|   171k|            int v;
12614|   171k|            v = JS_VALUE_GET_INT(val);
12615|   171k|            if (v < 0)
12616|      0|                goto fail;
12617|   171k|            len = v;
12618|   171k|        }
12619|      0|        break;
12620|      0|    default:
12621|      0|        if (JS_TAG_IS_FLOAT64(tag)) {
12622|      0|            double d;
12623|      0|            d = JS_VALUE_GET_FLOAT64(val);
12624|      0|            if (!(d >= 0 && d <= UINT32_MAX))
12625|      0|                goto fail;
12626|      0|            len = (uint32_t)d;
12627|      0|            if (len != d)
12628|      0|                goto fail;
12629|      0|        } else {
12630|      0|            uint32_t len1;
12631|       |
12632|      0|            if (is_array_ctor) {
12633|      0|                val = JS_ToNumberFree(ctx, val);
12634|      0|                if (JS_IsException(val))
12635|      0|                    return -1;
12636|       |                /* cannot recurse because val is a number */
12637|      0|                if (JS_ToArrayLengthFree(ctx, &len, val, TRUE))
12638|      0|                    return -1;
12639|      0|            } else {
12640|       |                /* legacy behavior: must do the conversion twice and compare */
12641|      0|                if (JS_ToUint32(ctx, &len, val)) {
12642|      0|                    JS_FreeValue(ctx, val);
12643|      0|                    return -1;
12644|      0|                }
12645|      0|                val = JS_ToNumberFree(ctx, val);
12646|      0|                if (JS_IsException(val))
12647|      0|                    return -1;
12648|       |                /* cannot recurse because val is a number */
12649|      0|                if (JS_ToArrayLengthFree(ctx, &len1, val, FALSE))
12650|      0|                    return -1;
12651|      0|                if (len1 != len) {
12652|      0|                fail:
12653|      0|                    JS_ThrowRangeError(ctx, "invalid array length");
12654|      0|                    return -1;
12655|      0|                }
12656|      0|            }
12657|      0|        }
12658|      0|        break;
12659|   171k|    }
12660|   171k|    *plen = len;
12661|   171k|    return 0;
12662|   171k|}
12663|       |
12664|   232k|#define MAX_SAFE_INTEGER (((int64_t)1 << 53) - 1)
12665|       |
12666|       |static BOOL is_safe_integer(double d)
12667|      0|{
12668|      0|    return isfinite(d) && floor(d) == d &&
12669|      0|        fabs(d) <= (double)MAX_SAFE_INTEGER;
12670|      0|}
12671|       |
12672|       |int JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val)
12673|      0|{
12674|      0|    int64_t v;
12675|      0|    if (JS_ToInt64Sat(ctx, &v, val))
12676|      0|        return -1;
12677|      0|    if (v < 0 || v > MAX_SAFE_INTEGER) {
12678|      0|        JS_ThrowRangeError(ctx, "invalid array index");
12679|      0|        *plen = 0;
12680|      0|        return -1;
12681|      0|    }
12682|      0|    *plen = v;
12683|      0|    return 0;
12684|      0|}
12685|       |
12686|       |/* convert a value to a length between 0 and MAX_SAFE_INTEGER.
12687|       |   return -1 for exception */
12688|       |static __exception int JS_ToLengthFree(JSContext *ctx, int64_t *plen,
12689|       |                                       JSValue val)
12690|   232k|{
12691|   232k|    int res = JS_ToInt64Clamp(ctx, plen, val, 0, MAX_SAFE_INTEGER, 0);
12692|   232k|    JS_FreeValue(ctx, val);
12693|   232k|    return res;
12694|   232k|}
12695|       |
12696|       |/* Note: can return an exception */
12697|       |static int JS_NumberIsInteger(JSContext *ctx, JSValueConst val)
12698|      0|{
12699|      0|    double d;
12700|      0|    if (!JS_IsNumber(val))
12701|      0|        return FALSE;
12702|      0|    if (unlikely(JS_ToFloat64(ctx, &d, val)))
12703|      0|        return -1;
12704|      0|    return isfinite(d) && floor(d) == d;
12705|      0|}
12706|       |
12707|       |static BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val)
12708|      0|{
12709|      0|    uint32_t tag;
12710|       |
12711|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
12712|      0|    switch(tag) {
12713|      0|    case JS_TAG_INT:
12714|      0|        {
12715|      0|            int v;
12716|      0|            v = JS_VALUE_GET_INT(val);
12717|      0|            return (v < 0);
12718|      0|        }
12719|      0|    case JS_TAG_FLOAT64:
12720|      0|        {
12721|      0|            JSFloat64Union u;
12722|      0|            u.d = JS_VALUE_GET_FLOAT64(val);
12723|      0|            return (u.u64 >> 63);
12724|      0|        }
12725|      0|    case JS_TAG_SHORT_BIG_INT:
12726|      0|        return (JS_VALUE_GET_SHORT_BIG_INT(val) < 0);
12727|      0|    case JS_TAG_BIG_INT:
12728|      0|        {
12729|      0|            JSBigInt *p = JS_VALUE_GET_PTR(val);
12730|      0|            return js_bigint_sign(p);
12731|      0|        }
12732|      0|    default:
12733|      0|        return FALSE;
12734|      0|    }
12735|      0|}
12736|       |
12737|       |static JSValue js_bigint_to_string(JSContext *ctx, JSValueConst val)
12738|   851k|{
12739|   851k|    return js_bigint_to_string1(ctx, val, 10);
12740|   851k|}
12741|       |
12742|       |static JSValue js_dtoa2(JSContext *ctx,
12743|       |                        double d, int radix, int n_digits, int flags)
12744|   239k|{
12745|   239k|    char static_buf[128], *buf, *tmp_buf;
12746|   239k|    int len, len_max;
12747|   239k|    JSValue res;
12748|   239k|    JSDTOATempMem dtoa_mem;
12749|   239k|    len_max = js_dtoa_max_len(d, radix, n_digits, flags);
12750|       |    
12751|       |    /* longer buffer may be used if radix != 10 */
12752|   239k|    if (len_max > sizeof(static_buf) - 1) {
12753|      0|        tmp_buf = js_malloc(ctx, len_max + 1);
12754|      0|        if (!tmp_buf)
12755|      0|            return JS_EXCEPTION;
12756|      0|        buf = tmp_buf;
12757|   239k|    } else {
12758|   239k|        tmp_buf = NULL;
12759|   239k|        buf = static_buf;
12760|   239k|    }
12761|   239k|    len = js_dtoa(buf, d, radix, n_digits, flags, &dtoa_mem);
12762|   239k|    res = js_new_string8_len(ctx, buf, len);
12763|   239k|    js_free(ctx, tmp_buf);
12764|   239k|    return res;
12765|   239k|}
12766|       |
12767|       |static JSValue JS_ToStringInternal(JSContext *ctx, JSValueConst val, BOOL is_ToPropertyKey)
12768|  3.32M|{
12769|  3.32M|    uint32_t tag;
12770|  3.32M|    char buf[32];
12771|       |
12772|  3.32M|    tag = JS_VALUE_GET_NORM_TAG(val);
12773|  3.32M|    switch(tag) {
12774|   437k|    case JS_TAG_STRING:
12775|   437k|        return JS_DupValue(ctx, val);
12776|  17.1k|    case JS_TAG_STRING_ROPE:
12777|  17.1k|        return js_linearize_string_rope(ctx, JS_DupValue(ctx, val));
12778|  1.70M|    case JS_TAG_INT:
12779|  1.70M|        {
12780|  1.70M|            size_t len;
12781|  1.70M|            len = i32toa(buf, JS_VALUE_GET_INT(val));
12782|  1.70M|            return js_new_string8_len(ctx, buf, len);
12783|      0|        }
12784|      0|        break;
12785|  11.6k|    case JS_TAG_BOOL:
12786|  11.6k|        return JS_AtomToString(ctx, JS_VALUE_GET_BOOL(val) ?
12787|  10.2k|                          JS_ATOM_true : JS_ATOM_false);
12788|      0|    case JS_TAG_NULL:
12789|      0|        return JS_AtomToString(ctx, JS_ATOM_null);
12790|  2.09k|    case JS_TAG_UNDEFINED:
12791|  2.09k|        return JS_AtomToString(ctx, JS_ATOM_undefined);
12792|      8|    case JS_TAG_EXCEPTION:
12793|      8|        return JS_EXCEPTION;
12794|  60.4k|    case JS_TAG_OBJECT:
12795|  60.4k|        {
12796|  60.4k|            JSValue val1, ret;
12797|  60.4k|            val1 = JS_ToPrimitive(ctx, val, HINT_STRING);
12798|  60.4k|            if (JS_IsException(val1))
12799|      0|                return val1;
12800|  60.4k|            ret = JS_ToStringInternal(ctx, val1, is_ToPropertyKey);
12801|  60.4k|            JS_FreeValue(ctx, val1);
12802|  60.4k|            return ret;
12803|  60.4k|        }
12804|      0|        break;
12805|      0|    case JS_TAG_FUNCTION_BYTECODE:
12806|      0|        return js_new_string8(ctx, "[function bytecode]");
12807|      0|    case JS_TAG_SYMBOL:
12808|      0|        if (is_ToPropertyKey) {
12809|      0|            return JS_DupValue(ctx, val);
12810|      0|        } else {
12811|      0|            return JS_ThrowTypeError(ctx, "cannot convert symbol to string");
12812|      0|        }
12813|   239k|    case JS_TAG_FLOAT64:
12814|   239k|        return js_dtoa2(ctx, JS_VALUE_GET_FLOAT64(val), 10, 0,
12815|   239k|                        JS_DTOA_FORMAT_FREE);
12816|   835k|    case JS_TAG_SHORT_BIG_INT:
12817|   851k|    case JS_TAG_BIG_INT:
12818|   851k|        return js_bigint_to_string(ctx, val);
12819|      1|    default:
12820|      1|        return js_new_string8(ctx, "[unsupported type]");
12821|  3.32M|    }
12822|  3.32M|}
12823|       |
12824|       |JSValue JS_ToString(JSContext *ctx, JSValueConst val)
12825|  2.95M|{
12826|  2.95M|    return JS_ToStringInternal(ctx, val, FALSE);
12827|  2.95M|}
12828|       |
12829|       |static JSValue JS_ToStringFree(JSContext *ctx, JSValue val)
12830|  2.69M|{
12831|  2.69M|    JSValue ret;
12832|  2.69M|    ret = JS_ToString(ctx, val);
12833|  2.69M|    JS_FreeValue(ctx, val);
12834|  2.69M|    return ret;
12835|  2.69M|}
12836|       |
12837|       |static JSValue JS_ToLocaleStringFree(JSContext *ctx, JSValue val)
12838|      0|{
12839|      0|    if (JS_IsUndefined(val) || JS_IsNull(val))
12840|      0|        return JS_ToStringFree(ctx, val);
12841|      0|    return JS_InvokeFree(ctx, val, JS_ATOM_toLocaleString, 0, NULL);
12842|      0|}
12843|       |
12844|       |JSValue JS_ToPropertyKey(JSContext *ctx, JSValueConst val)
12845|   309k|{
12846|   309k|    return JS_ToStringInternal(ctx, val, TRUE);
12847|   309k|}
12848|       |
12849|       |static JSValue JS_ToStringCheckObject(JSContext *ctx, JSValueConst val)
12850|  7.60k|{
12851|  7.60k|    uint32_t tag = JS_VALUE_GET_TAG(val);
12852|  7.60k|    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)
12853|      0|        return JS_ThrowTypeError(ctx, "null or undefined are forbidden");
12854|  7.60k|    return JS_ToString(ctx, val);
12855|  7.60k|}
12856|       |
12857|       |static JSValue JS_ToQuotedString(JSContext *ctx, JSValueConst val1)
12858|      0|{
12859|      0|    JSValue val;
12860|      0|    JSString *p;
12861|      0|    int i;
12862|      0|    uint32_t c;
12863|      0|    StringBuffer b_s, *b = &b_s;
12864|      0|    char buf[16];
12865|       |
12866|      0|    val = JS_ToStringCheckObject(ctx, val1);
12867|      0|    if (JS_IsException(val))
12868|      0|        return val;
12869|      0|    p = JS_VALUE_GET_STRING(val);
12870|       |
12871|      0|    if (string_buffer_init(ctx, b, p->len + 2))
12872|      0|        goto fail;
12873|       |
12874|      0|    if (string_buffer_putc8(b, '\"'))
12875|      0|        goto fail;
12876|      0|    for(i = 0; i < p->len; ) {
12877|      0|        c = string_getc(p, &i);
12878|      0|        switch(c) {
12879|      0|        case '\t':
12880|      0|            c = 't';
12881|      0|            goto quote;
12882|      0|        case '\r':
12883|      0|            c = 'r';
12884|      0|            goto quote;
12885|      0|        case '\n':
12886|      0|            c = 'n';
12887|      0|            goto quote;
12888|      0|        case '\b':
12889|      0|            c = 'b';
12890|      0|            goto quote;
12891|      0|        case '\f':
12892|      0|            c = 'f';
12893|      0|            goto quote;
12894|      0|        case '\"':
12895|      0|        case '\\':
12896|      0|        quote:
12897|      0|            if (string_buffer_putc8(b, '\\'))
12898|      0|                goto fail;
12899|      0|            if (string_buffer_putc8(b, c))
12900|      0|                goto fail;
12901|      0|            break;
12902|      0|        default:
12903|      0|            if (c < 32 || is_surrogate(c)) {
12904|      0|                snprintf(buf, sizeof(buf), "\\u%04x", c);
12905|      0|                if (string_buffer_puts8(b, buf))
12906|      0|                    goto fail;
12907|      0|            } else {
12908|      0|                if (string_buffer_putc(b, c))
12909|      0|                    goto fail;
12910|      0|            }
12911|      0|            break;
12912|      0|        }
12913|      0|    }
12914|      0|    if (string_buffer_putc8(b, '\"'))
12915|      0|        goto fail;
12916|      0|    JS_FreeValue(ctx, val);
12917|      0|    return string_buffer_end(b);
12918|      0| fail:
12919|      0|    JS_FreeValue(ctx, val);
12920|      0|    string_buffer_free(b);
12921|      0|    return JS_EXCEPTION;
12922|      0|}
12923|       |
12924|       |static __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt)
12925|      0|{
12926|      0|    printf("%14s %4s %4s %14s %10s %s\n",
12927|      0|           "ADDRESS", "REFS", "SHRF", "PROTO", "CLASS", "PROPS");
12928|      0|}
12929|       |
12930|       |/* for debug only: dump an object without side effect */
12931|       |static __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p)
12932|      0|{
12933|      0|    uint32_t i;
12934|      0|    char atom_buf[ATOM_GET_STR_BUF_SIZE];
12935|      0|    JSShape *sh;
12936|      0|    JSShapeProperty *prs;
12937|      0|    JSProperty *pr;
12938|      0|    BOOL is_first = TRUE;
12939|      0|
12940|      0|    /* XXX: should encode atoms with special characters */
12941|      0|    sh = p->shape; /* the shape can be NULL while freeing an object */
12942|      0|    printf("%14p %4d ",
12943|      0|           (void *)p,
12944|      0|           p->header.ref_count);
12945|      0|    if (sh) {
12946|      0|        printf("%3d%c %14p ",
12947|      0|               sh->header.ref_count,
12948|      0|               " *"[sh->is_hashed],
12949|      0|               (void *)sh->proto);
12950|      0|    } else {
12951|      0|        printf("%3s  %14s ", "-", "-");
12952|      0|    }
12953|      0|    printf("%10s ",
12954|      0|           JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), rt->class_array[p->class_id].class_name));
12955|      0|    if (p->is_exotic && p->fast_array) {
12956|      0|        printf("[ ");
12957|      0|        for(i = 0; i < p->u.array.count; i++) {
12958|      0|            if (i != 0)
12959|      0|                printf(", ");
12960|      0|            switch (p->class_id) {
12961|      0|            case JS_CLASS_ARRAY:
12962|      0|            case JS_CLASS_ARGUMENTS:
12963|      0|                JS_DumpValueShort(rt, p->u.array.u.values[i]);
12964|      0|                break;
12965|      0|            case JS_CLASS_UINT8C_ARRAY:
12966|      0|            case JS_CLASS_INT8_ARRAY:
12967|      0|            case JS_CLASS_UINT8_ARRAY:
12968|      0|            case JS_CLASS_INT16_ARRAY:
12969|      0|            case JS_CLASS_UINT16_ARRAY:
12970|      0|            case JS_CLASS_INT32_ARRAY:
12971|      0|            case JS_CLASS_UINT32_ARRAY:
12972|      0|            case JS_CLASS_BIG_INT64_ARRAY:
12973|      0|            case JS_CLASS_BIG_UINT64_ARRAY:
12974|      0|            case JS_CLASS_FLOAT32_ARRAY:
12975|      0|            case JS_CLASS_FLOAT64_ARRAY:
12976|      0|                {
12977|      0|                    int size = 1 << typed_array_size_log2(p->class_id);
12978|      0|                    const uint8_t *b = p->u.array.u.uint8_ptr + i * size;
12979|      0|                    while (size-- > 0)
12980|      0|                        printf("%02X", *b++);
12981|      0|                }
12982|      0|                break;
12983|      0|            }
12984|      0|        }
12985|      0|        printf(" ] ");
12986|      0|    }
12987|      0|
12988|      0|    if (sh) {
12989|      0|        printf("{ ");
12990|      0|        for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
12991|      0|            if (prs->atom != JS_ATOM_NULL) {
12992|      0|                pr = &p->prop[i];
12993|      0|                if (!is_first)
12994|      0|                    printf(", ");
12995|      0|                printf("%s: ",
12996|      0|                       JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), prs->atom));
12997|      0|                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
12998|      0|                    printf("[getset %p %p]", (void *)pr->u.getset.getter,
12999|      0|                           (void *)pr->u.getset.setter);
13000|      0|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
13001|      0|                    printf("[varref %p]", (void *)pr->u.var_ref);
13002|      0|                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
13003|      0|                    printf("[autoinit %p %d %p]",
13004|      0|                           (void *)js_autoinit_get_realm(pr),
13005|      0|                           js_autoinit_get_id(pr),
13006|      0|                           (void *)pr->u.init.opaque);
13007|      0|                } else {
13008|      0|                    JS_DumpValueShort(rt, pr->u.value);
13009|      0|                }
13010|      0|                is_first = FALSE;
13011|      0|            }
13012|      0|        }
13013|      0|        printf(" }");
13014|      0|    }
13015|      0|
13016|      0|    if (js_class_has_bytecode(p->class_id)) {
13017|      0|        JSFunctionBytecode *b = p->u.func.function_bytecode;
13018|      0|        JSVarRef **var_refs;
13019|      0|        if (b->closure_var_count) {
13020|      0|            var_refs = p->u.func.var_refs;
13021|      0|            printf(" Closure:");
13022|      0|            for(i = 0; i < b->closure_var_count; i++) {
13023|      0|                printf(" ");
13024|      0|                JS_DumpValueShort(rt, var_refs[i]->value);
13025|      0|            }
13026|      0|            if (p->u.func.home_object) {
13027|      0|                printf(" HomeObject: ");
13028|      0|                JS_DumpValueShort(rt, JS_MKPTR(JS_TAG_OBJECT, p->u.func.home_object));
13029|      0|            }
13030|      0|        }
13031|      0|    }
13032|      0|    printf("\n");
13033|      0|}
13034|       |
13035|       |static __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p)
13036|      0|{
13037|      0|    if (p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {
13038|      0|        JS_DumpObject(rt, (JSObject *)p);
13039|      0|    } else {
13040|      0|        printf("%14p %4d ",
13041|      0|               (void *)p,
13042|      0|               p->ref_count);
13043|      0|        switch(p->gc_obj_type) {
13044|      0|        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
13045|      0|            printf("[function bytecode]");
13046|      0|            break;
13047|      0|        case JS_GC_OBJ_TYPE_SHAPE:
13048|      0|            printf("[shape]");
13049|      0|            break;
13050|      0|        case JS_GC_OBJ_TYPE_VAR_REF:
13051|      0|            printf("[var_ref]");
13052|      0|            break;
13053|      0|        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
13054|      0|            printf("[async_function]");
13055|      0|            break;
13056|      0|        case JS_GC_OBJ_TYPE_JS_CONTEXT:
13057|      0|            printf("[js_context]");
13058|      0|            break;
13059|      0|        default:
13060|      0|            printf("[unknown %d]", p->gc_obj_type);
13061|      0|            break;
13062|      0|        }
13063|      0|        printf("\n");
13064|      0|    }
13065|      0|}
13066|       |
13067|       |static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
13068|       |                                                      JSValueConst val)
13069|      0|{
13070|      0|    uint32_t tag = JS_VALUE_GET_NORM_TAG(val);
13071|      0|    const char *str;
13072|      0|
13073|      0|    switch(tag) {
13074|      0|    case JS_TAG_INT:
13075|      0|        printf("%d", JS_VALUE_GET_INT(val));
13076|      0|        break;
13077|      0|    case JS_TAG_BOOL:
13078|      0|        if (JS_VALUE_GET_BOOL(val))
13079|      0|            str = "true";
13080|      0|        else
13081|      0|            str = "false";
13082|      0|        goto print_str;
13083|      0|    case JS_TAG_NULL:
13084|      0|        str = "null";
13085|      0|        goto print_str;
13086|      0|    case JS_TAG_EXCEPTION:
13087|      0|        str = "exception";
13088|      0|        goto print_str;
13089|      0|    case JS_TAG_UNINITIALIZED:
13090|      0|        str = "uninitialized";
13091|      0|        goto print_str;
13092|      0|    case JS_TAG_UNDEFINED:
13093|      0|        str = "undefined";
13094|      0|    print_str:
13095|      0|        printf("%s", str);
13096|      0|        break;
13097|      0|    case JS_TAG_FLOAT64:
13098|      0|        printf("%.14g", JS_VALUE_GET_FLOAT64(val));
13099|      0|        break;
13100|      0|    case JS_TAG_SHORT_BIG_INT:
13101|      0|        printf("%" PRId64 "n", (int64_t)JS_VALUE_GET_SHORT_BIG_INT(val));
13102|      0|        break;
13103|      0|    case JS_TAG_BIG_INT:
13104|      0|        {
13105|      0|            JSBigInt *p = JS_VALUE_GET_PTR(val);
13106|      0|            int sgn, i;
13107|      0|            /* In order to avoid allocations we just dump the limbs */
13108|      0|            sgn = js_bigint_sign(p);
13109|      0|            if (sgn)
13110|      0|                printf("BigInt.asIntN(%d,", p->len * JS_LIMB_BITS);
13111|      0|            printf("0x");
13112|      0|            for(i = p->len - 1; i >= 0; i--) {
13113|      0|                if (i != p->len - 1)
13114|      0|                    printf("_");
13115|      0|#if JS_LIMB_BITS == 32
13116|      0|                printf("%08x", p->tab[i]);
13117|      0|#else
13118|      0|                printf("%016" PRIx64, p->tab[i]);
13119|      0|#endif
13120|      0|            }
13121|      0|            printf("n");
13122|      0|            if (sgn)
13123|      0|                printf(")");
13124|      0|        }
13125|      0|        break;
13126|      0|    case JS_TAG_STRING:
13127|      0|        {
13128|      0|            JSString *p;
13129|      0|            p = JS_VALUE_GET_STRING(val);
13130|      0|            JS_DumpString(rt, p);
13131|      0|        }
13132|      0|        break;
13133|      0|    case JS_TAG_STRING_ROPE:
13134|      0|        {
13135|      0|            JSStringRope *r = JS_VALUE_GET_STRING_ROPE(val);
13136|      0|            printf("[rope len=%d depth=%d]", r->len, r->depth);
13137|      0|        }
13138|      0|        break;
13139|      0|    case JS_TAG_FUNCTION_BYTECODE:
13140|      0|        {
13141|      0|            JSFunctionBytecode *b = JS_VALUE_GET_PTR(val);
13142|      0|            char buf[ATOM_GET_STR_BUF_SIZE];
13143|      0|            printf("[bytecode %s]", JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));
13144|      0|        }
13145|      0|        break;
13146|      0|    case JS_TAG_OBJECT:
13147|      0|        {
13148|      0|            JSObject *p = JS_VALUE_GET_OBJ(val);
13149|      0|            JSAtom atom = rt->class_array[p->class_id].class_name;
13150|      0|            char atom_buf[ATOM_GET_STR_BUF_SIZE];
13151|      0|            printf("[%s %p]",
13152|      0|                   JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), atom), (void *)p);
13153|      0|        }
13154|      0|        break;
13155|      0|    case JS_TAG_SYMBOL:
13156|      0|        {
13157|      0|            JSAtomStruct *p = JS_VALUE_GET_PTR(val);
13158|      0|            char atom_buf[ATOM_GET_STR_BUF_SIZE];
13159|      0|            printf("Symbol(%s)",
13160|      0|                   JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), js_get_atom_index(rt, p)));
13161|      0|        }
13162|      0|        break;
13163|      0|    case JS_TAG_MODULE:
13164|      0|        printf("[module]");
13165|      0|        break;
13166|      0|    default:
13167|      0|        printf("[unknown tag %d]", tag);
13168|      0|        break;
13169|      0|    }
13170|      0|}
13171|       |
13172|       |static __maybe_unused void JS_DumpValue(JSContext *ctx,
13173|       |                                                 JSValueConst val)
13174|      0|{
13175|      0|    JS_DumpValueShort(ctx->rt, val);
13176|      0|}
13177|       |
13178|       |static __maybe_unused void JS_PrintValue(JSContext *ctx,
13179|       |                                                  const char *str,
13180|       |                                                  JSValueConst val)
13181|      0|{
13182|      0|    printf("%s=", str);
13183|      0|    JS_DumpValueShort(ctx->rt, val);
13184|      0|    printf("\n");
13185|      0|}
13186|       |
13187|       |/* return -1 if exception (proxy case) or TRUE/FALSE */
13188|       |// TODO: should take flags to make proxy resolution and exceptions optional
13189|       |int JS_IsArray(JSContext *ctx, JSValueConst val)
13190|    619|{
13191|    619|    if (js_resolve_proxy(ctx, &val, TRUE))
13192|      0|        return -1;
13193|    619|    if (JS_VALUE_GET_TAG(val) == JS_TAG_OBJECT) {
13194|    619|        JSObject *p = JS_VALUE_GET_OBJ(val);
13195|    619|        return p->class_id == JS_CLASS_ARRAY;
13196|    619|    } else {
13197|      0|        return FALSE;
13198|      0|    }
13199|    619|}
13200|       |
13201|       |static double js_pow(double a, double b)
13202|   130k|{
13203|   130k|    if (unlikely(!isfinite(b)) && fabs(a) == 1) {
13204|       |        /* not compatible with IEEE 754 */
13205|     20|        return JS_FLOAT64_NAN;
13206|   130k|    } else {
13207|   130k|        return pow(a, b);
13208|   130k|    }
13209|   130k|}
13210|       |
13211|       |JSValue JS_NewBigInt64(JSContext *ctx, int64_t v)
13212|  57.9k|{
13213|  57.9k|#if JS_SHORT_BIG_INT_BITS == 64
13214|  57.9k|    return __JS_NewShortBigInt(ctx, v);
13215|       |#else
13216|       |    if (v >= JS_SHORT_BIG_INT_MIN && v <= JS_SHORT_BIG_INT_MAX) {
13217|       |        return __JS_NewShortBigInt(ctx, v);
13218|       |    } else {
13219|       |        JSBigInt *p;
13220|       |        p = js_bigint_new_si64(ctx, v);
13221|       |        if (!p)
13222|       |            return JS_EXCEPTION;
13223|       |        return JS_MKPTR(JS_TAG_BIG_INT, p);
13224|       |    }
13225|       |#endif
13226|  57.9k|}
13227|       |
13228|       |JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)
13229|      0|{
13230|      0|    if (v <= JS_SHORT_BIG_INT_MAX) {
13231|      0|        return __JS_NewShortBigInt(ctx, v);
13232|      0|    } else {
13233|      0|        JSBigInt *p;
13234|      0|        p = js_bigint_new_ui64(ctx, v);
13235|      0|        if (!p)
13236|      0|            return JS_EXCEPTION;
13237|      0|        return JS_MKPTR(JS_TAG_BIG_INT, p);
13238|      0|    }
13239|      0|}
13240|       |
13241|       |/* return NaN if bad bigint literal */
13242|       |static JSValue JS_StringToBigInt(JSContext *ctx, JSValue val)
13243|   561k|{
13244|   561k|    const char *str, *p;
13245|   561k|    size_t len;
13246|   561k|    int flags;
13247|       |
13248|   561k|    str = JS_ToCStringLen(ctx, &len, val);
13249|   561k|    JS_FreeValue(ctx, val);
13250|   561k|    if (!str)
13251|      0|        return JS_EXCEPTION;
13252|   561k|    p = str;
13253|   561k|    p += skip_spaces(p);
13254|   561k|    if ((p - str) == len) {
13255|  57.9k|        val = JS_NewBigInt64(ctx, 0);
13256|   503k|    } else {
13257|   503k|        flags = ATOD_INT_ONLY | ATOD_ACCEPT_BIN_OCT | ATOD_TYPE_BIG_INT;
13258|   503k|        val = js_atof(ctx, p, &p, 0, flags);
13259|   503k|        p += skip_spaces(p);
13260|   503k|        if (!JS_IsException(val)) {
13261|   503k|            if ((p - str) != len) {
13262|   481k|                JS_FreeValue(ctx, val);
13263|   481k|                val = JS_NAN;
13264|   481k|            }
13265|   503k|        }
13266|   503k|    }
13267|   561k|    JS_FreeCString(ctx, str);
13268|   561k|    return val;
13269|   561k|}
13270|       |
13271|       |static JSValue JS_StringToBigIntErr(JSContext *ctx, JSValue val)
13272|      0|{
13273|      0|    val = JS_StringToBigInt(ctx, val);
13274|      0|    if (JS_VALUE_IS_NAN(val))
13275|      0|        return JS_ThrowSyntaxError(ctx, "invalid bigint literal");
13276|      0|    return val;
13277|      0|}
13278|       |
13279|       |/* JS Numbers are not allowed */
13280|       |static JSValue JS_ToBigIntFree(JSContext *ctx, JSValue val)
13281|      0|{
13282|      0|    uint32_t tag;
13283|       |
13284|      0| redo:
13285|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
13286|      0|    switch(tag) {
13287|      0|    case JS_TAG_SHORT_BIG_INT:
13288|      0|    case JS_TAG_BIG_INT:
13289|      0|        break;
13290|      0|    case JS_TAG_INT:
13291|      0|    case JS_TAG_NULL:
13292|      0|    case JS_TAG_UNDEFINED:
13293|      0|    case JS_TAG_FLOAT64:
13294|      0|        goto fail;
13295|      0|    case JS_TAG_BOOL:
13296|      0|        val = __JS_NewShortBigInt(ctx, JS_VALUE_GET_INT(val));
13297|      0|        break;
13298|      0|    case JS_TAG_STRING:
13299|      0|    case JS_TAG_STRING_ROPE:
13300|      0|        val = JS_StringToBigIntErr(ctx, val);
13301|      0|        if (JS_IsException(val))
13302|      0|            return val;
13303|      0|        goto redo;
13304|      0|    case JS_TAG_OBJECT:
13305|      0|        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
13306|      0|        if (JS_IsException(val))
13307|      0|            return val;
13308|      0|        goto redo;
13309|      0|    default:
13310|      0|    fail:
13311|      0|        JS_FreeValue(ctx, val);
13312|      0|        return JS_ThrowTypeError(ctx, "cannot convert to bigint");
13313|      0|    }
13314|      0|    return val;
13315|      0|}
13316|       |
13317|       |static JSValue JS_ToBigInt(JSContext *ctx, JSValueConst val)
13318|      0|{
13319|      0|    return JS_ToBigIntFree(ctx, JS_DupValue(ctx, val));
13320|      0|}
13321|       |
13322|       |/* XXX: merge with JS_ToInt64Free with a specific flag ? */
13323|       |static int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val)
13324|      0|{
13325|      0|    uint64_t res;
13326|       |
13327|      0|    val = JS_ToBigIntFree(ctx, val);
13328|      0|    if (JS_IsException(val)) {
13329|      0|        *pres = 0;
13330|      0|        return -1;
13331|      0|    }
13332|      0|    if (JS_VALUE_GET_TAG(val) == JS_TAG_SHORT_BIG_INT) {
13333|      0|        res = JS_VALUE_GET_SHORT_BIG_INT(val);
13334|      0|    } else {
13335|      0|        JSBigInt *p = JS_VALUE_GET_PTR(val);
13336|       |        /* return the value mod 2^64 */
13337|      0|        res = p->tab[0];
13338|       |#if JS_LIMB_BITS == 32
13339|       |        if (p->len >= 2)
13340|       |            res |= (uint64_t)p->tab[1] << 32;
13341|       |#endif
13342|      0|        JS_FreeValue(ctx, val);
13343|      0|    }
13344|      0|    *pres = res;
13345|      0|    return 0;
13346|      0|}
13347|       |
13348|       |int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
13349|      0|{
13350|      0|    return JS_ToBigInt64Free(ctx, pres, JS_DupValue(ctx, val));
13351|      0|}
13352|       |
13353|       |static no_inline __exception int js_unary_arith_slow(JSContext *ctx,
13354|       |                                                     JSValue *sp,
13355|       |                                                     OPCodeEnum op)
13356|  1.50M|{
13357|  1.50M|    JSValue op1;
13358|  1.50M|    int v;
13359|  1.50M|    uint32_t tag;
13360|  1.50M|    JSBigIntBuf buf1;
13361|  1.50M|    JSBigInt *p1;
13362|       |
13363|  1.50M|    op1 = sp[-1];
13364|       |    /* fast path for float64 */
13365|  1.50M|    if (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(op1)))
13366|  76.4k|        goto handle_float64;
13367|  1.42M|    op1 = JS_ToNumericFree(ctx, op1);
13368|  1.42M|    if (JS_IsException(op1))
13369|      1|        goto exception;
13370|  1.42M|    tag = JS_VALUE_GET_TAG(op1);
13371|  1.42M|    switch(tag) {
13372|  56.7k|    case JS_TAG_INT:
13373|  56.7k|        {
13374|  56.7k|            int64_t v64;
13375|  56.7k|            v64 = JS_VALUE_GET_INT(op1);
13376|  56.7k|            switch(op) {
13377|    111|            case OP_inc:
13378|    128|            case OP_dec:
13379|    128|                v = 2 * (op - OP_dec) - 1;
13380|    128|                v64 += v;
13381|    128|                break;
13382|  16.8k|            case OP_plus:
13383|  16.8k|                break;
13384|  39.8k|            case OP_neg:
13385|  39.8k|                if (v64 == 0) {
13386|  1.34k|                    sp[-1] = __JS_NewFloat64(ctx, -0.0);
13387|  1.34k|                    return 0;
13388|  38.4k|                } else {
13389|  38.4k|                    v64 = -v64;
13390|  38.4k|                }
13391|  38.4k|                break;
13392|  38.4k|            default:
13393|      0|                abort();
13394|  56.7k|            }
13395|  55.4k|            sp[-1] = JS_NewInt64(ctx, v64);
13396|  55.4k|        }
13397|      0|        break;
13398|   777k|    case JS_TAG_SHORT_BIG_INT:
13399|   777k|        {
13400|   777k|            int64_t v;
13401|   777k|            v = JS_VALUE_GET_SHORT_BIG_INT(op1);
13402|   777k|            switch(op) {
13403|      3|            case OP_plus:
13404|      3|                JS_ThrowTypeError(ctx, "bigint argument with unary +");
13405|      3|                goto exception;
13406|      4|            case OP_inc:
13407|      4|                if (v == JS_SHORT_BIG_INT_MAX)
13408|      0|                    goto bigint_slow_case;
13409|      4|                sp[-1] = __JS_NewShortBigInt(ctx, v + 1);
13410|      4|                break;
13411|     55|            case OP_dec:
13412|     55|                if (v == JS_SHORT_BIG_INT_MIN)
13413|      0|                    goto bigint_slow_case;
13414|     55|                sp[-1] = __JS_NewShortBigInt(ctx, v - 1);
13415|     55|                break;
13416|   777k|            case OP_neg:
13417|   777k|                v = JS_VALUE_GET_SHORT_BIG_INT(op1);
13418|   777k|                if (v == JS_SHORT_BIG_INT_MIN) {
13419|      0|                bigint_slow_case:
13420|      0|                    p1 = js_bigint_set_short(&buf1, op1);
13421|      0|                    goto bigint_slow_case1;
13422|      0|                }
13423|   777k|                sp[-1] = __JS_NewShortBigInt(ctx, -v);
13424|   777k|                break;
13425|      0|            default:
13426|      0|                abort();
13427|   777k|            }
13428|   777k|        }
13429|   777k|        break;
13430|   777k|    case JS_TAG_BIG_INT:
13431|   270k|        {
13432|   270k|            JSBigInt *r;
13433|   270k|            p1 = JS_VALUE_GET_PTR(op1);
13434|   270k|        bigint_slow_case1:
13435|   270k|            switch(op) {
13436|      2|            case OP_plus:
13437|      2|                JS_ThrowTypeError(ctx, "bigint argument with unary +");
13438|      2|                JS_FreeValue(ctx, op1);
13439|      2|                goto exception;
13440|      3|            case OP_inc:
13441|     69|            case OP_dec:
13442|     69|                {
13443|     69|                    JSBigIntBuf buf2;
13444|     69|                    JSBigInt *p2;
13445|     69|                    p2 = js_bigint_set_si(&buf2, 2 * (op - OP_dec) - 1);
13446|     69|                    r = js_bigint_add(ctx, p1, p2, 0);
13447|     69|                }
13448|     69|                break;
13449|   269k|            case OP_neg:
13450|   269k|                r = js_bigint_neg(ctx, p1);
13451|   269k|                break;
13452|      0|            case OP_not:
13453|      0|                r = js_bigint_not(ctx, p1);
13454|      0|                break;
13455|      0|            default:
13456|      0|                abort();
13457|   270k|            }
13458|   270k|            JS_FreeValue(ctx, op1);
13459|   270k|            if (!r)
13460|      0|                goto exception;
13461|   270k|            sp[-1] = JS_CompactBigInt(ctx, r);
13462|   270k|        }
13463|      0|        break;
13464|   319k|    default:
13465|   396k|    handle_float64:
13466|   396k|        {
13467|   396k|            double d;
13468|   396k|            d = JS_VALUE_GET_FLOAT64(op1);
13469|   396k|            switch(op) {
13470|  74.4k|            case OP_inc:
13471|   113k|            case OP_dec:
13472|   113k|                v = 2 * (op - OP_dec) - 1;
13473|   113k|                d += v;
13474|   113k|                break;
13475|  13.3k|            case OP_plus:
13476|  13.3k|                break;
13477|   269k|            case OP_neg:
13478|   269k|                d = -d;
13479|   269k|                break;
13480|      0|            default:
13481|      0|                abort();
13482|   396k|            }
13483|   396k|            sp[-1] = __JS_NewFloat64(ctx, d);
13484|   396k|        }
13485|      0|        break;
13486|  1.42M|    }
13487|  1.49M|    return 0;
13488|      6| exception:
13489|      6|    sp[-1] = JS_UNDEFINED;
13490|      6|    return -1;
13491|  1.42M|}
13492|       |
13493|       |static __exception int js_post_inc_slow(JSContext *ctx,
13494|       |                                        JSValue *sp, OPCodeEnum op)
13495|  76.5k|{
13496|  76.5k|    JSValue op1;
13497|       |
13498|       |    /* XXX: allow custom operators */
13499|  76.5k|    op1 = sp[-1];
13500|  76.5k|    op1 = JS_ToNumericFree(ctx, op1);
13501|  76.5k|    if (JS_IsException(op1)) {
13502|      0|        sp[-1] = JS_UNDEFINED;
13503|      0|        return -1;
13504|      0|    }
13505|  76.5k|    sp[-1] = op1;
13506|  76.5k|    sp[0] = JS_DupValue(ctx, op1);
13507|  76.5k|    return js_unary_arith_slow(ctx, sp + 1, op - OP_post_dec + OP_dec);
13508|  76.5k|}
13509|       |
13510|       |static no_inline int js_not_slow(JSContext *ctx, JSValue *sp)
13511|  69.9k|{
13512|  69.9k|    JSValue op1;
13513|       |
13514|  69.9k|    op1 = sp[-1];
13515|  69.9k|    op1 = JS_ToNumericFree(ctx, op1);
13516|  69.9k|    if (JS_IsException(op1))
13517|      1|        goto exception;
13518|  69.9k|    if (JS_VALUE_GET_TAG(op1) == JS_TAG_SHORT_BIG_INT) {
13519|  3.94k|        sp[-1] = __JS_NewShortBigInt(ctx, ~JS_VALUE_GET_SHORT_BIG_INT(op1));
13520|  65.9k|    } else if (JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT) {
13521|  24.2k|        JSBigInt *r;
13522|  24.2k|        r = js_bigint_not(ctx, JS_VALUE_GET_PTR(op1));
13523|  24.2k|        JS_FreeValue(ctx, op1);
13524|  24.2k|        if (!r)
13525|      0|            goto exception;
13526|  24.2k|        sp[-1] = JS_CompactBigInt(ctx, r);
13527|  41.7k|    } else {
13528|  41.7k|        int32_t v1;
13529|  41.7k|        if (unlikely(JS_ToInt32Free(ctx, &v1, op1)))
13530|      0|            goto exception;
13531|  41.7k|        sp[-1] = JS_NewInt32(ctx, ~v1);
13532|  41.7k|    }
13533|  69.9k|    return 0;
13534|      1| exception:
13535|      1|    sp[-1] = JS_UNDEFINED;
13536|      1|    return -1;
13537|  69.9k|}
13538|       |
13539|       |static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *sp,
13540|       |                                                      OPCodeEnum op)
13541|  4.93M|{
13542|  4.93M|    JSValue op1, op2;
13543|  4.93M|    uint32_t tag1, tag2;
13544|  4.93M|    double d1, d2;
13545|       |
13546|  4.93M|    op1 = sp[-2];
13547|  4.93M|    op2 = sp[-1];
13548|  4.93M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
13549|  4.93M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
13550|       |    /* fast path for float operations */
13551|  4.93M|    if (tag1 == JS_TAG_FLOAT64 && tag2 == JS_TAG_FLOAT64) {
13552|   267k|        d1 = JS_VALUE_GET_FLOAT64(op1);
13553|   267k|        d2 = JS_VALUE_GET_FLOAT64(op2);
13554|   267k|        goto handle_float64;
13555|   267k|    }
13556|       |    /* fast path for short big int operations */
13557|  4.66M|    if (tag1 == JS_TAG_SHORT_BIG_INT && tag2 == JS_TAG_SHORT_BIG_INT) {
13558|  1.63M|        js_slimb_t v1, v2;
13559|  1.63M|        js_sdlimb_t v;
13560|  1.63M|        v1 = JS_VALUE_GET_SHORT_BIG_INT(op1);
13561|  1.63M|        v2 = JS_VALUE_GET_SHORT_BIG_INT(op2);
13562|  1.63M|        switch(op) {
13563|   669k|        case OP_sub:
13564|   669k|            v = (js_sdlimb_t)v1 - (js_sdlimb_t)v2;
13565|   669k|            break;
13566|  32.5k|        case OP_mul:
13567|  32.5k|            v = (js_sdlimb_t)v1 * (js_sdlimb_t)v2;
13568|  32.5k|            break;
13569|   898k|        case OP_div:
13570|   898k|            if (v2 == 0 ||
13571|   898k|                ((js_limb_t)v1 == (js_limb_t)1 << (JS_LIMB_BITS - 1) &&
13572|   898k|                 v2 == -1)) {
13573|      1|                goto slow_big_int;
13574|      1|            }
13575|   898k|            sp[-2] = __JS_NewShortBigInt(ctx, v1 / v2);
13576|   898k|            return 0;
13577|  18.3k|        case OP_mod:
13578|  18.3k|            if (v2 == 0 ||
13579|  18.3k|                ((js_limb_t)v1 == (js_limb_t)1 << (JS_LIMB_BITS - 1) &&
13580|  18.3k|                 v2 == -1)) {
13581|      1|                goto slow_big_int;
13582|      1|            }
13583|  18.3k|            sp[-2] = __JS_NewShortBigInt(ctx, v1 % v2);
13584|  18.3k|            return 0;
13585|  17.3k|        case OP_pow:
13586|  17.3k|            goto slow_big_int;
13587|      0|        default:
13588|      0|            abort();
13589|  1.63M|        }
13590|   702k|        if (likely(v >= JS_SHORT_BIG_INT_MIN && v <= JS_SHORT_BIG_INT_MAX)) {
13591|   695k|            sp[-2] = __JS_NewShortBigInt(ctx, v);
13592|   695k|        } else {
13593|  6.56k|            JSBigInt *r = js_bigint_new_di(ctx, v);
13594|  6.56k|            if (!r)
13595|      0|                goto exception;
13596|  6.56k|            sp[-2] = JS_MKPTR(JS_TAG_BIG_INT, r);
13597|  6.56k|        }
13598|   702k|        return 0;
13599|   702k|    }
13600|  3.02M|    op1 = JS_ToNumericFree(ctx, op1);
13601|  3.02M|    if (JS_IsException(op1)) {
13602|     47|        JS_FreeValue(ctx, op2);
13603|     47|        goto exception;
13604|     47|    }
13605|  3.02M|    op2 = JS_ToNumericFree(ctx, op2);
13606|  3.02M|    if (JS_IsException(op2)) {
13607|      1|        JS_FreeValue(ctx, op1);
13608|      1|        goto exception;
13609|      1|    }
13610|  3.02M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
13611|  3.02M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
13612|       |
13613|  3.02M|    if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {
13614|   369k|        int32_t v1, v2;
13615|   369k|        int64_t v;
13616|   369k|        v1 = JS_VALUE_GET_INT(op1);
13617|   369k|        v2 = JS_VALUE_GET_INT(op2);
13618|   369k|        switch(op) {
13619|  84.0k|        case OP_sub:
13620|  84.0k|            v = (int64_t)v1 - (int64_t)v2;
13621|  84.0k|            break;
13622|   214k|        case OP_mul:
13623|   214k|            v = (int64_t)v1 * (int64_t)v2;
13624|   214k|            if (v == 0 && (v1 | v2) < 0) {
13625|   206k|                sp[-2] = __JS_NewFloat64(ctx, -0.0);
13626|   206k|                return 0;
13627|   206k|            }
13628|  8.12k|            break;
13629|  17.6k|        case OP_div:
13630|  17.6k|            sp[-2] = JS_NewFloat64(ctx, (double)v1 / (double)v2);
13631|  17.6k|            return 0;
13632|  8.44k|        case OP_mod:
13633|  8.44k|            if (v1 < 0 || v2 <= 0) {
13634|  7.43k|                sp[-2] = JS_NewFloat64(ctx, fmod(v1, v2));
13635|  7.43k|                return 0;
13636|  7.43k|            } else {
13637|  1.00k|                v = (int64_t)v1 % (int64_t)v2;
13638|  1.00k|            }
13639|  1.00k|            break;
13640|  45.3k|        case OP_pow:
13641|  45.3k|            sp[-2] = JS_NewFloat64(ctx, js_pow(v1, v2));
13642|  45.3k|            return 0;
13643|      0|        default:
13644|      0|            abort();
13645|   369k|        }
13646|  93.1k|        sp[-2] = JS_NewInt64(ctx, v);
13647|  2.65M|    } else if ((tag1 == JS_TAG_SHORT_BIG_INT || tag1 == JS_TAG_BIG_INT) &&
13648|  2.65M|               (tag2 == JS_TAG_SHORT_BIG_INT || tag2 == JS_TAG_BIG_INT)) {
13649|  1.45M|        JSBigInt *p1, *p2, *r;
13650|  1.45M|        JSBigIntBuf buf1, buf2;
13651|  1.47M|    slow_big_int:
13652|       |        /* bigint result */
13653|  1.47M|        if (JS_VALUE_GET_TAG(op1) == JS_TAG_SHORT_BIG_INT)
13654|   414k|            p1 = js_bigint_set_short(&buf1, op1);
13655|  1.06M|        else
13656|  1.06M|            p1 = JS_VALUE_GET_PTR(op1);
13657|  1.47M|        if (JS_VALUE_GET_TAG(op2) == JS_TAG_SHORT_BIG_INT)
13658|   945k|            p2 = js_bigint_set_short(&buf2, op2);
13659|   530k|        else
13660|   530k|            p2 = JS_VALUE_GET_PTR(op2);
13661|  1.47M|        switch(op) {
13662|      0|        case OP_add:
13663|      0|            r = js_bigint_add(ctx, p1, p2, 0);
13664|      0|            break;
13665|   280k|        case OP_sub:
13666|   280k|            r = js_bigint_add(ctx, p1, p2, 1);
13667|   280k|            break;
13668|  65.3k|        case OP_mul:
13669|  65.3k|            r = js_bigint_mul(ctx, p1, p2);
13670|  65.3k|            break;
13671|   985k|        case OP_div:
13672|   985k|            r = js_bigint_divrem(ctx, p1, p2, FALSE);
13673|   985k|            break;
13674|   124k|        case OP_mod:
13675|   124k|            r = js_bigint_divrem(ctx, p1, p2, TRUE);
13676|   124k|            break;
13677|  19.9k|        case OP_pow:
13678|  19.9k|            r = js_bigint_pow(ctx, p1, p2);
13679|  19.9k|            break;
13680|      0|        default:
13681|      0|            abort();
13682|  1.47M|        }
13683|  1.47M|        JS_FreeValue(ctx, op1);
13684|  1.47M|        JS_FreeValue(ctx, op2);
13685|  1.47M|        if (!r)
13686|     21|            goto exception;
13687|  1.47M|        sp[-2] = JS_CompactBigInt(ctx, r);
13688|  1.47M|    } else {
13689|  1.20M|        double dr;
13690|       |        /* float64 result */
13691|  1.20M|        if (JS_ToFloat64Free(ctx, &d1, op1)) {
13692|    116|            JS_FreeValue(ctx, op2);
13693|    116|            goto exception;
13694|    116|        }
13695|  1.20M|        if (JS_ToFloat64Free(ctx, &d2, op2))
13696|    201|            goto exception;
13697|  1.46M|    handle_float64:
13698|  1.46M|        switch(op) {
13699|   535k|        case OP_sub:
13700|   535k|            dr = d1 - d2;
13701|   535k|            break;
13702|   376k|        case OP_mul:
13703|   376k|            dr = d1 * d2;
13704|   376k|            break;
13705|   457k|        case OP_div:
13706|   457k|            dr = d1 / d2;
13707|   457k|            break;
13708|  12.0k|        case OP_mod:
13709|  12.0k|            dr = fmod(d1, d2);
13710|  12.0k|            break;
13711|  85.4k|        case OP_pow:
13712|  85.4k|            dr = js_pow(d1, d2);
13713|  85.4k|            break;
13714|      0|        default:
13715|      0|            abort();
13716|  1.46M|        }
13717|  1.46M|        sp[-2] = __JS_NewFloat64(ctx, dr);
13718|  1.46M|    }
13719|  3.03M|    return 0;
13720|    386| exception:
13721|    386|    sp[-2] = JS_UNDEFINED;
13722|    386|    sp[-1] = JS_UNDEFINED;
13723|    386|    return -1;
13724|  3.02M|}
13725|       |
13726|       |static inline BOOL tag_is_string(uint32_t tag)
13727|  10.3M|{
13728|  10.3M|    return tag == JS_TAG_STRING || tag == JS_TAG_STRING_ROPE;
13729|  10.3M|}
13730|       |
13731|       |static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
13732|  1.44M|{
13733|  1.44M|    JSValue op1, op2;
13734|  1.44M|    uint32_t tag1, tag2;
13735|       |
13736|  1.44M|    op1 = sp[-2];
13737|  1.44M|    op2 = sp[-1];
13738|       |
13739|  1.44M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
13740|  1.44M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
13741|       |    /* fast path for float64 */
13742|  1.44M|    if (tag1 == JS_TAG_FLOAT64 && tag2 == JS_TAG_FLOAT64) {
13743|      0|        double d1, d2;
13744|      0|        d1 = JS_VALUE_GET_FLOAT64(op1);
13745|      0|        d2 = JS_VALUE_GET_FLOAT64(op2);
13746|      0|        sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
13747|      0|        return 0;
13748|      0|    }
13749|       |    /* fast path for short bigint */
13750|  1.44M|    if (tag1 == JS_TAG_SHORT_BIG_INT && tag2 == JS_TAG_SHORT_BIG_INT) {
13751|  15.2k|        js_slimb_t v1, v2;
13752|  15.2k|        js_sdlimb_t v;
13753|  15.2k|        v1 = JS_VALUE_GET_SHORT_BIG_INT(op1);
13754|  15.2k|        v2 = JS_VALUE_GET_SHORT_BIG_INT(op2);
13755|  15.2k|        v = (js_sdlimb_t)v1 + (js_sdlimb_t)v2;
13756|  15.2k|        if (likely(v >= JS_SHORT_BIG_INT_MIN && v <= JS_SHORT_BIG_INT_MAX)) {
13757|  15.2k|            sp[-2] = __JS_NewShortBigInt(ctx, v);
13758|  15.2k|        } else {
13759|      0|            JSBigInt *r = js_bigint_new_di(ctx, v);
13760|      0|            if (!r)
13761|      0|                goto exception;
13762|      0|            sp[-2] = JS_MKPTR(JS_TAG_BIG_INT, r);
13763|      0|        }
13764|  15.2k|        return 0;
13765|  15.2k|    }
13766|       |    
13767|  1.42M|    if (tag1 == JS_TAG_OBJECT || tag2 == JS_TAG_OBJECT) {
13768|   412k|        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
13769|   412k|        if (JS_IsException(op1)) {
13770|      1|            JS_FreeValue(ctx, op2);
13771|      1|            goto exception;
13772|      1|        }
13773|       |
13774|   412k|        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);
13775|   412k|        if (JS_IsException(op2)) {
13776|      3|            JS_FreeValue(ctx, op1);
13777|      3|            goto exception;
13778|      3|        }
13779|   412k|        tag1 = JS_VALUE_GET_NORM_TAG(op1);
13780|   412k|        tag2 = JS_VALUE_GET_NORM_TAG(op2);
13781|   412k|    }
13782|       |
13783|  1.42M|    if (tag_is_string(tag1) || tag_is_string(tag2)) {
13784|  1.33M|        sp[-2] = JS_ConcatString(ctx, op1, op2);
13785|  1.33M|        if (JS_IsException(sp[-2]))
13786|      0|            goto exception;
13787|  1.33M|        return 0;
13788|  1.33M|    }
13789|       |
13790|  89.3k|    op1 = JS_ToNumericFree(ctx, op1);
13791|  89.3k|    if (JS_IsException(op1)) {
13792|      0|        JS_FreeValue(ctx, op2);
13793|      0|        goto exception;
13794|      0|    }
13795|  89.3k|    op2 = JS_ToNumericFree(ctx, op2);
13796|  89.3k|    if (JS_IsException(op2)) {
13797|      0|        JS_FreeValue(ctx, op1);
13798|      0|        goto exception;
13799|      0|    }
13800|  89.3k|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
13801|  89.3k|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
13802|       |
13803|  89.3k|    if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {
13804|  9.44k|        int32_t v1, v2;
13805|  9.44k|        int64_t v;
13806|  9.44k|        v1 = JS_VALUE_GET_INT(op1);
13807|  9.44k|        v2 = JS_VALUE_GET_INT(op2);
13808|  9.44k|        v = (int64_t)v1 + (int64_t)v2;
13809|  9.44k|        sp[-2] = JS_NewInt64(ctx, v);
13810|  79.9k|    } else if ((tag1 == JS_TAG_BIG_INT || tag1 == JS_TAG_SHORT_BIG_INT) &&
13811|  79.9k|               (tag2 == JS_TAG_BIG_INT || tag2 == JS_TAG_SHORT_BIG_INT)) {
13812|  37.9k|        JSBigInt *p1, *p2, *r;
13813|  37.9k|        JSBigIntBuf buf1, buf2;
13814|       |        /* bigint result */
13815|  37.9k|        if (JS_VALUE_GET_TAG(op1) == JS_TAG_SHORT_BIG_INT)
13816|  7.67k|            p1 = js_bigint_set_short(&buf1, op1);
13817|  30.2k|        else
13818|  30.2k|            p1 = JS_VALUE_GET_PTR(op1);
13819|  37.9k|        if (JS_VALUE_GET_TAG(op2) == JS_TAG_SHORT_BIG_INT)
13820|  15.2k|            p2 = js_bigint_set_short(&buf2, op2);
13821|  22.6k|        else
13822|  22.6k|            p2 = JS_VALUE_GET_PTR(op2);
13823|  37.9k|        r = js_bigint_add(ctx, p1, p2, 0);
13824|  37.9k|        JS_FreeValue(ctx, op1);
13825|  37.9k|        JS_FreeValue(ctx, op2);
13826|  37.9k|        if (!r)
13827|      0|            goto exception;
13828|  37.9k|        sp[-2] = JS_CompactBigInt(ctx, r);
13829|  41.9k|    } else {
13830|  41.9k|        double d1, d2;
13831|       |        /* float64 result */
13832|  41.9k|        if (JS_ToFloat64Free(ctx, &d1, op1)) {
13833|    471|            JS_FreeValue(ctx, op2);
13834|    471|            goto exception;
13835|    471|        }
13836|  41.4k|        if (JS_ToFloat64Free(ctx, &d2, op2))
13837|     40|            goto exception;
13838|  41.4k|        sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
13839|  41.4k|    }
13840|  88.8k|    return 0;
13841|    515| exception:
13842|    515|    sp[-2] = JS_UNDEFINED;
13843|    515|    sp[-1] = JS_UNDEFINED;
13844|    515|    return -1;
13845|  89.3k|}
13846|       |
13847|       |static no_inline __exception int js_binary_logic_slow(JSContext *ctx,
13848|       |                                                      JSValue *sp,
13849|       |                                                      OPCodeEnum op)
13850|  1.75M|{
13851|  1.75M|    JSValue op1, op2;
13852|  1.75M|    uint32_t tag1, tag2;
13853|  1.75M|    uint32_t v1, v2, r;
13854|       |
13855|  1.75M|    op1 = sp[-2];
13856|  1.75M|    op2 = sp[-1];
13857|  1.75M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
13858|  1.75M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
13859|       |
13860|  1.75M|    if (tag1 == JS_TAG_SHORT_BIG_INT && tag2 == JS_TAG_SHORT_BIG_INT) {
13861|  58.2k|        js_slimb_t v1, v2, v;
13862|  58.2k|        js_sdlimb_t vd;
13863|  58.2k|        v1 = JS_VALUE_GET_SHORT_BIG_INT(op1);
13864|  58.2k|        v2 = JS_VALUE_GET_SHORT_BIG_INT(op2);
13865|       |        /* bigint fast path */
13866|  58.2k|        switch(op) {
13867|  2.53k|        case OP_and:
13868|  2.53k|            v = v1 & v2;
13869|  2.53k|            break;
13870|    407|        case OP_or:
13871|    407|            v = v1 | v2;
13872|    407|            break;
13873|  1.84k|        case OP_xor:
13874|  1.84k|            v = v1 ^ v2;
13875|  1.84k|            break;
13876|  15.8k|        case OP_sar:
13877|  15.8k|            if (v2 > (JS_LIMB_BITS - 1)) {
13878|  5.24k|                goto slow_big_int;
13879|  10.5k|            } else if (v2 < 0) {
13880|  1.89k|                if (v2 < -(JS_LIMB_BITS - 1))
13881|  1.60k|                    goto slow_big_int;
13882|    287|                v2 = -v2;
13883|    287|                goto bigint_shl;
13884|  1.89k|            }
13885|  11.0k|        bigint_sar:
13886|  11.0k|            v = v1 >> v2;
13887|  11.0k|            break;
13888|  37.6k|        case OP_shl:
13889|  37.6k|            if (v2 > (JS_LIMB_BITS - 1)) {
13890|  7.24k|                goto slow_big_int;
13891|  30.4k|            } else if (v2 < 0) {
13892|  6.04k|                if (v2 < -(JS_LIMB_BITS - 1))
13893|  3.68k|                    goto slow_big_int;
13894|  2.36k|                v2 = -v2;
13895|  2.36k|                goto bigint_sar;
13896|  6.04k|            }
13897|  24.6k|        bigint_shl:
13898|  24.6k|            vd = (js_dlimb_t)v1 << v2;
13899|  24.6k|            if (likely(vd >= JS_SHORT_BIG_INT_MIN &&
13900|  24.6k|                       vd <= JS_SHORT_BIG_INT_MAX)) {
13901|  2.68k|                v = vd;
13902|  21.9k|            } else {
13903|  21.9k|                JSBigInt *r = js_bigint_new_di(ctx, vd);
13904|  21.9k|                if (!r)
13905|      0|                    goto exception;
13906|  21.9k|                sp[-2] = JS_MKPTR(JS_TAG_BIG_INT, r);
13907|  21.9k|                return 0;
13908|  21.9k|            }
13909|  2.68k|            break;
13910|  2.68k|        default:
13911|      0|            abort();
13912|  58.2k|        }
13913|  18.5k|        sp[-2] = __JS_NewShortBigInt(ctx, v);
13914|  18.5k|        return 0;
13915|  58.2k|    }
13916|  1.70M|    op1 = JS_ToNumericFree(ctx, op1);
13917|  1.70M|    if (JS_IsException(op1)) {
13918|      0|        JS_FreeValue(ctx, op2);
13919|      0|        goto exception;
13920|      0|    }
13921|  1.70M|    op2 = JS_ToNumericFree(ctx, op2);
13922|  1.70M|    if (JS_IsException(op2)) {
13923|      0|        JS_FreeValue(ctx, op1);
13924|      0|        goto exception;
13925|      0|    }
13926|       |
13927|  1.70M|    tag1 = JS_VALUE_GET_TAG(op1);
13928|  1.70M|    tag2 = JS_VALUE_GET_TAG(op2);
13929|  1.70M|    if ((tag1 == JS_TAG_BIG_INT || tag1 == JS_TAG_SHORT_BIG_INT) &&
13930|  1.70M|        (tag2 == JS_TAG_BIG_INT || tag2 == JS_TAG_SHORT_BIG_INT)) {
13931|   244k|        JSBigInt *p1, *p2, *r;
13932|   244k|        JSBigIntBuf buf1, buf2;
13933|   262k|    slow_big_int:
13934|   262k|        if (JS_VALUE_GET_TAG(op1) == JS_TAG_SHORT_BIG_INT)
13935|  23.7k|            p1 = js_bigint_set_short(&buf1, op1);
13936|   238k|        else
13937|   238k|            p1 = JS_VALUE_GET_PTR(op1);
13938|   262k|        if (JS_VALUE_GET_TAG(op2) == JS_TAG_SHORT_BIG_INT)
13939|   128k|            p2 = js_bigint_set_short(&buf2, op2);
13940|   134k|        else
13941|   134k|            p2 = JS_VALUE_GET_PTR(op2);
13942|   262k|        switch(op) {
13943|  33.9k|        case OP_and:
13944|  74.8k|        case OP_or:
13945|   198k|        case OP_xor:
13946|   198k|            r = js_bigint_logic(ctx, p1, p2, op);
13947|   198k|            break;
13948|  12.0k|        case OP_shl:
13949|  63.5k|        case OP_sar:
13950|  63.5k|            {
13951|  63.5k|                js_slimb_t shift;
13952|  63.5k|                shift = js_bigint_get_si_sat(p2);
13953|  63.5k|                if (shift > INT32_MAX)
13954|  18.5k|                    shift = INT32_MAX;
13955|  45.0k|                else if (shift < -INT32_MAX)
13956|    339|                    shift = -INT32_MAX;
13957|  63.5k|                if (op == OP_sar)
13958|  51.5k|                    shift = -shift;
13959|  63.5k|                if (shift >= 0)
13960|  16.4k|                    r = js_bigint_shl(ctx, p1, shift);
13961|  47.1k|                else
13962|  47.1k|                    r = js_bigint_shr(ctx, p1, -shift);
13963|  63.5k|            }
13964|  63.5k|            break;
13965|      0|        default:
13966|      0|            abort();
13967|   262k|        }
13968|   262k|        JS_FreeValue(ctx, op1);
13969|   262k|        JS_FreeValue(ctx, op2);
13970|   262k|        if (!r)
13971|     35|            goto exception;
13972|   262k|        sp[-2] = JS_CompactBigInt(ctx, r);
13973|  1.45M|    } else {
13974|  1.45M|        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
13975|    208|            JS_FreeValue(ctx, op2);
13976|    208|            goto exception;
13977|    208|        }
13978|  1.45M|        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))
13979|     64|            goto exception;
13980|  1.45M|        switch(op) {
13981|  2.23k|        case OP_shl:
13982|  2.23k|            r = v1 << (v2 & 0x1f);
13983|  2.23k|            break;
13984|   368k|        case OP_sar:
13985|   368k|            r = (int)v1 >> (v2 & 0x1f);
13986|   368k|            break;
13987|  1.04M|        case OP_and:
13988|  1.04M|            r = v1 & v2;
13989|  1.04M|            break;
13990|  43.0k|        case OP_or:
13991|  43.0k|            r = v1 | v2;
13992|  43.0k|            break;
13993|    858|        case OP_xor:
13994|    858|            r = v1 ^ v2;
13995|    858|            break;
13996|      0|        default:
13997|      0|            abort();
13998|  1.45M|        }
13999|  1.45M|        sp[-2] = JS_NewInt32(ctx, r);
14000|  1.45M|    }
14001|  1.71M|    return 0;
14002|    307| exception:
14003|    307|    sp[-2] = JS_UNDEFINED;
14004|    307|    sp[-1] = JS_UNDEFINED;
14005|    307|    return -1;
14006|  1.70M|}
14007|       |
14008|       |/* op1 must be a bigint or int. */
14009|       |static JSBigInt *JS_ToBigIntBuf(JSContext *ctx, JSBigIntBuf *buf1,
14010|       |                                JSValue op1)
14011|   546k|{
14012|   546k|    JSBigInt *p1;
14013|       |    
14014|   546k|    switch(JS_VALUE_GET_TAG(op1)) {
14015|  96.6k|    case JS_TAG_INT:
14016|  96.6k|        p1 = js_bigint_set_si(buf1, JS_VALUE_GET_INT(op1));
14017|  96.6k|        break;
14018|   161k|    case JS_TAG_SHORT_BIG_INT:
14019|   161k|        p1 = js_bigint_set_short(buf1, op1);
14020|   161k|        break;
14021|   287k|    case JS_TAG_BIG_INT:
14022|   287k|        p1 = JS_VALUE_GET_PTR(op1);
14023|   287k|        break;
14024|      0|    default:
14025|      0|        abort();
14026|   546k|    }
14027|   546k|    return p1;
14028|   546k|}
14029|       |
14030|       |/* op1 and op2 must be numeric types and at least one must be a
14031|       |   bigint. No exception is generated. */
14032|       |static int js_compare_bigint(JSContext *ctx, OPCodeEnum op,
14033|       |                             JSValue op1, JSValue op2)
14034|  1.32M|{
14035|  1.32M|    int res, val, tag1, tag2;
14036|  1.32M|    JSBigIntBuf buf1, buf2;
14037|  1.32M|    JSBigInt *p1, *p2;
14038|       |    
14039|  1.32M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
14040|  1.32M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
14041|  1.32M|    if ((tag1 == JS_TAG_SHORT_BIG_INT || tag1 == JS_TAG_INT) &&
14042|  1.32M|        (tag2 == JS_TAG_SHORT_BIG_INT || tag2 == JS_TAG_INT)) {
14043|       |        /* fast path */
14044|   934k|        js_slimb_t v1, v2;
14045|   934k|        if (tag1 == JS_TAG_INT)
14046|   357k|            v1 = JS_VALUE_GET_INT(op1);
14047|   576k|        else
14048|   576k|            v1 = JS_VALUE_GET_SHORT_BIG_INT(op1);
14049|   934k|        if (tag2 == JS_TAG_INT)
14050|  72.6k|            v2 = JS_VALUE_GET_INT(op2);
14051|   861k|        else
14052|   861k|            v2 = JS_VALUE_GET_SHORT_BIG_INT(op2);
14053|   934k|        val = (v1 > v2) - (v1 < v2);
14054|   934k|    } else {
14055|   393k|        if (tag1 == JS_TAG_FLOAT64) {
14056|   102k|            p2 = JS_ToBigIntBuf(ctx, &buf2, op2);
14057|   102k|            val = js_bigint_float64_cmp(ctx, p2, JS_VALUE_GET_FLOAT64(op1));
14058|   102k|            if (val == 2)
14059|  96.2k|                goto unordered;
14060|  6.44k|            val = -val;
14061|   290k|        } else if (tag2 == JS_TAG_FLOAT64) {
14062|   138k|            p1 = JS_ToBigIntBuf(ctx, &buf1, op1);
14063|   138k|            val = js_bigint_float64_cmp(ctx, p1, JS_VALUE_GET_FLOAT64(op2));
14064|   138k|            if (val == 2) {
14065|   117k|            unordered:
14066|   117k|                JS_FreeValue(ctx, op1);
14067|   117k|                JS_FreeValue(ctx, op2);
14068|   117k|                return FALSE;
14069|  20.8k|            }
14070|   152k|        } else {
14071|   152k|            p1 = JS_ToBigIntBuf(ctx, &buf1, op1);
14072|   152k|            p2 = JS_ToBigIntBuf(ctx, &buf2, op2);
14073|   152k|            val = js_bigint_cmp(ctx, p1, p2);
14074|   152k|        }
14075|   276k|        JS_FreeValue(ctx, op1);
14076|   276k|        JS_FreeValue(ctx, op2);
14077|   276k|    }
14078|       |
14079|  1.21M|    switch(op) {
14080|   385k|    case OP_lt:
14081|   385k|        res = val < 0;
14082|   385k|        break;
14083|  41.4k|    case OP_lte:
14084|  41.4k|        res = val <= 0;
14085|  41.4k|        break;
14086|   634k|    case OP_gt:
14087|   634k|        res = val > 0;
14088|   634k|        break;
14089|   107k|    case OP_gte:
14090|   107k|        res = val >= 0;
14091|   107k|        break;
14092|  42.1k|    case OP_eq:
14093|  42.1k|        res = val == 0;
14094|  42.1k|        break;
14095|      0|    default:
14096|      0|        abort();
14097|  1.21M|    }
14098|  1.21M|    return res;
14099|  1.21M|}
14100|       |
14101|       |static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
14102|       |                                        OPCodeEnum op)
14103|  3.24M|{
14104|  3.24M|    JSValue op1, op2;
14105|  3.24M|    int res;
14106|  3.24M|    uint32_t tag1, tag2;
14107|       |
14108|  3.24M|    op1 = sp[-2];
14109|  3.24M|    op2 = sp[-1];
14110|  3.24M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
14111|  3.24M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
14112|  3.24M|    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);
14113|  3.24M|    if (JS_IsException(op1)) {
14114|      4|        JS_FreeValue(ctx, op2);
14115|      4|        goto exception;
14116|      4|    }
14117|  3.24M|    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);
14118|  3.24M|    if (JS_IsException(op2)) {
14119|      1|        JS_FreeValue(ctx, op1);
14120|      1|        goto exception;
14121|      1|    }
14122|  3.24M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
14123|  3.24M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
14124|       |
14125|  3.24M|    if (tag_is_string(tag1) && tag_is_string(tag2)) {
14126|   330k|        if (tag1 == JS_TAG_STRING && tag2 == JS_TAG_STRING) {
14127|   251k|            res = js_string_compare(ctx, JS_VALUE_GET_STRING(op1),
14128|   251k|                                    JS_VALUE_GET_STRING(op2));
14129|   251k|        } else {
14130|  78.7k|            res = js_string_rope_compare(ctx, op1, op2, FALSE);
14131|  78.7k|        }
14132|   330k|        switch(op) {
14133|   135k|        case OP_lt:
14134|   135k|            res = (res < 0);
14135|   135k|            break;
14136|    667|        case OP_lte:
14137|    667|            res = (res <= 0);
14138|    667|            break;
14139|  51.1k|        case OP_gt:
14140|  51.1k|            res = (res > 0);
14141|  51.1k|            break;
14142|      0|        default:
14143|   142k|        case OP_gte:
14144|   142k|            res = (res >= 0);
14145|   142k|            break;
14146|   330k|        }
14147|   330k|        JS_FreeValue(ctx, op1);
14148|   330k|        JS_FreeValue(ctx, op2);
14149|  2.91M|    } else if ((tag1 <= JS_TAG_NULL || tag1 == JS_TAG_FLOAT64) &&
14150|  2.91M|               (tag2 <= JS_TAG_NULL || tag2 == JS_TAG_FLOAT64)) {
14151|       |        /* fast path for float64/int */
14152|   962k|        goto float64_compare;
14153|  1.95M|    } else {
14154|  1.95M|        if ((((tag1 == JS_TAG_BIG_INT || tag1 == JS_TAG_SHORT_BIG_INT) &&
14155|  1.95M|              tag_is_string(tag2)) ||
14156|  1.95M|             ((tag2 == JS_TAG_BIG_INT || tag2 == JS_TAG_SHORT_BIG_INT) &&
14157|  1.93M|              tag_is_string(tag1)))) {
14158|   500k|            if (tag_is_string(tag1)) {
14159|   482k|                op1 = JS_StringToBigInt(ctx, op1);
14160|   482k|                if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT &&
14161|   482k|                    JS_VALUE_GET_TAG(op1) != JS_TAG_SHORT_BIG_INT)
14162|   409k|                    goto invalid_bigint_string;
14163|   482k|            }
14164|  90.6k|            if (tag_is_string(tag2)) {
14165|  18.2k|                op2 = JS_StringToBigInt(ctx, op2);
14166|  18.2k|                if (JS_VALUE_GET_TAG(op2) != JS_TAG_BIG_INT &&
14167|  18.2k|                    JS_VALUE_GET_TAG(op2) != JS_TAG_SHORT_BIG_INT) {
14168|   420k|                invalid_bigint_string:
14169|   420k|                    JS_FreeValue(ctx, op1);
14170|   420k|                    JS_FreeValue(ctx, op2);
14171|   420k|                    res = FALSE;
14172|   420k|                    goto done;
14173|  10.3k|                }
14174|  18.2k|            }
14175|  1.45M|        } else {
14176|  1.45M|            op1 = JS_ToNumericFree(ctx, op1);
14177|  1.45M|            if (JS_IsException(op1)) {
14178|      0|                JS_FreeValue(ctx, op2);
14179|      0|                goto exception;
14180|      0|            }
14181|  1.45M|            op2 = JS_ToNumericFree(ctx, op2);
14182|  1.45M|            if (JS_IsException(op2)) {
14183|      0|                JS_FreeValue(ctx, op1);
14184|      0|                goto exception;
14185|      0|            }
14186|  1.45M|        }
14187|       |
14188|  1.53M|        tag1 = JS_VALUE_GET_NORM_TAG(op1);
14189|  1.53M|        tag2 = JS_VALUE_GET_NORM_TAG(op2);
14190|       |
14191|  1.53M|        if (tag1 == JS_TAG_BIG_INT || tag1 == JS_TAG_SHORT_BIG_INT ||
14192|  1.53M|            tag2 == JS_TAG_BIG_INT || tag2 == JS_TAG_SHORT_BIG_INT) {
14193|  1.28M|            res = js_compare_bigint(ctx, op, op1, op2);
14194|  1.28M|        } else {
14195|   246k|            double d1, d2;
14196|       |
14197|  1.20M|        float64_compare:
14198|       |            /* can use floating point comparison */
14199|  1.20M|            if (tag1 == JS_TAG_FLOAT64) {
14200|   164k|                d1 = JS_VALUE_GET_FLOAT64(op1);
14201|  1.04M|            } else {
14202|  1.04M|                d1 = JS_VALUE_GET_INT(op1);
14203|  1.04M|            }
14204|  1.20M|            if (tag2 == JS_TAG_FLOAT64) {
14205|   543k|                d2 = JS_VALUE_GET_FLOAT64(op2);
14206|   665k|            } else {
14207|   665k|                d2 = JS_VALUE_GET_INT(op2);
14208|   665k|            }
14209|  1.20M|            switch(op) {
14210|   777k|            case OP_lt:
14211|   777k|                res = (d1 < d2); /* if NaN return false */
14212|   777k|                break;
14213|  1.04k|            case OP_lte:
14214|  1.04k|                res = (d1 <= d2); /* if NaN return false */
14215|  1.04k|                break;
14216|   379k|            case OP_gt:
14217|   379k|                res = (d1 > d2); /* if NaN return false */
14218|   379k|                break;
14219|      0|            default:
14220|  51.2k|            case OP_gte:
14221|  51.2k|                res = (d1 >= d2); /* if NaN return false */
14222|  51.2k|                break;
14223|  1.20M|            }
14224|  1.20M|        }
14225|  1.53M|    }
14226|  3.24M| done:
14227|  3.24M|    sp[-2] = JS_NewBool(ctx, res);
14228|  3.24M|    return 0;
14229|      5| exception:
14230|      5|    sp[-2] = JS_UNDEFINED;
14231|      5|    sp[-1] = JS_UNDEFINED;
14232|      5|    return -1;
14233|  3.24M|}
14234|       |
14235|       |static BOOL tag_is_number(uint32_t tag)
14236|  1.59M|{
14237|  1.59M|    return (tag == JS_TAG_INT || 
14238|  1.59M|            tag == JS_TAG_FLOAT64 ||
14239|  1.59M|            tag == JS_TAG_BIG_INT || tag == JS_TAG_SHORT_BIG_INT);
14240|  1.59M|}
14241|       |
14242|       |static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
14243|       |                                            BOOL is_neq)
14244|   753k|{
14245|   753k|    JSValue op1, op2;
14246|   753k|    int res;
14247|   753k|    uint32_t tag1, tag2;
14248|       |
14249|   753k|    op1 = sp[-2];
14250|   753k|    op2 = sp[-1];
14251|  1.05M| redo:
14252|  1.05M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
14253|  1.05M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
14254|  1.05M|    if (tag_is_number(tag1) && tag_is_number(tag2)) {
14255|   112k|        if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {
14256|  51.8k|            res = JS_VALUE_GET_INT(op1) == JS_VALUE_GET_INT(op2);
14257|  60.7k|        } else if ((tag1 == JS_TAG_FLOAT64 &&
14258|  60.7k|                    (tag2 == JS_TAG_INT || tag2 == JS_TAG_FLOAT64)) ||
14259|  60.7k|                   (tag2 == JS_TAG_FLOAT64 &&
14260|  56.5k|                    (tag1 == JS_TAG_INT || tag1 == JS_TAG_FLOAT64))) {
14261|  18.0k|            double d1, d2;
14262|  18.0k|            if (tag1 == JS_TAG_FLOAT64) {
14263|  4.14k|                d1 = JS_VALUE_GET_FLOAT64(op1);
14264|  13.9k|            } else {
14265|  13.9k|                d1 = JS_VALUE_GET_INT(op1);
14266|  13.9k|            }
14267|  18.0k|            if (tag2 == JS_TAG_FLOAT64) {
14268|  15.8k|                d2 = JS_VALUE_GET_FLOAT64(op2);
14269|  15.8k|            } else {
14270|  2.21k|                d2 = JS_VALUE_GET_INT(op2);
14271|  2.21k|            }
14272|  18.0k|            res = (d1 == d2);
14273|  42.6k|        } else {
14274|  42.6k|            res = js_compare_bigint(ctx, OP_eq, op1, op2);
14275|  42.6k|        }
14276|   940k|    } else if (tag1 == tag2) {
14277|   477k|        res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
14278|   477k|    } else if ((tag1 == JS_TAG_NULL && tag2 == JS_TAG_UNDEFINED) ||
14279|   463k|               (tag2 == JS_TAG_NULL && tag1 == JS_TAG_UNDEFINED)) {
14280|      0|        res = TRUE;
14281|   463k|    } else if (tag_is_string(tag1) && tag_is_string(tag2)) {
14282|       |        /* needed when comparing strings and ropes */
14283|  3.36k|        res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
14284|   460k|    } else if ((tag_is_string(tag1) && tag_is_number(tag2)) ||
14285|   460k|               (tag_is_string(tag2) && tag_is_number(tag1))) {
14286|       |
14287|   148k|        if (tag1 == JS_TAG_BIG_INT || tag1 == JS_TAG_SHORT_BIG_INT ||
14288|   148k|            tag2 == JS_TAG_BIG_INT || tag2 == JS_TAG_SHORT_BIG_INT) {
14289|  61.2k|            if (tag_is_string(tag1)) {
14290|  54.9k|                op1 = JS_StringToBigInt(ctx, op1);
14291|  54.9k|                if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT &&
14292|  54.9k|                    JS_VALUE_GET_TAG(op1) != JS_TAG_SHORT_BIG_INT)
14293|  54.9k|                    goto invalid_bigint_string;
14294|  54.9k|            }
14295|  6.28k|            if (tag_is_string(tag2)) {
14296|  6.26k|                op2 = JS_StringToBigInt(ctx, op2);
14297|  6.26k|                if (JS_VALUE_GET_TAG(op2) != JS_TAG_BIG_INT &&
14298|  6.26k|                    JS_VALUE_GET_TAG(op2) != JS_TAG_SHORT_BIG_INT ) {
14299|  61.2k|                invalid_bigint_string:
14300|  61.2k|                    JS_FreeValue(ctx, op1);
14301|  61.2k|                    JS_FreeValue(ctx, op2);
14302|  61.2k|                    res = FALSE;
14303|  61.2k|                    goto done;
14304|  6.26k|                }
14305|  6.26k|            }
14306|  87.4k|        } else {
14307|  87.4k|            op1 = JS_ToNumericFree(ctx, op1);
14308|  87.4k|            if (JS_IsException(op1)) {
14309|      0|                JS_FreeValue(ctx, op2);
14310|      0|                goto exception;
14311|      0|            }
14312|  87.4k|            op2 = JS_ToNumericFree(ctx, op2);
14313|  87.4k|            if (JS_IsException(op2)) {
14314|      0|                JS_FreeValue(ctx, op1);
14315|      0|                goto exception;
14316|      0|            }
14317|  87.4k|        }
14318|  87.4k|        res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
14319|   311k|    } else if (tag1 == JS_TAG_BOOL) {
14320|   149k|        op1 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op1));
14321|   149k|        goto redo;
14322|   161k|    } else if (tag2 == JS_TAG_BOOL) {
14323|  34.2k|        op2 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op2));
14324|  34.2k|        goto redo;
14325|   127k|    } else if ((tag1 == JS_TAG_OBJECT &&
14326|   127k|                (tag_is_number(tag2) || tag_is_string(tag2) || tag2 == JS_TAG_SYMBOL)) ||
14327|   127k|               (tag2 == JS_TAG_OBJECT &&
14328|   115k|                (tag_is_number(tag1) || tag_is_string(tag1) || tag1 == JS_TAG_SYMBOL))) {
14329|   115k|        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
14330|   115k|        if (JS_IsException(op1)) {
14331|      0|            JS_FreeValue(ctx, op2);
14332|      0|            goto exception;
14333|      0|        }
14334|   115k|        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);
14335|   115k|        if (JS_IsException(op2)) {
14336|      0|            JS_FreeValue(ctx, op1);
14337|      0|            goto exception;
14338|      0|        }
14339|   115k|        goto redo;
14340|   115k|    } else {
14341|       |        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */
14342|  11.6k|        if ((JS_IsHTMLDDA(ctx, op1) &&
14343|  11.6k|             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||
14344|  11.6k|            (JS_IsHTMLDDA(ctx, op2) &&
14345|  11.6k|             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {
14346|      0|            res = TRUE;
14347|  11.6k|        } else {
14348|  11.6k|            res = FALSE;
14349|  11.6k|        }
14350|  11.6k|        JS_FreeValue(ctx, op1);
14351|  11.6k|        JS_FreeValue(ctx, op2);
14352|  11.6k|    }
14353|   753k| done:
14354|   753k|    sp[-2] = JS_NewBool(ctx, res ^ is_neq);
14355|   753k|    return 0;
14356|      0| exception:
14357|      0|    sp[-2] = JS_UNDEFINED;
14358|      0|    sp[-1] = JS_UNDEFINED;
14359|      0|    return -1;
14360|  1.05M|}
14361|       |
14362|       |static no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)
14363|  67.0k|{
14364|  67.0k|    JSValue op1, op2;
14365|  67.0k|    uint32_t v1, v2, r;
14366|       |
14367|  67.0k|    op1 = sp[-2];
14368|  67.0k|    op2 = sp[-1];
14369|  67.0k|    op1 = JS_ToNumericFree(ctx, op1);
14370|  67.0k|    if (JS_IsException(op1)) {
14371|      0|        JS_FreeValue(ctx, op2);
14372|      0|        goto exception;
14373|      0|    }
14374|  67.0k|    op2 = JS_ToNumericFree(ctx, op2);
14375|  67.0k|    if (JS_IsException(op2)) {
14376|      0|        JS_FreeValue(ctx, op1);
14377|      0|        goto exception;
14378|      0|    }
14379|  67.0k|    if (JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT ||
14380|  67.0k|        JS_VALUE_GET_TAG(op1) == JS_TAG_SHORT_BIG_INT ||
14381|  67.0k|        JS_VALUE_GET_TAG(op2) == JS_TAG_BIG_INT ||
14382|  67.0k|        JS_VALUE_GET_TAG(op2) == JS_TAG_SHORT_BIG_INT) {
14383|      5|        JS_ThrowTypeError(ctx, "bigint operands are forbidden for >>>");
14384|      5|        JS_FreeValue(ctx, op1);
14385|      5|        JS_FreeValue(ctx, op2);
14386|      5|        goto exception;
14387|      5|    }
14388|       |    /* cannot give an exception */
14389|  67.0k|    JS_ToUint32Free(ctx, &v1, op1);
14390|  67.0k|    JS_ToUint32Free(ctx, &v2, op2);
14391|  67.0k|    r = v1 >> (v2 & 0x1f);
14392|  67.0k|    sp[-2] = JS_NewUint32(ctx, r);
14393|  67.0k|    return 0;
14394|      5| exception:
14395|      5|    sp[-2] = JS_UNDEFINED;
14396|      5|    sp[-1] = JS_UNDEFINED;
14397|      5|    return -1;
14398|  67.0k|}
14399|       |
14400|       |/* XXX: Should take JSValueConst arguments */
14401|       |static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
14402|       |                          JSStrictEqModeEnum eq_mode)
14403|  1.44M|{
14404|  1.44M|    BOOL res;
14405|  1.44M|    int tag1, tag2;
14406|  1.44M|    double d1, d2;
14407|       |
14408|  1.44M|    tag1 = JS_VALUE_GET_NORM_TAG(op1);
14409|  1.44M|    tag2 = JS_VALUE_GET_NORM_TAG(op2);
14410|  1.44M|    switch(tag1) {
14411|   470k|    case JS_TAG_BOOL:
14412|   470k|        if (tag1 != tag2) {
14413|  24.3k|            res = FALSE;
14414|   445k|        } else {
14415|   445k|            res = JS_VALUE_GET_INT(op1) == JS_VALUE_GET_INT(op2);
14416|   445k|            goto done_no_free;
14417|   445k|        }
14418|  24.3k|        break;
14419|  24.3k|    case JS_TAG_NULL:
14420|  34.5k|    case JS_TAG_UNDEFINED:
14421|  34.5k|        res = (tag1 == tag2);
14422|  34.5k|        break;
14423|  44.2k|    case JS_TAG_STRING:
14424|  48.8k|    case JS_TAG_STRING_ROPE:
14425|  48.8k|        {
14426|  48.8k|            if (!tag_is_string(tag2)) {
14427|  12.4k|                res = FALSE;
14428|  36.3k|            } else if (tag1 == JS_TAG_STRING && tag2 == JS_TAG_STRING) {
14429|  33.0k|                res = (js_string_compare(ctx, JS_VALUE_GET_STRING(op1),
14430|  33.0k|                                         JS_VALUE_GET_STRING(op2)) == 0);
14431|  33.0k|            } else {
14432|  3.36k|                res = (js_string_rope_compare(ctx, op1, op2, TRUE) == 0);
14433|  3.36k|            }
14434|  48.8k|        }
14435|  48.8k|        break;
14436|      0|    case JS_TAG_SYMBOL:
14437|      0|        {
14438|      0|            JSAtomStruct *p1, *p2;
14439|      0|            if (tag1 != tag2) {
14440|      0|                res = FALSE;
14441|      0|            } else {
14442|      0|                p1 = JS_VALUE_GET_PTR(op1);
14443|      0|                p2 = JS_VALUE_GET_PTR(op2);
14444|      0|                res = (p1 == p2);
14445|      0|            }
14446|      0|        }
14447|      0|        break;
14448|   794k|    case JS_TAG_OBJECT:
14449|   794k|        if (tag1 != tag2)
14450|  13.6k|            res = FALSE;
14451|   781k|        else
14452|   781k|            res = JS_VALUE_GET_OBJ(op1) == JS_VALUE_GET_OBJ(op2);
14453|   794k|        break;
14454|  45.7k|    case JS_TAG_INT:
14455|  45.7k|        d1 = JS_VALUE_GET_INT(op1);
14456|  45.7k|        if (tag2 == JS_TAG_INT) {
14457|     46|            d2 = JS_VALUE_GET_INT(op2);
14458|     46|            goto number_test;
14459|  45.7k|        } else if (tag2 == JS_TAG_FLOAT64) {
14460|  44.6k|            d2 = JS_VALUE_GET_FLOAT64(op2);
14461|  44.6k|            goto number_test;
14462|  44.6k|        } else {
14463|  1.09k|            res = FALSE;
14464|  1.09k|        }
14465|  1.09k|        break;
14466|  45.9k|    case JS_TAG_FLOAT64:
14467|  45.9k|        d1 = JS_VALUE_GET_FLOAT64(op1);
14468|  45.9k|        if (tag2 == JS_TAG_FLOAT64) {
14469|  12.9k|            d2 = JS_VALUE_GET_FLOAT64(op2);
14470|  32.9k|        } else if (tag2 == JS_TAG_INT) {
14471|  30.7k|            d2 = JS_VALUE_GET_INT(op2);
14472|  30.7k|        } else {
14473|  2.25k|            res = FALSE;
14474|  2.25k|            break;
14475|  2.25k|        }
14476|  88.4k|    number_test:
14477|  88.4k|        if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {
14478|      0|            JSFloat64Union u1, u2;
14479|       |            /* NaN is not always normalized, so this test is necessary */
14480|      0|            if (isnan(d1) || isnan(d2)) {
14481|      0|                res = isnan(d1) == isnan(d2);
14482|      0|            } else if (eq_mode == JS_EQ_SAME_VALUE_ZERO) {
14483|      0|                res = (d1 == d2); /* +0 == -0 */
14484|      0|            } else {
14485|      0|                u1.d = d1;
14486|      0|                u2.d = d2;
14487|      0|                res = (u1.u64 == u2.u64); /* +0 != -0 */
14488|      0|            }
14489|  88.4k|        } else {
14490|  88.4k|            res = (d1 == d2); /* if NaN return false and +0 == -0 */
14491|  88.4k|        }
14492|  88.4k|        goto done_no_free;
14493|  2.78k|    case JS_TAG_SHORT_BIG_INT:
14494|  4.28k|    case JS_TAG_BIG_INT:
14495|  4.28k|        {
14496|  4.28k|            JSBigIntBuf buf1, buf2;
14497|  4.28k|            JSBigInt *p1, *p2;
14498|       |
14499|  4.28k|            if (tag2 != JS_TAG_SHORT_BIG_INT &&
14500|  4.28k|                tag2 != JS_TAG_BIG_INT) {
14501|  2.11k|                res = FALSE;
14502|  2.11k|                break;
14503|  2.11k|            }
14504|       |            
14505|  2.16k|            if (JS_VALUE_GET_TAG(op1) == JS_TAG_SHORT_BIG_INT)
14506|  1.46k|                p1 = js_bigint_set_short(&buf1, op1);
14507|    704|            else
14508|    704|                p1 = JS_VALUE_GET_PTR(op1);
14509|  2.16k|            if (JS_VALUE_GET_TAG(op2) == JS_TAG_SHORT_BIG_INT)
14510|  1.70k|                p2 = js_bigint_set_short(&buf2, op2);
14511|    466|            else
14512|    466|                p2 = JS_VALUE_GET_PTR(op2);
14513|  2.16k|            res = (js_bigint_cmp(ctx, p1, p2) == 0);
14514|  2.16k|        }
14515|      0|        break;
14516|      0|    default:
14517|      0|        res = FALSE;
14518|      0|        break;
14519|  1.44M|    }
14520|   910k|    JS_FreeValue(ctx, op1);
14521|   910k|    JS_FreeValue(ctx, op2);
14522|  1.44M| done_no_free:
14523|  1.44M|    return res;
14524|   910k|}
14525|       |
14526|       |static BOOL js_strict_eq(JSContext *ctx, JSValueConst op1, JSValueConst op2)
14527|      0|{
14528|      0|    return js_strict_eq2(ctx,
14529|      0|                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),
14530|      0|                         JS_EQ_STRICT);
14531|      0|}
14532|       |
14533|       |BOOL JS_StrictEq(JSContext *ctx, JSValueConst op1, JSValueConst op2)
14534|      0|{
14535|      0|    return js_strict_eq(ctx, op1, op2);
14536|      0|}
14537|       |
14538|       |static BOOL js_same_value(JSContext *ctx, JSValueConst op1, JSValueConst op2)
14539|   780k|{
14540|   780k|    return js_strict_eq2(ctx,
14541|   780k|                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),
14542|   780k|                         JS_EQ_SAME_VALUE);
14543|   780k|}
14544|       |
14545|       |BOOL JS_SameValue(JSContext *ctx, JSValueConst op1, JSValueConst op2)
14546|      0|{
14547|      0|    return js_same_value(ctx, op1, op2);
14548|      0|}
14549|       |
14550|       |static BOOL js_same_value_zero(JSContext *ctx, JSValueConst op1, JSValueConst op2)
14551|      0|{
14552|      0|    return js_strict_eq2(ctx,
14553|      0|                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),
14554|      0|                         JS_EQ_SAME_VALUE_ZERO);
14555|      0|}
14556|       |
14557|       |BOOL JS_SameValueZero(JSContext *ctx, JSValueConst op1, JSValueConst op2)
14558|      0|{
14559|      0|    return js_same_value_zero(ctx, op1, op2);
14560|      0|}
14561|       |
14562|       |static no_inline int js_strict_eq_slow(JSContext *ctx, JSValue *sp,
14563|       |                                       BOOL is_neq)
14564|  95.0k|{
14565|  95.0k|    BOOL res;
14566|  95.0k|    res = js_strict_eq2(ctx, sp[-2], sp[-1], JS_EQ_STRICT);
14567|  95.0k|    sp[-2] = JS_NewBool(ctx, res ^ is_neq);
14568|  95.0k|    return 0;
14569|  95.0k|}
14570|       |
14571|       |static __exception int js_operator_in(JSContext *ctx, JSValue *sp)
14572|   140k|{
14573|   140k|    JSValue op1, op2;
14574|   140k|    JSAtom atom;
14575|   140k|    int ret;
14576|       |
14577|   140k|    op1 = sp[-2];
14578|   140k|    op2 = sp[-1];
14579|       |
14580|   140k|    if (JS_VALUE_GET_TAG(op2) != JS_TAG_OBJECT) {
14581|      6|        JS_ThrowTypeError(ctx, "invalid 'in' operand");
14582|      6|        return -1;
14583|      6|    }
14584|   140k|    atom = JS_ValueToAtom(ctx, op1);
14585|   140k|    if (unlikely(atom == JS_ATOM_NULL))
14586|      0|        return -1;
14587|   140k|    ret = JS_HasProperty(ctx, op2, atom);
14588|   140k|    JS_FreeAtom(ctx, atom);
14589|   140k|    if (ret < 0)
14590|      0|        return -1;
14591|   140k|    JS_FreeValue(ctx, op1);
14592|   140k|    JS_FreeValue(ctx, op2);
14593|   140k|    sp[-2] = JS_NewBool(ctx, ret);
14594|   140k|    return 0;
14595|   140k|}
14596|       |
14597|       |static __exception int js_operator_private_in(JSContext *ctx, JSValue *sp)
14598|      0|{
14599|      0|    JSValue op1, op2;
14600|      0|    int ret;
14601|       |
14602|      0|    op1 = sp[-2]; /* object */
14603|      0|    op2 = sp[-1]; /* field name or method function */
14604|       |
14605|      0|    if (JS_VALUE_GET_TAG(op1) != JS_TAG_OBJECT) {
14606|      0|        JS_ThrowTypeError(ctx, "invalid 'in' operand");
14607|      0|        return -1;
14608|      0|    }
14609|      0|    if (JS_IsObject(op2)) {
14610|       |        /* method: use the brand */
14611|      0|        ret = JS_CheckBrand(ctx, op1, op2);
14612|      0|        if (ret < 0)
14613|      0|            return -1;
14614|      0|    } else {
14615|      0|        JSAtom atom;
14616|      0|        JSObject *p;
14617|      0|        JSShapeProperty *prs;
14618|      0|        JSProperty *pr;
14619|       |        /* field */
14620|      0|        atom = JS_ValueToAtom(ctx, op2);
14621|      0|        if (unlikely(atom == JS_ATOM_NULL))
14622|      0|            return -1;
14623|      0|        p = JS_VALUE_GET_OBJ(op1);
14624|      0|        prs = find_own_property(&pr, p, atom);
14625|      0|        JS_FreeAtom(ctx, atom);
14626|      0|        ret = (prs != NULL);
14627|      0|    }
14628|      0|    JS_FreeValue(ctx, op1);
14629|      0|    JS_FreeValue(ctx, op2);
14630|      0|    sp[-2] = JS_NewBool(ctx, ret);
14631|      0|    return 0;
14632|      0|}
14633|       |
14634|       |static __exception int js_has_unscopable(JSContext *ctx, JSValueConst obj,
14635|       |                                         JSAtom atom)
14636|      0|{
14637|      0|    JSValue arr, val;
14638|      0|    int ret;
14639|       |
14640|      0|    arr = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_unscopables);
14641|      0|    if (JS_IsException(arr))
14642|      0|        return -1;
14643|      0|    ret = 0;
14644|      0|    if (JS_IsObject(arr)) {
14645|      0|        val = JS_GetProperty(ctx, arr, atom);
14646|      0|        ret = JS_ToBoolFree(ctx, val);
14647|      0|    }
14648|      0|    JS_FreeValue(ctx, arr);
14649|      0|    return ret;
14650|      0|}
14651|       |
14652|       |static __exception int js_operator_instanceof(JSContext *ctx, JSValue *sp)
14653|      0|{
14654|      0|    JSValue op1, op2;
14655|      0|    BOOL ret;
14656|       |
14657|      0|    op1 = sp[-2];
14658|      0|    op2 = sp[-1];
14659|      0|    ret = JS_IsInstanceOf(ctx, op1, op2);
14660|      0|    if (ret < 0)
14661|      0|        return ret;
14662|      0|    JS_FreeValue(ctx, op1);
14663|      0|    JS_FreeValue(ctx, op2);
14664|      0|    sp[-2] = JS_NewBool(ctx, ret);
14665|      0|    return 0;
14666|      0|}
14667|       |
14668|       |static __exception int js_operator_typeof(JSContext *ctx, JSValueConst op1)
14669|      0|{
14670|      0|    JSAtom atom;
14671|      0|    uint32_t tag;
14672|       |
14673|      0|    tag = JS_VALUE_GET_NORM_TAG(op1);
14674|      0|    switch(tag) {
14675|      0|    case JS_TAG_SHORT_BIG_INT:
14676|      0|    case JS_TAG_BIG_INT:
14677|      0|        atom = JS_ATOM_bigint;
14678|      0|        break;
14679|      0|    case JS_TAG_INT:
14680|      0|    case JS_TAG_FLOAT64:
14681|      0|        atom = JS_ATOM_number;
14682|      0|        break;
14683|      0|    case JS_TAG_UNDEFINED:
14684|      0|        atom = JS_ATOM_undefined;
14685|      0|        break;
14686|      0|    case JS_TAG_BOOL:
14687|      0|        atom = JS_ATOM_boolean;
14688|      0|        break;
14689|      0|    case JS_TAG_STRING:
14690|      0|    case JS_TAG_STRING_ROPE:
14691|      0|        atom = JS_ATOM_string;
14692|      0|        break;
14693|      0|    case JS_TAG_OBJECT:
14694|      0|        {
14695|      0|            JSObject *p;
14696|      0|            p = JS_VALUE_GET_OBJ(op1);
14697|      0|            if (unlikely(p->is_HTMLDDA))
14698|      0|                atom = JS_ATOM_undefined;
14699|      0|            else if (JS_IsFunction(ctx, op1))
14700|      0|                atom = JS_ATOM_function;
14701|      0|            else
14702|      0|                goto obj_type;
14703|      0|        }
14704|      0|        break;
14705|      0|    case JS_TAG_NULL:
14706|      0|    obj_type:
14707|      0|        atom = JS_ATOM_object;
14708|      0|        break;
14709|      0|    case JS_TAG_SYMBOL:
14710|      0|        atom = JS_ATOM_symbol;
14711|      0|        break;
14712|      0|    default:
14713|      0|        atom = JS_ATOM_unknown;
14714|      0|        break;
14715|      0|    }
14716|      0|    return atom;
14717|      0|}
14718|       |
14719|       |static __exception int js_operator_delete(JSContext *ctx, JSValue *sp)
14720|      0|{
14721|      0|    JSValue op1, op2;
14722|      0|    JSAtom atom;
14723|      0|    int ret;
14724|       |
14725|      0|    op1 = sp[-2];
14726|      0|    op2 = sp[-1];
14727|      0|    atom = JS_ValueToAtom(ctx, op2);
14728|      0|    if (unlikely(atom == JS_ATOM_NULL))
14729|      0|        return -1;
14730|      0|    ret = JS_DeleteProperty(ctx, op1, atom, JS_PROP_THROW_STRICT);
14731|      0|    JS_FreeAtom(ctx, atom);
14732|      0|    if (unlikely(ret < 0))
14733|      0|        return -1;
14734|      0|    JS_FreeValue(ctx, op1);
14735|      0|    JS_FreeValue(ctx, op2);
14736|      0|    sp[-2] = JS_NewBool(ctx, ret);
14737|      0|    return 0;
14738|      0|}
14739|       |
14740|       |/* XXX: not 100% compatible, but mozilla seems to use a similar
14741|       |   implementation to ensure that caller in non strict mode does not
14742|       |   throw (ES5 compatibility) */
14743|       |static JSValue js_throw_type_error(JSContext *ctx, JSValueConst this_val,
14744|       |                                   int argc, JSValueConst *argv)
14745|      0|{
14746|      0|    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);
14747|      0|    if (!b || (b->js_mode & JS_MODE_STRICT) || !b->has_prototype || argc >= 1) {
14748|      0|        return JS_ThrowTypeError(ctx, "invalid property access");
14749|      0|    }
14750|      0|    return JS_UNDEFINED;
14751|      0|}
14752|       |
14753|       |static JSValue js_function_proto_fileName(JSContext *ctx,
14754|       |                                          JSValueConst this_val)
14755|      0|{
14756|      0|    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);
14757|      0|    if (b && b->has_debug) {
14758|      0|        return JS_AtomToString(ctx, b->debug.filename);
14759|      0|    }
14760|      0|    return JS_UNDEFINED;
14761|      0|}
14762|       |
14763|       |static JSValue js_function_proto_lineNumber(JSContext *ctx,
14764|       |                                            JSValueConst this_val, int is_col)
14765|      0|{
14766|      0|    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);
14767|      0|    if (b && b->has_debug) {
14768|      0|        int line_num, col_num;
14769|      0|        line_num = find_line_num(ctx, b, -1, &col_num);
14770|      0|        if (is_col)
14771|      0|            return JS_NewInt32(ctx, col_num);
14772|      0|        else
14773|      0|            return JS_NewInt32(ctx, line_num);
14774|      0|    }
14775|      0|    return JS_UNDEFINED;
14776|      0|}
14777|       |
14778|       |static int js_arguments_define_own_property(JSContext *ctx,
14779|       |                                            JSValueConst this_obj,
14780|       |                                            JSAtom prop, JSValueConst val,
14781|       |                                            JSValueConst getter, JSValueConst setter, int flags)
14782|      0|{
14783|      0|    JSObject *p;
14784|      0|    uint32_t idx;
14785|      0|    p = JS_VALUE_GET_OBJ(this_obj);
14786|       |    /* convert to normal array when redefining an existing numeric field */
14787|      0|    if (p->fast_array && JS_AtomIsArrayIndex(ctx, &idx, prop) &&
14788|      0|        idx < p->u.array.count) {
14789|      0|        if (convert_fast_array_to_array(ctx, p))
14790|      0|            return -1;
14791|      0|    }
14792|       |    /* run the default define own property */
14793|      0|    return JS_DefineProperty(ctx, this_obj, prop, val, getter, setter,
14794|      0|                             flags | JS_PROP_NO_EXOTIC);
14795|      0|}
14796|       |
14797|       |static const JSClassExoticMethods js_arguments_exotic_methods = {
14798|       |    .define_own_property = js_arguments_define_own_property,
14799|       |};
14800|       |
14801|       |static JSValue js_build_arguments(JSContext *ctx, int argc, JSValueConst *argv)
14802|      0|{
14803|      0|    JSValue val, *tab;
14804|      0|    JSProperty *pr;
14805|      0|    JSObject *p;
14806|      0|    int i;
14807|       |
14808|      0|    val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
14809|      0|                                 JS_CLASS_ARGUMENTS);
14810|      0|    if (JS_IsException(val))
14811|      0|        return val;
14812|      0|    p = JS_VALUE_GET_OBJ(val);
14813|       |
14814|       |    /* add the length field (cannot fail) */
14815|      0|    pr = add_property(ctx, p, JS_ATOM_length,
14816|      0|                      JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
14817|      0|    if (unlikely(!pr))
14818|      0|        goto fail;
14819|      0|    pr->u.value = JS_NewInt32(ctx, argc);
14820|       |
14821|       |    /* initialize the fast array part */
14822|      0|    tab = NULL;
14823|      0|    if (argc > 0) {
14824|      0|        tab = js_malloc(ctx, sizeof(tab[0]) * argc);
14825|      0|        if (!tab)
14826|      0|            goto fail;
14827|      0|        for(i = 0; i < argc; i++) {
14828|      0|            tab[i] = JS_DupValue(ctx, argv[i]);
14829|      0|        }
14830|      0|    }
14831|      0|    p->u.array.u.values = tab;
14832|      0|    p->u.array.count = argc;
14833|       |
14834|      0|    JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,
14835|      0|                           JS_DupValue(ctx, ctx->array_proto_values),
14836|      0|                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
14837|       |    /* add callee property to throw a TypeError in strict mode */
14838|      0|    JS_DefineProperty(ctx, val, JS_ATOM_callee, JS_UNDEFINED,
14839|      0|                      ctx->throw_type_error, ctx->throw_type_error,
14840|      0|                      JS_PROP_HAS_GET | JS_PROP_HAS_SET);
14841|      0|    return val;
14842|      0| fail:
14843|      0|    JS_FreeValue(ctx, val);
14844|      0|    return JS_EXCEPTION;
14845|      0|}
14846|       |
14847|  23.7k|#define GLOBAL_VAR_OFFSET 0x40000000
14848|   405k|#define ARGUMENT_VAR_OFFSET 0x20000000
14849|       |
14850|       |/* legacy arguments object: add references to the function arguments */
14851|       |static JSValue js_build_mapped_arguments(JSContext *ctx, int argc,
14852|       |                                         JSValueConst *argv,
14853|       |                                         JSStackFrame *sf, int arg_count)
14854|      0|{
14855|      0|    JSValue val;
14856|      0|    JSProperty *pr;
14857|      0|    JSObject *p;
14858|      0|    int i;
14859|       |
14860|      0|    val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
14861|      0|                                 JS_CLASS_MAPPED_ARGUMENTS);
14862|      0|    if (JS_IsException(val))
14863|      0|        return val;
14864|      0|    p = JS_VALUE_GET_OBJ(val);
14865|       |
14866|       |    /* add the length field (cannot fail) */
14867|      0|    pr = add_property(ctx, p, JS_ATOM_length,
14868|      0|                      JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
14869|      0|    if (unlikely(!pr))
14870|      0|        goto fail;
14871|      0|    pr->u.value = JS_NewInt32(ctx, argc);
14872|       |
14873|      0|    for(i = 0; i < arg_count; i++) {
14874|      0|        JSVarRef *var_ref;
14875|      0|        var_ref = get_var_ref(ctx, sf, i, TRUE);
14876|      0|        if (!var_ref)
14877|      0|            goto fail;
14878|      0|        pr = add_property(ctx, p, __JS_AtomFromUInt32(i), JS_PROP_C_W_E | JS_PROP_VARREF);
14879|      0|        if (!pr) {
14880|      0|            free_var_ref(ctx->rt, var_ref);
14881|      0|            goto fail;
14882|      0|        }
14883|      0|        pr->u.var_ref = var_ref;
14884|      0|    }
14885|       |
14886|       |    /* the arguments not mapped to the arguments of the function can
14887|       |       be normal properties */
14888|      0|    for(i = arg_count; i < argc; i++) {
14889|      0|        if (JS_DefinePropertyValueUint32(ctx, val, i,
14890|      0|                                         JS_DupValue(ctx, argv[i]),
14891|      0|                                         JS_PROP_C_W_E) < 0)
14892|      0|            goto fail;
14893|      0|    }
14894|       |
14895|      0|    JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,
14896|      0|                           JS_DupValue(ctx, ctx->array_proto_values),
14897|      0|                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
14898|       |    /* callee returns this function in non strict mode */
14899|      0|    JS_DefinePropertyValue(ctx, val, JS_ATOM_callee,
14900|      0|                           JS_DupValue(ctx, ctx->rt->current_stack_frame->cur_func),
14901|      0|                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
14902|      0|    return val;
14903|      0| fail:
14904|      0|    JS_FreeValue(ctx, val);
14905|      0|    return JS_EXCEPTION;
14906|      0|}
14907|       |
14908|       |static JSValue js_build_rest(JSContext *ctx, int first, int argc, JSValueConst *argv)
14909|      0|{
14910|      0|    JSValue val;
14911|      0|    int i, ret;
14912|       |
14913|      0|    val = JS_NewArray(ctx);
14914|      0|    if (JS_IsException(val))
14915|      0|        return val;
14916|      0|    for (i = first; i < argc; i++) {
14917|      0|        ret = JS_DefinePropertyValueUint32(ctx, val, i - first,
14918|      0|                                           JS_DupValue(ctx, argv[i]),
14919|      0|                                           JS_PROP_C_W_E);
14920|      0|        if (ret < 0) {
14921|      0|            JS_FreeValue(ctx, val);
14922|      0|            return JS_EXCEPTION;
14923|      0|        }
14924|      0|    }
14925|      0|    return val;
14926|      0|}
14927|       |
14928|       |static JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)
14929|  1.87M|{
14930|  1.87M|    JSObject *p, *p1;
14931|  1.87M|    JSPropertyEnum *tab_atom;
14932|  1.87M|    int i;
14933|  1.87M|    JSValue enum_obj;
14934|  1.87M|    JSForInIterator *it;
14935|  1.87M|    uint32_t tag, tab_atom_count;
14936|       |
14937|  1.87M|    tag = JS_VALUE_GET_TAG(obj);
14938|  1.87M|    if (tag != JS_TAG_OBJECT && tag != JS_TAG_NULL && tag != JS_TAG_UNDEFINED) {
14939|  1.86M|        obj = JS_ToObjectFree(ctx, obj);
14940|  1.86M|    }
14941|       |
14942|  1.87M|    it = js_malloc(ctx, sizeof(*it));
14943|  1.87M|    if (!it) {
14944|      0|        JS_FreeValue(ctx, obj);
14945|      0|        return JS_EXCEPTION;
14946|      0|    }
14947|  1.87M|    enum_obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_FOR_IN_ITERATOR);
14948|  1.87M|    if (JS_IsException(enum_obj)) {
14949|      0|        js_free(ctx, it);
14950|      0|        JS_FreeValue(ctx, obj);
14951|      0|        return JS_EXCEPTION;
14952|      0|    }
14953|  1.87M|    it->is_array = FALSE;
14954|  1.87M|    it->obj = obj;
14955|  1.87M|    it->idx = 0;
14956|  1.87M|    it->tab_atom = NULL;
14957|  1.87M|    it->atom_count = 0;
14958|  1.87M|    it->in_prototype_chain = FALSE;
14959|  1.87M|    p1 = JS_VALUE_GET_OBJ(enum_obj);
14960|  1.87M|    p1->u.for_in_iterator = it;
14961|       |
14962|  1.87M|    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)
14963|  2.88k|        return enum_obj;
14964|       |
14965|  1.87M|    p = JS_VALUE_GET_OBJ(obj);
14966|  1.87M|    if (p->fast_array) {
14967|      0|        JSShape *sh;
14968|      0|        JSShapeProperty *prs;
14969|       |        /* check that there are no enumerable normal fields */
14970|      0|        sh = p->shape;
14971|      0|        for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
14972|      0|            if (prs->flags & JS_PROP_ENUMERABLE)
14973|      0|                goto normal_case;
14974|      0|        }
14975|       |        /* for fast arrays, we only store the number of elements */
14976|      0|        it->is_array = TRUE;
14977|      0|        it->atom_count = p->u.array.count;
14978|  1.87M|    } else {
14979|  1.87M|    normal_case:
14980|  1.87M|        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
14981|  1.87M|                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
14982|      0|            JS_FreeValue(ctx, enum_obj);
14983|      0|            return JS_EXCEPTION;
14984|      0|        }
14985|  1.87M|        it->tab_atom = tab_atom;
14986|  1.87M|        it->atom_count = tab_atom_count;
14987|  1.87M|    }
14988|  1.87M|    return enum_obj;
14989|  1.87M|}
14990|       |
14991|       |/* obj -> enum_obj */
14992|       |static __exception int js_for_in_start(JSContext *ctx, JSValue *sp)
14993|  1.87M|{
14994|  1.87M|    sp[-1] = build_for_in_iterator(ctx, sp[-1]);
14995|  1.87M|    if (JS_IsException(sp[-1]))
14996|      0|        return -1;
14997|  1.87M|    return 0;
14998|  1.87M|}
14999|       |
15000|       |/* return -1 if exception, 0 if slow case, 1 if the enumeration is finished */
15001|       |static __exception int js_for_in_prepare_prototype_chain_enum(JSContext *ctx,
15002|       |                                                              JSValueConst enum_obj)
15003|  1.87M|{
15004|  1.87M|    JSObject *p;
15005|  1.87M|    JSForInIterator *it;
15006|  1.87M|    JSPropertyEnum *tab_atom;
15007|  1.87M|    uint32_t tab_atom_count, i;
15008|  1.87M|    JSValue obj1;
15009|       |
15010|  1.87M|    p = JS_VALUE_GET_OBJ(enum_obj);
15011|  1.87M|    it = p->u.for_in_iterator;
15012|       |
15013|       |    /* check if there are enumerable properties in the prototype chain (fast path) */
15014|  1.87M|    obj1 = JS_DupValue(ctx, it->obj);
15015|  5.61M|    for(;;) {
15016|  5.61M|        obj1 = JS_GetPrototypeFree(ctx, obj1);
15017|  5.61M|        if (JS_IsNull(obj1))
15018|  1.87M|            break;
15019|  3.74M|        if (JS_IsException(obj1))
15020|      0|            goto fail;
15021|  3.74M|        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
15022|  3.74M|                                           JS_VALUE_GET_OBJ(obj1),
15023|  3.74M|                                           JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY)) {
15024|      0|            JS_FreeValue(ctx, obj1);
15025|      0|            goto fail;
15026|      0|        }
15027|  3.74M|        js_free_prop_enum(ctx, tab_atom, tab_atom_count);
15028|  3.74M|        if (tab_atom_count != 0) {
15029|      0|            JS_FreeValue(ctx, obj1);
15030|      0|            goto slow_path;
15031|      0|        }
15032|       |        /* must check for timeout to avoid infinite loop */
15033|  3.74M|        if (js_poll_interrupts(ctx)) {
15034|      0|            JS_FreeValue(ctx, obj1);
15035|      0|            goto fail;
15036|      0|        }
15037|  3.74M|    }
15038|  1.87M|    JS_FreeValue(ctx, obj1);
15039|  1.87M|    return 1;
15040|       |
15041|      0| slow_path:
15042|       |    /* add the visited properties, even if they are not enumerable */
15043|      0|    if (it->is_array) {
15044|      0|        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
15045|      0|                                           JS_VALUE_GET_OBJ(it->obj),
15046|      0|                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
15047|      0|            goto fail;
15048|      0|        }
15049|      0|        it->is_array = FALSE;
15050|      0|        it->tab_atom = tab_atom;
15051|      0|        it->atom_count = tab_atom_count;
15052|      0|    }
15053|       |
15054|      0|    for(i = 0; i < it->atom_count; i++) {
15055|      0|        if (JS_DefinePropertyValue(ctx, enum_obj, it->tab_atom[i].atom, JS_NULL, JS_PROP_ENUMERABLE) < 0)
15056|      0|            goto fail;
15057|      0|    }
15058|      0|    return 0;
15059|      0| fail:
15060|      0|    return -1;
15061|      0|}
15062|       |
15063|       |/* enum_obj -> enum_obj value done */
15064|       |static __exception int js_for_in_next(JSContext *ctx, JSValue *sp)
15065|  6.76M|{
15066|  6.76M|    JSValueConst enum_obj;
15067|  6.76M|    JSObject *p;
15068|  6.76M|    JSAtom prop;
15069|  6.76M|    JSForInIterator *it;
15070|  6.76M|    JSPropertyEnum *tab_atom;
15071|  6.76M|    uint32_t tab_atom_count;
15072|  6.76M|    int ret;
15073|       |
15074|  6.76M|    enum_obj = sp[-1];
15075|       |    /* fail safe */
15076|  6.76M|    if (JS_VALUE_GET_TAG(enum_obj) != JS_TAG_OBJECT)
15077|      0|        goto done;
15078|  6.76M|    p = JS_VALUE_GET_OBJ(enum_obj);
15079|  6.76M|    if (p->class_id != JS_CLASS_FOR_IN_ITERATOR)
15080|      0|        goto done;
15081|  6.76M|    it = p->u.for_in_iterator;
15082|       |
15083|  6.97M|    for(;;) {
15084|  6.97M|        if (it->idx >= it->atom_count) {
15085|  1.87M|            if (JS_IsNull(it->obj) || JS_IsUndefined(it->obj))
15086|  2.88k|                goto done; /* not an object */
15087|       |            /* no more property in the current object: look in the prototype */
15088|  1.87M|            if (!it->in_prototype_chain) {
15089|  1.87M|                ret = js_for_in_prepare_prototype_chain_enum(ctx, enum_obj);
15090|  1.87M|                if (ret < 0)
15091|      0|                    return -1;
15092|  1.87M|                if (ret)
15093|  1.87M|                    goto done;
15094|      0|                it->in_prototype_chain = TRUE;
15095|      0|            }
15096|      0|            it->obj = JS_GetPrototypeFree(ctx, it->obj);
15097|      0|            if (JS_IsException(it->obj))
15098|      0|                return -1;
15099|      0|            if (JS_IsNull(it->obj))
15100|      0|                goto done; /* no more prototype */
15101|       |
15102|       |            /* must check for timeout to avoid infinite loop */
15103|      0|            if (js_poll_interrupts(ctx))
15104|      0|                return -1;
15105|       |
15106|      0|            if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
15107|      0|                                               JS_VALUE_GET_OBJ(it->obj),
15108|      0|                                               JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
15109|      0|                return -1;
15110|      0|            }
15111|      0|            js_free_prop_enum(ctx, it->tab_atom, it->atom_count);
15112|      0|            it->tab_atom = tab_atom;
15113|      0|            it->atom_count = tab_atom_count;
15114|      0|            it->idx = 0;
15115|  5.10M|        } else {
15116|  5.10M|            if (it->is_array) {
15117|      0|                prop = __JS_AtomFromUInt32(it->idx);
15118|      0|                it->idx++;
15119|  5.10M|            } else {
15120|  5.10M|                BOOL is_enumerable;
15121|  5.10M|                prop = it->tab_atom[it->idx].atom;
15122|  5.10M|                is_enumerable = it->tab_atom[it->idx].is_enumerable;
15123|  5.10M|                it->idx++;
15124|  5.10M|                if (it->in_prototype_chain) {
15125|       |                    /* slow case: we are in the prototype chain */
15126|      0|                    ret = JS_GetOwnPropertyInternal(ctx, NULL, JS_VALUE_GET_OBJ(enum_obj), prop);
15127|      0|                    if (ret < 0)
15128|      0|                        return ret;
15129|      0|                    if (ret)
15130|      0|                        continue; /* already visited */
15131|       |                    /* add to the visited property list */
15132|      0|                    if (JS_DefinePropertyValue(ctx, enum_obj, prop, JS_NULL,
15133|      0|                                               JS_PROP_ENUMERABLE) < 0)
15134|      0|                        return -1;
15135|      0|                }
15136|  5.10M|                if (!is_enumerable)
15137|   204k|                    continue;
15138|  5.10M|            }
15139|       |            /* check if the property was deleted */
15140|  4.89M|            ret = JS_GetOwnPropertyInternal(ctx, NULL, JS_VALUE_GET_OBJ(it->obj), prop);
15141|  4.89M|            if (ret < 0)
15142|      0|                return ret;
15143|  4.89M|            if (ret)
15144|  4.89M|                break;
15145|  4.89M|        }
15146|  6.97M|    }
15147|       |    /* return the property */
15148|  4.89M|    sp[0] = JS_AtomToValue(ctx, prop);
15149|  4.89M|    sp[1] = JS_FALSE;
15150|  4.89M|    return 0;
15151|  1.87M| done:
15152|       |    /* return the end */
15153|  1.87M|    sp[0] = JS_UNDEFINED;
15154|  1.87M|    sp[1] = JS_TRUE;
15155|  1.87M|    return 0;
15156|  6.76M|}
15157|       |
15158|       |static JSValue JS_GetIterator2(JSContext *ctx, JSValueConst obj,
15159|       |                               JSValueConst method)
15160|  7.47k|{
15161|  7.47k|    JSValue enum_obj;
15162|       |
15163|  7.47k|    enum_obj = JS_Call(ctx, method, obj, 0, NULL);
15164|  7.47k|    if (JS_IsException(enum_obj))
15165|      0|        return enum_obj;
15166|  7.47k|    if (!JS_IsObject(enum_obj)) {
15167|      0|        JS_FreeValue(ctx, enum_obj);
15168|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
15169|      0|    }
15170|  7.47k|    return enum_obj;
15171|  7.47k|}
15172|       |
15173|       |static JSValue JS_GetIterator(JSContext *ctx, JSValueConst obj, BOOL is_async)
15174|  7.52k|{
15175|  7.52k|    JSValue method, ret, sync_iter;
15176|       |
15177|  7.52k|    if (is_async) {
15178|      0|        method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_asyncIterator);
15179|      0|        if (JS_IsException(method))
15180|      0|            return method;
15181|      0|        if (JS_IsUndefined(method) || JS_IsNull(method)) {
15182|      0|            method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);
15183|      0|            if (JS_IsException(method))
15184|      0|                return method;
15185|      0|            sync_iter = JS_GetIterator2(ctx, obj, method);
15186|      0|            JS_FreeValue(ctx, method);
15187|      0|            if (JS_IsException(sync_iter))
15188|      0|                return sync_iter;
15189|      0|            ret = JS_CreateAsyncFromSyncIterator(ctx, sync_iter);
15190|      0|            JS_FreeValue(ctx, sync_iter);
15191|      0|            return ret;
15192|      0|        }
15193|  7.52k|    } else {
15194|  7.52k|        method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);
15195|  7.52k|        if (JS_IsException(method))
15196|      7|            return method;
15197|  7.52k|    }
15198|  7.51k|    if (!JS_IsFunction(ctx, method)) {
15199|     42|        JS_FreeValue(ctx, method);
15200|     42|        return JS_ThrowTypeError(ctx, "value is not iterable");
15201|     42|    }
15202|  7.47k|    ret = JS_GetIterator2(ctx, obj, method);
15203|  7.47k|    JS_FreeValue(ctx, method);
15204|  7.47k|    return ret;
15205|  7.51k|}
15206|       |
15207|       |/* return *pdone = 2 if the iterator object is not parsed */
15208|       |static JSValue JS_IteratorNext2(JSContext *ctx, JSValueConst enum_obj,
15209|       |                                JSValueConst method,
15210|       |                                int argc, JSValueConst *argv, int *pdone)
15211|  8.44k|{
15212|  8.44k|    JSValue obj;
15213|       |
15214|       |    /* fast path for the built-in iterators (avoid creating the
15215|       |       intermediate result object) */
15216|  8.44k|    if (JS_IsObject(method)) {
15217|  8.44k|        JSObject *p = JS_VALUE_GET_OBJ(method);
15218|  8.44k|        if (p->class_id == JS_CLASS_C_FUNCTION &&
15219|  8.44k|            p->u.cfunc.cproto == JS_CFUNC_iterator_next) {
15220|  8.44k|            JSCFunctionType func;
15221|  8.44k|            JSValueConst args[1];
15222|       |
15223|       |            /* in case the function expects one argument */
15224|  8.44k|            if (argc == 0) {
15225|  8.44k|                args[0] = JS_UNDEFINED;
15226|  8.44k|                argv = args;
15227|  8.44k|            }
15228|  8.44k|            func = p->u.cfunc.c_function;
15229|  8.44k|            return func.iterator_next(ctx, enum_obj, argc, argv,
15230|  8.44k|                                      pdone, p->u.cfunc.magic);
15231|  8.44k|        }
15232|  8.44k|    }
15233|      0|    obj = JS_Call(ctx, method, enum_obj, argc, argv);
15234|      0|    if (JS_IsException(obj))
15235|      0|        goto fail;
15236|      0|    if (!JS_IsObject(obj)) {
15237|      0|        JS_FreeValue(ctx, obj);
15238|      0|        JS_ThrowTypeError(ctx, "iterator must return an object");
15239|      0|        goto fail;
15240|      0|    }
15241|      0|    *pdone = 2;
15242|      0|    return obj;
15243|      0| fail:
15244|      0|    *pdone = FALSE;
15245|      0|    return JS_EXCEPTION;
15246|      0|}
15247|       |
15248|       |/* Note: always return JS_UNDEFINED when *pdone = TRUE. */
15249|       |static JSValue JS_IteratorNext(JSContext *ctx, JSValueConst enum_obj,
15250|       |                               JSValueConst method,
15251|       |                               int argc, JSValueConst *argv, BOOL *pdone)
15252|  8.44k|{
15253|  8.44k|    JSValue obj, value, done_val;
15254|  8.44k|    int done;
15255|       |
15256|  8.44k|    obj = JS_IteratorNext2(ctx, enum_obj, method, argc, argv, &done);
15257|  8.44k|    if (JS_IsException(obj))
15258|      0|        goto fail;
15259|  8.44k|    if (likely(done == 0)) {
15260|  6.81k|        *pdone = FALSE;
15261|  6.81k|        return obj;
15262|  6.81k|    } else if (done != 2) {
15263|  1.63k|        JS_FreeValue(ctx, obj);
15264|  1.63k|        *pdone = TRUE;
15265|  1.63k|        return JS_UNDEFINED;
15266|  1.63k|    } else {
15267|      0|        done_val = JS_GetProperty(ctx, obj, JS_ATOM_done);
15268|      0|        if (JS_IsException(done_val))
15269|      0|            goto fail;
15270|      0|        *pdone = JS_ToBoolFree(ctx, done_val);
15271|      0|        value = JS_UNDEFINED;
15272|      0|        if (!*pdone) {
15273|      0|            value = JS_GetProperty(ctx, obj, JS_ATOM_value);
15274|      0|        }
15275|      0|        JS_FreeValue(ctx, obj);
15276|      0|        return value;
15277|      0|    }
15278|      0| fail:
15279|      0|    JS_FreeValue(ctx, obj);
15280|      0|    *pdone = FALSE;
15281|      0|    return JS_EXCEPTION;
15282|  8.44k|}
15283|       |
15284|       |/* return < 0 in case of exception */
15285|       |static int JS_IteratorClose(JSContext *ctx, JSValueConst enum_obj,
15286|       |                            BOOL is_exception_pending)
15287|  6.02k|{
15288|  6.02k|    JSValue method, ret, ex_obj;
15289|  6.02k|    int res;
15290|       |
15291|  6.02k|    if (is_exception_pending) {
15292|    217|        ex_obj = ctx->rt->current_exception;
15293|    217|        ctx->rt->current_exception = JS_UNINITIALIZED;
15294|    217|        res = -1;
15295|  5.80k|    } else {
15296|  5.80k|        ex_obj = JS_UNDEFINED;
15297|  5.80k|        res = 0;
15298|  5.80k|    }
15299|  6.02k|    method = JS_GetProperty(ctx, enum_obj, JS_ATOM_return);
15300|  6.02k|    if (JS_IsException(method)) {
15301|    178|        res = -1;
15302|    178|        goto done;
15303|    178|    }
15304|  5.84k|    if (JS_IsUndefined(method) || JS_IsNull(method)) {
15305|  5.84k|        goto done;
15306|  5.84k|    }
15307|      0|    ret = JS_CallFree(ctx, method, enum_obj, 0, NULL);
15308|      0|    if (!is_exception_pending) {
15309|      0|        if (JS_IsException(ret)) {
15310|      0|            res = -1;
15311|      0|        } else if (!JS_IsObject(ret)) {
15312|      0|            JS_ThrowTypeErrorNotAnObject(ctx);
15313|      0|            res = -1;
15314|      0|        }
15315|      0|    }
15316|      0|    JS_FreeValue(ctx, ret);
15317|  6.02k| done:
15318|  6.02k|    if (is_exception_pending) {
15319|    217|        JS_Throw(ctx, ex_obj);
15320|    217|    }
15321|  6.02k|    return res;
15322|      0|}
15323|       |
15324|       |/* obj -> enum_rec (3 slots) */
15325|       |static __exception int js_for_of_start(JSContext *ctx, JSValue *sp,
15326|       |                                       BOOL is_async)
15327|  7.52k|{
15328|  7.52k|    JSValue op1, obj, method;
15329|  7.52k|    op1 = sp[-1];
15330|  7.52k|    obj = JS_GetIterator(ctx, op1, is_async);
15331|  7.52k|    if (JS_IsException(obj))
15332|     47|        return -1;
15333|  7.47k|    JS_FreeValue(ctx, op1);
15334|  7.47k|    sp[-1] = obj;
15335|  7.47k|    method = JS_GetProperty(ctx, obj, JS_ATOM_next);
15336|  7.47k|    if (JS_IsException(method))
15337|      0|        return -1;
15338|  7.47k|    sp[0] = method;
15339|  7.47k|    return 0;
15340|  7.47k|}
15341|       |
15342|       |/* enum_rec [objs] -> enum_rec [objs] value done. There are 'offset'
15343|       |   objs. If 'done' is true or in case of exception, 'enum_rec' is set
15344|       |   to undefined. If 'done' is true, 'value' is always set to
15345|       |   undefined. */
15346|       |static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
15347|   180k|{
15348|   180k|    JSValue value = JS_UNDEFINED;
15349|   180k|    int done = 1;
15350|       |
15351|   180k|    if (likely(!JS_IsUndefined(sp[offset]))) {
15352|  8.44k|        value = JS_IteratorNext(ctx, sp[offset], sp[offset + 1], 0, NULL, &done);
15353|  8.44k|        if (JS_IsException(value))
15354|      0|            done = -1;
15355|  8.44k|        if (done) {
15356|       |            /* value is JS_UNDEFINED or JS_EXCEPTION */
15357|       |            /* replace the iteration object with undefined */
15358|  1.63k|            JS_FreeValue(ctx, sp[offset]);
15359|  1.63k|            sp[offset] = JS_UNDEFINED;
15360|  1.63k|            if (done < 0) {
15361|      0|                return -1;
15362|  1.63k|            } else {
15363|  1.63k|                JS_FreeValue(ctx, value);
15364|  1.63k|                value = JS_UNDEFINED;
15365|  1.63k|            }
15366|  1.63k|        }
15367|  8.44k|    }
15368|   180k|    sp[0] = value;
15369|   180k|    sp[1] = JS_NewBool(ctx, done);
15370|   180k|    return 0;
15371|   180k|}
15372|       |
15373|       |static __exception int js_for_await_of_next(JSContext *ctx, JSValue *sp)
15374|      0|{
15375|      0|    JSValue obj, iter, next;
15376|       |
15377|      0|    sp[-1] = JS_UNDEFINED; /* disable the catch offset so that
15378|       |                              exceptions do not close the iterator */
15379|      0|    iter = sp[-3];
15380|      0|    next = sp[-2];
15381|      0|    obj = JS_Call(ctx, next, iter, 0, NULL);
15382|      0|    if (JS_IsException(obj))
15383|      0|        return -1;
15384|      0|    sp[0] = obj;
15385|      0|    return 0;
15386|      0|}
15387|       |
15388|       |static JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValueConst obj,
15389|       |                                           BOOL *pdone)
15390|      0|{
15391|      0|    JSValue done_val, value;
15392|      0|    BOOL done;
15393|      0|    done_val = JS_GetProperty(ctx, obj, JS_ATOM_done);
15394|      0|    if (JS_IsException(done_val))
15395|      0|        goto fail;
15396|      0|    done = JS_ToBoolFree(ctx, done_val);
15397|      0|    value = JS_GetProperty(ctx, obj, JS_ATOM_value);
15398|      0|    if (JS_IsException(value))
15399|      0|        goto fail;
15400|      0|    *pdone = done;
15401|      0|    return value;
15402|      0| fail:
15403|      0|    *pdone = FALSE;
15404|      0|    return JS_EXCEPTION;
15405|      0|}
15406|       |
15407|       |static __exception int js_iterator_get_value_done(JSContext *ctx, JSValue *sp)
15408|      0|{
15409|      0|    JSValue obj, value;
15410|      0|    BOOL done;
15411|      0|    obj = sp[-1];
15412|      0|    if (!JS_IsObject(obj)) {
15413|      0|        JS_ThrowTypeError(ctx, "iterator must return an object");
15414|      0|        return -1;
15415|      0|    }
15416|      0|    value = JS_IteratorGetCompleteValue(ctx, obj, &done);
15417|      0|    if (JS_IsException(value))
15418|      0|        return -1;
15419|      0|    JS_FreeValue(ctx, obj);
15420|       |    /* put again the catch offset so that exceptions close the
15421|       |       iterator */
15422|      0|    sp[-2] = JS_NewCatchOffset(ctx, 0); 
15423|      0|    sp[-1] = value;
15424|      0|    sp[0] = JS_NewBool(ctx, done);
15425|      0|    return 0;
15426|      0|}
15427|       |
15428|       |static JSValue js_create_iterator_result(JSContext *ctx,
15429|       |                                         JSValue val,
15430|       |                                         BOOL done)
15431|      0|{
15432|      0|    JSValue obj;
15433|      0|    obj = JS_NewObject(ctx);
15434|      0|    if (JS_IsException(obj)) {
15435|      0|        JS_FreeValue(ctx, val);
15436|      0|        return obj;
15437|      0|    }
15438|      0|    if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_value,
15439|      0|                               val, JS_PROP_C_W_E) < 0) {
15440|      0|        goto fail;
15441|      0|    }
15442|      0|    if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_done,
15443|      0|                               JS_NewBool(ctx, done), JS_PROP_C_W_E) < 0) {
15444|      0|    fail:
15445|      0|        JS_FreeValue(ctx, obj);
15446|      0|        return JS_EXCEPTION;
15447|      0|    }
15448|      0|    return obj;
15449|      0|}
15450|       |
15451|       |static JSValue js_array_iterator_next(JSContext *ctx, JSValueConst this_val,
15452|       |                                      int argc, JSValueConst *argv,
15453|       |                                      BOOL *pdone, int magic);
15454|       |
15455|       |static JSValue js_create_array_iterator(JSContext *ctx, JSValueConst this_val,
15456|       |                                        int argc, JSValueConst *argv, int magic);
15457|       |
15458|       |static BOOL js_is_fast_array(JSContext *ctx, JSValueConst obj)
15459|      0|{
15460|       |    /* Try and handle fast arrays explicitly */
15461|      0|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
15462|      0|        JSObject *p = JS_VALUE_GET_OBJ(obj);
15463|      0|        if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {
15464|      0|            return TRUE;
15465|      0|        }
15466|      0|    }
15467|      0|    return FALSE;
15468|      0|}
15469|       |
15470|       |/* Access an Array's internal JSValue array if available */
15471|       |static BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,
15472|       |                              JSValue **arrpp, uint32_t *countp)
15473|      0|{
15474|       |    /* Try and handle fast arrays explicitly */
15475|      0|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
15476|      0|        JSObject *p = JS_VALUE_GET_OBJ(obj);
15477|      0|        if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {
15478|      0|            *countp = p->u.array.count;
15479|      0|            *arrpp = p->u.array.u.values;
15480|      0|            return TRUE;
15481|      0|        }
15482|      0|    }
15483|      0|    return FALSE;
15484|      0|}
15485|       |
15486|       |static __exception int js_append_enumerate(JSContext *ctx, JSValue *sp)
15487|      3|{
15488|      3|    JSValue iterator, enumobj, method, value;
15489|      3|    int is_array_iterator;
15490|      3|    JSValue *arrp;
15491|      3|    uint32_t i, count32, pos;
15492|       |
15493|      3|    if (JS_VALUE_GET_TAG(sp[-2]) != JS_TAG_INT) {
15494|      0|        JS_ThrowInternalError(ctx, "invalid index for append");
15495|      0|        return -1;
15496|      0|    }
15497|       |
15498|      3|    pos = JS_VALUE_GET_INT(sp[-2]);
15499|       |
15500|       |    /* XXX: further optimisations:
15501|       |       - use ctx->array_proto_values?
15502|       |       - check if array_iterator_prototype next method is built-in and
15503|       |         avoid constructing actual iterator object?
15504|       |       - build this into js_for_of_start and use in all `for (x of o)` loops
15505|       |     */
15506|      3|    iterator = JS_GetProperty(ctx, sp[-1], JS_ATOM_Symbol_iterator);
15507|      3|    if (JS_IsException(iterator))
15508|      1|        return -1;
15509|      2|    is_array_iterator = JS_IsCFunction(ctx, iterator,
15510|      2|                                       (JSCFunction *)js_create_array_iterator,
15511|      2|                                       JS_ITERATOR_KIND_VALUE);
15512|      2|    JS_FreeValue(ctx, iterator);
15513|       |
15514|      2|    enumobj = JS_GetIterator(ctx, sp[-1], FALSE);
15515|      2|    if (JS_IsException(enumobj))
15516|      2|        return -1;
15517|      0|    method = JS_GetProperty(ctx, enumobj, JS_ATOM_next);
15518|      0|    if (JS_IsException(method)) {
15519|      0|        JS_FreeValue(ctx, enumobj);
15520|      0|        return -1;
15521|      0|    }
15522|      0|    if (is_array_iterator
15523|      0|    &&  JS_IsCFunction(ctx, method, (JSCFunction *)js_array_iterator_next, 0)
15524|      0|    &&  js_get_fast_array(ctx, sp[-1], &arrp, &count32)) {
15525|      0|        uint32_t len;
15526|      0|        if (js_get_length32(ctx, &len, sp[-1]))
15527|      0|            goto exception;
15528|       |        /* if len > count32, the elements >= count32 might be read in
15529|       |           the prototypes and might have side effects */
15530|      0|        if (len != count32)
15531|      0|            goto general_case;
15532|       |        /* Handle fast arrays explicitly */
15533|      0|        for (i = 0; i < count32; i++) {
15534|      0|            if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++,
15535|      0|                                             JS_DupValue(ctx, arrp[i]), JS_PROP_C_W_E) < 0)
15536|      0|                goto exception;
15537|      0|        }
15538|      0|    } else {
15539|      0|    general_case:
15540|      0|        for (;;) {
15541|      0|            BOOL done;
15542|      0|            value = JS_IteratorNext(ctx, enumobj, method, 0, NULL, &done);
15543|      0|            if (JS_IsException(value))
15544|      0|                goto exception;
15545|      0|            if (done) {
15546|       |                /* value is JS_UNDEFINED */
15547|      0|                break;
15548|      0|            }
15549|      0|            if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++, value, JS_PROP_C_W_E) < 0)
15550|      0|                goto exception;
15551|      0|        }
15552|      0|    }
15553|       |    /* Note: could raise an error if too many elements */
15554|      0|    sp[-2] = JS_NewInt32(ctx, pos);
15555|      0|    JS_FreeValue(ctx, enumobj);
15556|      0|    JS_FreeValue(ctx, method);
15557|      0|    return 0;
15558|       |
15559|      0|exception:
15560|      0|    JS_IteratorClose(ctx, enumobj, TRUE);
15561|      0|    JS_FreeValue(ctx, enumobj);
15562|      0|    JS_FreeValue(ctx, method);
15563|      0|    return -1;
15564|      0|}
15565|       |
15566|       |static __exception int JS_CopyDataProperties(JSContext *ctx,
15567|       |                                             JSValueConst target,
15568|       |                                             JSValueConst source,
15569|       |                                             JSValueConst excluded,
15570|       |                                             BOOL setprop)
15571|      0|{
15572|      0|    JSPropertyEnum *tab_atom;
15573|      0|    JSValue val;
15574|      0|    uint32_t i, tab_atom_count;
15575|      0|    JSObject *p;
15576|      0|    JSObject *pexcl = NULL;
15577|      0|    int ret, gpn_flags;
15578|      0|    JSPropertyDescriptor desc;
15579|      0|    BOOL is_enumerable;
15580|       |
15581|      0|    if (JS_VALUE_GET_TAG(source) != JS_TAG_OBJECT)
15582|      0|        return 0;
15583|       |
15584|      0|    if (JS_VALUE_GET_TAG(excluded) == JS_TAG_OBJECT)
15585|      0|        pexcl = JS_VALUE_GET_OBJ(excluded);
15586|       |
15587|      0|    p = JS_VALUE_GET_OBJ(source);
15588|       |
15589|      0|    gpn_flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK | JS_GPN_ENUM_ONLY;
15590|      0|    if (p->is_exotic) {
15591|      0|        const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
15592|       |        /* cannot use JS_GPN_ENUM_ONLY with e.g. proxies because it
15593|       |           introduces a visible change */
15594|      0|        if (em && em->get_own_property_names) {
15595|      0|            gpn_flags &= ~JS_GPN_ENUM_ONLY;
15596|      0|        }
15597|      0|    }
15598|      0|    if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
15599|      0|                                       gpn_flags))
15600|      0|        return -1;
15601|       |
15602|      0|    for (i = 0; i < tab_atom_count; i++) {
15603|      0|        if (pexcl) {
15604|      0|            ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);
15605|      0|            if (ret) {
15606|      0|                if (ret < 0)
15607|      0|                    goto exception;
15608|      0|                continue;
15609|      0|            }
15610|      0|        }
15611|      0|        if (!(gpn_flags & JS_GPN_ENUM_ONLY)) {
15612|       |            /* test if the property is enumerable */
15613|      0|            ret = JS_GetOwnPropertyInternal(ctx, &desc, p, tab_atom[i].atom);
15614|      0|            if (ret < 0)
15615|      0|                goto exception;
15616|      0|            if (!ret)
15617|      0|                continue;
15618|      0|            is_enumerable = (desc.flags & JS_PROP_ENUMERABLE) != 0;
15619|      0|            js_free_desc(ctx, &desc);
15620|      0|            if (!is_enumerable)
15621|      0|                continue;
15622|      0|        }
15623|      0|        val = JS_GetProperty(ctx, source, tab_atom[i].atom);
15624|      0|        if (JS_IsException(val))
15625|      0|            goto exception;
15626|      0|        if (setprop)
15627|      0|            ret = JS_SetProperty(ctx, target, tab_atom[i].atom, val);
15628|      0|        else
15629|      0|            ret = JS_DefinePropertyValue(ctx, target, tab_atom[i].atom, val,
15630|      0|                                         JS_PROP_C_W_E);
15631|      0|        if (ret < 0)
15632|      0|            goto exception;
15633|      0|    }
15634|      0|    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
15635|      0|    return 0;
15636|      0| exception:
15637|      0|    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
15638|      0|    return -1;
15639|      0|}
15640|       |
15641|       |/* only valid inside C functions */
15642|       |static JSValueConst JS_GetActiveFunction(JSContext *ctx)
15643|      0|{
15644|      0|    return ctx->rt->current_stack_frame->cur_func;
15645|      0|}
15646|       |
15647|       |static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf,
15648|       |                             int var_idx, BOOL is_arg)
15649|  85.3k|{
15650|  85.3k|    JSVarRef *var_ref;
15651|  85.3k|    struct list_head *el;
15652|  85.3k|    JSValue *pvalue;
15653|       |
15654|  85.3k|    if (is_arg)
15655|  50.3k|        pvalue = &sf->arg_buf[var_idx];
15656|  34.9k|    else
15657|  34.9k|        pvalue = &sf->var_buf[var_idx];
15658|       |
15659|  85.3k|    list_for_each(el, &sf->var_ref_list) {
15660|  38.2k|        var_ref = list_entry(el, JSVarRef, var_ref_link);
15661|  38.2k|        if (var_ref->pvalue == pvalue) {
15662|  24.4k|            var_ref->header.ref_count++;
15663|  24.4k|            return var_ref;
15664|  24.4k|        }
15665|  38.2k|    }
15666|       |    /* create a new one */
15667|  60.9k|    var_ref = js_malloc(ctx, sizeof(JSVarRef));
15668|  60.9k|    if (!var_ref)
15669|      0|        return NULL;
15670|  60.9k|    var_ref->header.ref_count = 1;
15671|  60.9k|    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
15672|  60.9k|    var_ref->is_detached = FALSE;
15673|  60.9k|    list_add_tail(&var_ref->var_ref_link, &sf->var_ref_list);
15674|  60.9k|    if (sf->js_mode & JS_MODE_ASYNC) {
15675|       |        /* The stack frame is detached and may be destroyed at any
15676|       |           time so its reference count must be increased. Calling
15677|       |           close_var_refs() when destroying the stack frame is not
15678|       |           possible because it would change the graph between the GC
15679|       |           objects. Another solution could be to temporarily detach
15680|       |           the JSVarRef of async functions during the GC. It would
15681|       |           have the advantage of allowing the release of unused stack
15682|       |           frames in a cycle. */
15683|    265|        var_ref->async_func = container_of(sf, JSAsyncFunctionState, frame);
15684|    265|        var_ref->async_func->header.ref_count++;
15685|  60.6k|    } else {
15686|  60.6k|        var_ref->async_func = NULL;
15687|  60.6k|    }
15688|  60.9k|    var_ref->pvalue = pvalue;
15689|  60.9k|    return var_ref;
15690|  60.9k|}
15691|       |
15692|       |static JSValue js_closure2(JSContext *ctx, JSValue func_obj,
15693|       |                           JSFunctionBytecode *b,
15694|       |                           JSVarRef **cur_var_refs,
15695|       |                           JSStackFrame *sf)
15696|   156k|{
15697|   156k|    JSObject *p;
15698|   156k|    JSVarRef **var_refs;
15699|   156k|    int i;
15700|       |
15701|   156k|    p = JS_VALUE_GET_OBJ(func_obj);
15702|   156k|    p->u.func.function_bytecode = b;
15703|   156k|    p->u.func.home_object = NULL;
15704|   156k|    p->u.func.var_refs = NULL;
15705|   156k|    if (b->closure_var_count) {
15706|   102k|        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);
15707|   102k|        if (!var_refs)
15708|      0|            goto fail;
15709|   102k|        p->u.func.var_refs = var_refs;
15710|   247k|        for(i = 0; i < b->closure_var_count; i++) {
15711|   144k|            JSClosureVar *cv = &b->closure_var[i];
15712|   144k|            JSVarRef *var_ref;
15713|   144k|            if (cv->is_local) {
15714|       |                /* reuse the existing variable reference if it already exists */
15715|  54.0k|                var_ref = get_var_ref(ctx, sf, cv->var_idx, cv->is_arg);
15716|  54.0k|                if (!var_ref)
15717|      0|                    goto fail;
15718|  90.6k|            } else {
15719|  90.6k|                var_ref = cur_var_refs[cv->var_idx];
15720|  90.6k|                var_ref->header.ref_count++;
15721|  90.6k|            }
15722|   144k|            var_refs[i] = var_ref;
15723|   144k|        }
15724|   102k|    }
15725|   156k|    return func_obj;
15726|      0| fail:
15727|       |    /* bfunc is freed when func_obj is freed */
15728|      0|    JS_FreeValue(ctx, func_obj);
15729|      0|    return JS_EXCEPTION;
15730|   156k|}
15731|       |
15732|       |static JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque)
15733|      0|{
15734|      0|    JSValue obj, this_val;
15735|      0|    int ret;
15736|       |
15737|      0|    this_val = JS_MKPTR(JS_TAG_OBJECT, p);
15738|      0|    obj = JS_NewObject(ctx);
15739|      0|    if (JS_IsException(obj))
15740|      0|        return JS_EXCEPTION;
15741|      0|    set_cycle_flag(ctx, obj);
15742|      0|    set_cycle_flag(ctx, this_val);
15743|      0|    ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_constructor,
15744|      0|                                 JS_DupValue(ctx, this_val),
15745|      0|                                 JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
15746|      0|    if (ret < 0) {
15747|      0|        JS_FreeValue(ctx, obj);
15748|      0|        return JS_EXCEPTION;
15749|      0|    }
15750|      0|    return obj;
15751|      0|}
15752|       |
15753|       |static const uint16_t func_kind_to_class_id[] = {
15754|       |    [JS_FUNC_NORMAL] = JS_CLASS_BYTECODE_FUNCTION,
15755|       |    [JS_FUNC_GENERATOR] = JS_CLASS_GENERATOR_FUNCTION,
15756|       |    [JS_FUNC_ASYNC] = JS_CLASS_ASYNC_FUNCTION,
15757|       |    [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,
15758|       |};
15759|       |
15760|       |static JSValue js_closure(JSContext *ctx, JSValue bfunc,
15761|       |                          JSVarRef **cur_var_refs,
15762|       |                          JSStackFrame *sf)
15763|   156k|{
15764|   156k|    JSFunctionBytecode *b;
15765|   156k|    JSValue func_obj;
15766|   156k|    JSAtom name_atom;
15767|       |
15768|   156k|    b = JS_VALUE_GET_PTR(bfunc);
15769|   156k|    func_obj = JS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);
15770|   156k|    if (JS_IsException(func_obj)) {
15771|      0|        JS_FreeValue(ctx, bfunc);
15772|      0|        return JS_EXCEPTION;
15773|      0|    }
15774|   156k|    func_obj = js_closure2(ctx, func_obj, b, cur_var_refs, sf);
15775|   156k|    if (JS_IsException(func_obj)) {
15776|       |        /* bfunc has been freed */
15777|      0|        goto fail;
15778|      0|    }
15779|   156k|    name_atom = b->func_name;
15780|   156k|    if (name_atom == JS_ATOM_NULL)
15781|   147k|        name_atom = JS_ATOM_empty_string;
15782|   156k|    js_function_set_properties(ctx, func_obj, name_atom,
15783|   156k|                               b->defined_arg_count);
15784|       |
15785|   156k|    if (b->func_kind & JS_FUNC_GENERATOR) {
15786|      0|        JSValue proto;
15787|      0|        int proto_class_id;
15788|       |        /* generators have a prototype field which is used as
15789|       |           prototype for the generator object */
15790|      0|        if (b->func_kind == JS_FUNC_ASYNC_GENERATOR)
15791|      0|            proto_class_id = JS_CLASS_ASYNC_GENERATOR;
15792|      0|        else
15793|      0|            proto_class_id = JS_CLASS_GENERATOR;
15794|      0|        proto = JS_NewObjectProto(ctx, ctx->class_proto[proto_class_id]);
15795|      0|        if (JS_IsException(proto))
15796|      0|            goto fail;
15797|      0|        JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_prototype, proto,
15798|      0|                               JS_PROP_WRITABLE);
15799|   156k|    } else if (b->has_prototype) {
15800|       |        /* add the 'prototype' property: delay instantiation to avoid
15801|       |           creating cycles for every javascript function. The prototype
15802|       |           object is created on the fly when first accessed */
15803|      0|        JS_SetConstructorBit(ctx, func_obj, TRUE);
15804|      0|        JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,
15805|      0|                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,
15806|      0|                                  JS_PROP_WRITABLE);
15807|      0|    }
15808|   156k|    return func_obj;
15809|      0| fail:
15810|       |    /* bfunc is freed when func_obj is freed */
15811|      0|    JS_FreeValue(ctx, func_obj);
15812|      0|    return JS_EXCEPTION;
15813|   156k|}
15814|       |
15815|      0|#define JS_DEFINE_CLASS_HAS_HERITAGE     (1 << 0)
15816|       |
15817|       |static int js_op_define_class(JSContext *ctx, JSValue *sp,
15818|       |                              JSAtom class_name, int class_flags,
15819|       |                              JSVarRef **cur_var_refs,
15820|       |                              JSStackFrame *sf, BOOL is_computed_name)
15821|      0|{
15822|      0|    JSValue bfunc, parent_class, proto = JS_UNDEFINED;
15823|      0|    JSValue ctor = JS_UNDEFINED, parent_proto = JS_UNDEFINED;
15824|      0|    JSFunctionBytecode *b;
15825|       |
15826|      0|    parent_class = sp[-2];
15827|      0|    bfunc = sp[-1];
15828|       |
15829|      0|    if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE) {
15830|      0|        if (JS_IsNull(parent_class)) {
15831|      0|            parent_proto = JS_NULL;
15832|      0|            parent_class = JS_DupValue(ctx, ctx->function_proto);
15833|      0|        } else {
15834|      0|            if (!JS_IsConstructor(ctx, parent_class)) {
15835|      0|                JS_ThrowTypeError(ctx, "parent class must be constructor");
15836|      0|                goto fail;
15837|      0|            }
15838|      0|            parent_proto = JS_GetProperty(ctx, parent_class, JS_ATOM_prototype);
15839|      0|            if (JS_IsException(parent_proto))
15840|      0|                goto fail;
15841|      0|            if (!JS_IsNull(parent_proto) && !JS_IsObject(parent_proto)) {
15842|      0|                JS_ThrowTypeError(ctx, "parent prototype must be an object or null");
15843|      0|                goto fail;
15844|      0|            }
15845|      0|        }
15846|      0|    } else {
15847|       |        /* parent_class is JS_UNDEFINED in this case */
15848|      0|        parent_proto = JS_DupValue(ctx, ctx->class_proto[JS_CLASS_OBJECT]);
15849|      0|        parent_class = JS_DupValue(ctx, ctx->function_proto);
15850|      0|    }
15851|      0|    proto = JS_NewObjectProto(ctx, parent_proto);
15852|      0|    if (JS_IsException(proto))
15853|      0|        goto fail;
15854|       |
15855|      0|    b = JS_VALUE_GET_PTR(bfunc);
15856|      0|    assert(b->func_kind == JS_FUNC_NORMAL);
15857|      0|    ctor = JS_NewObjectProtoClass(ctx, parent_class,
15858|      0|                                  JS_CLASS_BYTECODE_FUNCTION);
15859|      0|    if (JS_IsException(ctor))
15860|      0|        goto fail;
15861|      0|    ctor = js_closure2(ctx, ctor, b, cur_var_refs, sf);
15862|      0|    bfunc = JS_UNDEFINED;
15863|      0|    if (JS_IsException(ctor))
15864|      0|        goto fail;
15865|      0|    js_method_set_home_object(ctx, ctor, proto);
15866|      0|    JS_SetConstructorBit(ctx, ctor, TRUE);
15867|       |
15868|      0|    JS_DefinePropertyValue(ctx, ctor, JS_ATOM_length,
15869|      0|                           JS_NewInt32(ctx, b->defined_arg_count),
15870|      0|                           JS_PROP_CONFIGURABLE);
15871|       |
15872|      0|    if (is_computed_name) {
15873|      0|        if (JS_DefineObjectNameComputed(ctx, ctor, sp[-3],
15874|      0|                                        JS_PROP_CONFIGURABLE) < 0)
15875|      0|            goto fail;
15876|      0|    } else {
15877|      0|        if (JS_DefineObjectName(ctx, ctor, class_name, JS_PROP_CONFIGURABLE) < 0)
15878|      0|            goto fail;
15879|      0|    }
15880|       |
15881|       |    /* the constructor property must be first. It can be overriden by
15882|       |       computed property names */
15883|      0|    if (JS_DefinePropertyValue(ctx, proto, JS_ATOM_constructor,
15884|      0|                               JS_DupValue(ctx, ctor),
15885|      0|                               JS_PROP_CONFIGURABLE |
15886|      0|                               JS_PROP_WRITABLE | JS_PROP_THROW) < 0)
15887|      0|        goto fail;
15888|       |    /* set the prototype property */
15889|      0|    if (JS_DefinePropertyValue(ctx, ctor, JS_ATOM_prototype,
15890|      0|                               JS_DupValue(ctx, proto), JS_PROP_THROW) < 0)
15891|      0|        goto fail;
15892|      0|    set_cycle_flag(ctx, ctor);
15893|      0|    set_cycle_flag(ctx, proto);
15894|       |
15895|      0|    JS_FreeValue(ctx, parent_proto);
15896|      0|    JS_FreeValue(ctx, parent_class);
15897|       |
15898|      0|    sp[-2] = ctor;
15899|      0|    sp[-1] = proto;
15900|      0|    return 0;
15901|      0| fail:
15902|      0|    JS_FreeValue(ctx, parent_class);
15903|      0|    JS_FreeValue(ctx, parent_proto);
15904|      0|    JS_FreeValue(ctx, bfunc);
15905|      0|    JS_FreeValue(ctx, proto);
15906|      0|    JS_FreeValue(ctx, ctor);
15907|      0|    sp[-2] = JS_UNDEFINED;
15908|      0|    sp[-1] = JS_UNDEFINED;
15909|      0|    return -1;
15910|      0|}
15911|       |
15912|       |static void close_var_refs(JSRuntime *rt, JSStackFrame *sf)
15913|  20.1k|{
15914|  20.1k|    struct list_head *el, *el1;
15915|  20.1k|    JSVarRef *var_ref;
15916|       |
15917|  20.4k|    list_for_each_safe(el, el1, &sf->var_ref_list) {
15918|  20.4k|        var_ref = list_entry(el, JSVarRef, var_ref_link);
15919|       |        /* no need to unlink var_ref->var_ref_link as the list is never used afterwards */
15920|  20.4k|        if (var_ref->async_func)
15921|     71|            async_func_free(rt, var_ref->async_func);
15922|  20.4k|        var_ref->value = JS_DupValueRT(rt, *var_ref->pvalue);
15923|  20.4k|        var_ref->pvalue = &var_ref->value;
15924|       |        /* the reference is no longer to a local variable */
15925|  20.4k|        var_ref->is_detached = TRUE;
15926|  20.4k|    }
15927|  20.1k|}
15928|       |
15929|       |static void close_lexical_var(JSContext *ctx, JSStackFrame *sf, int var_idx)
15930|    268|{
15931|    268|    JSValue *pvalue;
15932|    268|    struct list_head *el, *el1;
15933|    268|    JSVarRef *var_ref;
15934|       |
15935|    268|    pvalue = &sf->var_buf[var_idx];
15936|    450|    list_for_each_safe(el, el1, &sf->var_ref_list) {
15937|    450|        var_ref = list_entry(el, JSVarRef, var_ref_link);
15938|    450|        if (var_ref->pvalue == pvalue) {
15939|    254|            list_del(&var_ref->var_ref_link);
15940|    254|            if (var_ref->async_func)
15941|     10|                async_func_free(ctx->rt, var_ref->async_func);
15942|    254|            var_ref->value = JS_DupValue(ctx, *var_ref->pvalue);
15943|    254|            var_ref->pvalue = &var_ref->value;
15944|       |            /* the reference is no longer to a local variable */
15945|    254|            var_ref->is_detached = TRUE;
15946|    254|        }
15947|    450|    }
15948|    268|}
15949|       |
15950|  9.58M|#define JS_CALL_FLAG_COPY_ARGV   (1 << 1)
15951|    903|#define JS_CALL_FLAG_GENERATOR   (1 << 2)
15952|       |
15953|       |static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
15954|       |                                  JSValueConst this_obj,
15955|       |                                  int argc, JSValueConst *argv, int flags)
15956|  9.57M|{
15957|  9.57M|    JSRuntime *rt = ctx->rt;
15958|  9.57M|    JSCFunctionType func;
15959|  9.57M|    JSObject *p;
15960|  9.57M|    JSStackFrame sf_s, *sf = &sf_s, *prev_sf;
15961|  9.57M|    JSValue ret_val;
15962|  9.57M|    JSValueConst *arg_buf;
15963|  9.57M|    int arg_count, i;
15964|  9.57M|    JSCFunctionEnum cproto;
15965|       |
15966|  9.57M|    p = JS_VALUE_GET_OBJ(func_obj);
15967|  9.57M|    cproto = p->u.cfunc.cproto;
15968|  9.57M|    arg_count = p->u.cfunc.length;
15969|       |
15970|       |    /* better to always check stack overflow */
15971|  9.57M|    if (js_check_stack_overflow(rt, sizeof(arg_buf[0]) * arg_count))
15972|     59|        return JS_ThrowStackOverflow(ctx);
15973|       |
15974|  9.57M|    prev_sf = rt->current_stack_frame;
15975|  9.57M|    sf->prev_frame = prev_sf;
15976|  9.57M|    rt->current_stack_frame = sf;
15977|  9.57M|    ctx = p->u.cfunc.realm; /* change the current realm */
15978|  9.57M|    sf->js_mode = 0;
15979|  9.57M|    sf->cur_func = (JSValue)func_obj;
15980|  9.57M|    sf->arg_count = argc;
15981|  9.57M|    arg_buf = argv;
15982|       |
15983|  9.57M|    if (unlikely(argc < arg_count)) {
15984|       |        /* ensure that at least argc_count arguments are readable */
15985|   232k|        arg_buf = alloca(sizeof(arg_buf[0]) * arg_count);
15986|   232k|        for(i = 0; i < argc; i++)
15987|      0|            arg_buf[i] = argv[i];
15988|   465k|        for(i = argc; i < arg_count; i++)
15989|   232k|            arg_buf[i] = JS_UNDEFINED;
15990|   232k|        sf->arg_count = arg_count;
15991|   232k|    }
15992|  9.57M|    sf->arg_buf = (JSValue*)arg_buf;
15993|       |
15994|  9.57M|    func = p->u.cfunc.c_function;
15995|  9.57M|    switch(cproto) {
15996|      0|    case JS_CFUNC_constructor:
15997|      0|    case JS_CFUNC_constructor_or_func:
15998|      0|        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {
15999|      0|            if (cproto == JS_CFUNC_constructor) {
16000|      0|            not_a_constructor:
16001|      0|                ret_val = JS_ThrowTypeError(ctx, "must be called with new");
16002|      0|                break;
16003|      0|            } else {
16004|      0|                this_obj = JS_UNDEFINED;
16005|      0|            }
16006|      0|        }
16007|       |        /* here this_obj is new_target */
16008|       |        /* fall thru */
16009|  2.30M|    case JS_CFUNC_generic:
16010|  2.30M|        ret_val = func.generic(ctx, this_obj, argc, arg_buf);
16011|  2.30M|        break;
16012|      0|    case JS_CFUNC_constructor_magic:
16013|      0|    case JS_CFUNC_constructor_or_func_magic:
16014|      0|        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {
16015|      0|            if (cproto == JS_CFUNC_constructor_magic) {
16016|      0|                goto not_a_constructor;
16017|      0|            } else {
16018|      0|                this_obj = JS_UNDEFINED;
16019|      0|            }
16020|      0|        }
16021|       |        /* fall thru */
16022|   240k|    case JS_CFUNC_generic_magic:
16023|   240k|        ret_val = func.generic_magic(ctx, this_obj, argc, arg_buf,
16024|   240k|                                     p->u.cfunc.magic);
16025|   240k|        break;
16026|  1.56M|    case JS_CFUNC_getter:
16027|  1.56M|        ret_val = func.getter(ctx, this_obj);
16028|  1.56M|        break;
16029|      0|    case JS_CFUNC_setter:
16030|      0|        ret_val = func.setter(ctx, this_obj, arg_buf[0]);
16031|      0|        break;
16032|  5.46M|    case JS_CFUNC_getter_magic:
16033|  5.46M|        ret_val = func.getter_magic(ctx, this_obj, p->u.cfunc.magic);
16034|  5.46M|        break;
16035|      0|    case JS_CFUNC_setter_magic:
16036|      0|        ret_val = func.setter_magic(ctx, this_obj, arg_buf[0], p->u.cfunc.magic);
16037|      0|        break;
16038|      0|    case JS_CFUNC_f_f:
16039|      0|        {
16040|      0|            double d1;
16041|       |
16042|      0|            if (unlikely(JS_ToFloat64(ctx, &d1, arg_buf[0]))) {
16043|      0|                ret_val = JS_EXCEPTION;
16044|      0|                break;
16045|      0|            }
16046|      0|            ret_val = JS_NewFloat64(ctx, func.f_f(d1));
16047|      0|        }
16048|      0|        break;
16049|      0|    case JS_CFUNC_f_f_f:
16050|      0|        {
16051|      0|            double d1, d2;
16052|       |
16053|      0|            if (unlikely(JS_ToFloat64(ctx, &d1, arg_buf[0]))) {
16054|      0|                ret_val = JS_EXCEPTION;
16055|      0|                break;
16056|      0|            }
16057|      0|            if (unlikely(JS_ToFloat64(ctx, &d2, arg_buf[1]))) {
16058|      0|                ret_val = JS_EXCEPTION;
16059|      0|                break;
16060|      0|            }
16061|      0|            ret_val = JS_NewFloat64(ctx, func.f_f_f(d1, d2));
16062|      0|        }
16063|      0|        break;
16064|      0|    case JS_CFUNC_iterator_next:
16065|      0|        {
16066|      0|            int done;
16067|      0|            ret_val = func.iterator_next(ctx, this_obj, argc, arg_buf,
16068|      0|                                         &done, p->u.cfunc.magic);
16069|      0|            if (!JS_IsException(ret_val) && done != 2) {
16070|      0|                ret_val = js_create_iterator_result(ctx, ret_val, done);
16071|      0|            }
16072|      0|        }
16073|      0|        break;
16074|      0|    default:
16075|      0|        abort();
16076|  9.57M|    }
16077|       |
16078|  9.57M|    rt->current_stack_frame = sf->prev_frame;
16079|  9.57M|    return ret_val;
16080|  9.57M|}
16081|       |
16082|       |static JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,
16083|       |                                      JSValueConst this_obj,
16084|       |                                      int argc, JSValueConst *argv, int flags)
16085|      0|{
16086|      0|    JSObject *p;
16087|      0|    JSBoundFunction *bf;
16088|      0|    JSValueConst *arg_buf, new_target;
16089|      0|    int arg_count, i;
16090|       |
16091|      0|    p = JS_VALUE_GET_OBJ(func_obj);
16092|      0|    bf = p->u.bound_function;
16093|      0|    arg_count = bf->argc + argc;
16094|      0|    if (js_check_stack_overflow(ctx->rt, sizeof(JSValue) * arg_count))
16095|      0|        return JS_ThrowStackOverflow(ctx);
16096|      0|    arg_buf = alloca(sizeof(JSValue) * arg_count);
16097|      0|    for(i = 0; i < bf->argc; i++) {
16098|      0|        arg_buf[i] = bf->argv[i];
16099|      0|    }
16100|      0|    for(i = 0; i < argc; i++) {
16101|      0|        arg_buf[bf->argc + i] = argv[i];
16102|      0|    }
16103|      0|    if (flags & JS_CALL_FLAG_CONSTRUCTOR) {
16104|      0|        new_target = this_obj;
16105|      0|        if (js_same_value(ctx, func_obj, new_target))
16106|      0|            new_target = bf->func_obj;
16107|      0|        return JS_CallConstructor2(ctx, bf->func_obj, new_target,
16108|      0|                                   arg_count, arg_buf);
16109|      0|    } else {
16110|      0|        return JS_Call(ctx, bf->func_obj, bf->this_val,
16111|      0|                       arg_count, arg_buf);
16112|      0|    }
16113|      0|}
16114|       |
16115|       |/* argument of OP_special_object */
16116|       |typedef enum {
16117|       |    OP_SPECIAL_OBJECT_ARGUMENTS,
16118|       |    OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS,
16119|       |    OP_SPECIAL_OBJECT_THIS_FUNC,
16120|       |    OP_SPECIAL_OBJECT_NEW_TARGET,
16121|       |    OP_SPECIAL_OBJECT_HOME_OBJECT,
16122|       |    OP_SPECIAL_OBJECT_VAR_OBJECT,
16123|       |    OP_SPECIAL_OBJECT_IMPORT_META,
16124|       |} OPSpecialObjectEnum;
16125|       |
16126|      0|#define FUNC_RET_AWAIT         0
16127|      0|#define FUNC_RET_YIELD         1
16128|      0|#define FUNC_RET_YIELD_STAR    2
16129|      0|#define FUNC_RET_INITIAL_YIELD 3
16130|       |
16131|       |/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */
16132|       |static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
16133|       |                               JSValueConst this_obj, JSValueConst new_target,
16134|       |                               int argc, JSValue *argv, int flags)
16135|  9.82M|{
16136|  9.82M|    JSRuntime *rt = caller_ctx->rt;
16137|  9.82M|    JSContext *ctx;
16138|  9.82M|    JSObject *p;
16139|  9.82M|    JSFunctionBytecode *b;
16140|  9.82M|    JSStackFrame sf_s, *sf = &sf_s;
16141|  9.82M|    const uint8_t *pc;
16142|  9.82M|    int opcode, arg_allocated_size, i;
16143|  9.82M|    JSValue *local_buf, *stack_buf, *var_buf, *arg_buf, *sp, ret_val, *pval;
16144|  9.82M|    JSVarRef **var_refs;
16145|  9.82M|    size_t alloca_size;
16146|       |
16147|       |#if !DIRECT_DISPATCH
16148|       |#define SWITCH(pc)      switch (opcode = *pc++)
16149|       |#define CASE(op)        case op
16150|       |#define DEFAULT         default
16151|       |#define BREAK           break
16152|       |#else
16153|  9.82M|    static const void * const dispatch_table[256] = {
16154|  2.43G|#define DEF(id, size, n_pop, n_push, f) && case_OP_ ## id,
16155|  9.82M|#if SHORT_OPCODES
16156|  9.82M|#define def(id, size, n_pop, n_push, f)
16157|       |#else
16158|       |#define def(id, size, n_pop, n_push, f) && case_default,
16159|       |#endif
16160|  9.82M|#include "quickjs-opcode.h"
16161|  9.82M|        [ OP_COUNT ... 255 ] = &&case_default
16162|  9.82M|    };
16163|  80.7M|#define SWITCH(pc)      goto *dispatch_table[opcode = *pc++];
16164|  91.0M|#define CASE(op)        case_ ## op
16165|  9.82M|#define DEFAULT         case_default
16166|  80.4M|#define BREAK           SWITCH(pc)
16167|  9.82M|#endif
16168|       |
16169|  9.82M|    if (js_poll_interrupts(caller_ctx))
16170|      0|        return JS_EXCEPTION;
16171|  9.82M|    if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)) {
16172|    536|        if (flags & JS_CALL_FLAG_GENERATOR) {
16173|    367|            JSAsyncFunctionState *s = JS_VALUE_GET_PTR(func_obj);
16174|       |            /* func_obj get contains a pointer to JSFuncAsyncState */
16175|       |            /* the stack frame is already allocated */
16176|    367|            sf = &s->frame;
16177|    367|            p = JS_VALUE_GET_OBJ(sf->cur_func);
16178|    367|            b = p->u.func.function_bytecode;
16179|    367|            ctx = b->realm;
16180|    367|            var_refs = p->u.func.var_refs;
16181|    367|            local_buf = arg_buf = sf->arg_buf;
16182|    367|            var_buf = sf->var_buf;
16183|    367|            stack_buf = sf->var_buf + b->var_count;
16184|    367|            sp = sf->cur_sp;
16185|    367|            sf->cur_sp = NULL; /* cur_sp is NULL if the function is running */
16186|    367|            pc = sf->cur_pc;
16187|    367|            sf->prev_frame = rt->current_stack_frame;
16188|    367|            rt->current_stack_frame = sf;
16189|    367|            if (s->throw_flag)
16190|      0|                goto exception;
16191|    367|            else
16192|    367|                goto restart;
16193|    367|        } else {
16194|    169|            goto not_a_function;
16195|    169|        }
16196|    536|    }
16197|  9.82M|    p = JS_VALUE_GET_OBJ(func_obj);
16198|  9.82M|    if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
16199|  9.57M|        JSClassCall *call_func;
16200|  9.57M|        call_func = rt->class_array[p->class_id].call;
16201|  9.57M|        if (!call_func) {
16202|    193|        not_a_function:
16203|    193|            return JS_ThrowTypeError(caller_ctx, "not a function");
16204|     24|        }
16205|  9.57M|        return call_func(caller_ctx, func_obj, this_obj, argc,
16206|  9.57M|                         (JSValueConst *)argv, flags);
16207|  9.57M|    }
16208|   247k|    b = p->u.func.function_bytecode;
16209|       |
16210|   247k|    if (unlikely(argc < b->arg_count || (flags & JS_CALL_FLAG_COPY_ARGV))) {
16211|   239k|        arg_allocated_size = b->arg_count;
16212|   239k|    } else {
16213|  7.65k|        arg_allocated_size = 0;
16214|  7.65k|    }
16215|       |
16216|   247k|    alloca_size = sizeof(JSValue) * (arg_allocated_size + b->var_count +
16217|   247k|                                     b->stack_size);
16218|   247k|    if (js_check_stack_overflow(rt, alloca_size))
16219|     80|        return JS_ThrowStackOverflow(caller_ctx);
16220|       |
16221|   247k|    sf->js_mode = b->js_mode;
16222|   247k|    arg_buf = argv;
16223|   247k|    sf->arg_count = argc;
16224|   247k|    sf->cur_func = (JSValue)func_obj;
16225|   247k|    init_list_head(&sf->var_ref_list);
16226|   247k|    var_refs = p->u.func.var_refs;
16227|       |
16228|   247k|    local_buf = alloca(alloca_size);
16229|   247k|    if (unlikely(arg_allocated_size)) {
16230|   230k|        int n = min_int(argc, b->arg_count);
16231|   230k|        arg_buf = local_buf;
16232|   230k|        for(i = 0; i < n; i++)
16233|      0|            arg_buf[i] = JS_DupValue(caller_ctx, argv[i]);
16234|   460k|        for(; i < b->arg_count; i++)
16235|   230k|            arg_buf[i] = JS_UNDEFINED;
16236|   230k|        sf->arg_count = b->arg_count;
16237|   230k|    }
16238|   247k|    var_buf = local_buf + arg_allocated_size;
16239|   247k|    sf->var_buf = var_buf;
16240|   247k|    sf->arg_buf = arg_buf;
16241|       |
16242|   266k|    for(i = 0; i < b->var_count; i++)
16243|   247k|        var_buf[i] = JS_UNDEFINED;
16244|       |
16245|   247k|    stack_buf = var_buf + b->var_count;
16246|   247k|    sp = stack_buf;
16247|   247k|    pc = b->byte_code_buf;
16248|   247k|    sf->prev_frame = rt->current_stack_frame;
16249|   247k|    rt->current_stack_frame = sf;
16250|   247k|    ctx = b->realm; /* set the current realm */
16251|       |
16252|   247k| restart:
16253|   247k|    for(;;) {
16254|   247k|        int call_argc;
16255|   247k|        JSValue *call_argv;
16256|       |
16257|   247k|        SWITCH(pc) {
16258|   536k|        CASE(OP_push_i32):
16259|   536k|            *sp++ = JS_NewInt32(ctx, get_u32(pc));
16260|   536k|            pc += 4;
16261|   536k|            BREAK;
16262|  4.84M|        CASE(OP_push_bigint_i32):
16263|  4.84M|            *sp++ = __JS_NewShortBigInt(ctx, (int)get_u32(pc));
16264|  4.84M|            pc += 4;
16265|  4.84M|            BREAK;
16266|  4.84M|        CASE(OP_push_const):
16267|  35.2k|            *sp++ = JS_DupValue(ctx, b->cpool[get_u32(pc)]);
16268|  35.2k|            pc += 4;
16269|  35.2k|            BREAK;
16270|  35.2k|#if SHORT_OPCODES
16271|  35.2k|        CASE(OP_push_minus1):
16272|  25.5k|        CASE(OP_push_0):
16273|   322k|        CASE(OP_push_1):
16274|   355k|        CASE(OP_push_2):
16275|   648k|        CASE(OP_push_3):
16276|  1.16M|        CASE(OP_push_4):
16277|  1.16M|        CASE(OP_push_5):
16278|  1.16M|        CASE(OP_push_6):
16279|  1.43M|        CASE(OP_push_7):
16280|  1.43M|            *sp++ = JS_NewInt32(ctx, opcode - OP_push_0);
16281|  1.43M|            BREAK;
16282|  2.70M|        CASE(OP_push_i8):
16283|  2.70M|            *sp++ = JS_NewInt32(ctx, get_i8(pc));
16284|  2.70M|            pc += 1;
16285|  2.70M|            BREAK;
16286|  3.30M|        CASE(OP_push_i16):
16287|  3.30M|            *sp++ = JS_NewInt32(ctx, get_i16(pc));
16288|  3.30M|            pc += 2;
16289|  3.30M|            BREAK;
16290|  5.54M|        CASE(OP_push_const8):
16291|  5.54M|            *sp++ = JS_DupValue(ctx, b->cpool[*pc++]);
16292|  5.54M|            BREAK;
16293|  5.54M|        CASE(OP_fclosure8):
16294|   143k|            *sp++ = js_closure(ctx, JS_DupValue(ctx, b->cpool[*pc++]), var_refs, sf);
16295|   143k|            if (unlikely(JS_IsException(sp[-1])))
16296|      0|                goto exception;
16297|   143k|            BREAK;
16298|   221k|        CASE(OP_push_empty_string):
16299|   221k|            *sp++ = JS_AtomToString(ctx, JS_ATOM_empty_string);
16300|   221k|            BREAK;
16301|   221k|        CASE(OP_get_length):
16302|      0|            {
16303|      0|                JSValue val;
16304|       |
16305|      0|                val = JS_GetProperty(ctx, sp[-1], JS_ATOM_length);
16306|      0|                if (unlikely(JS_IsException(val)))
16307|      0|                    goto exception;
16308|      0|                JS_FreeValue(ctx, sp[-1]);
16309|      0|                sp[-1] = val;
16310|      0|            }
16311|      0|            BREAK;
16312|      0|#endif
16313|  2.94M|        CASE(OP_push_atom_value):
16314|  2.94M|            *sp++ = JS_AtomToValue(ctx, get_u32(pc));
16315|  2.94M|            pc += 4;
16316|  2.94M|            BREAK;
16317|  2.94M|        CASE(OP_undefined):
16318|  1.87M|            *sp++ = JS_UNDEFINED;
16319|  1.87M|            BREAK;
16320|  1.87M|        CASE(OP_null):
16321|      0|            *sp++ = JS_NULL;
16322|      0|            BREAK;
16323|    734|        CASE(OP_push_this):
16324|       |            /* OP_push_this is only called at the start of a function */
16325|    734|            {
16326|    734|                JSValue val;
16327|    734|                if (!(b->js_mode & JS_MODE_STRICT)) {
16328|      0|                    uint32_t tag = JS_VALUE_GET_TAG(this_obj);
16329|      0|                    if (likely(tag == JS_TAG_OBJECT))
16330|      0|                        goto normal_this;
16331|      0|                    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED) {
16332|      0|                        val = JS_DupValue(ctx, ctx->global_obj);
16333|      0|                    } else {
16334|      0|                        val = JS_ToObject(ctx, this_obj);
16335|      0|                        if (JS_IsException(val))
16336|      0|                            goto exception;
16337|      0|                    }
16338|    734|                } else {
16339|    734|                normal_this:
16340|    734|                    val = JS_DupValue(ctx, this_obj);
16341|    734|                }
16342|    734|                *sp++ = val;
16343|    734|            }
16344|    734|            BREAK;
16345|    734|        CASE(OP_push_false):
16346|      0|            *sp++ = JS_FALSE;
16347|      0|            BREAK;
16348|      0|        CASE(OP_push_true):
16349|      0|            *sp++ = JS_TRUE;
16350|      0|            BREAK;
16351|     74|        CASE(OP_object):
16352|     74|            *sp++ = JS_NewObject(ctx);
16353|     74|            if (unlikely(JS_IsException(sp[-1])))
16354|      0|                goto exception;
16355|     74|            BREAK;
16356|     74|        CASE(OP_special_object):
16357|      0|            {
16358|      0|                int arg = *pc++;
16359|      0|                switch(arg) {
16360|      0|                case OP_SPECIAL_OBJECT_ARGUMENTS:
16361|      0|                    *sp++ = js_build_arguments(ctx, argc, (JSValueConst *)argv);
16362|      0|                    if (unlikely(JS_IsException(sp[-1])))
16363|      0|                        goto exception;
16364|      0|                    break;
16365|      0|                case OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS:
16366|      0|                    *sp++ = js_build_mapped_arguments(ctx, argc, (JSValueConst *)argv,
16367|      0|                                                      sf, min_int(argc, b->arg_count));
16368|      0|                    if (unlikely(JS_IsException(sp[-1])))
16369|      0|                        goto exception;
16370|      0|                    break;
16371|      0|                case OP_SPECIAL_OBJECT_THIS_FUNC:
16372|      0|                    *sp++ = JS_DupValue(ctx, sf->cur_func);
16373|      0|                    break;
16374|      0|                case OP_SPECIAL_OBJECT_NEW_TARGET:
16375|      0|                    *sp++ = JS_DupValue(ctx, new_target);
16376|      0|                    break;
16377|      0|                case OP_SPECIAL_OBJECT_HOME_OBJECT:
16378|      0|                    {
16379|      0|                        JSObject *p1;
16380|      0|                        p1 = p->u.func.home_object;
16381|      0|                        if (unlikely(!p1))
16382|      0|                            *sp++ = JS_UNDEFINED;
16383|      0|                        else
16384|      0|                            *sp++ = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));
16385|      0|                    }
16386|      0|                    break;
16387|      0|                case OP_SPECIAL_OBJECT_VAR_OBJECT:
16388|      0|                    *sp++ = JS_NewObjectProto(ctx, JS_NULL);
16389|      0|                    if (unlikely(JS_IsException(sp[-1])))
16390|      0|                        goto exception;
16391|      0|                    break;
16392|      0|                case OP_SPECIAL_OBJECT_IMPORT_META:
16393|      0|                    *sp++ = js_import_meta(ctx);
16394|      0|                    if (unlikely(JS_IsException(sp[-1])))
16395|      0|                        goto exception;
16396|      0|                    break;
16397|      0|                default:
16398|      0|                    abort();
16399|      0|                }
16400|      0|            }
16401|      0|            BREAK;
16402|      0|        CASE(OP_rest):
16403|      0|            {
16404|      0|                int first = get_u16(pc);
16405|      0|                pc += 2;
16406|      0|                *sp++ = js_build_rest(ctx, first, argc, (JSValueConst *)argv);
16407|      0|                if (unlikely(JS_IsException(sp[-1])))
16408|      0|                    goto exception;
16409|      0|            }
16410|      0|            BREAK;
16411|       |
16412|  6.09M|        CASE(OP_drop):
16413|  6.09M|            JS_FreeValue(ctx, sp[-1]);
16414|  6.09M|            sp--;
16415|  6.09M|            BREAK;
16416|  6.09M|        CASE(OP_nip):
16417|    514|            JS_FreeValue(ctx, sp[-2]);
16418|    514|            sp[-2] = sp[-1];
16419|    514|            sp--;
16420|    514|            BREAK;
16421|    514|        CASE(OP_nip1): /* a b c -> b c */
16422|      0|            JS_FreeValue(ctx, sp[-3]);
16423|      0|            sp[-3] = sp[-2];
16424|      0|            sp[-2] = sp[-1];
16425|      0|            sp--;
16426|      0|            BREAK;
16427|  1.86M|        CASE(OP_dup):
16428|  1.86M|            sp[0] = JS_DupValue(ctx, sp[-1]);
16429|  1.86M|            sp++;
16430|  1.86M|            BREAK;
16431|  1.86M|        CASE(OP_dup2): /* a b -> a b a b */
16432|  38.8k|            sp[0] = JS_DupValue(ctx, sp[-2]);
16433|  38.8k|            sp[1] = JS_DupValue(ctx, sp[-1]);
16434|  38.8k|            sp += 2;
16435|  38.8k|            BREAK;
16436|  38.8k|        CASE(OP_dup3): /* a b c -> a b c a b c */
16437|      0|            sp[0] = JS_DupValue(ctx, sp[-3]);
16438|      0|            sp[1] = JS_DupValue(ctx, sp[-2]);
16439|      0|            sp[2] = JS_DupValue(ctx, sp[-1]);
16440|      0|            sp += 3;
16441|      0|            BREAK;
16442|      0|        CASE(OP_dup1): /* a b -> a a b */
16443|      0|            sp[0] = sp[-1];
16444|      0|            sp[-1] = JS_DupValue(ctx, sp[-2]);
16445|      0|            sp++;
16446|      0|            BREAK;
16447|  28.8k|        CASE(OP_insert2): /* obj a -> a obj a (dup_x1) */
16448|  28.8k|            sp[0] = sp[-1];
16449|  28.8k|            sp[-1] = sp[-2];
16450|  28.8k|            sp[-2] = JS_DupValue(ctx, sp[0]);
16451|  28.8k|            sp++;
16452|  28.8k|            BREAK;
16453|  37.1k|        CASE(OP_insert3): /* obj prop a -> a obj prop a (dup_x2) */
16454|  37.1k|            sp[0] = sp[-1];
16455|  37.1k|            sp[-1] = sp[-2];
16456|  37.1k|            sp[-2] = sp[-3];
16457|  37.1k|            sp[-3] = JS_DupValue(ctx, sp[0]);
16458|  37.1k|            sp++;
16459|  37.1k|            BREAK;
16460|  37.1k|        CASE(OP_insert4): /* this obj prop a -> a this obj prop a */
16461|      0|            sp[0] = sp[-1];
16462|      0|            sp[-1] = sp[-2];
16463|      0|            sp[-2] = sp[-3];
16464|      0|            sp[-3] = sp[-4];
16465|      0|            sp[-4] = JS_DupValue(ctx, sp[0]);
16466|      0|            sp++;
16467|      0|            BREAK;
16468|  13.4k|        CASE(OP_perm3): /* obj a b -> a obj b (213) */
16469|  13.4k|            {
16470|  13.4k|                JSValue tmp;
16471|  13.4k|                tmp = sp[-2];
16472|  13.4k|                sp[-2] = sp[-3];
16473|  13.4k|                sp[-3] = tmp;
16474|  13.4k|            }
16475|  13.4k|            BREAK;
16476|  13.4k|        CASE(OP_rot3l): /* x a b -> a b x (231) */
16477|  2.11k|            {
16478|  2.11k|                JSValue tmp;
16479|  2.11k|                tmp = sp[-3];
16480|  2.11k|                sp[-3] = sp[-2];
16481|  2.11k|                sp[-2] = sp[-1];
16482|  2.11k|                sp[-1] = tmp;
16483|  2.11k|            }
16484|  2.11k|            BREAK;
16485|  2.11k|        CASE(OP_rot4l): /* x a b c -> a b c x */
16486|      0|            {
16487|      0|                JSValue tmp;
16488|      0|                tmp = sp[-4];
16489|      0|                sp[-4] = sp[-3];
16490|      0|                sp[-3] = sp[-2];
16491|      0|                sp[-2] = sp[-1];
16492|      0|                sp[-1] = tmp;
16493|      0|            }
16494|      0|            BREAK;
16495|      0|        CASE(OP_rot5l): /* x a b c d -> a b c d x */
16496|      0|            {
16497|      0|                JSValue tmp;
16498|      0|                tmp = sp[-5];
16499|      0|                sp[-5] = sp[-4];
16500|      0|                sp[-4] = sp[-3];
16501|      0|                sp[-3] = sp[-2];
16502|      0|                sp[-2] = sp[-1];
16503|      0|                sp[-1] = tmp;
16504|      0|            }
16505|      0|            BREAK;
16506|      0|        CASE(OP_rot3r): /* a b x -> x a b (312) */
16507|      0|            {
16508|      0|                JSValue tmp;
16509|      0|                tmp = sp[-1];
16510|      0|                sp[-1] = sp[-2];
16511|      0|                sp[-2] = sp[-3];
16512|      0|                sp[-3] = tmp;
16513|      0|            }
16514|      0|            BREAK;
16515|  2.21k|        CASE(OP_perm4): /* obj prop a b -> a obj prop b */
16516|  2.21k|            {
16517|  2.21k|                JSValue tmp;
16518|  2.21k|                tmp = sp[-2];
16519|  2.21k|                sp[-2] = sp[-3];
16520|  2.21k|                sp[-3] = sp[-4];
16521|  2.21k|                sp[-4] = tmp;
16522|  2.21k|            }
16523|  2.21k|            BREAK;
16524|  2.21k|        CASE(OP_perm5): /* this obj prop a b -> a this obj prop b */
16525|      0|            {
16526|      0|                JSValue tmp;
16527|      0|                tmp = sp[-2];
16528|      0|                sp[-2] = sp[-3];
16529|      0|                sp[-3] = sp[-4];
16530|      0|                sp[-4] = sp[-5];
16531|      0|                sp[-5] = tmp;
16532|      0|            }
16533|      0|            BREAK;
16534|    550|        CASE(OP_swap): /* a b -> b a */
16535|    550|            {
16536|    550|                JSValue tmp;
16537|    550|                tmp = sp[-2];
16538|    550|                sp[-2] = sp[-1];
16539|    550|                sp[-1] = tmp;
16540|    550|            }
16541|    550|            BREAK;
16542|    550|        CASE(OP_swap2): /* a b c d -> c d a b */
16543|      0|            {
16544|      0|                JSValue tmp1, tmp2;
16545|      0|                tmp1 = sp[-4];
16546|      0|                tmp2 = sp[-3];
16547|      0|                sp[-4] = sp[-2];
16548|      0|                sp[-3] = sp[-1];
16549|      0|                sp[-2] = tmp1;
16550|      0|                sp[-1] = tmp2;
16551|      0|            }
16552|      0|            BREAK;
16553|       |
16554|  3.83k|        CASE(OP_fclosure):
16555|  3.83k|            {
16556|  3.83k|                JSValue bfunc = JS_DupValue(ctx, b->cpool[get_u32(pc)]);
16557|  3.83k|                pc += 4;
16558|  3.83k|                *sp++ = js_closure(ctx, bfunc, var_refs, sf);
16559|  3.83k|                if (unlikely(JS_IsException(sp[-1])))
16560|      0|                    goto exception;
16561|  3.83k|            }
16562|  3.83k|            BREAK;
16563|  3.83k|#if SHORT_OPCODES
16564|   227k|        CASE(OP_call0):
16565|   234k|        CASE(OP_call1):
16566|   235k|        CASE(OP_call2):
16567|   235k|        CASE(OP_call3):
16568|   235k|            call_argc = opcode - OP_call0;
16569|   235k|            goto has_call_argc;
16570|      0|#endif
16571|      7|        CASE(OP_call):
16572|  2.66k|        CASE(OP_tail_call):
16573|  2.66k|            {
16574|  2.66k|                call_argc = get_u16(pc);
16575|  2.66k|                pc += 2;
16576|  2.66k|                goto has_call_argc;
16577|   238k|            has_call_argc:
16578|   238k|                call_argv = sp - call_argc;
16579|   238k|                sf->cur_pc = pc;
16580|   238k|                ret_val = JS_CallInternal(ctx, call_argv[-1], JS_UNDEFINED,
16581|   238k|                                          JS_UNDEFINED, call_argc, call_argv, 0);
16582|   238k|                if (unlikely(JS_IsException(ret_val)))
16583|   139k|                    goto exception;
16584|  98.8k|                if (opcode == OP_tail_call)
16585|    584|                    goto done;
16586|   198k|                for(i = -1; i < call_argc; i++)
16587|  99.9k|                    JS_FreeValue(ctx, call_argv[i]);
16588|  98.3k|                sp -= call_argc + 1;
16589|  98.3k|                *sp++ = ret_val;
16590|  98.3k|            }
16591|  98.3k|            BREAK;
16592|  98.3k|        CASE(OP_call_constructor):
16593|      2|            {
16594|      2|                call_argc = get_u16(pc);
16595|      2|                pc += 2;
16596|      2|                call_argv = sp - call_argc;
16597|      2|                sf->cur_pc = pc;
16598|      2|                ret_val = JS_CallConstructorInternal(ctx, call_argv[-2],
16599|      2|                                                     call_argv[-1],
16600|      2|                                                     call_argc, call_argv, 0);
16601|      2|                if (unlikely(JS_IsException(ret_val)))
16602|      2|                    goto exception;
16603|      0|                for(i = -2; i < call_argc; i++)
16604|      0|                    JS_FreeValue(ctx, call_argv[i]);
16605|      0|                sp -= call_argc + 2;
16606|      0|                *sp++ = ret_val;
16607|      0|            }
16608|      0|            BREAK;
16609|  2.76k|        CASE(OP_call_method):
16610|  2.76k|        CASE(OP_tail_call_method):
16611|  2.76k|            {
16612|  2.76k|                call_argc = get_u16(pc);
16613|  2.76k|                pc += 2;
16614|  2.76k|                call_argv = sp - call_argc;
16615|  2.76k|                sf->cur_pc = pc;
16616|  2.76k|                ret_val = JS_CallInternal(ctx, call_argv[-1], call_argv[-2],
16617|  2.76k|                                          JS_UNDEFINED, call_argc, call_argv, 0);
16618|  2.76k|                if (unlikely(JS_IsException(ret_val)))
16619|     48|                    goto exception;
16620|  2.71k|                if (opcode == OP_tail_call_method)
16621|      0|                    goto done;
16622|  40.7k|                for(i = -2; i < call_argc; i++)
16623|  38.0k|                    JS_FreeValue(ctx, call_argv[i]);
16624|  2.71k|                sp -= call_argc + 2;
16625|  2.71k|                *sp++ = ret_val;
16626|  2.71k|            }
16627|  2.71k|            BREAK;
16628|   357k|        CASE(OP_array_from):
16629|   357k|            {
16630|   357k|                int i, ret;
16631|       |
16632|   357k|                call_argc = get_u16(pc);
16633|   357k|                pc += 2;
16634|   357k|                ret_val = JS_NewArray(ctx);
16635|   357k|                if (unlikely(JS_IsException(ret_val)))
16636|      0|                    goto exception;
16637|   357k|                call_argv = sp - call_argc;
16638|   549k|                for(i = 0; i < call_argc; i++) {
16639|   192k|                    ret = JS_DefinePropertyValue(ctx, ret_val, __JS_AtomFromUInt32(i), call_argv[i],
16640|   192k|                                                 JS_PROP_C_W_E | JS_PROP_THROW);
16641|   192k|                    call_argv[i] = JS_UNDEFINED;
16642|   192k|                    if (ret < 0) {
16643|      0|                        JS_FreeValue(ctx, ret_val);
16644|      0|                        goto exception;
16645|      0|                    }
16646|   192k|                }
16647|   357k|                sp -= call_argc;
16648|   357k|                *sp++ = ret_val;
16649|   357k|            }
16650|   357k|            BREAK;
16651|       |
16652|   357k|        CASE(OP_apply):
16653|      0|            {
16654|      0|                int magic;
16655|      0|                magic = get_u16(pc);
16656|      0|                pc += 2;
16657|       |
16658|      0|                ret_val = js_function_apply(ctx, sp[-3], 2, (JSValueConst *)&sp[-2], magic);
16659|      0|                if (unlikely(JS_IsException(ret_val)))
16660|      0|                    goto exception;
16661|      0|                JS_FreeValue(ctx, sp[-3]);
16662|      0|                JS_FreeValue(ctx, sp[-2]);
16663|      0|                JS_FreeValue(ctx, sp[-1]);
16664|      0|                sp -= 3;
16665|      0|                *sp++ = ret_val;
16666|      0|            }
16667|      0|            BREAK;
16668|   101k|        CASE(OP_return):
16669|   101k|            ret_val = *--sp;
16670|   101k|            goto done;
16671|    367|        CASE(OP_return_undef):
16672|    367|            ret_val = JS_UNDEFINED;
16673|    367|            goto done;
16674|       |
16675|      0|        CASE(OP_check_ctor_return):
16676|       |            /* return TRUE if 'this' should be returned */
16677|      0|            if (!JS_IsObject(sp[-1])) {
16678|      0|                if (!JS_IsUndefined(sp[-1])) {
16679|      0|                    JS_ThrowTypeError(caller_ctx, "derived class constructor must return an object or undefined");
16680|      0|                    goto exception;
16681|      0|                }
16682|      0|                sp[0] = JS_TRUE;
16683|      0|            } else {
16684|      0|                sp[0] = JS_FALSE;
16685|      0|            }
16686|      0|            sp++;
16687|      0|            BREAK;
16688|      0|        CASE(OP_check_ctor):
16689|      0|            if (JS_IsUndefined(new_target)) {
16690|      0|            non_ctor_call:
16691|      0|                JS_ThrowTypeError(ctx, "class constructors must be invoked with 'new'");
16692|      0|                goto exception;
16693|      0|            }
16694|      0|            BREAK;
16695|      0|        CASE(OP_init_ctor):
16696|      0|            {
16697|      0|                JSValue super, ret;
16698|      0|                sf->cur_pc = pc;
16699|      0|                if (JS_IsUndefined(new_target))
16700|      0|                    goto non_ctor_call;
16701|      0|                super = JS_GetPrototype(ctx, func_obj);
16702|      0|                if (JS_IsException(super))
16703|      0|                    goto exception;
16704|      0|                ret = JS_CallConstructor2(ctx, super, new_target, argc, (JSValueConst *)argv);
16705|      0|                JS_FreeValue(ctx, super);
16706|      0|                if (JS_IsException(ret))
16707|      0|                    goto exception;
16708|      0|                *sp++ = ret;
16709|      0|            }
16710|      0|            BREAK;
16711|      0|        CASE(OP_check_brand):
16712|      0|            {
16713|      0|                int ret = JS_CheckBrand(ctx, sp[-2], sp[-1]);
16714|      0|                if (ret < 0)
16715|      0|                    goto exception;
16716|      0|                if (!ret) {
16717|      0|                    JS_ThrowTypeError(ctx, "invalid brand on object");
16718|      0|                    goto exception;
16719|      0|                }
16720|      0|            }
16721|      0|            BREAK;
16722|      0|        CASE(OP_add_brand):
16723|      0|            if (JS_AddBrand(ctx, sp[-2], sp[-1]) < 0)
16724|      0|                goto exception;
16725|      0|            JS_FreeValue(ctx, sp[-2]);
16726|      0|            JS_FreeValue(ctx, sp[-1]);
16727|      0|            sp -= 2;
16728|      0|            BREAK;
16729|       |
16730|     28|        CASE(OP_throw):
16731|     28|            JS_Throw(ctx, *--sp);
16732|     28|            goto exception;
16733|       |
16734|     11|        CASE(OP_throw_error):
16735|  2.49k|#define JS_THROW_VAR_RO             0
16736|     11|#define JS_THROW_VAR_REDECL         1
16737|     11|#define JS_THROW_VAR_UNINITIALIZED  2
16738|     11|#define JS_THROW_ERROR_DELETE_SUPER   3
16739|     11|#define JS_THROW_ERROR_ITERATOR_THROW 4
16740|     11|            {
16741|     11|                JSAtom atom;
16742|     11|                int type;
16743|     11|                atom = get_u32(pc);
16744|     11|                type = pc[4];
16745|     11|                pc += 5;
16746|     11|                if (type == JS_THROW_VAR_RO)
16747|     11|                    JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, atom);
16748|      0|                else
16749|      0|                if (type == JS_THROW_VAR_REDECL)
16750|      0|                    JS_ThrowSyntaxErrorVarRedeclaration(ctx, atom);
16751|      0|                else
16752|      0|                if (type == JS_THROW_VAR_UNINITIALIZED)
16753|      0|                    JS_ThrowReferenceErrorUninitialized(ctx, atom);
16754|      0|                else
16755|      0|                if (type == JS_THROW_ERROR_DELETE_SUPER)
16756|      0|                    JS_ThrowReferenceError(ctx, "unsupported reference to 'super'");
16757|      0|                else
16758|      0|                if (type == JS_THROW_ERROR_ITERATOR_THROW)
16759|      0|                    JS_ThrowTypeError(ctx, "iterator does not have a throw method");
16760|      0|                else
16761|      0|                    JS_ThrowInternalError(ctx, "invalid throw var type %d", type);
16762|     11|            }
16763|     11|            goto exception;
16764|       |
16765|      0|        CASE(OP_eval):
16766|      0|            {
16767|      0|                JSValueConst obj;
16768|      0|                int scope_idx;
16769|      0|                call_argc = get_u16(pc);
16770|      0|                scope_idx = get_u16(pc + 2) + ARG_SCOPE_END;
16771|      0|                pc += 4;
16772|      0|                call_argv = sp - call_argc;
16773|      0|                sf->cur_pc = pc;
16774|      0|                if (js_same_value(ctx, call_argv[-1], ctx->eval_obj)) {
16775|      0|                    if (call_argc >= 1)
16776|      0|                        obj = call_argv[0];
16777|      0|                    else
16778|      0|                        obj = JS_UNDEFINED;
16779|      0|                    ret_val = JS_EvalObject(ctx, JS_UNDEFINED, obj,
16780|      0|                                            JS_EVAL_TYPE_DIRECT, scope_idx);
16781|      0|                } else {
16782|      0|                    ret_val = JS_CallInternal(ctx, call_argv[-1], JS_UNDEFINED,
16783|      0|                                              JS_UNDEFINED, call_argc, call_argv, 0);
16784|      0|                }
16785|      0|                if (unlikely(JS_IsException(ret_val)))
16786|      0|                    goto exception;
16787|      0|                for(i = -1; i < call_argc; i++)
16788|      0|                    JS_FreeValue(ctx, call_argv[i]);
16789|      0|                sp -= call_argc + 1;
16790|      0|                *sp++ = ret_val;
16791|      0|            }
16792|      0|            BREAK;
16793|       |            /* could merge with OP_apply */
16794|      0|        CASE(OP_apply_eval):
16795|      0|            {
16796|      0|                int scope_idx;
16797|      0|                uint32_t len;
16798|      0|                JSValue *tab;
16799|      0|                JSValueConst obj;
16800|       |
16801|      0|                scope_idx = get_u16(pc) + ARG_SCOPE_END;
16802|      0|                pc += 2;
16803|      0|                tab = build_arg_list(ctx, &len, sp[-1]);
16804|      0|                if (!tab)
16805|      0|                    goto exception;
16806|      0|                if (js_same_value(ctx, sp[-2], ctx->eval_obj)) {
16807|      0|                    if (len >= 1)
16808|      0|                        obj = tab[0];
16809|      0|                    else
16810|      0|                        obj = JS_UNDEFINED;
16811|      0|                    ret_val = JS_EvalObject(ctx, JS_UNDEFINED, obj,
16812|      0|                                            JS_EVAL_TYPE_DIRECT, scope_idx);
16813|      0|                } else {
16814|      0|                    ret_val = JS_Call(ctx, sp[-2], JS_UNDEFINED, len,
16815|      0|                                      (JSValueConst *)tab);
16816|      0|                }
16817|      0|                free_arg_list(ctx, tab, len);
16818|      0|                if (unlikely(JS_IsException(ret_val)))
16819|      0|                    goto exception;
16820|      0|                JS_FreeValue(ctx, sp[-2]);
16821|      0|                JS_FreeValue(ctx, sp[-1]);
16822|      0|                sp -= 2;
16823|      0|                *sp++ = ret_val;
16824|      0|            }
16825|      0|            BREAK;
16826|       |
16827|   849k|        CASE(OP_regexp):
16828|   849k|            {
16829|   849k|                sp[-2] = js_regexp_constructor_internal(ctx, JS_UNDEFINED,
16830|   849k|                                                        sp[-2], sp[-1]);
16831|   849k|                sp--;
16832|   849k|            }
16833|   849k|            BREAK;
16834|       |
16835|   849k|        CASE(OP_get_super):
16836|      0|            {
16837|      0|                JSValue proto;
16838|      0|                proto = JS_GetPrototype(ctx, sp[-1]);
16839|      0|                if (JS_IsException(proto))
16840|      0|                    goto exception;
16841|      0|                JS_FreeValue(ctx, sp[-1]);
16842|      0|                sp[-1] = proto;
16843|      0|            }
16844|      0|            BREAK;
16845|       |
16846|      0|        CASE(OP_import):
16847|      0|            {
16848|      0|                JSValue val;
16849|      0|                val = js_dynamic_import(ctx, sp[-1]);
16850|      0|                if (JS_IsException(val))
16851|      0|                    goto exception;
16852|      0|                JS_FreeValue(ctx, sp[-1]);
16853|      0|                sp[-1] = val;
16854|      0|            }
16855|      0|            BREAK;
16856|       |
16857|    365|        CASE(OP_check_var):
16858|    365|            {
16859|    365|                int ret;
16860|    365|                JSAtom atom;
16861|    365|                atom = get_u32(pc);
16862|    365|                pc += 4;
16863|       |
16864|    365|                ret = JS_CheckGlobalVar(ctx, atom);
16865|    365|                if (ret < 0)
16866|      0|                    goto exception;
16867|    365|                *sp++ = JS_NewBool(ctx, ret);
16868|    365|            }
16869|    365|            BREAK;
16870|       |
16871|    365|        CASE(OP_get_var_undef):
16872|  55.4k|        CASE(OP_get_var):
16873|  55.4k|            {
16874|  55.4k|                JSValue val;
16875|  55.4k|                JSAtom atom;
16876|  55.4k|                atom = get_u32(pc);
16877|  55.4k|                pc += 4;
16878|       |
16879|  55.4k|                val = JS_GetGlobalVar(ctx, atom, opcode - OP_get_var_undef);
16880|  55.4k|                if (unlikely(JS_IsException(val)))
16881|  3.94k|                    goto exception;
16882|  51.4k|                *sp++ = val;
16883|  51.4k|            }
16884|  51.4k|            BREAK;
16885|       |
16886|  4.71M|        CASE(OP_put_var):
16887|  4.71M|        CASE(OP_put_var_init):
16888|  4.71M|            {
16889|  4.71M|                int ret;
16890|  4.71M|                JSAtom atom;
16891|  4.71M|                atom = get_u32(pc);
16892|  4.71M|                pc += 4;
16893|       |
16894|  4.71M|                ret = JS_SetGlobalVar(ctx, atom, sp[-1], opcode - OP_put_var);
16895|  4.71M|                sp--;
16896|  4.71M|                if (unlikely(ret < 0))
16897|      3|                    goto exception;
16898|  4.71M|            }
16899|  4.71M|            BREAK;
16900|       |
16901|  4.71M|        CASE(OP_put_var_strict):
16902|    153|            {
16903|    153|                int ret;
16904|    153|                JSAtom atom;
16905|    153|                atom = get_u32(pc);
16906|    153|                pc += 4;
16907|       |
16908|       |                /* sp[-2] is JS_TRUE or JS_FALSE */
16909|    153|                if (unlikely(!JS_VALUE_GET_INT(sp[-2]))) {
16910|    153|                    JS_ThrowReferenceErrorNotDefined(ctx, atom);
16911|    153|                    goto exception;
16912|    153|                }
16913|      0|                ret = JS_SetGlobalVar(ctx, atom, sp[-1], 2);
16914|      0|                sp -= 2;
16915|      0|                if (unlikely(ret < 0))
16916|      0|                    goto exception;
16917|      0|            }
16918|      0|            BREAK;
16919|       |
16920|  2.75k|        CASE(OP_check_define_var):
16921|  2.75k|            {
16922|  2.75k|                JSAtom atom;
16923|  2.75k|                int flags;
16924|  2.75k|                atom = get_u32(pc);
16925|  2.75k|                flags = pc[4];
16926|  2.75k|                pc += 5;
16927|  2.75k|                if (JS_CheckDefineGlobalVar(ctx, atom, flags))
16928|      0|                    goto exception;
16929|  2.75k|            }
16930|  2.75k|            BREAK;
16931|  2.75k|        CASE(OP_define_var):
16932|  2.75k|            {
16933|  2.75k|                JSAtom atom;
16934|  2.75k|                int flags;
16935|  2.75k|                atom = get_u32(pc);
16936|  2.75k|                flags = pc[4];
16937|  2.75k|                pc += 5;
16938|  2.75k|                if (JS_DefineGlobalVar(ctx, atom, flags))
16939|      0|                    goto exception;
16940|  2.75k|            }
16941|  2.75k|            BREAK;
16942|  2.75k|        CASE(OP_define_func):
16943|      0|            {
16944|      0|                JSAtom atom;
16945|      0|                int flags;
16946|      0|                atom = get_u32(pc);
16947|      0|                flags = pc[4];
16948|      0|                pc += 5;
16949|      0|                if (JS_DefineGlobalFunction(ctx, atom, sp[-1], flags))
16950|      0|                    goto exception;
16951|      0|                JS_FreeValue(ctx, sp[-1]);
16952|      0|                sp--;
16953|      0|            }
16954|      0|            BREAK;
16955|       |
16956|      0|        CASE(OP_get_loc):
16957|      0|            {
16958|      0|                int idx;
16959|      0|                idx = get_u16(pc);
16960|      0|                pc += 2;
16961|      0|                sp[0] = JS_DupValue(ctx, var_buf[idx]);
16962|      0|                sp++;
16963|      0|            }
16964|      0|            BREAK;
16965|      0|        CASE(OP_put_loc):
16966|      0|            {
16967|      0|                int idx;
16968|      0|                idx = get_u16(pc);
16969|      0|                pc += 2;
16970|      0|                set_value(ctx, &var_buf[idx], sp[-1]);
16971|      0|                sp--;
16972|      0|            }
16973|      0|            BREAK;
16974|      0|        CASE(OP_set_loc):
16975|      0|            {
16976|      0|                int idx;
16977|      0|                idx = get_u16(pc);
16978|      0|                pc += 2;
16979|      0|                set_value(ctx, &var_buf[idx], JS_DupValue(ctx, sp[-1]));
16980|      0|            }
16981|      0|            BREAK;
16982|      0|        CASE(OP_get_arg):
16983|      0|            {
16984|      0|                int idx;
16985|      0|                idx = get_u16(pc);
16986|      0|                pc += 2;
16987|      0|                sp[0] = JS_DupValue(ctx, arg_buf[idx]);
16988|      0|                sp++;
16989|      0|            }
16990|      0|            BREAK;
16991|      0|        CASE(OP_put_arg):
16992|      0|            {
16993|      0|                int idx;
16994|      0|                idx = get_u16(pc);
16995|      0|                pc += 2;
16996|      0|                set_value(ctx, &arg_buf[idx], sp[-1]);
16997|      0|                sp--;
16998|      0|            }
16999|      0|            BREAK;
17000|      0|        CASE(OP_set_arg):
17001|      0|            {
17002|      0|                int idx;
17003|      0|                idx = get_u16(pc);
17004|      0|                pc += 2;
17005|      0|                set_value(ctx, &arg_buf[idx], JS_DupValue(ctx, sp[-1]));
17006|      0|            }
17007|      0|            BREAK;
17008|       |
17009|      0|#if SHORT_OPCODES
17010|      0|        CASE(OP_get_loc8): *sp++ = JS_DupValue(ctx, var_buf[*pc++]); BREAK;
17011|  95.0k|        CASE(OP_put_loc8): set_value(ctx, &var_buf[*pc++], *--sp); BREAK;
17012|  95.0k|        CASE(OP_set_loc8): set_value(ctx, &var_buf[*pc++], JS_DupValue(ctx, sp[-1])); BREAK;
17013|       |
17014|    155|        CASE(OP_get_loc0): *sp++ = JS_DupValue(ctx, var_buf[0]); BREAK;
17015|    155|        CASE(OP_get_loc1): *sp++ = JS_DupValue(ctx, var_buf[1]); BREAK;
17016|      0|        CASE(OP_get_loc2): *sp++ = JS_DupValue(ctx, var_buf[2]); BREAK;
17017|      0|        CASE(OP_get_loc3): *sp++ = JS_DupValue(ctx, var_buf[3]); BREAK;
17018|  1.95M|        CASE(OP_put_loc0): set_value(ctx, &var_buf[0], *--sp); BREAK;
17019|  1.95M|        CASE(OP_put_loc1): set_value(ctx, &var_buf[1], *--sp); BREAK;
17020|   194k|        CASE(OP_put_loc2): set_value(ctx, &var_buf[2], *--sp); BREAK;
17021|  81.3k|        CASE(OP_put_loc3): set_value(ctx, &var_buf[3], *--sp); BREAK;
17022|  57.0k|        CASE(OP_set_loc0): set_value(ctx, &var_buf[0], JS_DupValue(ctx, sp[-1])); BREAK;
17023|  3.29k|        CASE(OP_set_loc1): set_value(ctx, &var_buf[1], JS_DupValue(ctx, sp[-1])); BREAK;
17024|      0|        CASE(OP_set_loc2): set_value(ctx, &var_buf[2], JS_DupValue(ctx, sp[-1])); BREAK;
17025|      0|        CASE(OP_set_loc3): set_value(ctx, &var_buf[3], JS_DupValue(ctx, sp[-1])); BREAK;
17026|  2.11k|        CASE(OP_get_arg0): *sp++ = JS_DupValue(ctx, arg_buf[0]); BREAK;
17027|  2.11k|        CASE(OP_get_arg1): *sp++ = JS_DupValue(ctx, arg_buf[1]); BREAK;
17028|      0|        CASE(OP_get_arg2): *sp++ = JS_DupValue(ctx, arg_buf[2]); BREAK;
17029|      0|        CASE(OP_get_arg3): *sp++ = JS_DupValue(ctx, arg_buf[3]); BREAK;
17030|     71|        CASE(OP_put_arg0): set_value(ctx, &arg_buf[0], *--sp); BREAK;
17031|     71|        CASE(OP_put_arg1): set_value(ctx, &arg_buf[1], *--sp); BREAK;
17032|      0|        CASE(OP_put_arg2): set_value(ctx, &arg_buf[2], *--sp); BREAK;
17033|      0|        CASE(OP_put_arg3): set_value(ctx, &arg_buf[3], *--sp); BREAK;
17034|  14.9k|        CASE(OP_set_arg0): set_value(ctx, &arg_buf[0], JS_DupValue(ctx, sp[-1])); BREAK;
17035|  14.9k|        CASE(OP_set_arg1): set_value(ctx, &arg_buf[1], JS_DupValue(ctx, sp[-1])); BREAK;
17036|      0|        CASE(OP_set_arg2): set_value(ctx, &arg_buf[2], JS_DupValue(ctx, sp[-1])); BREAK;
17037|      0|        CASE(OP_set_arg3): set_value(ctx, &arg_buf[3], JS_DupValue(ctx, sp[-1])); BREAK;
17038|  68.5k|        CASE(OP_get_var_ref0): *sp++ = JS_DupValue(ctx, *var_refs[0]->pvalue); BREAK;
17039|  68.5k|        CASE(OP_get_var_ref1): *sp++ = JS_DupValue(ctx, *var_refs[1]->pvalue); BREAK;
17040|  8.53k|        CASE(OP_get_var_ref2): *sp++ = JS_DupValue(ctx, *var_refs[2]->pvalue); BREAK;
17041|     53|        CASE(OP_get_var_ref3): *sp++ = JS_DupValue(ctx, *var_refs[3]->pvalue); BREAK;
17042|    909|        CASE(OP_put_var_ref0): set_value(ctx, var_refs[0]->pvalue, *--sp); BREAK;
17043|    909|        CASE(OP_put_var_ref1): set_value(ctx, var_refs[1]->pvalue, *--sp); BREAK;
17044|    417|        CASE(OP_put_var_ref2): set_value(ctx, var_refs[2]->pvalue, *--sp); BREAK;
17045|    630|        CASE(OP_put_var_ref3): set_value(ctx, var_refs[3]->pvalue, *--sp); BREAK;
17046|    897|        CASE(OP_set_var_ref0): set_value(ctx, var_refs[0]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;
17047|    898|        CASE(OP_set_var_ref1): set_value(ctx, var_refs[1]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;
17048|    898|        CASE(OP_set_var_ref2): set_value(ctx, var_refs[2]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;
17049|    108|        CASE(OP_set_var_ref3): set_value(ctx, var_refs[3]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;
17050|    108|#endif
17051|       |
17052|    264|        CASE(OP_get_var_ref):
17053|    264|            {
17054|    264|                int idx;
17055|    264|                JSValue val;
17056|    264|                idx = get_u16(pc);
17057|    264|                pc += 2;
17058|    264|                val = *var_refs[idx]->pvalue;
17059|    264|                sp[0] = JS_DupValue(ctx, val);
17060|    264|                sp++;
17061|    264|            }
17062|    264|            BREAK;
17063|    264|        CASE(OP_put_var_ref):
17064|    157|            {
17065|    157|                int idx;
17066|    157|                idx = get_u16(pc);
17067|    157|                pc += 2;
17068|    157|                set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
17069|    157|                sp--;
17070|    157|            }
17071|    157|            BREAK;
17072|  1.05k|        CASE(OP_set_var_ref):
17073|  1.05k|            {
17074|  1.05k|                int idx;
17075|  1.05k|                idx = get_u16(pc);
17076|  1.05k|                pc += 2;
17077|  1.05k|                set_value(ctx, var_refs[idx]->pvalue, JS_DupValue(ctx, sp[-1]));
17078|  1.05k|            }
17079|  1.05k|            BREAK;
17080|   259k|        CASE(OP_get_var_ref_check):
17081|   259k|            {
17082|   259k|                int idx;
17083|   259k|                JSValue val;
17084|   259k|                idx = get_u16(pc);
17085|   259k|                pc += 2;
17086|   259k|                val = *var_refs[idx]->pvalue;
17087|   259k|                if (unlikely(JS_IsUninitialized(val))) {
17088|      5|                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);
17089|      5|                    goto exception;
17090|      5|                }
17091|   259k|                sp[0] = JS_DupValue(ctx, val);
17092|   259k|                sp++;
17093|   259k|            }
17094|   259k|            BREAK;
17095|   259k|        CASE(OP_put_var_ref_check):
17096|  51.9k|            {
17097|  51.9k|                int idx;
17098|  51.9k|                idx = get_u16(pc);
17099|  51.9k|                pc += 2;
17100|  51.9k|                if (unlikely(JS_IsUninitialized(*var_refs[idx]->pvalue))) {
17101|      1|                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);
17102|      1|                    goto exception;
17103|      1|                }
17104|  51.9k|                set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
17105|  51.9k|                sp--;
17106|  51.9k|            }
17107|  51.9k|            BREAK;
17108|  51.9k|        CASE(OP_put_var_ref_check_init):
17109|      0|            {
17110|      0|                int idx;
17111|      0|                idx = get_u16(pc);
17112|      0|                pc += 2;
17113|      0|                if (unlikely(!JS_IsUninitialized(*var_refs[idx]->pvalue))) {
17114|      0|                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);
17115|      0|                    goto exception;
17116|      0|                }
17117|      0|                set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
17118|      0|                sp--;
17119|      0|            }
17120|      0|            BREAK;
17121|  13.4k|        CASE(OP_set_loc_uninitialized):
17122|  13.4k|            {
17123|  13.4k|                int idx;
17124|  13.4k|                idx = get_u16(pc);
17125|  13.4k|                pc += 2;
17126|  13.4k|                set_value(ctx, &var_buf[idx], JS_UNINITIALIZED);
17127|  13.4k|            }
17128|  13.4k|            BREAK;
17129|  25.5k|        CASE(OP_get_loc_check):
17130|  25.5k|            {
17131|  25.5k|                int idx;
17132|  25.5k|                idx = get_u16(pc);
17133|  25.5k|                pc += 2;
17134|  25.5k|                if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
17135|      2|                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);
17136|      2|                    goto exception;
17137|      2|                }
17138|  25.5k|                sp[0] = JS_DupValue(ctx, var_buf[idx]);
17139|  25.5k|                sp++;
17140|  25.5k|            }
17141|  25.5k|            BREAK;
17142|  25.5k|        CASE(OP_get_loc_checkthis):
17143|      0|            {
17144|      0|                int idx;
17145|      0|                idx = get_u16(pc);
17146|      0|                pc += 2;
17147|      0|                if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
17148|      0|                    JS_ThrowReferenceErrorUninitialized2(caller_ctx, b, idx, FALSE);
17149|      0|                    goto exception;
17150|      0|                }
17151|      0|                sp[0] = JS_DupValue(ctx, var_buf[idx]);
17152|      0|                sp++;
17153|      0|            }
17154|      0|            BREAK;
17155|  22.9k|        CASE(OP_put_loc_check):
17156|  22.9k|            {
17157|  22.9k|                int idx;
17158|  22.9k|                idx = get_u16(pc);
17159|  22.9k|                pc += 2;
17160|  22.9k|                if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
17161|      7|                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);
17162|      7|                    goto exception;
17163|      7|                }
17164|  22.9k|                set_value(ctx, &var_buf[idx], sp[-1]);
17165|  22.9k|                sp--;
17166|  22.9k|            }
17167|  22.9k|            BREAK;
17168|  22.9k|        CASE(OP_put_loc_check_init):
17169|      0|            {
17170|      0|                int idx;
17171|      0|                idx = get_u16(pc);
17172|      0|                pc += 2;
17173|      0|                if (unlikely(!JS_IsUninitialized(var_buf[idx]))) {
17174|      0|                    JS_ThrowReferenceError(ctx, "'this' can be initialized only once");
17175|      0|                    goto exception;
17176|      0|                }
17177|      0|                set_value(ctx, &var_buf[idx], sp[-1]);
17178|      0|                sp--;
17179|      0|            }
17180|      0|            BREAK;
17181|    268|        CASE(OP_close_loc):
17182|    268|            {
17183|    268|                int idx;
17184|    268|                idx = get_u16(pc);
17185|    268|                pc += 2;
17186|    268|                close_lexical_var(ctx, sf, idx);
17187|    268|            }
17188|    268|            BREAK;
17189|       |
17190|    268|        CASE(OP_make_loc_ref):
17191|  31.3k|        CASE(OP_make_arg_ref):
17192|  31.5k|        CASE(OP_make_var_ref_ref):
17193|  31.5k|            {
17194|  31.5k|                JSVarRef *var_ref;
17195|  31.5k|                JSProperty *pr;
17196|  31.5k|                JSAtom atom;
17197|  31.5k|                int idx;
17198|  31.5k|                atom = get_u32(pc);
17199|  31.5k|                idx = get_u16(pc + 4);
17200|  31.5k|                pc += 6;
17201|  31.5k|                *sp++ = JS_NewObjectProto(ctx, JS_NULL);
17202|  31.5k|                if (unlikely(JS_IsException(sp[-1])))
17203|      0|                    goto exception;
17204|  31.5k|                if (opcode == OP_make_var_ref_ref) {
17205|    206|                    var_ref = var_refs[idx];
17206|    206|                    var_ref->header.ref_count++;
17207|  31.3k|                } else {
17208|  31.3k|                    var_ref = get_var_ref(ctx, sf, idx, opcode == OP_make_arg_ref);
17209|  31.3k|                    if (!var_ref)
17210|      0|                        goto exception;
17211|  31.3k|                }
17212|  31.5k|                pr = add_property(ctx, JS_VALUE_GET_OBJ(sp[-1]), atom,
17213|  31.5k|                                  JS_PROP_WRITABLE | JS_PROP_VARREF);
17214|  31.5k|                if (!pr) {
17215|      0|                    free_var_ref(rt, var_ref);
17216|      0|                    goto exception;
17217|      0|                }
17218|  31.5k|                pr->u.var_ref = var_ref;
17219|  31.5k|                *sp++ = JS_AtomToValue(ctx, atom);
17220|  31.5k|            }
17221|  31.5k|            BREAK;
17222|  31.5k|        CASE(OP_make_var_ref):
17223|  15.5k|            {
17224|  15.5k|                JSAtom atom;
17225|  15.5k|                atom = get_u32(pc);
17226|  15.5k|                pc += 4;
17227|       |
17228|  15.5k|                if (JS_GetGlobalVarRef(ctx, atom, sp))
17229|      2|                    goto exception;
17230|  15.5k|                sp += 2;
17231|  15.5k|            }
17232|  15.5k|            BREAK;
17233|       |
17234|  27.8k|        CASE(OP_goto):
17235|  27.8k|            pc += (int32_t)get_u32(pc);
17236|  27.8k|            if (unlikely(js_poll_interrupts(ctx)))
17237|      0|                goto exception;
17238|  27.8k|            BREAK;
17239|  27.8k|#if SHORT_OPCODES
17240|   106k|        CASE(OP_goto16):
17241|   106k|            pc += (int16_t)get_u16(pc);
17242|   106k|            if (unlikely(js_poll_interrupts(ctx)))
17243|      0|                goto exception;
17244|   106k|            BREAK;
17245|  1.75M|        CASE(OP_goto8):
17246|  1.75M|            pc += (int8_t)pc[0];
17247|  1.75M|            if (unlikely(js_poll_interrupts(ctx)))
17248|      0|                goto exception;
17249|  1.75M|            BREAK;
17250|  1.75M|#endif
17251|  1.75M|        CASE(OP_if_true):
17252|   168k|            {
17253|   168k|                int res;
17254|   168k|                JSValue op1;
17255|       |
17256|   168k|                op1 = sp[-1];
17257|   168k|                pc += 4;
17258|   168k|                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {
17259|  14.1k|                    res = JS_VALUE_GET_INT(op1);
17260|   154k|                } else {
17261|   154k|                    res = JS_ToBoolFree(ctx, op1);
17262|   154k|                }
17263|   168k|                sp--;
17264|   168k|                if (res) {
17265|   156k|                    pc += (int32_t)get_u32(pc - 4) - 4;
17266|   156k|                }
17267|   168k|                if (unlikely(js_poll_interrupts(ctx)))
17268|      0|                    goto exception;
17269|   168k|            }
17270|   168k|            BREAK;
17271|  1.65M|        CASE(OP_if_false):
17272|  1.65M|            {
17273|  1.65M|                int res;
17274|  1.65M|                JSValue op1;
17275|       |
17276|  1.65M|                op1 = sp[-1];
17277|  1.65M|                pc += 4;
17278|       |                /* quick and dirty test for JS_TAG_INT, JS_TAG_BOOL, JS_TAG_NULL and JS_TAG_UNDEFINED */
17279|  1.65M|                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {
17280|  1.64M|                    res = JS_VALUE_GET_INT(op1);
17281|  1.64M|                } else {
17282|  8.10k|                    res = JS_ToBoolFree(ctx, op1);
17283|  8.10k|                }
17284|  1.65M|                sp--;
17285|  1.65M|                if (!res) {
17286|   595k|                    pc += (int32_t)get_u32(pc - 4) - 4;
17287|   595k|                }
17288|  1.65M|                if (unlikely(js_poll_interrupts(ctx)))
17289|      0|                    goto exception;
17290|  1.65M|            }
17291|  1.65M|            BREAK;
17292|  1.65M|#if SHORT_OPCODES
17293|  1.65M|        CASE(OP_if_true8):
17294|   237k|            {
17295|   237k|                int res;
17296|   237k|                JSValue op1;
17297|       |
17298|   237k|                op1 = sp[-1];
17299|   237k|                pc += 1;
17300|   237k|                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {
17301|  33.5k|                    res = JS_VALUE_GET_INT(op1);
17302|   203k|                } else {
17303|   203k|                    res = JS_ToBoolFree(ctx, op1);
17304|   203k|                }
17305|   237k|                sp--;
17306|   237k|                if (res) {
17307|   165k|                    pc += (int8_t)pc[-1] - 1;
17308|   165k|                }
17309|   237k|                if (unlikely(js_poll_interrupts(ctx)))
17310|      0|                    goto exception;
17311|   237k|            }
17312|   237k|            BREAK;
17313|  6.14M|        CASE(OP_if_false8):
17314|  6.14M|            {
17315|  6.14M|                int res;
17316|  6.14M|                JSValue op1;
17317|       |
17318|  6.14M|                op1 = sp[-1];
17319|  6.14M|                pc += 1;
17320|  6.14M|                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {
17321|  6.11M|                    res = JS_VALUE_GET_INT(op1);
17322|  6.11M|                } else {
17323|  28.6k|                    res = JS_ToBoolFree(ctx, op1);
17324|  28.6k|                }
17325|  6.14M|                sp--;
17326|  6.14M|                if (!res) {
17327|  4.31M|                    pc += (int8_t)pc[-1] - 1;
17328|  4.31M|                }
17329|  6.14M|                if (unlikely(js_poll_interrupts(ctx)))
17330|      0|                    goto exception;
17331|  6.14M|            }
17332|  6.14M|            BREAK;
17333|  6.14M|#endif
17334|  6.14M|        CASE(OP_catch):
17335|      0|            {
17336|      0|                int32_t diff;
17337|      0|                diff = get_u32(pc);
17338|      0|                sp[0] = JS_NewCatchOffset(ctx, pc + diff - b->byte_code_buf);
17339|      0|                sp++;
17340|      0|                pc += 4;
17341|      0|            }
17342|      0|            BREAK;
17343|      0|        CASE(OP_gosub):
17344|      0|            {
17345|      0|                int32_t diff;
17346|      0|                diff = get_u32(pc);
17347|       |                /* XXX: should have a different tag to avoid security flaw */
17348|      0|                sp[0] = JS_NewInt32(ctx, pc + 4 - b->byte_code_buf);
17349|      0|                sp++;
17350|      0|                pc += diff;
17351|      0|            }
17352|      0|            BREAK;
17353|      0|        CASE(OP_ret):
17354|      0|            {
17355|      0|                JSValue op1;
17356|      0|                uint32_t pos;
17357|      0|                op1 = sp[-1];
17358|      0|                if (unlikely(JS_VALUE_GET_TAG(op1) != JS_TAG_INT))
17359|      0|                    goto ret_fail;
17360|      0|                pos = JS_VALUE_GET_INT(op1);
17361|      0|                if (unlikely(pos >= b->byte_code_len)) {
17362|      0|                ret_fail:
17363|      0|                    JS_ThrowInternalError(ctx, "invalid ret value");
17364|      0|                    goto exception;
17365|      0|                }
17366|      0|                sp--;
17367|      0|                pc = b->byte_code_buf + pos;
17368|      0|            }
17369|      0|            BREAK;
17370|       |
17371|  1.87M|        CASE(OP_for_in_start):
17372|  1.87M|            if (js_for_in_start(ctx, sp))
17373|      0|                goto exception;
17374|  1.87M|            BREAK;
17375|  6.76M|        CASE(OP_for_in_next):
17376|  6.76M|            if (js_for_in_next(ctx, sp))
17377|      0|                goto exception;
17378|  6.76M|            sp += 2;
17379|  6.76M|            BREAK;
17380|  6.76M|        CASE(OP_for_of_start):
17381|  7.52k|            if (js_for_of_start(ctx, sp, FALSE))
17382|     47|                goto exception;
17383|  7.47k|            sp += 1;
17384|  7.47k|            *sp++ = JS_NewCatchOffset(ctx, 0);
17385|  7.47k|            BREAK;
17386|   180k|        CASE(OP_for_of_next):
17387|   180k|            {
17388|   180k|                int offset = -3 - pc[0];
17389|   180k|                pc += 1;
17390|   180k|                if (js_for_of_next(ctx, sp, offset))
17391|      0|                    goto exception;
17392|   180k|                sp += 2;
17393|   180k|            }
17394|   180k|            BREAK;
17395|   180k|        CASE(OP_for_await_of_next):
17396|      0|            if (js_for_await_of_next(ctx, sp))
17397|      0|                goto exception;
17398|      0|            sp++;
17399|      0|            BREAK;
17400|      0|        CASE(OP_for_await_of_start):
17401|      0|            if (js_for_of_start(ctx, sp, TRUE))
17402|      0|                goto exception;
17403|      0|            sp += 1;
17404|      0|            *sp++ = JS_NewCatchOffset(ctx, 0);
17405|      0|            BREAK;
17406|      0|        CASE(OP_iterator_get_value_done):
17407|      0|            if (js_iterator_get_value_done(ctx, sp))
17408|      0|                goto exception;
17409|      0|            sp += 1;
17410|      0|            BREAK;
17411|      0|        CASE(OP_iterator_check_object):
17412|      0|            if (unlikely(!JS_IsObject(sp[-1]))) {
17413|      0|                JS_ThrowTypeError(ctx, "iterator must return an object");
17414|      0|                goto exception;
17415|      0|            }
17416|      0|            BREAK;
17417|       |
17418|  7.25k|        CASE(OP_iterator_close):
17419|       |            /* iter_obj next catch_offset -> */
17420|  7.25k|            sp--; /* drop the catch offset to avoid getting caught by exception */
17421|  7.25k|            JS_FreeValue(ctx, sp[-1]); /* drop the next method */
17422|  7.25k|            sp--;
17423|  7.25k|            if (!JS_IsUndefined(sp[-1])) {
17424|  5.80k|                if (JS_IteratorClose(ctx, sp[-1], FALSE))
17425|      0|                    goto exception;
17426|  5.80k|                JS_FreeValue(ctx, sp[-1]);
17427|  5.80k|            }
17428|  7.25k|            sp--;
17429|  7.25k|            BREAK;
17430|  7.25k|        CASE(OP_nip_catch):
17431|      0|            {
17432|      0|                JSValue ret_val;
17433|       |                /* catch_offset ... ret_val -> ret_eval */
17434|      0|                ret_val = *--sp;
17435|      0|                while (sp > stack_buf &&
17436|      0|                       JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_CATCH_OFFSET) {
17437|      0|                    JS_FreeValue(ctx, *--sp);
17438|      0|                }
17439|      0|                if (unlikely(sp == stack_buf)) {
17440|      0|                    JS_ThrowInternalError(ctx, "nip_catch");
17441|      0|                    JS_FreeValue(ctx, ret_val);
17442|      0|                    goto exception;
17443|      0|                }
17444|      0|                sp[-1] = ret_val;
17445|      0|            }
17446|      0|            BREAK;
17447|       |
17448|      0|        CASE(OP_iterator_next):
17449|       |            /* stack: iter_obj next catch_offset val */
17450|      0|            {
17451|      0|                JSValue ret;
17452|      0|                ret = JS_Call(ctx, sp[-3], sp[-4],
17453|      0|                              1, (JSValueConst *)(sp - 1));
17454|      0|                if (JS_IsException(ret))
17455|      0|                    goto exception;
17456|      0|                JS_FreeValue(ctx, sp[-1]);
17457|      0|                sp[-1] = ret;
17458|      0|            }
17459|      0|            BREAK;
17460|       |
17461|      0|        CASE(OP_iterator_call):
17462|       |            /* stack: iter_obj next catch_offset val */
17463|      0|            {
17464|      0|                JSValue method, ret;
17465|      0|                BOOL ret_flag;
17466|      0|                int flags;
17467|      0|                flags = *pc++;
17468|      0|                method = JS_GetProperty(ctx, sp[-4], (flags & 1) ?
17469|      0|                                        JS_ATOM_throw : JS_ATOM_return);
17470|      0|                if (JS_IsException(method))
17471|      0|                    goto exception;
17472|      0|                if (JS_IsUndefined(method) || JS_IsNull(method)) {
17473|      0|                    ret_flag = TRUE;
17474|      0|                } else {
17475|      0|                    if (flags & 2) {
17476|       |                        /* no argument */
17477|      0|                        ret = JS_CallFree(ctx, method, sp[-4],
17478|      0|                                          0, NULL);
17479|      0|                    } else {
17480|      0|                        ret = JS_CallFree(ctx, method, sp[-4],
17481|      0|                                          1, (JSValueConst *)(sp - 1));
17482|      0|                    }
17483|      0|                    if (JS_IsException(ret))
17484|      0|                        goto exception;
17485|      0|                    JS_FreeValue(ctx, sp[-1]);
17486|      0|                    sp[-1] = ret;
17487|      0|                    ret_flag = FALSE;
17488|      0|                }
17489|      0|                sp[0] = JS_NewBool(ctx, ret_flag);
17490|      0|                sp += 1;
17491|      0|            }
17492|      0|            BREAK;
17493|       |
17494|  1.13M|        CASE(OP_lnot):
17495|  1.13M|            {
17496|  1.13M|                int res;
17497|  1.13M|                JSValue op1;
17498|       |
17499|  1.13M|                op1 = sp[-1];
17500|  1.13M|                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {
17501|   565k|                    res = JS_VALUE_GET_INT(op1) != 0;
17502|   569k|                } else {
17503|   569k|                    res = JS_ToBoolFree(ctx, op1);
17504|   569k|                }
17505|  1.13M|                sp[-1] = JS_NewBool(ctx, !res);
17506|  1.13M|            }
17507|  1.13M|            BREAK;
17508|       |
17509|  1.13M|        CASE(OP_get_field):
17510|   330k|            {
17511|   330k|                JSValue val;
17512|   330k|                JSAtom atom;
17513|   330k|                atom = get_u32(pc);
17514|   330k|                pc += 4;
17515|       |
17516|   330k|                val = JS_GetProperty(ctx, sp[-1], atom);
17517|   330k|                if (unlikely(JS_IsException(val)))
17518|      4|                    goto exception;
17519|   330k|                JS_FreeValue(ctx, sp[-1]);
17520|   330k|                sp[-1] = val;
17521|   330k|            }
17522|   330k|            BREAK;
17523|       |
17524|   330k|        CASE(OP_get_field2):
17525|  16.6k|            {
17526|  16.6k|                JSValue val;
17527|  16.6k|                JSAtom atom;
17528|  16.6k|                atom = get_u32(pc);
17529|  16.6k|                pc += 4;
17530|       |
17531|  16.6k|                val = JS_GetProperty(ctx, sp[-1], atom);
17532|  16.6k|                if (unlikely(JS_IsException(val)))
17533|     10|                    goto exception;
17534|  16.6k|                *sp++ = val;
17535|  16.6k|            }
17536|  16.6k|            BREAK;
17537|       |
17538|   214k|        CASE(OP_put_field):
17539|   214k|            {
17540|   214k|                int ret;
17541|   214k|                JSAtom atom;
17542|   214k|                atom = get_u32(pc);
17543|   214k|                pc += 4;
17544|       |
17545|   214k|                ret = JS_SetPropertyInternal(ctx, sp[-2], atom, sp[-1], sp[-2],
17546|   214k|                                             JS_PROP_THROW_STRICT);
17547|   214k|                JS_FreeValue(ctx, sp[-2]);
17548|   214k|                sp -= 2;
17549|   214k|                if (unlikely(ret < 0))
17550|      2|                    goto exception;
17551|   214k|            }
17552|   214k|            BREAK;
17553|       |
17554|   214k|        CASE(OP_private_symbol):
17555|      0|            {
17556|      0|                JSAtom atom;
17557|      0|                JSValue val;
17558|       |
17559|      0|                atom = get_u32(pc);
17560|      0|                pc += 4;
17561|      0|                val = JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);
17562|      0|                if (JS_IsException(val))
17563|      0|                    goto exception;
17564|      0|                *sp++ = val;
17565|      0|            }
17566|      0|            BREAK;
17567|       |
17568|      0|        CASE(OP_get_private_field):
17569|      0|            {
17570|      0|                JSValue val;
17571|       |
17572|      0|                val = JS_GetPrivateField(ctx, sp[-2], sp[-1]);
17573|      0|                JS_FreeValue(ctx, sp[-1]);
17574|      0|                JS_FreeValue(ctx, sp[-2]);
17575|      0|                sp[-2] = val;
17576|      0|                sp--;
17577|      0|                if (unlikely(JS_IsException(val)))
17578|      0|                    goto exception;
17579|      0|            }
17580|      0|            BREAK;
17581|       |
17582|      0|        CASE(OP_put_private_field):
17583|      0|            {
17584|      0|                int ret;
17585|      0|                ret = JS_SetPrivateField(ctx, sp[-3], sp[-1], sp[-2]);
17586|      0|                JS_FreeValue(ctx, sp[-3]);
17587|      0|                JS_FreeValue(ctx, sp[-1]);
17588|      0|                sp -= 3;
17589|      0|                if (unlikely(ret < 0))
17590|      0|                    goto exception;
17591|      0|            }
17592|      0|            BREAK;
17593|       |
17594|      0|        CASE(OP_define_private_field):
17595|      0|            {
17596|      0|                int ret;
17597|      0|                ret = JS_DefinePrivateField(ctx, sp[-3], sp[-2], sp[-1]);
17598|      0|                JS_FreeValue(ctx, sp[-2]);
17599|      0|                sp -= 2;
17600|      0|                if (unlikely(ret < 0))
17601|      0|                    goto exception;
17602|      0|            }
17603|      0|            BREAK;
17604|       |
17605|  1.51M|        CASE(OP_define_field):
17606|  1.51M|            {
17607|  1.51M|                int ret;
17608|  1.51M|                JSAtom atom;
17609|  1.51M|                atom = get_u32(pc);
17610|  1.51M|                pc += 4;
17611|       |
17612|  1.51M|                ret = JS_DefinePropertyValue(ctx, sp[-2], atom, sp[-1],
17613|  1.51M|                                             JS_PROP_C_W_E | JS_PROP_THROW);
17614|  1.51M|                sp--;
17615|  1.51M|                if (unlikely(ret < 0))
17616|      0|                    goto exception;
17617|  1.51M|            }
17618|  1.51M|            BREAK;
17619|       |
17620|  1.51M|        CASE(OP_set_name):
17621|  73.3k|            {
17622|  73.3k|                int ret;
17623|  73.3k|                JSAtom atom;
17624|  73.3k|                atom = get_u32(pc);
17625|  73.3k|                pc += 4;
17626|       |
17627|  73.3k|                ret = JS_DefineObjectName(ctx, sp[-1], atom, JS_PROP_CONFIGURABLE);
17628|  73.3k|                if (unlikely(ret < 0))
17629|      0|                    goto exception;
17630|  73.3k|            }
17631|  73.3k|            BREAK;
17632|  73.3k|        CASE(OP_set_name_computed):
17633|      0|            {
17634|      0|                int ret;
17635|      0|                ret = JS_DefineObjectNameComputed(ctx, sp[-1], sp[-2], JS_PROP_CONFIGURABLE);
17636|      0|                if (unlikely(ret < 0))
17637|      0|                    goto exception;
17638|      0|            }
17639|      0|            BREAK;
17640|      0|        CASE(OP_set_proto):
17641|      0|            {
17642|      0|                JSValue proto;
17643|      0|                proto = sp[-1];
17644|      0|                if (JS_IsObject(proto) || JS_IsNull(proto)) {
17645|      0|                    if (JS_SetPrototypeInternal(ctx, sp[-2], proto, TRUE) < 0)
17646|      0|                        goto exception;
17647|      0|                }
17648|      0|                JS_FreeValue(ctx, proto);
17649|      0|                sp--;
17650|      0|            }
17651|      0|            BREAK;
17652|      0|        CASE(OP_set_home_object):
17653|      0|            js_method_set_home_object(ctx, sp[-1], sp[-2]);
17654|      0|            BREAK;
17655|      1|        CASE(OP_define_method):
17656|      1|        CASE(OP_define_method_computed):
17657|      1|            {
17658|      1|                JSValue getter, setter, value;
17659|      1|                JSValueConst obj;
17660|      1|                JSAtom atom;
17661|      1|                int flags, ret, op_flags;
17662|      1|                BOOL is_computed;
17663|     45|#define OP_DEFINE_METHOD_METHOD 0
17664|      3|#define OP_DEFINE_METHOD_GETTER 1
17665|      1|#define OP_DEFINE_METHOD_SETTER 2
17666|     48|#define OP_DEFINE_METHOD_ENUMERABLE 4
17667|       |
17668|      1|                is_computed = (opcode == OP_define_method_computed);
17669|      1|                if (is_computed) {
17670|      0|                    atom = JS_ValueToAtom(ctx, sp[-2]);
17671|      0|                    if (unlikely(atom == JS_ATOM_NULL))
17672|      0|                        goto exception;
17673|      0|                    opcode += OP_define_method - OP_define_method_computed;
17674|      1|                } else {
17675|      1|                    atom = get_u32(pc);
17676|      1|                    pc += 4;
17677|      1|                }
17678|      1|                op_flags = *pc++;
17679|       |
17680|      1|                obj = sp[-2 - is_computed];
17681|      1|                flags = JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE |
17682|      1|                    JS_PROP_HAS_ENUMERABLE | JS_PROP_THROW;
17683|      1|                if (op_flags & OP_DEFINE_METHOD_ENUMERABLE)
17684|      1|                    flags |= JS_PROP_ENUMERABLE;
17685|      1|                op_flags &= 3;
17686|      1|                value = JS_UNDEFINED;
17687|      1|                getter = JS_UNDEFINED;
17688|      1|                setter = JS_UNDEFINED;
17689|      1|                if (op_flags == OP_DEFINE_METHOD_METHOD) {
17690|      1|                    value = sp[-1];
17691|      1|                    flags |= JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE;
17692|      1|                } else if (op_flags == OP_DEFINE_METHOD_GETTER) {
17693|      0|                    getter = sp[-1];
17694|      0|                    flags |= JS_PROP_HAS_GET;
17695|      0|                } else {
17696|      0|                    setter = sp[-1];
17697|      0|                    flags |= JS_PROP_HAS_SET;
17698|      0|                }
17699|      1|                ret = js_method_set_properties(ctx, sp[-1], atom, flags, obj);
17700|      1|                if (ret >= 0) {
17701|      1|                    ret = JS_DefineProperty(ctx, obj, atom, value,
17702|      1|                                            getter, setter, flags);
17703|      1|                }
17704|      1|                JS_FreeValue(ctx, sp[-1]);
17705|      1|                if (is_computed) {
17706|      0|                    JS_FreeAtom(ctx, atom);
17707|      0|                    JS_FreeValue(ctx, sp[-2]);
17708|      0|                }
17709|      1|                sp -= 1 + is_computed;
17710|      1|                if (unlikely(ret < 0))
17711|      0|                    goto exception;
17712|      1|            }
17713|      1|            BREAK;
17714|       |
17715|      1|        CASE(OP_define_class):
17716|      0|        CASE(OP_define_class_computed):
17717|      0|            {
17718|      0|                int class_flags;
17719|      0|                JSAtom atom;
17720|       |
17721|      0|                atom = get_u32(pc);
17722|      0|                class_flags = pc[4];
17723|      0|                pc += 5;
17724|      0|                if (js_op_define_class(ctx, sp, atom, class_flags,
17725|      0|                                       var_refs, sf,
17726|      0|                                       (opcode == OP_define_class_computed)) < 0)
17727|      0|                    goto exception;
17728|      0|            }
17729|      0|            BREAK;
17730|       |
17731|   176k|        CASE(OP_get_array_el):
17732|   176k|            {
17733|   176k|                JSValue val;
17734|       |
17735|   176k|                val = JS_GetPropertyValue(ctx, sp[-2], sp[-1]);
17736|   176k|                JS_FreeValue(ctx, sp[-2]);
17737|   176k|                sp[-2] = val;
17738|   176k|                sp--;
17739|   176k|                if (unlikely(JS_IsException(val)))
17740|      4|                    goto exception;
17741|   176k|            }
17742|   176k|            BREAK;
17743|       |
17744|   176k|        CASE(OP_get_array_el2):
17745|      2|            {
17746|      2|                JSValue val;
17747|       |
17748|      2|                val = JS_GetPropertyValue(ctx, sp[-2], sp[-1]);
17749|      2|                sp[-1] = val;
17750|      2|                if (unlikely(JS_IsException(val)))
17751|      1|                    goto exception;
17752|      2|            }
17753|      1|            BREAK;
17754|       |
17755|  40.4k|        CASE(OP_get_ref_value):
17756|  40.4k|            {
17757|  40.4k|                JSValue val;
17758|  40.4k|                JSAtom atom;
17759|  40.4k|                int ret;
17760|       |                
17761|  40.4k|                atom = JS_ValueToAtom(ctx, sp[-1]);
17762|  40.4k|                if (atom == JS_ATOM_NULL)
17763|      0|                    goto exception;
17764|  40.4k|                if (unlikely(JS_IsUndefined(sp[-2]))) {
17765|     74|                    JS_ThrowReferenceErrorNotDefined(ctx, atom);
17766|     74|                    JS_FreeAtom(ctx, atom);
17767|     74|                    goto exception;
17768|     74|                }
17769|  40.3k|                ret = JS_HasProperty(ctx, sp[-2], atom);
17770|  40.3k|                if (unlikely(ret <= 0)) {
17771|      2|                    if (ret < 0) {
17772|      2|                        JS_FreeAtom(ctx, atom);
17773|      2|                        goto exception;
17774|      2|                    }
17775|      0|                    if (is_strict_mode(ctx)) {
17776|      0|                        JS_ThrowReferenceErrorNotDefined(ctx, atom);
17777|      0|                        JS_FreeAtom(ctx, atom);
17778|      0|                        goto exception;
17779|      0|                    } 
17780|      0|                    val = JS_UNDEFINED;
17781|  40.3k|                } else {
17782|  40.3k|                    val = JS_GetProperty(ctx, sp[-2], atom);
17783|  40.3k|                }
17784|  40.3k|                JS_FreeAtom(ctx, atom);
17785|  40.3k|                if (unlikely(JS_IsException(val)))
17786|      0|                    goto exception;
17787|  40.3k|                sp[0] = val;
17788|  40.3k|                sp++;
17789|  40.3k|            }
17790|  40.3k|            BREAK;
17791|       |
17792|  40.3k|        CASE(OP_get_super_value):
17793|      0|            {
17794|      0|                JSValue val;
17795|      0|                JSAtom atom;
17796|      0|                atom = JS_ValueToAtom(ctx, sp[-1]);
17797|      0|                if (unlikely(atom == JS_ATOM_NULL))
17798|      0|                    goto exception;
17799|      0|                val = JS_GetPropertyInternal(ctx, sp[-2], atom, sp[-3], FALSE);
17800|      0|                JS_FreeAtom(ctx, atom);
17801|      0|                if (unlikely(JS_IsException(val)))
17802|      0|                    goto exception;
17803|      0|                JS_FreeValue(ctx, sp[-1]);
17804|      0|                JS_FreeValue(ctx, sp[-2]);
17805|      0|                JS_FreeValue(ctx, sp[-3]);
17806|      0|                sp[-3] = val;
17807|      0|                sp -= 2;
17808|      0|            }
17809|      0|            BREAK;
17810|       |
17811|  39.2k|        CASE(OP_put_array_el):
17812|  39.2k|            {
17813|  39.2k|                int ret;
17814|       |
17815|  39.2k|                ret = JS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1], JS_PROP_THROW_STRICT);
17816|  39.2k|                JS_FreeValue(ctx, sp[-3]);
17817|  39.2k|                sp -= 3;
17818|  39.2k|                if (unlikely(ret < 0))
17819|     20|                    goto exception;
17820|  39.2k|            }
17821|  39.2k|            BREAK;
17822|       |
17823|  39.2k|        CASE(OP_put_ref_value):
17824|  6.76k|            {
17825|  6.76k|                int ret;
17826|  6.76k|                JSAtom atom;
17827|  6.76k|                atom = JS_ValueToAtom(ctx, sp[-2]);
17828|  6.76k|                if (unlikely(atom == JS_ATOM_NULL))
17829|      0|                    goto exception;
17830|  6.76k|                if (unlikely(JS_IsUndefined(sp[-3]))) {
17831|    761|                    if (is_strict_mode(ctx)) {
17832|      1|                        JS_ThrowReferenceErrorNotDefined(ctx, atom);
17833|      1|                        JS_FreeAtom(ctx, atom);
17834|      1|                        goto exception;
17835|    760|                    } else {
17836|    760|                        sp[-3] = JS_DupValue(ctx, ctx->global_obj);
17837|    760|                    }
17838|    761|                }
17839|  6.76k|                ret = JS_HasProperty(ctx, sp[-3], atom);
17840|  6.76k|                if (unlikely(ret <= 0)) {
17841|    761|                    if (unlikely(ret < 0)) {
17842|      1|                        JS_FreeAtom(ctx, atom);
17843|      1|                        goto exception;
17844|      1|                    }
17845|    760|                    if (is_strict_mode(ctx)) {
17846|      0|                        JS_ThrowReferenceErrorNotDefined(ctx, atom);
17847|      0|                        JS_FreeAtom(ctx, atom);
17848|      0|                        goto exception;
17849|      0|                    }
17850|    760|                }
17851|  6.76k|                ret = JS_SetPropertyInternal(ctx, sp[-3], atom, sp[-1], sp[-3], JS_PROP_THROW_STRICT);
17852|  6.76k|                JS_FreeAtom(ctx, atom);
17853|  6.76k|                JS_FreeValue(ctx, sp[-2]);
17854|  6.76k|                JS_FreeValue(ctx, sp[-3]);
17855|  6.76k|                sp -= 3;
17856|  6.76k|                if (unlikely(ret < 0))
17857|      0|                    goto exception;
17858|  6.76k|            }
17859|  6.76k|            BREAK;
17860|       |
17861|  6.76k|        CASE(OP_put_super_value):
17862|      0|            {
17863|      0|                int ret;
17864|      0|                JSAtom atom;
17865|      0|                if (JS_VALUE_GET_TAG(sp[-3]) != JS_TAG_OBJECT) {
17866|      0|                    JS_ThrowTypeErrorNotAnObject(ctx);
17867|      0|                    goto exception;
17868|      0|                }
17869|      0|                atom = JS_ValueToAtom(ctx, sp[-2]);
17870|      0|                if (unlikely(atom == JS_ATOM_NULL))
17871|      0|                    goto exception;
17872|      0|                ret = JS_SetPropertyInternal(ctx, sp[-3], atom, sp[-1], sp[-4],
17873|      0|                                             JS_PROP_THROW_STRICT);
17874|      0|                JS_FreeAtom(ctx, atom);
17875|      0|                JS_FreeValue(ctx, sp[-4]);
17876|      0|                JS_FreeValue(ctx, sp[-3]);
17877|      0|                JS_FreeValue(ctx, sp[-2]);
17878|      0|                sp -= 4;
17879|      0|                if (ret < 0)
17880|      0|                    goto exception;
17881|      0|            }
17882|      0|            BREAK;
17883|       |
17884|      0|        CASE(OP_define_array_el):
17885|      0|            {
17886|      0|                int ret;
17887|      0|                ret = JS_DefinePropertyValueValue(ctx, sp[-3], JS_DupValue(ctx, sp[-2]), sp[-1],
17888|      0|                                                  JS_PROP_C_W_E | JS_PROP_THROW);
17889|      0|                sp -= 1;
17890|      0|                if (unlikely(ret < 0))
17891|      0|                    goto exception;
17892|      0|            }
17893|      0|            BREAK;
17894|       |
17895|      3|        CASE(OP_append):    /* array pos enumobj -- array pos */
17896|      3|            {
17897|      3|                if (js_append_enumerate(ctx, sp))
17898|      3|                    goto exception;
17899|      0|                JS_FreeValue(ctx, *--sp);
17900|      0|            }
17901|      0|            BREAK;
17902|       |
17903|      0|        CASE(OP_copy_data_properties):    /* target source excludeList */
17904|      0|            {
17905|       |                /* stack offsets (-1 based):
17906|       |                   2 bits for target,
17907|       |                   3 bits for source,
17908|       |                   2 bits for exclusionList */
17909|      0|                int mask;
17910|       |
17911|      0|                mask = *pc++;
17912|      0|                if (JS_CopyDataProperties(ctx, sp[-1 - (mask & 3)],
17913|      0|                                          sp[-1 - ((mask >> 2) & 7)],
17914|      0|                                          sp[-1 - ((mask >> 5) & 7)], 0))
17915|      0|                    goto exception;
17916|      0|            }
17917|      0|            BREAK;
17918|       |
17919|  2.08M|        CASE(OP_add):
17920|  2.08M|            {
17921|  2.08M|                JSValue op1, op2;
17922|  2.08M|                op1 = sp[-2];
17923|  2.08M|                op2 = sp[-1];
17924|  2.08M|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
17925|   189k|                    int64_t r;
17926|   189k|                    r = (int64_t)JS_VALUE_GET_INT(op1) + JS_VALUE_GET_INT(op2);
17927|   189k|                    if (unlikely((int)r != r))
17928|  8.96k|                        goto add_slow;
17929|   180k|                    sp[-2] = JS_NewInt32(ctx, r);
17930|   180k|                    sp--;
17931|  1.89M|                } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
17932|  57.9k|                    sp[-2] = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(op1) +
17933|  57.9k|                                             JS_VALUE_GET_FLOAT64(op2));
17934|  57.9k|                    sp--;
17935|  1.83M|                } else if (JS_IsString(op1) && JS_IsString(op2)) {
17936|   402k|                    sp[-2] = JS_ConcatString(ctx, op1, op2);
17937|   402k|                    sp--;
17938|   402k|                    if (JS_IsException(sp[-1]))
17939|      0|                        goto exception;
17940|  1.43M|                } else {
17941|  1.44M|                add_slow:
17942|  1.44M|                    if (js_add_slow(ctx, sp))
17943|    515|                        goto exception;
17944|  1.44M|                    sp--;
17945|  1.44M|                }
17946|  2.08M|            }
17947|  2.08M|            BREAK;
17948|  2.08M|        CASE(OP_add_loc):
17949|      0|            {
17950|      0|                JSValue op2;
17951|      0|                JSValue *pv;
17952|      0|                int idx;
17953|      0|                idx = *pc;
17954|      0|                pc += 1;
17955|       |
17956|      0|                op2 = sp[-1];
17957|      0|                pv = &var_buf[idx];
17958|      0|                if (likely(JS_VALUE_IS_BOTH_INT(*pv, op2))) {
17959|      0|                    int64_t r;
17960|      0|                    r = (int64_t)JS_VALUE_GET_INT(*pv) + JS_VALUE_GET_INT(op2);
17961|      0|                    if (unlikely((int)r != r))
17962|      0|                        goto add_loc_slow;
17963|      0|                    *pv = JS_NewInt32(ctx, r);
17964|      0|                    sp--;
17965|      0|                } else if (JS_VALUE_IS_BOTH_FLOAT(*pv, op2)) {
17966|      0|                    *pv = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(*pv) +
17967|      0|                                               JS_VALUE_GET_FLOAT64(op2));
17968|      0|                    sp--;
17969|      0|                } else if (JS_VALUE_GET_TAG(*pv) == JS_TAG_STRING) {
17970|      0|                    sp--;
17971|      0|                    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);
17972|      0|                    if (JS_IsException(op2))
17973|      0|                        goto exception;
17974|      0|                    if (JS_ConcatStringInPlace(ctx, JS_VALUE_GET_STRING(*pv), op2)) {
17975|      0|                        JS_FreeValue(ctx, op2);
17976|      0|                    } else {
17977|      0|                        op2 = JS_ConcatString(ctx, JS_DupValue(ctx, *pv), op2);
17978|      0|                        if (JS_IsException(op2))
17979|      0|                            goto exception;
17980|      0|                        set_value(ctx, pv, op2);
17981|      0|                    }
17982|      0|                } else {
17983|      0|                    JSValue ops[2];
17984|      0|                add_loc_slow:
17985|       |                    /* In case of exception, js_add_slow frees ops[0]
17986|       |                       and ops[1], so we must duplicate *pv */
17987|      0|                    ops[0] = JS_DupValue(ctx, *pv);
17988|      0|                    ops[1] = op2;
17989|      0|                    sp--;
17990|      0|                    if (js_add_slow(ctx, ops + 2))
17991|      0|                        goto exception;
17992|      0|                    set_value(ctx, pv, ops[0]);
17993|      0|                }
17994|      0|            }
17995|      0|            BREAK;
17996|  1.60M|        CASE(OP_sub):
17997|  1.60M|            {
17998|  1.60M|                JSValue op1, op2;
17999|  1.60M|                op1 = sp[-2];
18000|  1.60M|                op2 = sp[-1];
18001|  1.60M|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18002|  35.5k|                    int64_t r;
18003|  35.5k|                    r = (int64_t)JS_VALUE_GET_INT(op1) - JS_VALUE_GET_INT(op2);
18004|  35.5k|                    if (unlikely((int)r != r))
18005|  29.4k|                        goto binary_arith_slow;
18006|  6.10k|                    sp[-2] = JS_NewInt32(ctx, r);
18007|  6.10k|                    sp--;
18008|  1.56M|                } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
18009|  27.1k|                    sp[-2] = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(op1) -
18010|  27.1k|                                             JS_VALUE_GET_FLOAT64(op2));
18011|  27.1k|                    sp--;
18012|  1.54M|                } else {
18013|  1.54M|                    goto binary_arith_slow;
18014|  1.54M|                }
18015|  1.60M|            }
18016|  33.2k|            BREAK;
18017|   937k|        CASE(OP_mul):
18018|   937k|            {
18019|   937k|                JSValue op1, op2;
18020|   937k|                double d;
18021|   937k|                op1 = sp[-2];
18022|   937k|                op2 = sp[-1];
18023|   937k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18024|   217k|                    int32_t v1, v2;
18025|   217k|                    int64_t r;
18026|   217k|                    v1 = JS_VALUE_GET_INT(op1);
18027|   217k|                    v2 = JS_VALUE_GET_INT(op2);
18028|   217k|                    r = (int64_t)v1 * v2;
18029|   217k|                    if (unlikely((int)r != r)) {
18030|  26.5k|                        d = (double)r;
18031|  26.5k|                        goto mul_fp_res;
18032|  26.5k|                    }
18033|       |                    /* need to test zero case for -0 result */
18034|   191k|                    if (unlikely(r == 0 && (v1 | v2) < 0)) {
18035|  2.10k|                        d = -0.0;
18036|  2.10k|                        goto mul_fp_res;
18037|  2.10k|                    }
18038|   189k|                    sp[-2] = JS_NewInt32(ctx, r);
18039|   189k|                    sp--;
18040|   719k|                } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
18041|  30.9k|                    d = JS_VALUE_GET_FLOAT64(op1) * JS_VALUE_GET_FLOAT64(op2);
18042|  59.5k|                mul_fp_res:
18043|  59.5k|                    sp[-2] = __JS_NewFloat64(ctx, d);
18044|  59.5k|                    sp--;
18045|   688k|                } else {
18046|   688k|                    goto binary_arith_slow;
18047|   688k|                }
18048|   937k|            }
18049|   248k|            BREAK;
18050|  2.37M|        CASE(OP_div):
18051|  2.37M|            {
18052|  2.37M|                JSValue op1, op2;
18053|  2.37M|                op1 = sp[-2];
18054|  2.37M|                op2 = sp[-1];
18055|  2.37M|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18056|  17.6k|                    int v1, v2;
18057|  17.6k|                    v1 = JS_VALUE_GET_INT(op1);
18058|  17.6k|                    v2 = JS_VALUE_GET_INT(op2);
18059|  17.6k|                    sp[-2] = JS_NewFloat64(ctx, (double)v1 / (double)v2);
18060|  17.6k|                    sp--;
18061|  2.35M|                } else {
18062|  2.35M|                    goto binary_arith_slow;
18063|  2.35M|                }
18064|  2.37M|            }
18065|  17.6k|            BREAK;
18066|   164k|        CASE(OP_mod):
18067|   164k|            {
18068|   164k|                JSValue op1, op2;
18069|   164k|                op1 = sp[-2];
18070|   164k|                op2 = sp[-1];
18071|   164k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18072|  4.78k|                    int v1, v2, r;
18073|  4.78k|                    v1 = JS_VALUE_GET_INT(op1);
18074|  4.78k|                    v2 = JS_VALUE_GET_INT(op2);
18075|       |                    /* We must avoid v2 = 0, v1 = INT32_MIN and v2 =
18076|       |                       -1 and the cases where the result is -0. */
18077|  4.78k|                    if (unlikely(v1 < 0 || v2 <= 0))
18078|  4.14k|                        goto binary_arith_slow;
18079|    637|                    r = v1 % v2;
18080|    637|                    sp[-2] = JS_NewInt32(ctx, r);
18081|    637|                    sp--;
18082|   159k|                } else {
18083|   159k|                    goto binary_arith_slow;
18084|   159k|                }
18085|   164k|            }
18086|    637|            BREAK;
18087|   150k|        CASE(OP_pow):
18088|  4.93M|        binary_arith_slow:
18089|  4.93M|            if (js_binary_arith_slow(ctx, sp, opcode))
18090|    386|                goto exception;
18091|  4.93M|            sp--;
18092|  4.93M|            BREAK;
18093|       |
18094|  4.93M|        CASE(OP_plus):
18095|  52.1k|            {
18096|  52.1k|                JSValue op1;
18097|  52.1k|                uint32_t tag;
18098|  52.1k|                op1 = sp[-1];
18099|  52.1k|                tag = JS_VALUE_GET_TAG(op1);
18100|  52.1k|                if (tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag)) {
18101|  30.1k|                } else {
18102|  30.1k|                    if (js_unary_arith_slow(ctx, sp, opcode))
18103|      5|                        goto exception;
18104|  30.1k|                }
18105|  52.1k|            }
18106|  52.1k|            BREAK;
18107|  1.75M|        CASE(OP_neg):
18108|  1.75M|            {
18109|  1.75M|                JSValue op1;
18110|  1.75M|                uint32_t tag;
18111|  1.75M|                int val;
18112|  1.75M|                double d;
18113|  1.75M|                op1 = sp[-1];
18114|  1.75M|                tag = JS_VALUE_GET_TAG(op1);
18115|  1.75M|                if (tag == JS_TAG_INT) {
18116|  18.3k|                    val = JS_VALUE_GET_INT(op1);
18117|       |                    /* Note: -0 cannot be expressed as integer */
18118|  18.3k|                    if (unlikely(val == 0)) {
18119|  8.07k|                        d = -0.0;
18120|  8.07k|                        goto neg_fp_res;
18121|  8.07k|                    }
18122|  10.2k|                    if (unlikely(val == INT32_MIN)) {
18123|      1|                        d = -(double)val;
18124|      1|                        goto neg_fp_res;
18125|      1|                    }
18126|  10.2k|                    sp[-1] = JS_NewInt32(ctx, -val);
18127|  1.73M|                } else if (JS_TAG_IS_FLOAT64(tag)) {
18128|   378k|                    d = -JS_VALUE_GET_FLOAT64(op1);
18129|   386k|                neg_fp_res:
18130|   386k|                    sp[-1] = __JS_NewFloat64(ctx, d);
18131|  1.35M|                } else {
18132|  1.35M|                    if (js_unary_arith_slow(ctx, sp, opcode))
18133|      1|                        goto exception;
18134|  1.35M|                }
18135|  1.75M|            }
18136|  1.75M|            BREAK;
18137|  1.75M|        CASE(OP_inc):
18138|    234|            {
18139|    234|                JSValue op1;
18140|    234|                int val;
18141|    234|                op1 = sp[-1];
18142|    234|                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {
18143|      1|                    val = JS_VALUE_GET_INT(op1);
18144|      1|                    if (unlikely(val == INT32_MAX))
18145|      0|                        goto inc_slow;
18146|      1|                    sp[-1] = JS_NewInt32(ctx, val + 1);
18147|    233|                } else {
18148|    233|                inc_slow:
18149|    233|                    if (js_unary_arith_slow(ctx, sp, opcode))
18150|      0|                        goto exception;
18151|    233|                }
18152|    234|            }
18153|    234|            BREAK;
18154|  36.7k|        CASE(OP_dec):
18155|  36.7k|            {
18156|  36.7k|                JSValue op1;
18157|  36.7k|                int val;
18158|  36.7k|                op1 = sp[-1];
18159|  36.7k|                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {
18160|     24|                    val = JS_VALUE_GET_INT(op1);
18161|     24|                    if (unlikely(val == INT32_MIN))
18162|      0|                        goto dec_slow;
18163|     24|                    sp[-1] = JS_NewInt32(ctx, val - 1);
18164|  36.6k|                } else {
18165|  36.6k|                dec_slow:
18166|  36.6k|                    if (js_unary_arith_slow(ctx, sp, opcode))
18167|      0|                        goto exception;
18168|  36.6k|                }
18169|  36.7k|            }
18170|  36.7k|            BREAK;
18171|  74.3k|        CASE(OP_post_inc):
18172|  76.5k|        CASE(OP_post_dec):
18173|  76.5k|            if (js_post_inc_slow(ctx, sp, opcode))
18174|      0|                goto exception;
18175|  76.5k|            sp++;
18176|  76.5k|            BREAK;
18177|  76.5k|        CASE(OP_inc_loc):
18178|      0|            {
18179|      0|                JSValue op1;
18180|      0|                int val;
18181|      0|                int idx;
18182|      0|                idx = *pc;
18183|      0|                pc += 1;
18184|       |
18185|      0|                op1 = var_buf[idx];
18186|      0|                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {
18187|      0|                    val = JS_VALUE_GET_INT(op1);
18188|      0|                    if (unlikely(val == INT32_MAX))
18189|      0|                        goto inc_loc_slow;
18190|      0|                    var_buf[idx] = JS_NewInt32(ctx, val + 1);
18191|      0|                } else {
18192|      0|                inc_loc_slow:
18193|       |                    /* must duplicate otherwise the variable value may
18194|       |                       be destroyed before JS code accesses it */
18195|      0|                    op1 = JS_DupValue(ctx, op1);
18196|      0|                    if (js_unary_arith_slow(ctx, &op1 + 1, OP_inc))
18197|      0|                        goto exception;
18198|      0|                    set_value(ctx, &var_buf[idx], op1);
18199|      0|                }
18200|      0|            }
18201|      0|            BREAK;
18202|      0|        CASE(OP_dec_loc):
18203|      0|            {
18204|      0|                JSValue op1;
18205|      0|                int val;
18206|      0|                int idx;
18207|      0|                idx = *pc;
18208|      0|                pc += 1;
18209|       |
18210|      0|                op1 = var_buf[idx];
18211|      0|                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {
18212|      0|                    val = JS_VALUE_GET_INT(op1);
18213|      0|                    if (unlikely(val == INT32_MIN))
18214|      0|                        goto dec_loc_slow;
18215|      0|                    var_buf[idx] = JS_NewInt32(ctx, val - 1);
18216|      0|                } else {
18217|      0|                dec_loc_slow:
18218|       |                    /* must duplicate otherwise the variable value may
18219|       |                       be destroyed before JS code accesses it */
18220|      0|                    op1 = JS_DupValue(ctx, op1);
18221|      0|                    if (js_unary_arith_slow(ctx, &op1 + 1, OP_dec))
18222|      0|                        goto exception;
18223|      0|                    set_value(ctx, &var_buf[idx], op1);
18224|      0|                }
18225|      0|            }
18226|      0|            BREAK;
18227|   157k|        CASE(OP_not):
18228|   157k|            {
18229|   157k|                JSValue op1;
18230|   157k|                op1 = sp[-1];
18231|   157k|                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {
18232|  87.3k|                    sp[-1] = JS_NewInt32(ctx, ~JS_VALUE_GET_INT(op1));
18233|  87.3k|                } else {
18234|  69.9k|                    if (js_not_slow(ctx, sp))
18235|      1|                        goto exception;
18236|  69.9k|                }
18237|   157k|            }
18238|   157k|            BREAK;
18239|       |
18240|   157k|        CASE(OP_shl):
18241|  42.5k|            {
18242|  42.5k|                JSValue op1, op2;
18243|  42.5k|                op1 = sp[-2];
18244|  42.5k|                op2 = sp[-1];
18245|  42.5k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18246|  1.52k|                    uint32_t v1, v2;
18247|  1.52k|                    v1 = JS_VALUE_GET_INT(op1);
18248|  1.52k|                    v2 = JS_VALUE_GET_INT(op2);
18249|  1.52k|                    v2 &= 0x1f;
18250|  1.52k|                    sp[-2] = JS_NewInt32(ctx, v1 << v2);
18251|  1.52k|                    sp--;
18252|  40.9k|                } else {
18253|  40.9k|                    if (js_binary_logic_slow(ctx, sp, opcode))
18254|      2|                        goto exception;
18255|  40.9k|                    sp--;
18256|  40.9k|                }
18257|  42.5k|            }
18258|  42.5k|            BREAK;
18259|  69.6k|        CASE(OP_shr):
18260|  69.6k|            {
18261|  69.6k|                JSValue op1, op2;
18262|  69.6k|                op1 = sp[-2];
18263|  69.6k|                op2 = sp[-1];
18264|  69.6k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18265|  2.60k|                    uint32_t v2;
18266|  2.60k|                    v2 = JS_VALUE_GET_INT(op2);
18267|  2.60k|                    v2 &= 0x1f;
18268|  2.60k|                    sp[-2] = JS_NewUint32(ctx,
18269|  2.60k|                                          (uint32_t)JS_VALUE_GET_INT(op1) >>
18270|  2.60k|                                          v2);
18271|  2.60k|                    sp--;
18272|  67.0k|                } else {
18273|  67.0k|                    if (js_shr_slow(ctx, sp))
18274|      5|                        goto exception;
18275|  67.0k|                    sp--;
18276|  67.0k|                }
18277|  69.6k|            }
18278|  69.6k|            BREAK;
18279|   429k|        CASE(OP_sar):
18280|   429k|            {
18281|   429k|                JSValue op1, op2;
18282|   429k|                op1 = sp[-2];
18283|   429k|                op2 = sp[-1];
18284|   429k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18285|    299|                    uint32_t v2;
18286|    299|                    v2 = JS_VALUE_GET_INT(op2);
18287|    299|                    v2 &= 0x1f;
18288|    299|                    sp[-2] = JS_NewInt32(ctx,
18289|    299|                                          (int)JS_VALUE_GET_INT(op1) >> v2);
18290|    299|                    sp--;
18291|   429k|                } else {
18292|   429k|                    if (js_binary_logic_slow(ctx, sp, opcode))
18293|    176|                        goto exception;
18294|   429k|                    sp--;
18295|   429k|                }
18296|   429k|            }
18297|   429k|            BREAK;
18298|  2.76M|        CASE(OP_and):
18299|  2.76M|            {
18300|  2.76M|                JSValue op1, op2;
18301|  2.76M|                op1 = sp[-2];
18302|  2.76M|                op2 = sp[-1];
18303|  2.76M|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18304|  1.68M|                    sp[-2] = JS_NewInt32(ctx,
18305|  1.68M|                                         JS_VALUE_GET_INT(op1) &
18306|  1.68M|                                         JS_VALUE_GET_INT(op2));
18307|  1.68M|                    sp--;
18308|  1.68M|                } else {
18309|  1.07M|                    if (js_binary_logic_slow(ctx, sp, opcode))
18310|     74|                        goto exception;
18311|  1.07M|                    sp--;
18312|  1.07M|                }
18313|  2.76M|            }
18314|  2.76M|            BREAK;
18315|  2.76M|        CASE(OP_or):
18316|   131k|            {
18317|   131k|                JSValue op1, op2;
18318|   131k|                op1 = sp[-2];
18319|   131k|                op2 = sp[-1];
18320|   131k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18321|  47.0k|                    sp[-2] = JS_NewInt32(ctx,
18322|  47.0k|                                         JS_VALUE_GET_INT(op1) |
18323|  47.0k|                                         JS_VALUE_GET_INT(op2));
18324|  47.0k|                    sp--;
18325|  84.3k|                } else {
18326|  84.3k|                    if (js_binary_logic_slow(ctx, sp, opcode))
18327|     10|                        goto exception;
18328|  84.3k|                    sp--;
18329|  84.3k|                }
18330|   131k|            }
18331|   131k|            BREAK;
18332|   131k|        CASE(OP_xor):
18333|   127k|            {
18334|   127k|                JSValue op1, op2;
18335|   127k|                op1 = sp[-2];
18336|   127k|                op2 = sp[-1];
18337|   127k|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
18338|    513|                    sp[-2] = JS_NewInt32(ctx,
18339|    513|                                         JS_VALUE_GET_INT(op1) ^
18340|    513|                                         JS_VALUE_GET_INT(op2));
18341|    513|                    sp--;
18342|   126k|                } else {
18343|   126k|                    if (js_binary_logic_slow(ctx, sp, opcode))
18344|     45|                        goto exception;
18345|   126k|                    sp--;
18346|   126k|                }
18347|   127k|            }
18348|   126k|            BREAK;
18349|       |
18350|       |
18351|   126k|#define OP_CMP(opcode, binary_op, slow_call)              \
18352|  4.16M|            CASE(opcode):                                 \
18353|  4.16M|                {                                         \
18354|  4.16M|                JSValue op1, op2;                         \
18355|  4.16M|                op1 = sp[-2];                             \
18356|  4.16M|                op2 = sp[-1];                                   \
18357|  4.16M|                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {           \
18358|  72.4k|                    sp[-2] = JS_NewBool(ctx, JS_VALUE_GET_INT(op1) binary_op JS_VALUE_GET_INT(op2)); \
18359|  72.4k|                    sp--;                                               \
18360|  4.09M|                } else {                                                \
18361|  4.09M|                    if (slow_call)                                      \
18362|  4.09M|                        goto exception;                                 \
18363|  4.09M|                    sp--;                                               \
18364|  4.09M|                }                                                       \
18365|  4.16M|                }                                                       \
18366|  4.16M|            BREAK
18367|       |
18368|  2.59M|            OP_CMP(OP_lt, <, js_relational_slow(ctx, sp, opcode));
18369|  2.59M|            OP_CMP(OP_lte, <=, js_relational_slow(ctx, sp, opcode));
18370|  2.73M|            OP_CMP(OP_gt, >, js_relational_slow(ctx, sp, opcode));
18371|  2.73M|            OP_CMP(OP_gte, >=, js_relational_slow(ctx, sp, opcode));
18372|  1.51M|            OP_CMP(OP_eq, ==, js_eq_slow(ctx, sp, 0));
18373|  1.51M|            OP_CMP(OP_neq, !=, js_eq_slow(ctx, sp, 1));
18374|   191k|            OP_CMP(OP_strict_eq, ==, js_strict_eq_slow(ctx, sp, 0));
18375|   191k|            OP_CMP(OP_strict_neq, !=, js_strict_eq_slow(ctx, sp, 1));
18376|       |
18377|   140k|        CASE(OP_in):
18378|   140k|            if (js_operator_in(ctx, sp))
18379|      6|                goto exception;
18380|   140k|            sp--;
18381|   140k|            BREAK;
18382|   140k|        CASE(OP_private_in):
18383|      0|            if (js_operator_private_in(ctx, sp))
18384|      0|                goto exception;
18385|      0|            sp--;
18386|      0|            BREAK;
18387|      0|        CASE(OP_instanceof):
18388|      0|            if (js_operator_instanceof(ctx, sp))
18389|      0|                goto exception;
18390|      0|            sp--;
18391|      0|            BREAK;
18392|      0|        CASE(OP_typeof):
18393|      0|            {
18394|      0|                JSValue op1;
18395|      0|                JSAtom atom;
18396|       |
18397|      0|                op1 = sp[-1];
18398|      0|                atom = js_operator_typeof(ctx, op1);
18399|      0|                JS_FreeValue(ctx, op1);
18400|      0|                sp[-1] = JS_AtomToString(ctx, atom);
18401|      0|            }
18402|      0|            BREAK;
18403|      0|        CASE(OP_delete):
18404|      0|            if (js_operator_delete(ctx, sp))
18405|      0|                goto exception;
18406|      0|            sp--;
18407|      0|            BREAK;
18408|      0|        CASE(OP_delete_var):
18409|      0|            {
18410|      0|                JSAtom atom;
18411|      0|                int ret;
18412|       |
18413|      0|                atom = get_u32(pc);
18414|      0|                pc += 4;
18415|       |
18416|      0|                ret = JS_DeleteProperty(ctx, ctx->global_obj, atom, 0);
18417|      0|                if (unlikely(ret < 0))
18418|      0|                    goto exception;
18419|      0|                *sp++ = JS_NewBool(ctx, ret);
18420|      0|            }
18421|      0|            BREAK;
18422|       |
18423|  2.11k|        CASE(OP_to_object):
18424|  2.11k|            if (JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_OBJECT) {
18425|    879|                ret_val = JS_ToObject(ctx, sp[-1]);
18426|    879|                if (JS_IsException(ret_val))
18427|      1|                    goto exception;
18428|    878|                JS_FreeValue(ctx, sp[-1]);
18429|    878|                sp[-1] = ret_val;
18430|    878|            }
18431|  2.11k|            BREAK;
18432|       |
18433|  2.11k|        CASE(OP_to_propkey):
18434|      0|            switch (JS_VALUE_GET_TAG(sp[-1])) {
18435|      0|            case JS_TAG_INT:
18436|      0|            case JS_TAG_STRING:
18437|      0|            case JS_TAG_SYMBOL:
18438|      0|                break;
18439|      0|            default:
18440|      0|                ret_val = JS_ToPropertyKey(ctx, sp[-1]);
18441|      0|                if (JS_IsException(ret_val))
18442|      0|                    goto exception;
18443|      0|                JS_FreeValue(ctx, sp[-1]);
18444|      0|                sp[-1] = ret_val;
18445|      0|                break;
18446|      0|            }
18447|      0|            BREAK;
18448|       |
18449|  38.8k|        CASE(OP_to_propkey2):
18450|       |            /* must be tested first */
18451|  38.8k|            if (unlikely(JS_IsUndefined(sp[-2]) || JS_IsNull(sp[-2]))) {
18452|      1|                JS_ThrowTypeError(ctx, "value has no property");
18453|      1|                goto exception;
18454|      1|            }
18455|  38.8k|            switch (JS_VALUE_GET_TAG(sp[-1])) {
18456|  5.80k|            case JS_TAG_INT:
18457|  5.80k|            case JS_TAG_STRING:
18458|  5.80k|            case JS_TAG_SYMBOL:
18459|  5.80k|                break;
18460|  33.0k|            default:
18461|  33.0k|                ret_val = JS_ToPropertyKey(ctx, sp[-1]);
18462|  33.0k|                if (JS_IsException(ret_val))
18463|      0|                    goto exception;
18464|  33.0k|                JS_FreeValue(ctx, sp[-1]);
18465|  33.0k|                sp[-1] = ret_val;
18466|  33.0k|                break;
18467|  38.8k|            }
18468|  38.8k|            BREAK;
18469|       |#if 0
18470|       |        CASE(OP_to_string):
18471|       |            if (JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_STRING) {
18472|       |                ret_val = JS_ToString(ctx, sp[-1]);
18473|       |                if (JS_IsException(ret_val))
18474|       |                    goto exception;
18475|       |                JS_FreeValue(ctx, sp[-1]);
18476|       |                sp[-1] = ret_val;
18477|       |            }
18478|       |            BREAK;
18479|       |#endif
18480|  38.8k|        CASE(OP_with_get_var):
18481|      0|        CASE(OP_with_put_var):
18482|      0|        CASE(OP_with_delete_var):
18483|      0|        CASE(OP_with_make_ref):
18484|      0|        CASE(OP_with_get_ref):
18485|      0|            {
18486|      0|                JSAtom atom;
18487|      0|                int32_t diff;
18488|      0|                JSValue obj, val;
18489|      0|                int ret, is_with;
18490|      0|                atom = get_u32(pc);
18491|      0|                diff = get_u32(pc + 4);
18492|      0|                is_with = pc[8];
18493|      0|                pc += 9;
18494|       |
18495|      0|                obj = sp[-1];
18496|      0|                ret = JS_HasProperty(ctx, obj, atom);
18497|      0|                if (unlikely(ret < 0))
18498|      0|                    goto exception;
18499|      0|                if (ret) {
18500|      0|                    if (is_with) {
18501|      0|                        ret = js_has_unscopable(ctx, obj, atom);
18502|      0|                        if (unlikely(ret < 0))
18503|      0|                            goto exception;
18504|      0|                        if (ret)
18505|      0|                            goto no_with;
18506|      0|                    }
18507|      0|                    switch (opcode) {
18508|      0|                    case OP_with_get_var:
18509|       |                        /* in Object Environment Records, GetBindingValue() calls HasProperty() */
18510|      0|                        ret = JS_HasProperty(ctx, obj, atom);
18511|      0|                        if (unlikely(ret <= 0)) {
18512|      0|                            if (ret < 0)
18513|      0|                                goto exception;
18514|      0|                            if (is_strict_mode(ctx)) {
18515|      0|                                JS_ThrowReferenceErrorNotDefined(ctx, atom);
18516|      0|                                goto exception;
18517|      0|                            } 
18518|      0|                            val = JS_UNDEFINED;
18519|      0|                        } else {
18520|      0|                            val = JS_GetProperty(ctx, obj, atom);
18521|      0|                            if (unlikely(JS_IsException(val)))
18522|      0|                                goto exception;
18523|      0|                        }
18524|      0|                        set_value(ctx, &sp[-1], val);
18525|      0|                        break;
18526|      0|                    case OP_with_put_var: /* used e.g. in for in/of */
18527|       |                        /* in Object Environment Records, SetMutableBinding() calls HasProperty() */
18528|      0|                        ret = JS_HasProperty(ctx, obj, atom);
18529|      0|                        if (unlikely(ret <= 0)) {
18530|      0|                            if (ret < 0)
18531|      0|                                goto exception;
18532|      0|                            if (is_strict_mode(ctx)) {
18533|      0|                                JS_ThrowReferenceErrorNotDefined(ctx, atom);
18534|      0|                                goto exception;
18535|      0|                            } 
18536|      0|                        }
18537|      0|                        ret = JS_SetPropertyInternal(ctx, obj, atom, sp[-2], obj,
18538|      0|                                                     JS_PROP_THROW_STRICT);
18539|      0|                        JS_FreeValue(ctx, sp[-1]);
18540|      0|                        sp -= 2;
18541|      0|                        if (unlikely(ret < 0))
18542|      0|                            goto exception;
18543|      0|                        break;
18544|      0|                    case OP_with_delete_var:
18545|      0|                        ret = JS_DeleteProperty(ctx, obj, atom, 0);
18546|      0|                        if (unlikely(ret < 0))
18547|      0|                            goto exception;
18548|      0|                        JS_FreeValue(ctx, sp[-1]);
18549|      0|                        sp[-1] = JS_NewBool(ctx, ret);
18550|      0|                        break;
18551|      0|                    case OP_with_make_ref:
18552|       |                        /* produce a pair object/propname on the stack */
18553|      0|                        *sp++ = JS_AtomToValue(ctx, atom);
18554|      0|                        break;
18555|      0|                    case OP_with_get_ref:
18556|       |                        /* produce a pair object/method on the stack */
18557|       |                        /* in Object Environment Records, GetBindingValue() calls HasProperty() */
18558|      0|                        ret = JS_HasProperty(ctx, obj, atom);
18559|      0|                        if (unlikely(ret < 0))
18560|      0|                            goto exception;
18561|      0|                        if (!ret) {
18562|      0|                            val = JS_UNDEFINED;
18563|      0|                        } else {
18564|      0|                            val = JS_GetProperty(ctx, obj, atom);
18565|      0|                            if (unlikely(JS_IsException(val)))
18566|      0|                                goto exception;
18567|      0|                        }
18568|      0|                        *sp++ = val;
18569|      0|                        break;
18570|      0|                    }
18571|      0|                    pc += diff - 5;
18572|      0|                } else {
18573|      0|                no_with:
18574|       |                    /* if not jumping, drop the object argument */
18575|      0|                    JS_FreeValue(ctx, sp[-1]);
18576|      0|                    sp--;
18577|      0|                }
18578|      0|            }
18579|      0|            BREAK;
18580|       |
18581|      0|        CASE(OP_await):
18582|      0|            ret_val = JS_NewInt32(ctx, FUNC_RET_AWAIT);
18583|      0|            goto done_generator;
18584|      0|        CASE(OP_yield):
18585|      0|            ret_val = JS_NewInt32(ctx, FUNC_RET_YIELD);
18586|      0|            goto done_generator;
18587|      0|        CASE(OP_yield_star):
18588|      0|        CASE(OP_async_yield_star):
18589|      0|            ret_val = JS_NewInt32(ctx, FUNC_RET_YIELD_STAR);
18590|      0|            goto done_generator;
18591|     15|        CASE(OP_return_async):
18592|     15|            ret_val = JS_UNDEFINED;
18593|     15|            goto done_generator;
18594|      0|        CASE(OP_initial_yield):
18595|      0|            ret_val = JS_NewInt32(ctx, FUNC_RET_INITIAL_YIELD);
18596|      0|            goto done_generator;
18597|       |
18598|      0|        CASE(OP_nop):
18599|      0|            BREAK;
18600|  13.7k|        CASE(OP_is_undefined_or_null):
18601|  13.7k|            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED ||
18602|  13.7k|                JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_NULL) {
18603|    106|                goto set_true;
18604|  13.6k|            } else {
18605|  13.6k|                goto free_and_set_false;
18606|  13.6k|            }
18607|      0|#if SHORT_OPCODES
18608|    681|        CASE(OP_is_undefined):
18609|    681|            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED) {
18610|    577|                goto set_true;
18611|    577|            } else {
18612|    104|                goto free_and_set_false;
18613|    104|            }
18614|      0|        CASE(OP_is_null):
18615|      0|            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_NULL) {
18616|      0|                goto set_true;
18617|      0|            } else {
18618|      0|                goto free_and_set_false;
18619|      0|            }
18620|       |            /* XXX: could merge to a single opcode */
18621|      0|        CASE(OP_typeof_is_undefined):
18622|       |            /* different from OP_is_undefined because of isHTMLDDA */
18623|      0|            if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_undefined) {
18624|      0|                goto free_and_set_true;
18625|      0|            } else {
18626|      0|                goto free_and_set_false;
18627|      0|            }
18628|      0|        CASE(OP_typeof_is_function):
18629|      0|            if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_function) {
18630|      0|                goto free_and_set_true;
18631|      0|            } else {
18632|      0|                goto free_and_set_false;
18633|      0|            }
18634|      0|        free_and_set_true:
18635|      0|            JS_FreeValue(ctx, sp[-1]);
18636|      0|#endif
18637|    683|        set_true:
18638|    683|            sp[-1] = JS_TRUE;
18639|    683|            BREAK;
18640|  13.7k|        free_and_set_false:
18641|  13.7k|            JS_FreeValue(ctx, sp[-1]);
18642|  13.7k|            sp[-1] = JS_FALSE;
18643|  13.7k|            BREAK;
18644|  13.7k|        CASE(OP_invalid):
18645|      0|        DEFAULT:
18646|      0|            JS_ThrowInternalError(ctx, "invalid opcode: pc=%u opcode=0x%02x",
18647|      0|                                  (int)(pc - b->byte_code_buf - 1), opcode);
18648|      0|            goto exception;
18649|      0|        }
18650|      0|    }
18651|   144k| exception:
18652|   144k|    if (is_backtrace_needed(ctx, rt->current_exception)) {
18653|       |        /* add the backtrace information now (it is not done
18654|       |           before if the exception happens in a bytecode
18655|       |           operation */
18656|  5.80k|        sf->cur_pc = pc;
18657|  5.80k|        build_backtrace(ctx, rt->current_exception, NULL, 0, 0, 0);
18658|  5.80k|    }
18659|   144k|    if (!JS_IsUncatchableError(ctx, rt->current_exception)) {
18660|   559k|        while (sp > stack_buf) {
18661|   414k|            JSValue val = *--sp;
18662|   414k|            JS_FreeValue(ctx, val);
18663|   414k|            if (JS_VALUE_GET_TAG(val) == JS_TAG_CATCH_OFFSET) {
18664|    217|                int pos = JS_VALUE_GET_INT(val);
18665|    217|                if (pos == 0) {
18666|       |                    /* enumerator: close it with a throw */
18667|    217|                    JS_FreeValue(ctx, sp[-1]); /* drop the next method */
18668|    217|                    sp--;
18669|    217|                    JS_IteratorClose(ctx, sp[-1], TRUE);
18670|    217|                } else {
18671|      0|                    *sp++ = rt->current_exception;
18672|      0|                    rt->current_exception = JS_UNINITIALIZED;
18673|      0|                    pc = b->byte_code_buf + pos;
18674|      0|                    goto restart;
18675|      0|                }
18676|    217|            }
18677|   414k|        }
18678|   144k|    }
18679|   144k|    ret_val = JS_EXCEPTION;
18680|       |    /* the local variables are freed by the caller in the generator
18681|       |       case. Hence the label 'done' should never be reached in a
18682|       |       generator function. */
18683|   144k|    if (b->func_kind != JS_FUNC_NORMAL) {
18684|    367|    done_generator:
18685|    367|        sf->cur_pc = pc;
18686|    367|        sf->cur_sp = sp;
18687|   144k|    } else {
18688|   247k|    done:
18689|   247k|        if (unlikely(!list_empty(&sf->var_ref_list))) {
18690|       |            /* variable references reference the stack: must close them */
18691|  19.7k|            close_var_refs(rt, sf);
18692|  19.7k|        }
18693|       |        /* free the local variables and stack */
18694|   497k|        for(pval = local_buf; pval < sp; pval++) {
18695|   250k|            JS_FreeValue(ctx, *pval);
18696|   250k|        }
18697|   247k|    }
18698|   247k|    rt->current_stack_frame = sf->prev_frame;
18699|   247k|    return ret_val;
18700|   144k|}
18701|       |
18702|       |JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
18703|       |                int argc, JSValueConst *argv)
18704|  8.95k|{
18705|  8.95k|    return JS_CallInternal(ctx, func_obj, this_obj, JS_UNDEFINED,
18706|  8.95k|                           argc, (JSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
18707|  8.95k|}
18708|       |
18709|       |static JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_obj,
18710|       |                           int argc, JSValueConst *argv)
18711|  9.57M|{
18712|  9.57M|    JSValue res = JS_CallInternal(ctx, func_obj, this_obj, JS_UNDEFINED,
18713|  9.57M|                                  argc, (JSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
18714|  9.57M|    JS_FreeValue(ctx, func_obj);
18715|  9.57M|    return res;
18716|  9.57M|}
18717|       |
18718|       |/* warning: the refcount of the context is not incremented. Return
18719|       |   NULL in case of exception (case of revoked proxy only) */
18720|       |static JSContext *JS_GetFunctionRealm(JSContext *ctx, JSValueConst func_obj)
18721|      0|{
18722|      0|    JSObject *p;
18723|      0|    JSContext *realm;
18724|       |
18725|      0|    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
18726|      0|        return ctx;
18727|      0|    p = JS_VALUE_GET_OBJ(func_obj);
18728|      0|    switch(p->class_id) {
18729|      0|    case JS_CLASS_C_FUNCTION:
18730|      0|        realm = p->u.cfunc.realm;
18731|      0|        break;
18732|      0|    case JS_CLASS_BYTECODE_FUNCTION:
18733|      0|    case JS_CLASS_GENERATOR_FUNCTION:
18734|      0|    case JS_CLASS_ASYNC_FUNCTION:
18735|      0|    case JS_CLASS_ASYNC_GENERATOR_FUNCTION:
18736|      0|        {
18737|      0|            JSFunctionBytecode *b;
18738|      0|            b = p->u.func.function_bytecode;
18739|      0|            realm = b->realm;
18740|      0|        }
18741|      0|        break;
18742|      0|    case JS_CLASS_PROXY:
18743|      0|        {
18744|      0|            JSProxyData *s = p->u.opaque;
18745|      0|            if (!s)
18746|      0|                return ctx;
18747|      0|            if (s->is_revoked) {
18748|      0|                JS_ThrowTypeErrorRevokedProxy(ctx);
18749|      0|                return NULL;
18750|      0|            } else {
18751|      0|                realm = JS_GetFunctionRealm(ctx, s->target);
18752|      0|            }
18753|      0|        }
18754|      0|        break;
18755|      0|    case JS_CLASS_BOUND_FUNCTION:
18756|      0|        {
18757|      0|            JSBoundFunction *bf = p->u.bound_function;
18758|      0|            realm = JS_GetFunctionRealm(ctx, bf->func_obj);
18759|      0|        }
18760|      0|        break;
18761|      0|    default:
18762|      0|        realm = ctx;
18763|      0|        break;
18764|      0|    }
18765|      0|    return realm;
18766|      0|}
18767|       |
18768|       |static JSValue js_create_from_ctor(JSContext *ctx, JSValueConst ctor,
18769|       |                                   int class_id)
18770|   849k|{
18771|   849k|    JSValue proto, obj;
18772|   849k|    JSContext *realm;
18773|       |
18774|   849k|    if (JS_IsUndefined(ctor)) {
18775|   849k|        proto = JS_DupValue(ctx, ctx->class_proto[class_id]);
18776|   849k|    } else {
18777|      0|        proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype);
18778|      0|        if (JS_IsException(proto))
18779|      0|            return proto;
18780|      0|        if (!JS_IsObject(proto)) {
18781|      0|            JS_FreeValue(ctx, proto);
18782|      0|            realm = JS_GetFunctionRealm(ctx, ctor);
18783|      0|            if (!realm)
18784|      0|                return JS_EXCEPTION;
18785|      0|            proto = JS_DupValue(ctx, realm->class_proto[class_id]);
18786|      0|        }
18787|      0|    }
18788|   849k|    obj = JS_NewObjectProtoClass(ctx, proto, class_id);
18789|   849k|    JS_FreeValue(ctx, proto);
18790|   849k|    return obj;
18791|   849k|}
18792|       |
18793|       |/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */
18794|       |static JSValue JS_CallConstructorInternal(JSContext *ctx,
18795|       |                                          JSValueConst func_obj,
18796|       |                                          JSValueConst new_target,
18797|       |                                          int argc, JSValue *argv, int flags)
18798|      2|{
18799|      2|    JSObject *p;
18800|      2|    JSFunctionBytecode *b;
18801|       |
18802|      2|    if (js_poll_interrupts(ctx))
18803|      0|        return JS_EXCEPTION;
18804|      2|    flags |= JS_CALL_FLAG_CONSTRUCTOR;
18805|      2|    if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT))
18806|      1|        goto not_a_function;
18807|      1|    p = JS_VALUE_GET_OBJ(func_obj);
18808|      1|    if (unlikely(!p->is_constructor))
18809|      1|        return JS_ThrowTypeError(ctx, "not a constructor");
18810|      0|    if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
18811|      0|        JSClassCall *call_func;
18812|      0|        call_func = ctx->rt->class_array[p->class_id].call;
18813|      0|        if (!call_func) {
18814|      1|        not_a_function:
18815|      1|            return JS_ThrowTypeError(ctx, "not a function");
18816|      0|        }
18817|      0|        return call_func(ctx, func_obj, new_target, argc,
18818|      0|                         (JSValueConst *)argv, flags);
18819|      0|    }
18820|       |
18821|      0|    b = p->u.func.function_bytecode;
18822|      0|    if (b->is_derived_class_constructor) {
18823|      0|        return JS_CallInternal(ctx, func_obj, JS_UNDEFINED, new_target, argc, argv, flags);
18824|      0|    } else {
18825|      0|        JSValue obj, ret;
18826|       |        /* legacy constructor behavior */
18827|      0|        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);
18828|      0|        if (JS_IsException(obj))
18829|      0|            return JS_EXCEPTION;
18830|      0|        ret = JS_CallInternal(ctx, func_obj, obj, new_target, argc, argv, flags);
18831|      0|        if (JS_VALUE_GET_TAG(ret) == JS_TAG_OBJECT ||
18832|      0|            JS_IsException(ret)) {
18833|      0|            JS_FreeValue(ctx, obj);
18834|      0|            return ret;
18835|      0|        } else {
18836|      0|            JS_FreeValue(ctx, ret);
18837|      0|            return obj;
18838|      0|        }
18839|      0|    }
18840|      0|}
18841|       |
18842|       |JSValue JS_CallConstructor2(JSContext *ctx, JSValueConst func_obj,
18843|       |                            JSValueConst new_target,
18844|       |                            int argc, JSValueConst *argv)
18845|      0|{
18846|      0|    return JS_CallConstructorInternal(ctx, func_obj, new_target,
18847|      0|                                      argc, (JSValue *)argv,
18848|      0|                                      JS_CALL_FLAG_COPY_ARGV);
18849|      0|}
18850|       |
18851|       |JSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,
18852|       |                           int argc, JSValueConst *argv)
18853|      0|{
18854|      0|    return JS_CallConstructorInternal(ctx, func_obj, func_obj,
18855|      0|                                      argc, (JSValue *)argv,
18856|      0|                                      JS_CALL_FLAG_COPY_ARGV);
18857|      0|}
18858|       |
18859|       |JSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,
18860|       |                  int argc, JSValueConst *argv)
18861|      0|{
18862|      0|    JSValue func_obj;
18863|      0|    func_obj = JS_GetProperty(ctx, this_val, atom);
18864|      0|    if (JS_IsException(func_obj))
18865|      0|        return func_obj;
18866|      0|    return JS_CallFree(ctx, func_obj, this_val, argc, argv);
18867|      0|}
18868|       |
18869|       |static JSValue JS_InvokeFree(JSContext *ctx, JSValue this_val, JSAtom atom,
18870|       |                             int argc, JSValueConst *argv)
18871|      0|{
18872|      0|    JSValue res = JS_Invoke(ctx, this_val, atom, argc, argv);
18873|      0|    JS_FreeValue(ctx, this_val);
18874|      0|    return res;
18875|      0|}
18876|       |
18877|       |/* JSAsyncFunctionState (used by generator and async functions) */
18878|       |static JSAsyncFunctionState *async_func_init(JSContext *ctx,
18879|       |                                             JSValueConst func_obj, JSValueConst this_obj,
18880|       |                                             int argc, JSValueConst *argv)
18881|    367|{
18882|    367|    JSAsyncFunctionState *s;
18883|    367|    JSObject *p;
18884|    367|    JSFunctionBytecode *b;
18885|    367|    JSStackFrame *sf;
18886|    367|    int local_count, i, arg_buf_len, n;
18887|       |
18888|    367|    s = js_mallocz(ctx, sizeof(*s));
18889|    367|    if (!s)
18890|      0|        return NULL;
18891|    367|    s->header.ref_count = 1;
18892|    367|    add_gc_object(ctx->rt, &s->header, JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
18893|       |
18894|    367|    sf = &s->frame;
18895|    367|    init_list_head(&sf->var_ref_list);
18896|    367|    p = JS_VALUE_GET_OBJ(func_obj);
18897|    367|    b = p->u.func.function_bytecode;
18898|    367|    sf->js_mode = b->js_mode | JS_MODE_ASYNC;
18899|    367|    sf->cur_pc = b->byte_code_buf;
18900|    367|    arg_buf_len = max_int(b->arg_count, argc);
18901|    367|    local_count = arg_buf_len + b->var_count + b->stack_size;
18902|    367|    sf->arg_buf = js_malloc(ctx, sizeof(JSValue) * max_int(local_count, 1));
18903|    367|    if (!sf->arg_buf) {
18904|      0|        js_free(ctx, s);
18905|      0|        return NULL;
18906|      0|    }
18907|    367|    sf->cur_func = JS_DupValue(ctx, func_obj);
18908|    367|    s->this_val = JS_DupValue(ctx, this_obj);
18909|    367|    s->argc = argc;
18910|    367|    sf->arg_count = arg_buf_len;
18911|    367|    sf->var_buf = sf->arg_buf + arg_buf_len;
18912|    367|    sf->cur_sp = sf->var_buf + b->var_count;
18913|    367|    for(i = 0; i < argc; i++)
18914|      0|        sf->arg_buf[i] = JS_DupValue(ctx, argv[i]);
18915|    367|    n = arg_buf_len + b->var_count;
18916|  6.71k|    for(i = argc; i < n; i++)
18917|  6.35k|        sf->arg_buf[i] = JS_UNDEFINED;
18918|    367|    s->resolving_funcs[0] = JS_UNDEFINED;
18919|    367|    s->resolving_funcs[1] = JS_UNDEFINED;
18920|    367|    s->is_completed = FALSE;
18921|    367|    return s;
18922|    367|}
18923|       |
18924|       |static void async_func_free_frame(JSRuntime *rt, JSAsyncFunctionState *s)
18925|    367|{
18926|    367|    JSStackFrame *sf = &s->frame;
18927|    367|    JSValue *sp;
18928|       |
18929|    367|    if (sf->arg_buf) {
18930|       |        /* cannot free the function if it is running */
18931|    367|        assert(sf->cur_sp != NULL);
18932|  6.73k|        for(sp = sf->arg_buf; sp < sf->cur_sp; sp++) {
18933|  6.36k|            JS_FreeValueRT(rt, *sp);
18934|  6.36k|        }
18935|    367|        js_free_rt(rt, sf->arg_buf);
18936|    367|        sf->arg_buf = NULL;
18937|    367|    }
18938|    367|    JS_FreeValueRT(rt, sf->cur_func);
18939|    367|    JS_FreeValueRT(rt, s->this_val);
18940|    367|}
18941|       |
18942|       |static JSValue async_func_resume(JSContext *ctx, JSAsyncFunctionState *s)
18943|    367|{
18944|    367|    JSRuntime *rt = ctx->rt;
18945|    367|    JSStackFrame *sf = &s->frame;
18946|    367|    JSValue func_obj, ret;
18947|       |
18948|    367|    assert(!s->is_completed);
18949|    367|    if (js_check_stack_overflow(ctx->rt, 0)) {
18950|      0|        ret = JS_ThrowStackOverflow(ctx);
18951|    367|    } else {
18952|       |        /* the tag does not matter provided it is not an object */
18953|    367|        func_obj = JS_MKPTR(JS_TAG_INT, s);
18954|    367|        ret = JS_CallInternal(ctx, func_obj, s->this_val, JS_UNDEFINED,
18955|    367|                              s->argc, sf->arg_buf, JS_CALL_FLAG_GENERATOR);
18956|    367|    }
18957|    367|    if (JS_IsException(ret) || JS_IsUndefined(ret)) {
18958|    367|        if (JS_IsUndefined(ret)) {
18959|     15|            ret = sf->cur_sp[-1];
18960|     15|            sf->cur_sp[-1] = JS_UNDEFINED;
18961|     15|        }
18962|       |        /* end of execution */
18963|    367|        s->is_completed = TRUE;
18964|       |
18965|       |        /* close the closure variables. */
18966|    367|        close_var_refs(rt, sf);
18967|       |
18968|    367|        async_func_free_frame(rt, s);
18969|    367|    }
18970|    367|    return ret;
18971|    367|}
18972|       |
18973|       |static void __async_func_free(JSRuntime *rt, JSAsyncFunctionState *s)
18974|     15|{
18975|       |    /* cannot close the closure variables here because it would
18976|       |       potentially modify the object graph */
18977|     15|    if (!s->is_completed) {
18978|      0|        async_func_free_frame(rt, s);
18979|      0|    }
18980|       |
18981|     15|    JS_FreeValueRT(rt, s->resolving_funcs[0]);
18982|     15|    JS_FreeValueRT(rt, s->resolving_funcs[1]);
18983|       |
18984|     15|    remove_gc_object(&s->header);
18985|     15|    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && s->header.ref_count != 0) {
18986|      0|        list_add_tail(&s->header.link, &rt->gc_zero_ref_count_list);
18987|     15|    } else {
18988|     15|        js_free_rt(rt, s);
18989|     15|    }
18990|     15|}
18991|       |
18992|       |static void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s)
18993|    280|{
18994|    280|    if (--s->header.ref_count == 0) {
18995|     15|        if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {
18996|     15|            list_del(&s->header.link);
18997|     15|            list_add(&s->header.link, &rt->gc_zero_ref_count_list);
18998|     15|            if (rt->gc_phase == JS_GC_PHASE_NONE) {
18999|     15|                free_zero_refcount(rt);
19000|     15|            }
19001|     15|        }
19002|     15|    }
19003|    280|}
19004|       |
19005|       |/* Generators */
19006|       |
19007|       |typedef enum JSGeneratorStateEnum {
19008|       |    JS_GENERATOR_STATE_SUSPENDED_START,
19009|       |    JS_GENERATOR_STATE_SUSPENDED_YIELD,
19010|       |    JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR,
19011|       |    JS_GENERATOR_STATE_EXECUTING,
19012|       |    JS_GENERATOR_STATE_COMPLETED,
19013|       |} JSGeneratorStateEnum;
19014|       |
19015|       |typedef struct JSGeneratorData {
19016|       |    JSGeneratorStateEnum state;
19017|       |    JSAsyncFunctionState *func_state;
19018|       |} JSGeneratorData;
19019|       |
19020|       |static void free_generator_stack_rt(JSRuntime *rt, JSGeneratorData *s)
19021|      0|{
19022|      0|    if (s->state == JS_GENERATOR_STATE_COMPLETED)
19023|      0|        return;
19024|      0|    if (s->func_state) {
19025|      0|        async_func_free(rt, s->func_state);
19026|      0|        s->func_state = NULL;
19027|      0|    }
19028|      0|    s->state = JS_GENERATOR_STATE_COMPLETED;
19029|      0|}
19030|       |
19031|       |static void js_generator_finalizer(JSRuntime *rt, JSValue obj)
19032|      0|{
19033|      0|    JSGeneratorData *s = JS_GetOpaque(obj, JS_CLASS_GENERATOR);
19034|       |
19035|      0|    if (s) {
19036|      0|        free_generator_stack_rt(rt, s);
19037|      0|        js_free_rt(rt, s);
19038|      0|    }
19039|      0|}
19040|       |
19041|       |static void free_generator_stack(JSContext *ctx, JSGeneratorData *s)
19042|      0|{
19043|      0|    free_generator_stack_rt(ctx->rt, s);
19044|      0|}
19045|       |
19046|       |static void js_generator_mark(JSRuntime *rt, JSValueConst val,
19047|       |                              JS_MarkFunc *mark_func)
19048|      0|{
19049|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
19050|      0|    JSGeneratorData *s = p->u.generator_data;
19051|       |
19052|      0|    if (!s || !s->func_state)
19053|      0|        return;
19054|      0|    mark_func(rt, &s->func_state->header);
19055|      0|}
19056|       |
19057|       |/* XXX: use enum */
19058|      0|#define GEN_MAGIC_NEXT   0
19059|      0|#define GEN_MAGIC_RETURN 1
19060|      0|#define GEN_MAGIC_THROW  2
19061|       |
19062|       |static JSValue js_generator_next(JSContext *ctx, JSValueConst this_val,
19063|       |                                 int argc, JSValueConst *argv,
19064|       |                                 BOOL *pdone, int magic)
19065|      0|{
19066|      0|    JSGeneratorData *s = JS_GetOpaque(this_val, JS_CLASS_GENERATOR);
19067|      0|    JSStackFrame *sf;
19068|      0|    JSValue ret, func_ret;
19069|       |
19070|      0|    *pdone = TRUE;
19071|      0|    if (!s)
19072|      0|        return JS_ThrowTypeError(ctx, "not a generator");
19073|      0|    switch(s->state) {
19074|      0|    default:
19075|      0|    case JS_GENERATOR_STATE_SUSPENDED_START:
19076|      0|        sf = &s->func_state->frame;
19077|      0|        if (magic == GEN_MAGIC_NEXT) {
19078|      0|            goto exec_no_arg;
19079|      0|        } else {
19080|      0|            free_generator_stack(ctx, s);
19081|      0|            goto done;
19082|      0|        }
19083|      0|        break;
19084|      0|    case JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR:
19085|      0|    case JS_GENERATOR_STATE_SUSPENDED_YIELD:
19086|      0|        sf = &s->func_state->frame;
19087|       |        /* cur_sp[-1] was set to JS_UNDEFINED in the previous call */
19088|      0|        ret = JS_DupValue(ctx, argv[0]);
19089|      0|        if (magic == GEN_MAGIC_THROW &&
19090|      0|            s->state == JS_GENERATOR_STATE_SUSPENDED_YIELD) {
19091|      0|            JS_Throw(ctx, ret);
19092|      0|            s->func_state->throw_flag = TRUE;
19093|      0|        } else {
19094|      0|            sf->cur_sp[-1] = ret;
19095|      0|            sf->cur_sp[0] = JS_NewInt32(ctx, magic);
19096|      0|            sf->cur_sp++;
19097|      0|        exec_no_arg:
19098|      0|            s->func_state->throw_flag = FALSE;
19099|      0|        }
19100|      0|        s->state = JS_GENERATOR_STATE_EXECUTING;
19101|      0|        func_ret = async_func_resume(ctx, s->func_state);
19102|      0|        s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD;
19103|      0|        if (s->func_state->is_completed) {
19104|       |            /* finalize the execution in case of exception or normal return */
19105|      0|            free_generator_stack(ctx, s);
19106|      0|            return func_ret;
19107|      0|        } else {
19108|      0|            assert(JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT);
19109|       |            /* get the returned yield value at the top of the stack */
19110|      0|            ret = sf->cur_sp[-1];
19111|      0|            sf->cur_sp[-1] = JS_UNDEFINED;
19112|      0|            if (JS_VALUE_GET_INT(func_ret) == FUNC_RET_YIELD_STAR) {
19113|      0|                s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
19114|       |                /* return (value, done) object */
19115|      0|                *pdone = 2;
19116|      0|            } else {
19117|      0|                *pdone = FALSE;
19118|      0|            }
19119|      0|        }
19120|      0|        break;
19121|      0|    case JS_GENERATOR_STATE_COMPLETED:
19122|      0|    done:
19123|       |        /* execution is finished */
19124|      0|        switch(magic) {
19125|      0|        default:
19126|      0|        case GEN_MAGIC_NEXT:
19127|      0|            ret = JS_UNDEFINED;
19128|      0|            break;
19129|      0|        case GEN_MAGIC_RETURN:
19130|      0|            ret = JS_DupValue(ctx, argv[0]);
19131|      0|            break;
19132|      0|        case GEN_MAGIC_THROW:
19133|      0|            ret = JS_Throw(ctx, JS_DupValue(ctx, argv[0]));
19134|      0|            break;
19135|      0|        }
19136|      0|        break;
19137|      0|    case JS_GENERATOR_STATE_EXECUTING:
19138|      0|        ret = JS_ThrowTypeError(ctx, "cannot invoke a running generator");
19139|      0|        break;
19140|      0|    }
19141|      0|    return ret;
19142|      0|}
19143|       |
19144|       |static JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,
19145|       |                                          JSValueConst this_obj,
19146|       |                                          int argc, JSValueConst *argv,
19147|       |                                          int flags)
19148|      0|{
19149|      0|    JSValue obj, func_ret;
19150|      0|    JSGeneratorData *s;
19151|       |
19152|      0|    s = js_mallocz(ctx, sizeof(*s));
19153|      0|    if (!s)
19154|      0|        return JS_EXCEPTION;
19155|      0|    s->state = JS_GENERATOR_STATE_SUSPENDED_START;
19156|      0|    s->func_state = async_func_init(ctx, func_obj, this_obj, argc, argv);
19157|      0|    if (!s->func_state) {
19158|      0|        s->state = JS_GENERATOR_STATE_COMPLETED;
19159|      0|        goto fail;
19160|      0|    }
19161|       |
19162|       |    /* execute the function up to 'OP_initial_yield' */
19163|      0|    func_ret = async_func_resume(ctx, s->func_state);
19164|      0|    if (JS_IsException(func_ret))
19165|      0|        goto fail;
19166|      0|    JS_FreeValue(ctx, func_ret);
19167|       |
19168|      0|    obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_GENERATOR);
19169|      0|    if (JS_IsException(obj))
19170|      0|        goto fail;
19171|      0|    JS_SetOpaque(obj, s);
19172|      0|    return obj;
19173|      0| fail:
19174|      0|    free_generator_stack_rt(ctx->rt, s);
19175|      0|    js_free(ctx, s);
19176|      0|    return JS_EXCEPTION;
19177|      0|}
19178|       |
19179|       |/* AsyncFunction */
19180|       |
19181|       |static void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val)
19182|      0|{
19183|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
19184|      0|    JSAsyncFunctionState *s = p->u.async_function_data;
19185|      0|    if (s) {
19186|      0|        async_func_free(rt, s);
19187|      0|    }
19188|      0|}
19189|       |
19190|       |static void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,
19191|       |                                           JS_MarkFunc *mark_func)
19192|      0|{
19193|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
19194|      0|    JSAsyncFunctionState *s = p->u.async_function_data;
19195|      0|    if (s) {
19196|      0|        mark_func(rt, &s->header);
19197|      0|    }
19198|      0|}
19199|       |
19200|       |static int js_async_function_resolve_create(JSContext *ctx,
19201|       |                                            JSAsyncFunctionState *s,
19202|       |                                            JSValue *resolving_funcs)
19203|      0|{
19204|      0|    int i;
19205|      0|    JSObject *p;
19206|       |
19207|      0|    for(i = 0; i < 2; i++) {
19208|      0|        resolving_funcs[i] =
19209|      0|            JS_NewObjectProtoClass(ctx, ctx->function_proto,
19210|      0|                                   JS_CLASS_ASYNC_FUNCTION_RESOLVE + i);
19211|      0|        if (JS_IsException(resolving_funcs[i])) {
19212|      0|            if (i == 1)
19213|      0|                JS_FreeValue(ctx, resolving_funcs[0]);
19214|      0|            return -1;
19215|      0|        }
19216|      0|        p = JS_VALUE_GET_OBJ(resolving_funcs[i]);
19217|      0|        s->header.ref_count++;
19218|      0|        p->u.async_function_data = s;
19219|      0|    }
19220|      0|    return 0;
19221|      0|}
19222|       |
19223|       |static void js_async_function_resume(JSContext *ctx, JSAsyncFunctionState *s)
19224|    367|{
19225|    367|    JSValue func_ret, ret2;
19226|       |
19227|    367|    func_ret = async_func_resume(ctx, s);
19228|    367|    if (s->is_completed) {
19229|    367|        if (JS_IsException(func_ret)) {
19230|    352|            JSValue error;
19231|    352|        fail:
19232|    352|            error = JS_GetException(ctx);
19233|    352|            ret2 = JS_Call(ctx, s->resolving_funcs[1], JS_UNDEFINED,
19234|    352|                           1, (JSValueConst *)&error);
19235|    352|            JS_FreeValue(ctx, error);
19236|    352|            JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
19237|    352|        } else {
19238|       |            /* normal return */
19239|     15|            ret2 = JS_Call(ctx, s->resolving_funcs[0], JS_UNDEFINED,
19240|     15|                           1, (JSValueConst *)&func_ret);
19241|     15|            JS_FreeValue(ctx, func_ret);
19242|     15|            JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
19243|     15|        }
19244|    367|    } else {
19245|      0|        JSValue value, promise, resolving_funcs[2], resolving_funcs1[2];
19246|      0|        int i, res;
19247|       |
19248|      0|        value = s->frame.cur_sp[-1];
19249|      0|        s->frame.cur_sp[-1] = JS_UNDEFINED;
19250|       |
19251|       |        /* await */
19252|      0|        JS_FreeValue(ctx, func_ret); /* not used */
19253|      0|        promise = js_promise_resolve(ctx, ctx->promise_ctor,
19254|      0|                                     1, (JSValueConst *)&value, 0);
19255|      0|        JS_FreeValue(ctx, value);
19256|      0|        if (JS_IsException(promise))
19257|      0|            goto fail;
19258|      0|        if (js_async_function_resolve_create(ctx, s, resolving_funcs)) {
19259|      0|            JS_FreeValue(ctx, promise);
19260|      0|            goto fail;
19261|      0|        }
19262|       |
19263|       |        /* Note: no need to create 'thrownawayCapability' as in
19264|       |           the spec */
19265|      0|        for(i = 0; i < 2; i++)
19266|      0|            resolving_funcs1[i] = JS_UNDEFINED;
19267|      0|        res = perform_promise_then(ctx, promise,
19268|      0|                                   (JSValueConst *)resolving_funcs,
19269|      0|                                   (JSValueConst *)resolving_funcs1);
19270|      0|        JS_FreeValue(ctx, promise);
19271|      0|        for(i = 0; i < 2; i++)
19272|      0|            JS_FreeValue(ctx, resolving_funcs[i]);
19273|      0|        if (res)
19274|      0|            goto fail;
19275|      0|    }
19276|    367|}
19277|       |
19278|       |static JSValue js_async_function_resolve_call(JSContext *ctx,
19279|       |                                              JSValueConst func_obj,
19280|       |                                              JSValueConst this_obj,
19281|       |                                              int argc, JSValueConst *argv,
19282|       |                                              int flags)
19283|      0|{
19284|      0|    JSObject *p = JS_VALUE_GET_OBJ(func_obj);
19285|      0|    JSAsyncFunctionState *s = p->u.async_function_data;
19286|      0|    BOOL is_reject = p->class_id - JS_CLASS_ASYNC_FUNCTION_RESOLVE;
19287|      0|    JSValueConst arg;
19288|       |
19289|      0|    if (argc > 0)
19290|      0|        arg = argv[0];
19291|      0|    else
19292|      0|        arg = JS_UNDEFINED;
19293|      0|    s->throw_flag = is_reject;
19294|      0|    if (is_reject) {
19295|      0|        JS_Throw(ctx, JS_DupValue(ctx, arg));
19296|      0|    } else {
19297|       |        /* return value of await */
19298|      0|        s->frame.cur_sp[-1] = JS_DupValue(ctx, arg);
19299|      0|    }
19300|      0|    js_async_function_resume(ctx, s);
19301|      0|    return JS_UNDEFINED;
19302|      0|}
19303|       |
19304|       |static JSValue js_async_function_call(JSContext *ctx, JSValueConst func_obj,
19305|       |                                      JSValueConst this_obj,
19306|       |                                      int argc, JSValueConst *argv, int flags)
19307|    367|{
19308|    367|    JSValue promise;
19309|    367|    JSAsyncFunctionState *s;
19310|       |
19311|    367|    s = async_func_init(ctx, func_obj, this_obj, argc, argv);
19312|    367|    if (!s)
19313|      0|        return JS_EXCEPTION;
19314|       |
19315|    367|    promise = JS_NewPromiseCapability(ctx, s->resolving_funcs);
19316|    367|    if (JS_IsException(promise)) {
19317|      0|        async_func_free(ctx->rt, s);
19318|      0|        return JS_EXCEPTION;
19319|      0|    }
19320|       |
19321|    367|    js_async_function_resume(ctx, s);
19322|       |
19323|    367|    async_func_free(ctx->rt, s);
19324|       |
19325|    367|    return promise;
19326|    367|}
19327|       |
19328|       |/* AsyncGenerator */
19329|       |
19330|       |typedef enum JSAsyncGeneratorStateEnum {
19331|       |    JS_ASYNC_GENERATOR_STATE_SUSPENDED_START,
19332|       |    JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD,
19333|       |    JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR,
19334|       |    JS_ASYNC_GENERATOR_STATE_EXECUTING,
19335|       |    JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN,
19336|       |    JS_ASYNC_GENERATOR_STATE_COMPLETED,
19337|       |} JSAsyncGeneratorStateEnum;
19338|       |
19339|       |typedef struct JSAsyncGeneratorRequest {
19340|       |    struct list_head link;
19341|       |    /* completion */
19342|       |    int completion_type; /* GEN_MAGIC_x */
19343|       |    JSValue result;
19344|       |    /* promise capability */
19345|       |    JSValue promise;
19346|       |    JSValue resolving_funcs[2];
19347|       |} JSAsyncGeneratorRequest;
19348|       |
19349|       |typedef struct JSAsyncGeneratorData {
19350|       |    JSObject *generator; /* back pointer to the object (const) */
19351|       |    JSAsyncGeneratorStateEnum state;
19352|       |    /* func_state is NULL is state AWAITING_RETURN and COMPLETED */
19353|       |    JSAsyncFunctionState *func_state;
19354|       |    struct list_head queue; /* list of JSAsyncGeneratorRequest.link */
19355|       |} JSAsyncGeneratorData;
19356|       |
19357|       |static void js_async_generator_free(JSRuntime *rt,
19358|       |                                    JSAsyncGeneratorData *s)
19359|      0|{
19360|      0|    struct list_head *el, *el1;
19361|      0|    JSAsyncGeneratorRequest *req;
19362|       |
19363|      0|    list_for_each_safe(el, el1, &s->queue) {
19364|      0|        req = list_entry(el, JSAsyncGeneratorRequest, link);
19365|      0|        JS_FreeValueRT(rt, req->result);
19366|      0|        JS_FreeValueRT(rt, req->promise);
19367|      0|        JS_FreeValueRT(rt, req->resolving_funcs[0]);
19368|      0|        JS_FreeValueRT(rt, req->resolving_funcs[1]);
19369|      0|        js_free_rt(rt, req);
19370|      0|    }
19371|      0|    if (s->func_state)
19372|      0|        async_func_free(rt, s->func_state);
19373|      0|    js_free_rt(rt, s);
19374|      0|}
19375|       |
19376|       |static void js_async_generator_finalizer(JSRuntime *rt, JSValue obj)
19377|      0|{
19378|      0|    JSAsyncGeneratorData *s = JS_GetOpaque(obj, JS_CLASS_ASYNC_GENERATOR);
19379|       |
19380|      0|    if (s) {
19381|      0|        js_async_generator_free(rt, s);
19382|      0|    }
19383|      0|}
19384|       |
19385|       |static void js_async_generator_mark(JSRuntime *rt, JSValueConst val,
19386|       |                                    JS_MarkFunc *mark_func)
19387|      0|{
19388|      0|    JSAsyncGeneratorData *s = JS_GetOpaque(val, JS_CLASS_ASYNC_GENERATOR);
19389|      0|    struct list_head *el;
19390|      0|    JSAsyncGeneratorRequest *req;
19391|      0|    if (s) {
19392|      0|        list_for_each(el, &s->queue) {
19393|      0|            req = list_entry(el, JSAsyncGeneratorRequest, link);
19394|      0|            JS_MarkValue(rt, req->result, mark_func);
19395|      0|            JS_MarkValue(rt, req->promise, mark_func);
19396|      0|            JS_MarkValue(rt, req->resolving_funcs[0], mark_func);
19397|      0|            JS_MarkValue(rt, req->resolving_funcs[1], mark_func);
19398|      0|        }
19399|      0|        if (s->func_state) {
19400|      0|            mark_func(rt, &s->func_state->header);
19401|      0|        }
19402|      0|    }
19403|      0|}
19404|       |
19405|       |static JSValue js_async_generator_resolve_function(JSContext *ctx,
19406|       |                                          JSValueConst this_obj,
19407|       |                                          int argc, JSValueConst *argv,
19408|       |                                          int magic, JSValue *func_data);
19409|       |
19410|       |static int js_async_generator_resolve_function_create(JSContext *ctx,
19411|       |                                                      JSValueConst generator,
19412|       |                                                      JSValue *resolving_funcs,
19413|       |                                                      BOOL is_resume_next)
19414|      0|{
19415|      0|    int i;
19416|      0|    JSValue func;
19417|       |
19418|      0|    for(i = 0; i < 2; i++) {
19419|      0|        func = JS_NewCFunctionData(ctx, js_async_generator_resolve_function, 1,
19420|      0|                                   i + is_resume_next * 2, 1, &generator);
19421|      0|        if (JS_IsException(func)) {
19422|      0|            if (i == 1)
19423|      0|                JS_FreeValue(ctx, resolving_funcs[0]);
19424|      0|            return -1;
19425|      0|        }
19426|      0|        resolving_funcs[i] = func;
19427|      0|    }
19428|      0|    return 0;
19429|      0|}
19430|       |
19431|       |static int js_async_generator_await(JSContext *ctx,
19432|       |                                    JSAsyncGeneratorData *s,
19433|       |                                    JSValueConst value)
19434|      0|{
19435|      0|    JSValue promise, resolving_funcs[2], resolving_funcs1[2];
19436|      0|    int i, res;
19437|       |
19438|      0|    promise = js_promise_resolve(ctx, ctx->promise_ctor,
19439|      0|                                 1, &value, 0);
19440|      0|    if (JS_IsException(promise))
19441|      0|        goto fail;
19442|       |
19443|      0|    if (js_async_generator_resolve_function_create(ctx, JS_MKPTR(JS_TAG_OBJECT, s->generator),
19444|      0|                                                   resolving_funcs, FALSE)) {
19445|      0|        JS_FreeValue(ctx, promise);
19446|      0|        goto fail;
19447|      0|    }
19448|       |
19449|       |    /* Note: no need to create 'thrownawayCapability' as in
19450|       |       the spec */
19451|      0|    for(i = 0; i < 2; i++)
19452|      0|        resolving_funcs1[i] = JS_UNDEFINED;
19453|      0|    res = perform_promise_then(ctx, promise,
19454|      0|                               (JSValueConst *)resolving_funcs,
19455|      0|                               (JSValueConst *)resolving_funcs1);
19456|      0|    JS_FreeValue(ctx, promise);
19457|      0|    for(i = 0; i < 2; i++)
19458|      0|        JS_FreeValue(ctx, resolving_funcs[i]);
19459|      0|    if (res)
19460|      0|        goto fail;
19461|      0|    return 0;
19462|      0| fail:
19463|      0|    return -1;
19464|      0|}
19465|       |
19466|       |static void js_async_generator_resolve_or_reject(JSContext *ctx,
19467|       |                                                 JSAsyncGeneratorData *s,
19468|       |                                                 JSValueConst result,
19469|       |                                                 int is_reject)
19470|      0|{
19471|      0|    JSAsyncGeneratorRequest *next;
19472|      0|    JSValue ret;
19473|       |
19474|      0|    next = list_entry(s->queue.next, JSAsyncGeneratorRequest, link);
19475|      0|    list_del(&next->link);
19476|      0|    ret = JS_Call(ctx, next->resolving_funcs[is_reject], JS_UNDEFINED, 1,
19477|      0|                  &result);
19478|      0|    JS_FreeValue(ctx, ret);
19479|      0|    JS_FreeValue(ctx, next->result);
19480|      0|    JS_FreeValue(ctx, next->promise);
19481|      0|    JS_FreeValue(ctx, next->resolving_funcs[0]);
19482|      0|    JS_FreeValue(ctx, next->resolving_funcs[1]);
19483|      0|    js_free(ctx, next);
19484|      0|}
19485|       |
19486|       |static void js_async_generator_resolve(JSContext *ctx,
19487|       |                                       JSAsyncGeneratorData *s,
19488|       |                                       JSValueConst value,
19489|       |                                       BOOL done)
19490|      0|{
19491|      0|    JSValue result;
19492|      0|    result = js_create_iterator_result(ctx, JS_DupValue(ctx, value), done);
19493|       |    /* XXX: better exception handling ? */
19494|      0|    js_async_generator_resolve_or_reject(ctx, s, result, 0);
19495|      0|    JS_FreeValue(ctx, result);
19496|      0| }
19497|       |
19498|       |static void js_async_generator_reject(JSContext *ctx,
19499|       |                                       JSAsyncGeneratorData *s,
19500|       |                                       JSValueConst exception)
19501|      0|{
19502|      0|    js_async_generator_resolve_or_reject(ctx, s, exception, 1);
19503|      0|}
19504|       |
19505|       |static void js_async_generator_complete(JSContext *ctx,
19506|       |                                        JSAsyncGeneratorData *s)
19507|      0|{
19508|      0|    if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED) {
19509|      0|        s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
19510|      0|        async_func_free(ctx->rt, s->func_state);
19511|      0|        s->func_state = NULL;
19512|      0|    }
19513|      0|}
19514|       |
19515|       |static int js_async_generator_completed_return(JSContext *ctx,
19516|       |                                               JSAsyncGeneratorData *s,
19517|       |                                               JSValueConst value)
19518|      0|{
19519|      0|    JSValue promise, resolving_funcs[2], resolving_funcs1[2];
19520|      0|    int res;
19521|       |
19522|       |    // Can fail looking up JS_ATOM_constructor when is_reject==0.
19523|      0|    promise = js_promise_resolve(ctx, ctx->promise_ctor, 1, &value,
19524|      0|                                 /*is_reject*/0);
19525|       |    // A poisoned .constructor property is observable and the resulting
19526|       |    // exception should be delivered to the catch handler.
19527|      0|    if (JS_IsException(promise)) {
19528|      0|        JSValue err = JS_GetException(ctx);
19529|      0|        promise = js_promise_resolve(ctx, ctx->promise_ctor, 1, (JSValueConst *)&err,
19530|      0|                                     /*is_reject*/1);
19531|      0|        JS_FreeValue(ctx, err);
19532|      0|        if (JS_IsException(promise))
19533|      0|            return -1;
19534|      0|    }
19535|      0|    if (js_async_generator_resolve_function_create(ctx,
19536|      0|                                                   JS_MKPTR(JS_TAG_OBJECT, s->generator),
19537|      0|                                                   resolving_funcs1,
19538|      0|                                                   TRUE)) {
19539|      0|        JS_FreeValue(ctx, promise);
19540|      0|        return -1;
19541|      0|    }
19542|      0|    resolving_funcs[0] = JS_UNDEFINED;
19543|      0|    resolving_funcs[1] = JS_UNDEFINED;
19544|      0|    res = perform_promise_then(ctx, promise,
19545|      0|                               (JSValueConst *)resolving_funcs1,
19546|      0|                               (JSValueConst *)resolving_funcs);
19547|      0|    JS_FreeValue(ctx, resolving_funcs1[0]);
19548|      0|    JS_FreeValue(ctx, resolving_funcs1[1]);
19549|      0|    JS_FreeValue(ctx, promise);
19550|      0|    return res;
19551|      0|}
19552|       |
19553|       |static void js_async_generator_resume_next(JSContext *ctx,
19554|       |                                           JSAsyncGeneratorData *s)
19555|      0|{
19556|      0|    JSAsyncGeneratorRequest *next;
19557|      0|    JSValue func_ret, value;
19558|       |
19559|      0|    for(;;) {
19560|      0|        if (list_empty(&s->queue))
19561|      0|            break;
19562|      0|        next = list_entry(s->queue.next, JSAsyncGeneratorRequest, link);
19563|      0|        switch(s->state) {
19564|      0|        case JS_ASYNC_GENERATOR_STATE_EXECUTING:
19565|       |            /* only happens when restarting execution after await() */
19566|      0|            goto resume_exec;
19567|      0|        case JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN:
19568|      0|            goto done;
19569|      0|        case JS_ASYNC_GENERATOR_STATE_SUSPENDED_START:
19570|      0|            if (next->completion_type == GEN_MAGIC_NEXT) {
19571|      0|                goto exec_no_arg;
19572|      0|            } else {
19573|      0|                js_async_generator_complete(ctx, s);
19574|      0|            }
19575|      0|            break;
19576|      0|        case JS_ASYNC_GENERATOR_STATE_COMPLETED:
19577|      0|            if (next->completion_type == GEN_MAGIC_NEXT) {
19578|      0|                js_async_generator_resolve(ctx, s, JS_UNDEFINED, TRUE);
19579|      0|            } else if (next->completion_type == GEN_MAGIC_RETURN) {
19580|      0|                s->state = JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN;
19581|      0|                js_async_generator_completed_return(ctx, s, next->result);
19582|      0|            } else {
19583|      0|                js_async_generator_reject(ctx, s, next->result);
19584|      0|            }
19585|      0|            goto done;
19586|      0|        case JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD:
19587|      0|        case JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR:
19588|      0|            value = JS_DupValue(ctx, next->result);
19589|      0|            if (next->completion_type == GEN_MAGIC_THROW &&
19590|      0|                s->state == JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD) {
19591|      0|                JS_Throw(ctx, value);
19592|      0|                s->func_state->throw_flag = TRUE;
19593|      0|            } else {
19594|       |                /* 'yield' returns a value. 'yield *' also returns a value
19595|       |                   in case the 'throw' method is called */
19596|      0|                s->func_state->frame.cur_sp[-1] = value;
19597|      0|                s->func_state->frame.cur_sp[0] =
19598|      0|                    JS_NewInt32(ctx, next->completion_type);
19599|      0|                s->func_state->frame.cur_sp++;
19600|      0|            exec_no_arg:
19601|      0|                s->func_state->throw_flag = FALSE;
19602|      0|            }
19603|      0|            s->state = JS_ASYNC_GENERATOR_STATE_EXECUTING;
19604|      0|        resume_exec:
19605|      0|            func_ret = async_func_resume(ctx, s->func_state);
19606|      0|            if (s->func_state->is_completed) {
19607|      0|                if (JS_IsException(func_ret)) {
19608|      0|                    value = JS_GetException(ctx);
19609|      0|                    js_async_generator_complete(ctx, s);
19610|      0|                    js_async_generator_reject(ctx, s, value);
19611|      0|                    JS_FreeValue(ctx, value);
19612|      0|                } else {
19613|       |                    /* end of function */
19614|      0|                    js_async_generator_complete(ctx, s);
19615|      0|                    js_async_generator_resolve(ctx, s, func_ret, TRUE);
19616|      0|                    JS_FreeValue(ctx, func_ret);
19617|      0|                }
19618|      0|            } else {
19619|      0|                int func_ret_code, ret;
19620|      0|                assert(JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT);
19621|      0|                func_ret_code = JS_VALUE_GET_INT(func_ret);
19622|      0|                value = s->func_state->frame.cur_sp[-1];
19623|      0|                s->func_state->frame.cur_sp[-1] = JS_UNDEFINED;
19624|      0|                switch(func_ret_code) {
19625|      0|                case FUNC_RET_YIELD:
19626|      0|                case FUNC_RET_YIELD_STAR:
19627|      0|                    if (func_ret_code == FUNC_RET_YIELD_STAR)
19628|      0|                        s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
19629|      0|                    else
19630|      0|                        s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD;
19631|      0|                    js_async_generator_resolve(ctx, s, value, FALSE);
19632|      0|                    JS_FreeValue(ctx, value);
19633|      0|                    break;
19634|      0|                case FUNC_RET_AWAIT:
19635|      0|                    ret = js_async_generator_await(ctx, s, value);
19636|      0|                    JS_FreeValue(ctx, value);
19637|      0|                    if (ret < 0) {
19638|       |                        /* exception: throw it */
19639|      0|                        s->func_state->throw_flag = TRUE;
19640|      0|                        goto resume_exec;
19641|      0|                    }
19642|      0|                    goto done;
19643|      0|                default:
19644|      0|                    abort();
19645|      0|                }
19646|      0|            }
19647|      0|            break;
19648|      0|        default:
19649|      0|            abort();
19650|      0|        }
19651|      0|    }
19652|      0| done: ;
19653|      0|}
19654|       |
19655|       |static JSValue js_async_generator_resolve_function(JSContext *ctx,
19656|       |                                                   JSValueConst this_obj,
19657|       |                                                   int argc, JSValueConst *argv,
19658|       |                                                   int magic, JSValue *func_data)
19659|      0|{
19660|      0|    BOOL is_reject = magic & 1;
19661|      0|    JSAsyncGeneratorData *s = JS_GetOpaque(func_data[0], JS_CLASS_ASYNC_GENERATOR);
19662|      0|    JSValueConst arg = argv[0];
19663|       |
19664|       |    /* XXX: what if s == NULL */
19665|       |
19666|      0|    if (magic >= 2) {
19667|       |        /* resume next case in AWAITING_RETURN state */
19668|      0|        assert(s->state == JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN ||
19669|      0|               s->state == JS_ASYNC_GENERATOR_STATE_COMPLETED);
19670|      0|        s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
19671|      0|        if (is_reject) {
19672|      0|            js_async_generator_reject(ctx, s, arg);
19673|      0|        } else {
19674|      0|            js_async_generator_resolve(ctx, s, arg, TRUE);
19675|      0|        }
19676|      0|    } else {
19677|       |        /* restart function execution after await() */
19678|      0|        assert(s->state == JS_ASYNC_GENERATOR_STATE_EXECUTING);
19679|      0|        s->func_state->throw_flag = is_reject;
19680|      0|        if (is_reject) {
19681|      0|            JS_Throw(ctx, JS_DupValue(ctx, arg));
19682|      0|        } else {
19683|       |            /* return value of await */
19684|      0|            s->func_state->frame.cur_sp[-1] = JS_DupValue(ctx, arg);
19685|      0|        }
19686|      0|        js_async_generator_resume_next(ctx, s);
19687|      0|    }
19688|      0|    return JS_UNDEFINED;
19689|      0|}
19690|       |
19691|       |/* magic = GEN_MAGIC_x */
19692|       |static JSValue js_async_generator_next(JSContext *ctx, JSValueConst this_val,
19693|       |                                       int argc, JSValueConst *argv,
19694|       |                                       int magic)
19695|      0|{
19696|      0|    JSAsyncGeneratorData *s = JS_GetOpaque(this_val, JS_CLASS_ASYNC_GENERATOR);
19697|      0|    JSValue promise, resolving_funcs[2];
19698|      0|    JSAsyncGeneratorRequest *req;
19699|       |
19700|      0|    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
19701|      0|    if (JS_IsException(promise))
19702|      0|        return JS_EXCEPTION;
19703|      0|    if (!s) {
19704|      0|        JSValue err, res2;
19705|      0|        JS_ThrowTypeError(ctx, "not an AsyncGenerator object");
19706|      0|        err = JS_GetException(ctx);
19707|      0|        res2 = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
19708|      0|                       1, (JSValueConst *)&err);
19709|      0|        JS_FreeValue(ctx, err);
19710|      0|        JS_FreeValue(ctx, res2);
19711|      0|        JS_FreeValue(ctx, resolving_funcs[0]);
19712|      0|        JS_FreeValue(ctx, resolving_funcs[1]);
19713|      0|        return promise;
19714|      0|    }
19715|      0|    req = js_mallocz(ctx, sizeof(*req));
19716|      0|    if (!req)
19717|      0|        goto fail;
19718|      0|    req->completion_type = magic;
19719|      0|    req->result = JS_DupValue(ctx, argv[0]);
19720|      0|    req->promise = JS_DupValue(ctx, promise);
19721|      0|    req->resolving_funcs[0] = resolving_funcs[0];
19722|      0|    req->resolving_funcs[1] = resolving_funcs[1];
19723|      0|    list_add_tail(&req->link, &s->queue);
19724|      0|    if (s->state != JS_ASYNC_GENERATOR_STATE_EXECUTING) {
19725|      0|        js_async_generator_resume_next(ctx, s);
19726|      0|    }
19727|      0|    return promise;
19728|      0| fail:
19729|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
19730|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
19731|      0|    JS_FreeValue(ctx, promise);
19732|      0|    return JS_EXCEPTION;
19733|      0|}
19734|       |
19735|       |static JSValue js_async_generator_function_call(JSContext *ctx, JSValueConst func_obj,
19736|       |                                                JSValueConst this_obj,
19737|       |                                                int argc, JSValueConst *argv,
19738|       |                                                int flags)
19739|      0|{
19740|      0|    JSValue obj, func_ret;
19741|      0|    JSAsyncGeneratorData *s;
19742|       |
19743|      0|    s = js_mallocz(ctx, sizeof(*s));
19744|      0|    if (!s)
19745|      0|        return JS_EXCEPTION;
19746|      0|    s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_START;
19747|      0|    init_list_head(&s->queue);
19748|      0|    s->func_state = async_func_init(ctx, func_obj, this_obj, argc, argv);
19749|      0|    if (!s->func_state)
19750|      0|        goto fail;
19751|       |    /* execute the function up to 'OP_initial_yield' (no yield nor
19752|       |       await are possible) */
19753|      0|    func_ret = async_func_resume(ctx, s->func_state);
19754|      0|    if (JS_IsException(func_ret))
19755|      0|        goto fail;
19756|      0|    JS_FreeValue(ctx, func_ret);
19757|       |
19758|      0|    obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_ASYNC_GENERATOR);
19759|      0|    if (JS_IsException(obj))
19760|      0|        goto fail;
19761|      0|    s->generator = JS_VALUE_GET_OBJ(obj);
19762|      0|    JS_SetOpaque(obj, s);
19763|      0|    return obj;
19764|      0| fail:
19765|      0|    js_async_generator_free(ctx->rt, s);
19766|      0|    return JS_EXCEPTION;
19767|      0|}
19768|       |
19769|       |/* JS parser */
19770|       |
19771|       |enum {
19772|       |    TOK_NUMBER = -128,
19773|       |    TOK_STRING,
19774|       |    TOK_TEMPLATE,
19775|       |    TOK_IDENT,
19776|       |    TOK_REGEXP,
19777|       |    /* warning: order matters (see js_parse_assign_expr) */
19778|       |    TOK_MUL_ASSIGN,
19779|       |    TOK_DIV_ASSIGN,
19780|       |    TOK_MOD_ASSIGN,
19781|       |    TOK_PLUS_ASSIGN,
19782|       |    TOK_MINUS_ASSIGN,
19783|       |    TOK_SHL_ASSIGN,
19784|       |    TOK_SAR_ASSIGN,
19785|       |    TOK_SHR_ASSIGN,
19786|       |    TOK_AND_ASSIGN,
19787|       |    TOK_XOR_ASSIGN,
19788|       |    TOK_OR_ASSIGN,
19789|       |    TOK_POW_ASSIGN,
19790|       |    TOK_LAND_ASSIGN,
19791|       |    TOK_LOR_ASSIGN,
19792|       |    TOK_DOUBLE_QUESTION_MARK_ASSIGN,
19793|       |    TOK_DEC,
19794|       |    TOK_INC,
19795|       |    TOK_SHL,
19796|       |    TOK_SAR,
19797|       |    TOK_SHR,
19798|       |    TOK_LT,
19799|       |    TOK_LTE,
19800|       |    TOK_GT,
19801|       |    TOK_GTE,
19802|       |    TOK_EQ,
19803|       |    TOK_STRICT_EQ,
19804|       |    TOK_NEQ,
19805|       |    TOK_STRICT_NEQ,
19806|       |    TOK_LAND,
19807|       |    TOK_LOR,
19808|       |    TOK_POW,
19809|       |    TOK_ARROW,
19810|       |    TOK_ELLIPSIS,
19811|       |    TOK_DOUBLE_QUESTION_MARK,
19812|       |    TOK_QUESTION_MARK_DOT,
19813|       |    TOK_ERROR,
19814|       |    TOK_PRIVATE_NAME,
19815|       |    TOK_EOF,
19816|       |    /* keywords: WARNING: same order as atoms */
19817|       |    TOK_NULL, /* must be first */
19818|       |    TOK_FALSE,
19819|       |    TOK_TRUE,
19820|       |    TOK_IF,
19821|       |    TOK_ELSE,
19822|       |    TOK_RETURN,
19823|       |    TOK_VAR,
19824|       |    TOK_THIS,
19825|       |    TOK_DELETE,
19826|       |    TOK_VOID,
19827|       |    TOK_TYPEOF,
19828|       |    TOK_NEW,
19829|       |    TOK_IN,
19830|       |    TOK_INSTANCEOF,
19831|       |    TOK_DO,
19832|       |    TOK_WHILE,
19833|       |    TOK_FOR,
19834|       |    TOK_BREAK,
19835|       |    TOK_CONTINUE,
19836|       |    TOK_SWITCH,
19837|       |    TOK_CASE,
19838|       |    TOK_DEFAULT,
19839|       |    TOK_THROW,
19840|       |    TOK_TRY,
19841|       |    TOK_CATCH,
19842|       |    TOK_FINALLY,
19843|       |    TOK_FUNCTION,
19844|       |    TOK_DEBUGGER,
19845|       |    TOK_WITH,
19846|       |    /* FutureReservedWord */
19847|       |    TOK_CLASS,
19848|       |    TOK_CONST,
19849|       |    TOK_ENUM,
19850|       |    TOK_EXPORT,
19851|       |    TOK_EXTENDS,
19852|       |    TOK_IMPORT,
19853|       |    TOK_SUPER,
19854|       |    /* FutureReservedWords when parsing strict mode code */
19855|       |    TOK_IMPLEMENTS,
19856|       |    TOK_INTERFACE,
19857|       |    TOK_LET,
19858|       |    TOK_PACKAGE,
19859|       |    TOK_PRIVATE,
19860|       |    TOK_PROTECTED,
19861|       |    TOK_PUBLIC,
19862|       |    TOK_STATIC,
19863|       |    TOK_YIELD,
19864|       |    TOK_AWAIT, /* must be last */
19865|       |    TOK_OF,     /* only used for js_parse_skip_parens_token() */
19866|       |};
19867|       |
19868|  35.1M|#define TOK_FIRST_KEYWORD   TOK_NULL
19869|  16.8M|#define TOK_LAST_KEYWORD    TOK_AWAIT
19870|       |
19871|       |/* unicode code points */
19872|       |#define CP_NBSP 0x00a0
19873|       |#define CP_BOM  0xfeff
19874|       |
19875|   663k|#define CP_LS   0x2028
19876|   331k|#define CP_PS   0x2029
19877|       |
19878|       |typedef struct BlockEnv {
19879|       |    struct BlockEnv *prev;
19880|       |    JSAtom label_name; /* JS_ATOM_NULL if none */
19881|       |    int label_break; /* -1 if none */
19882|       |    int label_cont; /* -1 if none */
19883|       |    int drop_count; /* number of stack elements to drop */
19884|       |    int label_finally; /* -1 if none */
19885|       |    int scope_level;
19886|       |    uint8_t has_iterator : 1;
19887|       |    uint8_t is_regular_stmt : 1; /* i.e. not a loop statement */
19888|       |} BlockEnv;
19889|       |
19890|       |typedef struct JSGlobalVar {
19891|       |    int cpool_idx; /* if >= 0, index in the constant pool for hoisted
19892|       |                      function defintion*/
19893|       |    uint8_t force_init : 1; /* force initialization to undefined */
19894|       |    uint8_t is_lexical : 1; /* global let/const definition */
19895|       |    uint8_t is_const   : 1; /* const definition */
19896|       |    int scope_level;    /* scope of definition */
19897|       |    JSAtom var_name;  /* variable name */
19898|       |} JSGlobalVar;
19899|       |
19900|       |typedef struct RelocEntry {
19901|       |    struct RelocEntry *next;
19902|       |    uint32_t addr; /* address to patch */
19903|       |    int size;   /* address size: 1, 2 or 4 bytes */
19904|       |} RelocEntry;
19905|       |
19906|       |typedef struct JumpSlot {
19907|       |    int op;
19908|       |    int size;
19909|       |    int pos;
19910|       |    int label;
19911|       |} JumpSlot;
19912|       |
19913|       |typedef struct LabelSlot {
19914|       |    int ref_count;
19915|       |    int pos;    /* phase 1 address, -1 means not resolved yet */
19916|       |    int pos2;   /* phase 2 address, -1 means not resolved yet */
19917|       |    int addr;   /* phase 3 address, -1 means not resolved yet */
19918|       |    RelocEntry *first_reloc;
19919|       |} LabelSlot;
19920|       |
19921|       |typedef struct LineNumberSlot {
19922|       |    uint32_t pc;
19923|       |    uint32_t source_pos;
19924|       |} LineNumberSlot;
19925|       |
19926|       |typedef struct {
19927|       |    /* last source position */
19928|       |    const uint8_t *ptr;
19929|       |    int line_num;
19930|       |    int col_num;
19931|       |    const uint8_t *buf_start;
19932|       |} GetLineColCache;
19933|       |
19934|       |typedef enum JSParseFunctionEnum {
19935|       |    JS_PARSE_FUNC_STATEMENT,
19936|       |    JS_PARSE_FUNC_VAR,
19937|       |    JS_PARSE_FUNC_EXPR,
19938|       |    JS_PARSE_FUNC_ARROW,
19939|       |    JS_PARSE_FUNC_GETTER,
19940|       |    JS_PARSE_FUNC_SETTER,
19941|       |    JS_PARSE_FUNC_METHOD,
19942|       |    JS_PARSE_FUNC_CLASS_STATIC_INIT,
19943|       |    JS_PARSE_FUNC_CLASS_CONSTRUCTOR,
19944|       |    JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR,
19945|       |} JSParseFunctionEnum;
19946|       |
19947|       |typedef enum JSParseExportEnum {
19948|       |    JS_PARSE_EXPORT_NONE,
19949|       |    JS_PARSE_EXPORT_NAMED,
19950|       |    JS_PARSE_EXPORT_DEFAULT,
19951|       |} JSParseExportEnum;
19952|       |
19953|       |typedef struct JSFunctionDef {
19954|       |    JSContext *ctx;
19955|       |    struct JSFunctionDef *parent;
19956|       |    int parent_cpool_idx; /* index in the constant pool of the parent
19957|       |                             or -1 if none */
19958|       |    int parent_scope_level; /* scope level in parent at point of definition */
19959|       |    struct list_head child_list; /* list of JSFunctionDef.link */
19960|       |    struct list_head link;
19961|       |
19962|       |    BOOL is_eval; /* TRUE if eval code */
19963|       |    int eval_type; /* only valid if is_eval = TRUE */
19964|       |    BOOL is_global_var; /* TRUE if variables are not defined locally:
19965|       |                           eval global, eval module or non strict eval */
19966|       |    BOOL is_func_expr; /* TRUE if function expression */
19967|       |    BOOL has_home_object; /* TRUE if the home object is available */
19968|       |    BOOL has_prototype; /* true if a prototype field is necessary */
19969|       |    BOOL has_simple_parameter_list;
19970|       |    BOOL has_parameter_expressions; /* if true, an argument scope is created */
19971|       |    BOOL has_use_strict; /* to reject directive in special cases */
19972|       |    BOOL has_eval_call; /* true if the function contains a call to eval() */
19973|       |    BOOL has_arguments_binding; /* true if the 'arguments' binding is
19974|       |                                   available in the function */
19975|       |    BOOL has_this_binding; /* true if the 'this' and new.target binding are
19976|       |                              available in the function */
19977|       |    BOOL new_target_allowed; /* true if the 'new.target' does not
19978|       |                                throw a syntax error */
19979|       |    BOOL super_call_allowed; /* true if super() is allowed */
19980|       |    BOOL super_allowed; /* true if super. or super[] is allowed */
19981|       |    BOOL arguments_allowed; /* true if the 'arguments' identifier is allowed */
19982|       |    BOOL is_derived_class_constructor;
19983|       |    BOOL in_function_body;
19984|       |    JSFunctionKindEnum func_kind : 8;
19985|       |    JSParseFunctionEnum func_type : 8;
19986|       |    uint8_t js_mode; /* bitmap of JS_MODE_x */
19987|       |    JSAtom func_name; /* JS_ATOM_NULL if no name */
19988|       |
19989|       |    JSVarDef *vars;
19990|       |    int var_size; /* allocated size for vars[] */
19991|       |    int var_count;
19992|       |    JSVarDef *args;
19993|       |    int arg_size; /* allocated size for args[] */
19994|       |    int arg_count; /* number of arguments */
19995|       |    int defined_arg_count;
19996|       |    int var_object_idx; /* -1 if none */
19997|       |    int arg_var_object_idx; /* -1 if none (var object for the argument scope) */
19998|       |    int arguments_var_idx; /* -1 if none */
19999|       |    int arguments_arg_idx; /* argument variable definition in argument scope,
20000|       |                              -1 if none */
20001|       |    int func_var_idx; /* variable containing the current function (-1
20002|       |                         if none, only used if is_func_expr is true) */
20003|       |    int eval_ret_idx; /* variable containing the return value of the eval, -1 if none */
20004|       |    int this_var_idx; /* variable containg the 'this' value, -1 if none */
20005|       |    int new_target_var_idx; /* variable containg the 'new.target' value, -1 if none */
20006|       |    int this_active_func_var_idx; /* variable containg the 'this.active_func' value, -1 if none */
20007|       |    int home_object_var_idx;
20008|       |    BOOL need_home_object;
20009|       |
20010|       |    int scope_level;    /* index into fd->scopes if the current lexical scope */
20011|       |    int scope_first;    /* index into vd->vars of first lexically scoped variable */
20012|       |    int scope_size;     /* allocated size of fd->scopes array */
20013|       |    int scope_count;    /* number of entries used in the fd->scopes array */
20014|       |    JSVarScope *scopes;
20015|       |    JSVarScope def_scope_array[4];
20016|       |    int body_scope; /* scope of the body of the function or eval */
20017|       |
20018|       |    int global_var_count;
20019|       |    int global_var_size;
20020|       |    JSGlobalVar *global_vars;
20021|       |
20022|       |    DynBuf byte_code;
20023|       |    int last_opcode_pos; /* -1 if no last opcode */
20024|       |    const uint8_t *last_opcode_source_ptr;
20025|       |    BOOL use_short_opcodes; /* true if short opcodes are used in byte_code */
20026|       |
20027|       |    LabelSlot *label_slots;
20028|       |    int label_size; /* allocated size for label_slots[] */
20029|       |    int label_count;
20030|       |    BlockEnv *top_break; /* break/continue label stack */
20031|       |
20032|       |    /* constant pool (strings, functions, numbers) */
20033|       |    JSValue *cpool;
20034|       |    int cpool_count;
20035|       |    int cpool_size;
20036|       |
20037|       |    /* list of variables in the closure */
20038|       |    int closure_var_count;
20039|       |    int closure_var_size;
20040|       |    JSClosureVar *closure_var;
20041|       |
20042|       |    JumpSlot *jump_slots;
20043|       |    int jump_size;
20044|       |    int jump_count;
20045|       |
20046|       |    LineNumberSlot *line_number_slots;
20047|       |    int line_number_size;
20048|       |    int line_number_count;
20049|       |    int line_number_last;
20050|       |    int line_number_last_pc;
20051|       |
20052|       |    /* pc2line table */
20053|       |    BOOL strip_debug : 1; /* strip all debug info (implies strip_source = TRUE) */
20054|       |    BOOL strip_source : 1; /* strip only source code */
20055|       |    JSAtom filename;
20056|       |    uint32_t source_pos; /* pointer in the eval() source */
20057|       |    GetLineColCache *get_line_col_cache; /* XXX: could remove to save memory */
20058|       |    DynBuf pc2line;
20059|       |
20060|       |    char *source;  /* raw source, utf-8 encoded */
20061|       |    int source_len;
20062|       |
20063|       |    JSModuleDef *module; /* != NULL when parsing a module */
20064|       |    BOOL has_await; /* TRUE if await is used (used in module eval) */
20065|       |} JSFunctionDef;
20066|       |
20067|       |typedef struct JSToken {
20068|       |    int val;
20069|       |    const uint8_t *ptr; /* position in the source */
20070|       |    union {
20071|       |        struct {
20072|       |            JSValue str;
20073|       |            int sep;
20074|       |        } str;
20075|       |        struct {
20076|       |            JSValue val;
20077|       |        } num;
20078|       |        struct {
20079|       |            JSAtom atom;
20080|       |            BOOL has_escape;
20081|       |            BOOL is_reserved;
20082|       |        } ident;
20083|       |        struct {
20084|       |            JSValue body;
20085|       |            JSValue flags;
20086|       |        } regexp;
20087|       |    } u;
20088|       |} JSToken;
20089|       |
20090|       |typedef struct JSParseState {
20091|       |    JSContext *ctx;
20092|       |    const char *filename;
20093|       |    JSToken token;
20094|       |    BOOL got_lf; /* true if got line feed before the current token */
20095|       |    const uint8_t *last_ptr;
20096|       |    const uint8_t *buf_start;
20097|       |    const uint8_t *buf_ptr;
20098|       |    const uint8_t *buf_end;
20099|       |
20100|       |    /* current function code */
20101|       |    JSFunctionDef *cur_func;
20102|       |    BOOL is_module; /* parsing a module */
20103|       |    BOOL allow_html_comments;
20104|       |    BOOL ext_json; /* true if accepting JSON superset */
20105|       |    GetLineColCache get_line_col_cache;
20106|       |} JSParseState;
20107|       |
20108|       |typedef struct JSOpCode {
20109|       |#ifdef DUMP_BYTECODE
20110|       |    const char *name;
20111|       |#endif
20112|       |    uint8_t size; /* in bytes */
20113|       |    /* the opcodes remove n_pop items from the top of the stack, then
20114|       |       pushes n_push items */
20115|       |    uint8_t n_pop;
20116|       |    uint8_t n_push;
20117|       |    uint8_t fmt;
20118|       |} JSOpCode;
20119|       |
20120|       |static const JSOpCode opcode_info[OP_COUNT + (OP_TEMP_END - OP_TEMP_START)] = {
20121|       |#define FMT(f)
20122|       |#ifdef DUMP_BYTECODE
20123|       |#define DEF(id, size, n_pop, n_push, f) { #id, size, n_pop, n_push, OP_FMT_ ## f },
20124|       |#else
20125|       |#define DEF(id, size, n_pop, n_push, f) { size, n_pop, n_push, OP_FMT_ ## f },
20126|       |#endif
20127|       |#include "quickjs-opcode.h"
20128|       |#undef DEF
20129|       |#undef FMT
20130|       |};
20131|       |
20132|       |#if SHORT_OPCODES
20133|       |/* After the final compilation pass, short opcodes are used. Their
20134|       |   opcodes overlap with the temporary opcodes which cannot appear in
20135|       |   the final bytecode. Their description is after the temporary
20136|       |   opcodes in opcode_info[]. */
20137|       |#define short_opcode_info(op)           \
20138|  6.56M|    opcode_info[(op) >= OP_TEMP_START ? \
20139|  6.56M|                (op) + (OP_TEMP_END - OP_TEMP_START) : (op)]
20140|       |#else
20141|       |#define short_opcode_info(op) opcode_info[op]
20142|       |#endif
20143|       |
20144|       |static __exception int next_token(JSParseState *s);
20145|       |
20146|       |static void free_token(JSParseState *s, JSToken *token)
20147|  23.4M|{
20148|  23.4M|    switch(token->val) {
20149|   639k|    case TOK_NUMBER:
20150|   639k|        JS_FreeValue(s->ctx, token->u.num.val);
20151|   639k|        break;
20152|   325k|    case TOK_STRING:
20153|  1.70M|    case TOK_TEMPLATE:
20154|  1.70M|        JS_FreeValue(s->ctx, token->u.str.str);
20155|  1.70M|        break;
20156|  59.7k|    case TOK_REGEXP:
20157|  59.7k|        JS_FreeValue(s->ctx, token->u.regexp.body);
20158|  59.7k|        JS_FreeValue(s->ctx, token->u.regexp.flags);
20159|  59.7k|        break;
20160|  3.54M|    case TOK_IDENT:
20161|  3.54M|    case TOK_PRIVATE_NAME:
20162|  3.54M|        JS_FreeAtom(s->ctx, token->u.ident.atom);
20163|  3.54M|        break;
20164|  17.5M|    default:
20165|  17.5M|        if (token->val >= TOK_FIRST_KEYWORD &&
20166|  17.5M|            token->val <= TOK_LAST_KEYWORD) {
20167|  61.0k|            JS_FreeAtom(s->ctx, token->u.ident.atom);
20168|  61.0k|        }
20169|  17.5M|        break;
20170|  23.4M|    }
20171|  23.4M|}
20172|       |
20173|       |static void __attribute((unused)) dump_token(JSParseState *s,
20174|       |                                             const JSToken *token)
20175|      0|{
20176|      0|    switch(token->val) {
20177|      0|    case TOK_NUMBER:
20178|      0|        {
20179|      0|            double d;
20180|      0|            JS_ToFloat64(s->ctx, &d, token->u.num.val);  /* no exception possible */
20181|      0|            printf("number: %.14g\n", d);
20182|      0|        }
20183|      0|        break;
20184|      0|    case TOK_IDENT:
20185|      0|    dump_atom:
20186|      0|        {
20187|      0|            char buf[ATOM_GET_STR_BUF_SIZE];
20188|      0|            printf("ident: '%s'\n",
20189|      0|                   JS_AtomGetStr(s->ctx, buf, sizeof(buf), token->u.ident.atom));
20190|      0|        }
20191|      0|        break;
20192|      0|    case TOK_STRING:
20193|      0|        {
20194|      0|            const char *str;
20195|      0|            /* XXX: quote the string */
20196|      0|            str = JS_ToCString(s->ctx, token->u.str.str);
20197|      0|            printf("string: '%s'\n", str);
20198|      0|            JS_FreeCString(s->ctx, str);
20199|      0|        }
20200|      0|        break;
20201|      0|    case TOK_TEMPLATE:
20202|      0|        {
20203|      0|            const char *str;
20204|      0|            str = JS_ToCString(s->ctx, token->u.str.str);
20205|      0|            printf("template: `%s`\n", str);
20206|      0|            JS_FreeCString(s->ctx, str);
20207|      0|        }
20208|      0|        break;
20209|      0|    case TOK_REGEXP:
20210|      0|        {
20211|      0|            const char *str, *str2;
20212|      0|            str = JS_ToCString(s->ctx, token->u.regexp.body);
20213|      0|            str2 = JS_ToCString(s->ctx, token->u.regexp.flags);
20214|      0|            printf("regexp: '%s' '%s'\n", str, str2);
20215|      0|            JS_FreeCString(s->ctx, str);
20216|      0|            JS_FreeCString(s->ctx, str2);
20217|      0|        }
20218|      0|        break;
20219|      0|    case TOK_EOF:
20220|      0|        printf("eof\n");
20221|      0|        break;
20222|      0|    default:
20223|      0|        if (s->token.val >= TOK_NULL && s->token.val <= TOK_LAST_KEYWORD) {
20224|      0|            goto dump_atom;
20225|      0|        } else if (s->token.val >= 256) {
20226|      0|            printf("token: %d\n", token->val);
20227|      0|        } else {
20228|      0|            printf("token: '%c'\n", token->val);
20229|      0|        }
20230|      0|        break;
20231|      0|    }
20232|      0|}
20233|       |
20234|       |/* return the zero based line and column number in the source. */
20235|       |/* Note: we no longer support '\r' as line terminator */
20236|       |static int get_line_col(int *pcol_num, const uint8_t *buf, size_t len)
20237|   862k|{
20238|   862k|    int line_num, col_num, c;
20239|   862k|    size_t i;
20240|       |    
20241|   862k|    line_num = 0;
20242|   862k|    col_num = 0;
20243|   123M|    for(i = 0; i < len; i++) {
20244|   122M|        c = buf[i];
20245|   122M|        if (c == '\n') {
20246|  2.33M|            line_num++;
20247|  2.33M|            col_num = 0;
20248|   120M|        } else if (c < 0x80 || c >= 0xc0) {
20249|   118M|            col_num++;
20250|   118M|        }
20251|   122M|    }
20252|   862k|    *pcol_num = col_num;
20253|   862k|    return line_num;
20254|   862k|}
20255|       |
20256|       |static int get_line_col_cached(GetLineColCache *s, int *pcol_num, const uint8_t *ptr)
20257|   779k|{
20258|   779k|    int line_num, col_num;
20259|   779k|    if (ptr >= s->ptr) {
20260|   668k|        line_num = get_line_col(&col_num, s->ptr, ptr - s->ptr);
20261|   668k|        if (line_num == 0) {
20262|   496k|            s->col_num += col_num;
20263|   496k|        } else {
20264|   171k|            s->line_num += line_num;
20265|   171k|            s->col_num = col_num;
20266|   171k|        }
20267|   668k|    } else {
20268|   110k|        line_num = get_line_col(&col_num, ptr, s->ptr - ptr);
20269|   110k|        if (line_num == 0) {
20270|   107k|            s->col_num -= col_num;
20271|   107k|        } else {
20272|  2.86k|            const uint8_t *p;
20273|  2.86k|            s->line_num -= line_num;
20274|       |            /* find the absolute column position */
20275|  2.86k|            col_num = 0;
20276|   232k|            for(p = ptr - 1; p >= s->buf_start; p--) {
20277|   230k|                if (*p == '\n') {
20278|  1.22k|                    break;
20279|   229k|                } else if (*p < 0x80 || *p >= 0xc0) {
20280|   229k|                    col_num++;
20281|   229k|                }
20282|   230k|            }
20283|  2.86k|            s->col_num = col_num;
20284|  2.86k|        }
20285|   110k|    }
20286|   779k|    s->ptr = ptr;
20287|   779k|    *pcol_num = s->col_num;
20288|   779k|    return s->line_num;
20289|   779k|}
20290|       |
20291|       |/* 'ptr' is the position of the error in the source */
20292|       |static int js_parse_error_v(JSParseState *s, const uint8_t *ptr, const char *fmt, va_list ap)
20293|  82.0k|{
20294|  82.0k|    JSContext *ctx = s->ctx;
20295|  82.0k|    int line_num, col_num;
20296|  82.0k|    line_num = get_line_col(&col_num, s->buf_start, ptr - s->buf_start);
20297|  82.0k|    JS_ThrowError2(ctx, JS_SYNTAX_ERROR, fmt, ap, FALSE);
20298|  82.0k|    build_backtrace(ctx, ctx->rt->current_exception, s->filename,
20299|  82.0k|                    line_num + 1, col_num + 1, 0);
20300|  82.0k|    return -1;
20301|  82.0k|}
20302|       |
20303|       |static __attribute__((format(printf, 3, 4))) int js_parse_error_pos(JSParseState *s, const uint8_t *ptr, const char *fmt, ...)
20304|  6.43k|{
20305|  6.43k|    va_list ap;
20306|  6.43k|    int ret;
20307|       |    
20308|  6.43k|    va_start(ap, fmt);
20309|  6.43k|    ret = js_parse_error_v(s, ptr, fmt, ap);
20310|  6.43k|    va_end(ap);
20311|  6.43k|    return ret;
20312|  6.43k|}
20313|       |
20314|       |static __attribute__((format(printf, 2, 3))) int js_parse_error(JSParseState *s, const char *fmt, ...)
20315|  75.6k|{
20316|  75.6k|    va_list ap;
20317|  75.6k|    int ret;
20318|       |    
20319|  75.6k|    va_start(ap, fmt);
20320|  75.6k|    ret = js_parse_error_v(s, s->token.ptr, fmt, ap);
20321|  75.6k|    va_end(ap);
20322|  75.6k|    return ret;
20323|  75.6k|}
20324|       |
20325|       |static int js_parse_expect(JSParseState *s, int tok)
20326|   441k|{
20327|   441k|    if (s->token.val != tok) {
20328|       |        /* XXX: dump token correctly in all cases */
20329|  1.55k|        return js_parse_error(s, "expecting '%c'", tok);
20330|  1.55k|    }
20331|   440k|    return next_token(s);
20332|   441k|}
20333|       |
20334|       |static int js_parse_expect_semi(JSParseState *s)
20335|   197k|{
20336|   197k|    if (s->token.val != ';') {
20337|       |        /* automatic insertion of ';' */
20338|   146k|        if (s->token.val == TOK_EOF || s->token.val == '}' || s->got_lf) {
20339|   145k|            return 0;
20340|   145k|        }
20341|    652|        return js_parse_error(s, "expecting '%c'", ';');
20342|   146k|    }
20343|  50.8k|    return next_token(s);
20344|   197k|}
20345|       |
20346|       |static int js_parse_error_reserved_identifier(JSParseState *s)
20347|     17|{
20348|     17|    char buf1[ATOM_GET_STR_BUF_SIZE];
20349|     17|    return js_parse_error(s, "'%s' is a reserved identifier",
20350|     17|                          JS_AtomGetStr(s->ctx, buf1, sizeof(buf1),
20351|     17|                                        s->token.u.ident.atom));
20352|     17|}
20353|       |
20354|       |static __exception int js_parse_template_part(JSParseState *s, const uint8_t *p)
20355|  1.38M|{
20356|  1.38M|    uint32_t c;
20357|  1.38M|    StringBuffer b_s, *b = &b_s;
20358|       |
20359|       |    /* p points to the first byte of the template part */
20360|  1.38M|    if (string_buffer_init(s->ctx, b, 32))
20361|      0|        goto fail;
20362|  2.36M|    for(;;) {
20363|  2.36M|        if (p >= s->buf_end)
20364|  2.28k|            goto unexpected_eof;
20365|  2.36M|        c = *p++;
20366|  2.36M|        if (c == '`') {
20367|       |            /* template end part */
20368|  1.33M|            break;
20369|  1.33M|        }
20370|  1.03M|        if (c == '$' && *p == '{') {
20371|       |            /* template start or middle part */
20372|  47.6k|            p++;
20373|  47.6k|            break;
20374|  47.6k|        }
20375|   982k|        if (c == '\\') {
20376|  3.41k|            if (string_buffer_putc8(b, c))
20377|      0|                goto fail;
20378|  3.41k|            if (p >= s->buf_end)
20379|    284|                goto unexpected_eof;
20380|  3.13k|            c = *p++;
20381|  3.13k|        }
20382|       |        /* newline sequences are normalized as single '\n' bytes */
20383|   982k|        if (c == '\r') {
20384|  3.18k|            if (*p == '\n')
20385|    148|                p++;
20386|  3.18k|            c = '\n';
20387|  3.18k|        }
20388|   982k|        if (c >= 0x80) {
20389|  4.07k|            const uint8_t *p_next;
20390|  4.07k|            c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
20391|  4.07k|            if (c > 0x10FFFF) {
20392|  1.37k|                js_parse_error_pos(s, p - 1, "invalid UTF-8 sequence");
20393|  1.37k|                goto fail;
20394|  1.37k|            }
20395|  2.69k|            p = p_next;
20396|  2.69k|        }
20397|   980k|        if (string_buffer_putc(b, c))
20398|      0|            goto fail;
20399|   980k|    }
20400|  1.38M|    s->token.val = TOK_TEMPLATE;
20401|  1.38M|    s->token.u.str.sep = c;
20402|  1.38M|    s->token.u.str.str = string_buffer_end(b);
20403|  1.38M|    s->buf_ptr = p;
20404|  1.38M|    return 0;
20405|       |
20406|  2.57k| unexpected_eof:
20407|  2.57k|    js_parse_error(s, "unexpected end of string");
20408|  3.95k| fail:
20409|  3.95k|    string_buffer_free(b);
20410|  3.95k|    return -1;
20411|  2.57k|}
20412|       |
20413|       |static __exception int js_parse_string(JSParseState *s, int sep,
20414|       |                                       BOOL do_throw, const uint8_t *p,
20415|       |                                       JSToken *token, const uint8_t **pp)
20416|   883k|{
20417|   883k|    int ret;
20418|   883k|    uint32_t c;
20419|   883k|    StringBuffer b_s, *b = &b_s;
20420|   883k|    const uint8_t *p_escape;
20421|       |    
20422|       |    /* string */
20423|   883k|    if (string_buffer_init(s->ctx, b, 32))
20424|      0|        goto fail;
20425|  29.6M|    for(;;) {
20426|  29.6M|        if (p >= s->buf_end)
20427|  3.81k|            goto invalid_char;
20428|  29.6M|        c = *p;
20429|  29.6M|        if (c < 0x20) {
20430|  1.10M|            if (!s->cur_func) {
20431|      0|                if (do_throw)
20432|      0|                    js_parse_error_pos(s, p, "invalid character in a JSON string");
20433|      0|                goto fail;
20434|      0|            }
20435|  1.10M|            if (sep == '`') {
20436|  62.6k|                if (c == '\r') {
20437|  1.24k|                    if (p[1] == '\n')
20438|     74|                        p++;
20439|  1.24k|                    c = '\n';
20440|  1.24k|                }
20441|       |                /* do not update s->line_num */
20442|  1.03M|            } else if (c == '\n' || c == '\r')
20443|  4.29k|                goto invalid_char;
20444|  1.10M|        }
20445|  29.6M|        p++;
20446|  29.6M|        if (c == sep)
20447|   862k|            break;
20448|  28.7M|        if (c == '$' && *p == '{' && sep == '`') {
20449|       |            /* template start or middle part */
20450|  4.65k|            p++;
20451|  4.65k|            break;
20452|  4.65k|        }
20453|  28.7M|        if (c == '\\') {
20454|  62.3k|            p_escape = p - 1;
20455|  62.3k|            c = *p;
20456|       |            /* XXX: need a specific JSON case to avoid
20457|       |               accepting invalid escapes */
20458|  62.3k|            switch(c) {
20459|  4.62k|            case '\0':
20460|  4.62k|                if (p >= s->buf_end)
20461|    252|                    goto invalid_char;
20462|  4.37k|                p++;
20463|  4.37k|                break;
20464|    589|            case '\'':
20465|    934|            case '\"':
20466|  6.82k|            case '\\':
20467|  6.82k|                p++;
20468|  6.82k|                break;
20469|    632|            case '\r':  /* accept DOS and MAC newline sequences */
20470|    632|                if (p[1] == '\n') {
20471|    281|                    p++;
20472|    281|                }
20473|       |                /* fall thru */
20474|    864|            case '\n':
20475|       |                /* ignore escaped newline sequence */
20476|    864|                p++;
20477|    864|                continue;
20478|  50.0k|            default:
20479|  50.0k|                if (c >= '0' && c <= '9') {
20480|  13.8k|                    if (!s->cur_func)
20481|      0|                        goto invalid_escape; /* JSON case */
20482|  13.8k|                    if (!(s->cur_func->js_mode & JS_MODE_STRICT) && sep != '`')
20483|  12.8k|                        goto parse_escape;
20484|  1.08k|                    if (c == '0' && !(p[1] >= '0' && p[1] <= '9')) {
20485|    381|                        p++;
20486|    381|                        c = '\0';
20487|    700|                    } else {
20488|    700|                        if (c >= '8' || sep == '`') {
20489|       |                            /* Note: according to ES2021, \8 and \9 are not
20490|       |                               accepted in strict mode or in templates. */
20491|    235|                            goto invalid_escape;
20492|    465|                        } else {
20493|    465|                            if (do_throw)
20494|    465|                                js_parse_error_pos(s, p_escape, "octal escape sequences are not allowed in strict mode");
20495|    465|                        }
20496|    465|                        goto fail;
20497|    700|                    }
20498|  36.1k|                } else if (c >= 0x80) {
20499|    984|                    const uint8_t *p_next;
20500|    984|                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
20501|    984|                    if (c > 0x10FFFF) {
20502|    199|                        goto invalid_utf8;
20503|    199|                    }
20504|    785|                    p = p_next;
20505|       |                    /* LS or PS are skipped */
20506|    785|                    if (c == CP_LS || c == CP_PS)
20507|    518|                        continue;
20508|  35.1k|                } else {
20509|  47.9k|                parse_escape:
20510|  47.9k|                    ret = lre_parse_escape(&p, TRUE);
20511|  47.9k|                    if (ret == -1) {
20512|    847|                    invalid_escape:
20513|    847|                        if (do_throw)
20514|    796|                            js_parse_error_pos(s, p_escape, "malformed escape sequence in string literal");
20515|    847|                        goto fail;
20516|  47.3k|                    } else if (ret < 0) {
20517|       |                        /* ignore the '\' (could output a warning) */
20518|  32.5k|                        p++;
20519|  32.5k|                    } else {
20520|  14.7k|                        c = ret;
20521|  14.7k|                    }
20522|  47.9k|                }
20523|  48.0k|                break;
20524|  62.3k|            }
20525|  28.7M|        } else if (c >= 0x80) {
20526|  55.8k|            const uint8_t *p_next;
20527|  55.8k|            c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
20528|  55.8k|            if (c > 0x10FFFF)
20529|  6.05k|                goto invalid_utf8;
20530|  49.7k|            p = p_next;
20531|  49.7k|        }
20532|  28.7M|        if (string_buffer_putc(b, c))
20533|      0|            goto fail;
20534|  28.7M|    }
20535|   867k|    token->val = TOK_STRING;
20536|   867k|    token->u.str.sep = c;
20537|   867k|    token->u.str.str = string_buffer_end(b);
20538|   867k|    *pp = p;
20539|   867k|    return 0;
20540|       |
20541|  6.25k| invalid_utf8:
20542|  6.25k|    if (do_throw)
20543|  6.25k|        js_parse_error(s, "invalid UTF-8 sequence");
20544|  6.25k|    goto fail;
20545|  8.36k| invalid_char:
20546|  8.36k|    if (do_throw)
20547|  8.36k|        js_parse_error(s, "unexpected end of string");
20548|  15.9k| fail:
20549|  15.9k|    string_buffer_free(b);
20550|  15.9k|    return -1;
20551|  8.36k|}
20552|       |
20553|  7.53M|static inline BOOL token_is_pseudo_keyword(JSParseState *s, JSAtom atom) {
20554|  7.53M|    return s->token.val == TOK_IDENT && s->token.u.ident.atom == atom &&
20555|  7.53M|        !s->token.u.ident.has_escape;
20556|  7.53M|}
20557|       |
20558|       |static __exception int js_parse_regexp(JSParseState *s)
20559|  65.4k|{
20560|  65.4k|    const uint8_t *p;
20561|  65.4k|    BOOL in_class;
20562|  65.4k|    StringBuffer b_s, *b = &b_s;
20563|  65.4k|    StringBuffer b2_s, *b2 = &b2_s;
20564|  65.4k|    uint32_t c;
20565|       |
20566|  65.4k|    p = s->buf_ptr;
20567|  65.4k|    p++;
20568|  65.4k|    in_class = FALSE;
20569|  65.4k|    if (string_buffer_init(s->ctx, b, 32))
20570|      0|        return -1;
20571|  65.4k|    if (string_buffer_init(s->ctx, b2, 1))
20572|      0|        goto fail;
20573|  1.97M|    for(;;) {
20574|  1.97M|        if (p >= s->buf_end) {
20575|  1.82k|        eof_error:
20576|  1.82k|            js_parse_error(s, "unexpected end of regexp");
20577|  1.82k|            goto fail;
20578|  1.50k|        }
20579|  1.97M|        c = *p++;
20580|  1.97M|        if (c == '\n' || c == '\r') {
20581|    811|            goto eol_error;
20582|  1.97M|        } else if (c == '/') {
20583|   105k|            if (!in_class)
20584|  60.2k|                break;
20585|  1.86M|        } else if (c == '[') {
20586|   183k|            in_class = TRUE;
20587|  1.68M|        } else if (c == ']') {
20588|       |            /* XXX: incorrect as the first character in a class */
20589|  31.8k|            in_class = FALSE;
20590|  1.64M|        } else if (c == '\\') {
20591|  66.7k|            if (string_buffer_putc8(b, c))
20592|      0|                goto fail;
20593|  66.7k|            c = *p++;
20594|  66.7k|            if (c == '\n' || c == '\r')
20595|    485|                goto eol_error;
20596|  66.2k|            else if (c == '\0' && p >= s->buf_end)
20597|    323|                goto eof_error;
20598|  65.9k|            else if (c >= 0x80) {
20599|    734|                const uint8_t *p_next;
20600|    734|                c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
20601|    734|                if (c > 0x10FFFF) {
20602|    233|                    goto invalid_utf8;
20603|    233|                }
20604|    501|                p = p_next;
20605|    501|                if (c == CP_LS || c == CP_PS)
20606|    246|                    goto eol_error;
20607|    501|            }
20608|  1.58M|        } else if (c >= 0x80) {
20609|  25.2k|            const uint8_t *p_next;
20610|  25.2k|            c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
20611|  25.2k|            if (c > 0x10FFFF) {
20612|  2.00k|            invalid_utf8:
20613|  2.00k|                js_parse_error_pos(s, p - 1, "invalid UTF-8 sequence");
20614|  2.00k|                goto fail;
20615|  1.34k|            }
20616|       |            /* LS or PS are considered as line terminator */
20617|  23.9k|            if (c == CP_LS || c == CP_PS) {
20618|  1.78k|            eol_error:
20619|  1.78k|                js_parse_error_pos(s, p - 1, "unexpected line terminator in regexp");
20620|  1.78k|                goto fail;
20621|    246|            }
20622|  23.6k|            p = p_next;
20623|  23.6k|        }
20624|  1.90M|        if (string_buffer_putc(b, c))
20625|      0|            goto fail;
20626|  1.90M|    }
20627|       |
20628|       |    /* flags */
20629|  81.2k|    for(;;) {
20630|  81.2k|        const uint8_t *p_next = p;
20631|  81.2k|        c = *p_next++;
20632|  81.2k|        if (c >= 0x80) {
20633|  2.47k|            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
20634|  2.47k|            if (c > 0x10FFFF) {
20635|    432|                p++;
20636|    432|                goto invalid_utf8;
20637|    432|            }
20638|  2.47k|        }
20639|  80.8k|        if (!lre_js_is_ident_next(c))
20640|  59.7k|            break;
20641|  21.0k|        if (string_buffer_putc(b2, c))
20642|      0|            goto fail;
20643|  21.0k|        p = p_next;
20644|  21.0k|    }
20645|       |
20646|  59.7k|    s->token.val = TOK_REGEXP;
20647|  59.7k|    s->token.u.regexp.body = string_buffer_end(b);
20648|  59.7k|    s->token.u.regexp.flags = string_buffer_end(b2);
20649|  59.7k|    s->buf_ptr = p;
20650|  59.7k|    return 0;
20651|  5.62k| fail:
20652|  5.62k|    string_buffer_free(b);
20653|  5.62k|    string_buffer_free(b2);
20654|  5.62k|    return -1;
20655|  60.2k|}
20656|       |
20657|       |static __exception int ident_realloc(JSContext *ctx, char **pbuf, size_t *psize,
20658|       |                                     char *static_buf)
20659|  6.75k|{
20660|  6.75k|    char *buf, *new_buf;
20661|  6.75k|    size_t size, new_size;
20662|       |
20663|  6.75k|    buf = *pbuf;
20664|  6.75k|    size = *psize;
20665|  6.75k|    if (size >= (SIZE_MAX / 3) * 2)
20666|      0|        new_size = SIZE_MAX;
20667|  6.75k|    else
20668|  6.75k|        new_size = size + (size >> 1);
20669|  6.75k|    if (buf == static_buf) {
20670|  1.68k|        new_buf = js_malloc(ctx, new_size);
20671|  1.68k|        if (!new_buf)
20672|      0|            return -1;
20673|  1.68k|        memcpy(new_buf, buf, size);
20674|  5.06k|    } else {
20675|  5.06k|        new_buf = js_realloc(ctx, buf, new_size);
20676|  5.06k|        if (!new_buf)
20677|      0|            return -1;
20678|  5.06k|    }
20679|  6.75k|    *pbuf = new_buf;
20680|  6.75k|    *psize = new_size;
20681|  6.75k|    return 0;
20682|  6.75k|}
20683|       |
20684|       |/* convert a TOK_IDENT to a keyword when needed */
20685|       |static void update_token_ident(JSParseState *s)
20686|  3.68M|{
20687|  3.68M|    if (s->token.u.ident.atom <= JS_ATOM_LAST_KEYWORD ||
20688|  3.68M|        (s->token.u.ident.atom <= JS_ATOM_LAST_STRICT_KEYWORD &&
20689|  3.62M|         (s->cur_func->js_mode & JS_MODE_STRICT)) ||
20690|  3.68M|        (s->token.u.ident.atom == JS_ATOM_yield &&
20691|  3.62M|         ((s->cur_func->func_kind & JS_FUNC_GENERATOR) ||
20692|      0|          (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
20693|      0|           !s->cur_func->in_function_body && s->cur_func->parent &&
20694|      0|           (s->cur_func->parent->func_kind & JS_FUNC_GENERATOR)))) ||
20695|  3.68M|        (s->token.u.ident.atom == JS_ATOM_await &&
20696|  3.62M|         (s->is_module ||
20697|      0|          (s->cur_func->func_kind & JS_FUNC_ASYNC) ||
20698|      0|          s->cur_func->func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT ||
20699|      0|          (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
20700|      0|           !s->cur_func->in_function_body && s->cur_func->parent &&
20701|      0|           ((s->cur_func->parent->func_kind & JS_FUNC_ASYNC) ||
20702|  61.9k|            s->cur_func->parent->func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT))))) {
20703|  61.9k|        if (s->token.u.ident.has_escape) {
20704|    846|            s->token.u.ident.is_reserved = TRUE;
20705|    846|            s->token.val = TOK_IDENT;
20706|  61.1k|        } else {
20707|       |            /* The keywords atoms are pre allocated */
20708|  61.1k|            s->token.val = s->token.u.ident.atom - 1 + TOK_FIRST_KEYWORD;
20709|  61.1k|        }
20710|  61.9k|    }
20711|  3.68M|}
20712|       |
20713|       |/* if the current token is an identifier or keyword, reparse it
20714|       |   according to the current function type */
20715|       |static void reparse_ident_token(JSParseState *s)
20716|   127k|{
20717|   127k|    if (s->token.val == TOK_IDENT ||
20718|   127k|        (s->token.val >= TOK_FIRST_KEYWORD &&
20719|  82.2k|         s->token.val <= TOK_LAST_KEYWORD)) {
20720|  82.2k|        s->token.val = TOK_IDENT;
20721|  82.2k|        s->token.u.ident.is_reserved = FALSE;
20722|  82.2k|        update_token_ident(s);
20723|  82.2k|    }
20724|   127k|}
20725|       |
20726|       |/* 'c' is the first character. Return JS_ATOM_NULL in case of error */
20727|       |static JSAtom parse_ident(JSParseState *s, const uint8_t **pp,
20728|       |                          BOOL *pident_has_escape, int c, BOOL is_private)
20729|  3.60M|{
20730|  3.60M|    const uint8_t *p, *p1;
20731|  3.60M|    char ident_buf[128], *buf;
20732|  3.60M|    size_t ident_size, ident_pos;
20733|  3.60M|    JSAtom atom;
20734|       |
20735|  3.60M|    p = *pp;
20736|  3.60M|    buf = ident_buf;
20737|  3.60M|    ident_size = sizeof(ident_buf);
20738|  3.60M|    ident_pos = 0;
20739|  3.60M|    if (is_private)
20740|  2.29k|        buf[ident_pos++] = '#';
20741|  11.6M|    for(;;) {
20742|  11.6M|        p1 = p;
20743|       |
20744|  11.6M|        if (c < 128) {
20745|  11.5M|            buf[ident_pos++] = c;
20746|  11.5M|        } else {
20747|  21.5k|            ident_pos += unicode_to_utf8((uint8_t*)buf + ident_pos, c);
20748|  21.5k|        }
20749|  11.6M|        c = *p1++;
20750|  11.6M|        if (c == '\\' && *p1 == 'u') {
20751|  3.13k|            c = lre_parse_escape(&p1, TRUE);
20752|  3.13k|            *pident_has_escape = TRUE;
20753|  11.6M|        } else if (c >= 128) {
20754|  30.5k|            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
20755|  30.5k|        }
20756|  11.6M|        if (!lre_js_is_ident_next(c))
20757|  3.60M|            break;
20758|  8.01M|        p = p1;
20759|  8.01M|        if (unlikely(ident_pos >= ident_size - UTF8_CHAR_LEN_MAX)) {
20760|  6.75k|            if (ident_realloc(s->ctx, &buf, &ident_size, ident_buf)) {
20761|      0|                atom = JS_ATOM_NULL;
20762|      0|                goto done;
20763|      0|            }
20764|  6.75k|        }
20765|  8.01M|    }
20766|  3.60M|    atom = JS_NewAtomLen(s->ctx, buf, ident_pos);
20767|  3.60M| done:
20768|  3.60M|    if (unlikely(buf != ident_buf))
20769|  1.68k|        js_free(s->ctx, buf);
20770|  3.60M|    *pp = p;
20771|  3.60M|    return atom;
20772|  3.60M|}
20773|       |
20774|       |
20775|       |static __exception int next_token(JSParseState *s)
20776|  23.4M|{
20777|  23.4M|    const uint8_t *p;
20778|  23.4M|    int c;
20779|  23.4M|    BOOL ident_has_escape;
20780|  23.4M|    JSAtom atom;
20781|       |
20782|  23.4M|    if (js_check_stack_overflow(s->ctx->rt, 0)) {
20783|     15|        return js_parse_error(s, "stack overflow");
20784|     15|    }
20785|       |
20786|  23.4M|    free_token(s, &s->token);
20787|       |
20788|  23.4M|    p = s->last_ptr = s->buf_ptr;
20789|  23.4M|    s->got_lf = FALSE;
20790|  24.9M| redo:
20791|  24.9M|    s->token.ptr = p;
20792|  24.9M|    c = *p;
20793|  24.9M|    switch(c) {
20794|  84.4k|    case 0:
20795|  84.4k|        if (p >= s->buf_end) {
20796|  29.8k|            s->token.val = TOK_EOF;
20797|  54.6k|        } else {
20798|  54.6k|            goto def_token;
20799|  54.6k|        }
20800|  29.8k|        break;
20801|  1.37M|    case '`':
20802|  1.37M|        if (js_parse_template_part(s, p + 1))
20803|  3.69k|            goto fail;
20804|  1.36M|        p = s->buf_ptr;
20805|  1.36M|        break;
20806|   338k|    case '\'':
20807|   341k|    case '\"':
20808|   341k|        if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p))
20809|  15.8k|            goto fail;
20810|   325k|        break;
20811|   325k|    case '\r':  /* accept DOS and MAC newline sequences */
20812|  64.3k|        if (p[1] == '\n') {
20813|    346|            p++;
20814|    346|        }
20815|       |        /* fall thru */
20816|   762k|    case '\n':
20817|   762k|        p++;
20818|   763k|    line_terminator:
20819|   763k|        s->got_lf = TRUE;
20820|   763k|        goto redo;
20821|  3.49k|    case '\f':
20822|  7.09k|    case '\v':
20823|   678k|    case ' ':
20824|   680k|    case '\t':
20825|   680k|        p++;
20826|   680k|        goto redo;
20827|   214k|    case '/':
20828|   214k|        if (p[1] == '*') {
20829|       |            /* comment */
20830|  3.44k|            p += 2;
20831|   226k|            for(;;) {
20832|   226k|                if (*p == '\0' && p >= s->buf_end) {
20833|  1.78k|                    js_parse_error(s, "unexpected end of comment");
20834|  1.78k|                    goto fail;
20835|  1.78k|                }
20836|   224k|                if (p[0] == '*' && p[1] == '/') {
20837|  1.66k|                    p += 2;
20838|  1.66k|                    break;
20839|  1.66k|                }
20840|   222k|                if (*p == '\n' || *p == '\r') {
20841|  4.86k|                    s->got_lf = TRUE; /* considered as LF for ASI */
20842|  4.86k|                    p++;
20843|   218k|                } else if (*p >= 0x80) {
20844|  13.8k|                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
20845|  13.8k|                    if (c == CP_LS || c == CP_PS) {
20846|    350|                        s->got_lf = TRUE; /* considered as LF for ASI */
20847|  13.5k|                    } else if (c == -1) {
20848|  9.70k|                        p++; /* skip invalid UTF-8 */
20849|  9.70k|                    }
20850|   204k|                } else {
20851|   204k|                    p++;
20852|   204k|                }
20853|   222k|            }
20854|  1.66k|            goto redo;
20855|   211k|        } else if (p[1] == '/') {
20856|       |            /* line comment */
20857|  38.3k|            p += 2;
20858|  38.9k|        skip_line_comment:
20859|  3.33M|            for(;;) {
20860|  3.33M|                if (*p == '\0' && p >= s->buf_end)
20861|  4.06k|                    break;
20862|  3.32M|                if (*p == '\r' || *p == '\n')
20863|  34.6k|                    break;
20864|  3.29M|                if (*p >= 0x80) {
20865|   289k|                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
20866|       |                    /* LS or PS are considered as line terminator */
20867|   289k|                    if (c == CP_LS || c == CP_PS) {
20868|    271|                        break;
20869|   289k|                    } else if (c == -1) {
20870|   286k|                        p++; /* skip invalid UTF-8 */
20871|   286k|                    }
20872|  3.00M|                } else {
20873|  3.00M|                    p++;
20874|  3.00M|                }
20875|  3.29M|            }
20876|  38.9k|            goto redo;
20877|   172k|        } else if (p[1] == '=') {
20878|    611|            p += 2;
20879|    611|            s->token.val = TOK_DIV_ASSIGN;
20880|   172k|        } else {
20881|   172k|            p++;
20882|   172k|            s->token.val = c;
20883|   172k|        }
20884|   172k|        break;
20885|   172k|    case '\\':
20886|  14.4k|        if (p[1] == 'u') {
20887|  3.43k|            const uint8_t *p1 = p + 1;
20888|  3.43k|            int c1 = lre_parse_escape(&p1, TRUE);
20889|  3.43k|            if (c1 >= 0 && lre_js_is_ident_first(c1)) {
20890|    279|                c = c1;
20891|    279|                p = p1;
20892|    279|                ident_has_escape = TRUE;
20893|    279|                goto has_ident;
20894|  3.15k|            } else {
20895|       |                /* XXX: syntax error? */
20896|  3.15k|            }
20897|  3.43k|        }
20898|  14.1k|        goto def_token;
20899|   312k|    case 'a': case 'b': case 'c': case 'd':
20900|   590k|    case 'e': case 'f': case 'g': case 'h':
20901|  1.15M|    case 'i': case 'j': case 'k': case 'l':
20902|  2.26M|    case 'm': case 'n': case 'o': case 'p':
20903|  2.83M|    case 'q': case 'r': case 's': case 't':
20904|  3.10M|    case 'u': case 'v': case 'w': case 'x':
20905|  3.19M|    case 'y': case 'z':
20906|  3.26M|    case 'A': case 'B': case 'C': case 'D':
20907|  3.36M|    case 'E': case 'F': case 'G': case 'H':
20908|  3.38M|    case 'I': case 'J': case 'K': case 'L':
20909|  3.39M|    case 'M': case 'N': case 'O': case 'P':
20910|  3.41M|    case 'Q': case 'R': case 'S': case 'T':
20911|  3.48M|    case 'U': case 'V': case 'W': case 'X':
20912|  3.57M|    case 'Y': case 'Z':
20913|  3.59M|    case '_':
20914|  3.59M|    case '$':
20915|       |        /* identifier */
20916|  3.59M|        p++;
20917|  3.59M|        ident_has_escape = FALSE;
20918|  3.60M|    has_ident:
20919|  3.60M|        atom = parse_ident(s, &p, &ident_has_escape, c, FALSE);
20920|  3.60M|        if (atom == JS_ATOM_NULL)
20921|      0|            goto fail;
20922|  3.60M|        s->token.u.ident.atom = atom;
20923|  3.60M|        s->token.u.ident.has_escape = ident_has_escape;
20924|  3.60M|        s->token.u.ident.is_reserved = FALSE;
20925|  3.60M|        s->token.val = TOK_IDENT;
20926|  3.60M|        update_token_ident(s);
20927|  3.60M|        break;
20928|  3.28k|    case '#':
20929|       |        /* private name */
20930|  3.28k|        {
20931|  3.28k|            const uint8_t *p1;
20932|  3.28k|            p++;
20933|  3.28k|            p1 = p;
20934|  3.28k|            c = *p1++;
20935|  3.28k|            if (c == '\\' && *p1 == 'u') {
20936|    320|                c = lre_parse_escape(&p1, TRUE);
20937|  2.96k|            } else if (c >= 128) {
20938|    278|                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
20939|    278|            }
20940|  3.28k|            if (!lre_js_is_ident_first(c)) {
20941|    996|                js_parse_error(s, "invalid first character of private name");
20942|    996|                goto fail;
20943|    996|            }
20944|  2.29k|            p = p1;
20945|  2.29k|            ident_has_escape = FALSE; /* not used */
20946|  2.29k|            atom = parse_ident(s, &p, &ident_has_escape, c, TRUE);
20947|  2.29k|            if (atom == JS_ATOM_NULL)
20948|      0|                goto fail;
20949|  2.29k|            s->token.u.ident.atom = atom;
20950|  2.29k|            s->token.val = TOK_PRIVATE_NAME;
20951|  2.29k|        }
20952|      0|        break;
20953|   198k|    case '.':
20954|   198k|        if (p[1] == '.' && p[2] == '.') {
20955|   139k|            p += 3;
20956|   139k|            s->token.val = TOK_ELLIPSIS;
20957|   139k|            break;
20958|   139k|        }
20959|  58.5k|        if (p[1] >= '0' && p[1] <= '9') {
20960|  3.05k|            goto parse_number;
20961|  55.5k|        } else {
20962|  55.5k|            goto def_token;
20963|  55.5k|        }
20964|      0|        break;
20965|  17.4k|    case '0':
20966|       |        /* in strict mode, octal literals are not accepted */
20967|  17.4k|        if (is_digit(p[1]) && (s->cur_func->js_mode & JS_MODE_STRICT)) {
20968|    213|            js_parse_error(s, "octal literals are deprecated in strict mode");
20969|    213|            goto fail;
20970|    213|        }
20971|  17.2k|        goto parse_number;
20972|   597k|    case '1': case '2': case '3': case '4':
20973|   632k|    case '5': case '6': case '7': case '8':
20974|   639k|    case '9':
20975|       |        /* number */
20976|   659k|    parse_number:
20977|   659k|        {
20978|   659k|            JSValue ret;
20979|   659k|            const uint8_t *p1;
20980|   659k|            int flags;
20981|   659k|            flags = ATOD_ACCEPT_BIN_OCT | ATOD_ACCEPT_LEGACY_OCTAL |
20982|   659k|                ATOD_ACCEPT_UNDERSCORES | ATOD_ACCEPT_SUFFIX;
20983|   659k|            ret = js_atof(s->ctx, (const char *)p, (const char **)&p, 0,
20984|   659k|                          flags);
20985|   659k|            if (JS_IsException(ret))
20986|      0|                goto fail;
20987|       |            /* reject `10instanceof Number` */
20988|   659k|            if (JS_VALUE_IS_NAN(ret) ||
20989|   659k|                lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
20990|  19.9k|                JS_FreeValue(s->ctx, ret);
20991|  19.9k|                js_parse_error(s, "invalid number literal");
20992|  19.9k|                goto fail;
20993|  19.9k|            }
20994|   639k|            s->token.val = TOK_NUMBER;
20995|   639k|            s->token.u.num.val = ret;
20996|   639k|        }
20997|      0|        break;
20998|  94.0k|    case '*':
20999|  94.0k|        if (p[1] == '=') {
21000|    329|            p += 2;
21001|    329|            s->token.val = TOK_MUL_ASSIGN;
21002|  93.7k|        } else if (p[1] == '*') {
21003|  15.2k|            if (p[2] == '=') {
21004|    250|                p += 3;
21005|    250|                s->token.val = TOK_POW_ASSIGN;
21006|  15.0k|            } else {
21007|  15.0k|                p += 2;
21008|  15.0k|                s->token.val = TOK_POW;
21009|  15.0k|            }
21010|  78.4k|        } else {
21011|  78.4k|            goto def_token;
21012|  78.4k|        }
21013|  15.6k|        break;
21014|  27.9k|    case '%':
21015|  27.9k|        if (p[1] == '=') {
21016|    210|            p += 2;
21017|    210|            s->token.val = TOK_MOD_ASSIGN;
21018|  27.7k|        } else {
21019|  27.7k|            goto def_token;
21020|  27.7k|        }
21021|    210|        break;
21022|   249k|    case '+':
21023|   249k|        if (p[1] == '=') {
21024|    264|            p += 2;
21025|    264|            s->token.val = TOK_PLUS_ASSIGN;
21026|   249k|        } else if (p[1] == '+') {
21027|  88.0k|            p += 2;
21028|  88.0k|            s->token.val = TOK_INC;
21029|   161k|        } else {
21030|   161k|            goto def_token;
21031|   161k|        }
21032|  88.2k|        break;
21033|   145k|    case '-':
21034|   145k|        if (p[1] == '=') {
21035|  4.45k|            p += 2;
21036|  4.45k|            s->token.val = TOK_MINUS_ASSIGN;
21037|   141k|        } else if (p[1] == '-') {
21038|  6.22k|            if (s->allow_html_comments && p[2] == '>' &&
21039|  6.22k|                (s->got_lf || s->last_ptr == s->buf_start)) {
21040|       |                /* Annex B: `-->` at beginning of line is an html comment end.
21041|       |                   It extends to the end of the line.
21042|       |                 */
21043|    395|                goto skip_line_comment;
21044|    395|            }
21045|  5.82k|            p += 2;
21046|  5.82k|            s->token.val = TOK_DEC;
21047|   135k|        } else {
21048|   135k|            goto def_token;
21049|   135k|        }
21050|  10.2k|        break;
21051|  21.5k|    case '<':
21052|  21.5k|        if (p[1] == '=') {
21053|    776|            p += 2;
21054|    776|            s->token.val = TOK_LTE;
21055|  20.7k|        } else if (p[1] == '<') {
21056|  4.38k|            if (p[2] == '=') {
21057|    241|                p += 3;
21058|    241|                s->token.val = TOK_SHL_ASSIGN;
21059|  4.14k|            } else {
21060|  4.14k|                p += 2;
21061|  4.14k|                s->token.val = TOK_SHL;
21062|  4.14k|            }
21063|  16.3k|        } else if (s->allow_html_comments &&
21064|  16.3k|                   p[1] == '!' && p[2] == '-' && p[3] == '-') {
21065|       |            /* Annex B: handle `<!--` single line html comments */
21066|    211|            goto skip_line_comment;
21067|  16.1k|        } else {
21068|  16.1k|            goto def_token;
21069|  16.1k|        }
21070|  5.16k|        break;
21071|   257k|    case '>':
21072|   257k|        if (p[1] == '=') {
21073|  3.24k|            p += 2;
21074|  3.24k|            s->token.val = TOK_GTE;
21075|   254k|        } else if (p[1] == '>') {
21076|  41.3k|            if (p[2] == '>') {
21077|  19.5k|                if (p[3] == '=') {
21078|    503|                    p += 4;
21079|    503|                    s->token.val = TOK_SHR_ASSIGN;
21080|  19.0k|                } else {
21081|  19.0k|                    p += 3;
21082|  19.0k|                    s->token.val = TOK_SHR;
21083|  19.0k|                }
21084|  21.7k|            } else if (p[2] == '=') {
21085|    237|                p += 3;
21086|    237|                s->token.val = TOK_SAR_ASSIGN;
21087|  21.5k|            } else {
21088|  21.5k|                p += 2;
21089|  21.5k|                s->token.val = TOK_SAR;
21090|  21.5k|            }
21091|   212k|        } else {
21092|   212k|            goto def_token;
21093|   212k|        }
21094|  44.6k|        break;
21095|  1.51M|    case '=':
21096|  1.51M|        if (p[1] == '=') {
21097|  20.5k|            if (p[2] == '=') {
21098|  7.04k|                p += 3;
21099|  7.04k|                s->token.val = TOK_STRICT_EQ;
21100|  13.5k|            } else {
21101|  13.5k|                p += 2;
21102|  13.5k|                s->token.val = TOK_EQ;
21103|  13.5k|            }
21104|  1.49M|        } else if (p[1] == '>') {
21105|   154k|            p += 2;
21106|   154k|            s->token.val = TOK_ARROW;
21107|  1.34M|        } else {
21108|  1.34M|            goto def_token;
21109|  1.34M|        }
21110|   175k|        break;
21111|   175k|    case '!':
21112|  31.0k|        if (p[1] == '=') {
21113|    768|            if (p[2] == '=') {
21114|    311|                p += 3;
21115|    311|                s->token.val = TOK_STRICT_NEQ;
21116|    457|            } else {
21117|    457|                p += 2;
21118|    457|                s->token.val = TOK_NEQ;
21119|    457|            }
21120|  30.2k|        } else {
21121|  30.2k|            goto def_token;
21122|  30.2k|        }
21123|    768|        break;
21124|  56.8k|    case '&':
21125|  56.8k|        if (p[1] == '=') {
21126|    230|            p += 2;
21127|    230|            s->token.val = TOK_AND_ASSIGN;
21128|  56.6k|        } else if (p[1] == '&') {
21129|  7.02k|            if (p[2] == '=') {
21130|    221|                p += 3;
21131|    221|                s->token.val = TOK_LAND_ASSIGN;
21132|  6.80k|            } else {
21133|  6.80k|                p += 2;
21134|  6.80k|                s->token.val = TOK_LAND;
21135|  6.80k|            }
21136|  49.6k|        } else {
21137|  49.6k|            goto def_token;
21138|  49.6k|        }
21139|  7.25k|        break;
21140|  13.0k|    case '^':
21141|  13.0k|        if (p[1] == '=') {
21142|    570|            p += 2;
21143|    570|            s->token.val = TOK_XOR_ASSIGN;
21144|  12.4k|        } else {
21145|  12.4k|            goto def_token;
21146|  12.4k|        }
21147|    570|        break;
21148|  16.6k|    case '|':
21149|  16.6k|        if (p[1] == '=') {
21150|    971|            p += 2;
21151|    971|            s->token.val = TOK_OR_ASSIGN;
21152|  15.7k|        } else if (p[1] == '|') {
21153|  4.10k|            if (p[2] == '=') {
21154|    592|                p += 3;
21155|    592|                s->token.val = TOK_LOR_ASSIGN;
21156|  3.51k|            } else {
21157|  3.51k|                p += 2;
21158|  3.51k|                s->token.val = TOK_LOR;
21159|  3.51k|            }
21160|  11.6k|        } else {
21161|  11.6k|            goto def_token;
21162|  11.6k|        }
21163|  5.07k|        break;
21164|   152k|    case '?':
21165|   152k|        if (p[1] == '?') {
21166|  30.6k|            if (p[2] == '=') {
21167|  7.59k|                p += 3;
21168|  7.59k|                s->token.val = TOK_DOUBLE_QUESTION_MARK_ASSIGN;
21169|  23.0k|            } else {
21170|  23.0k|                p += 2;
21171|  23.0k|                s->token.val = TOK_DOUBLE_QUESTION_MARK;
21172|  23.0k|            }
21173|   122k|        } else if (p[1] == '.' && !(p[2] >= '0' && p[2] <= '9')) {
21174|   111k|            p += 2;
21175|   111k|            s->token.val = TOK_QUESTION_MARK_DOT;
21176|   111k|        } else {
21177|  10.1k|            goto def_token;
21178|  10.1k|        }
21179|   142k|        break;
21180|  14.4M|    default:
21181|  14.4M|        if (c >= 128) {
21182|       |            /* unicode value */
21183|  34.6k|            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
21184|  34.6k|            switch(c) {
21185|    184|            case CP_PS:
21186|  1.01k|            case CP_LS:
21187|       |                /* XXX: should avoid incrementing line_number, but
21188|       |                   needed to handle HTML comments */
21189|  1.01k|                goto line_terminator;
21190|  33.5k|            default:
21191|  33.5k|                if (lre_is_space(c)) {
21192|  1.34k|                    goto redo;
21193|  32.2k|                } else if (lre_js_is_ident_first(c)) {
21194|  3.78k|                    ident_has_escape = FALSE;
21195|  3.78k|                    goto has_ident;
21196|  28.4k|                } else {
21197|  28.4k|                    js_parse_error(s, "unexpected character");
21198|  28.4k|                    goto fail;
21199|  28.4k|                }
21200|  34.6k|            }
21201|  34.6k|        }
21202|  16.5M|    def_token:
21203|  16.5M|        s->token.val = c;
21204|  16.5M|        p++;
21205|  16.5M|        break;
21206|  24.9M|    }
21207|  23.3M|    s->buf_ptr = p;
21208|       |
21209|       |    //    dump_token(s, &s->token);
21210|  23.3M|    return 0;
21211|       |
21212|  70.9k| fail:
21213|  70.9k|    s->token.val = TOK_ERROR;
21214|  70.9k|    return -1;
21215|  24.9M|}
21216|       |
21217|       |/* 'c' is the first character. Return JS_ATOM_NULL in case of error */
21218|       |static JSAtom json_parse_ident(JSParseState *s, const uint8_t **pp, int c)
21219|      0|{
21220|      0|    const uint8_t *p;
21221|      0|    char ident_buf[128], *buf;
21222|      0|    size_t ident_size, ident_pos;
21223|      0|    JSAtom atom;
21224|       |
21225|      0|    p = *pp;
21226|      0|    buf = ident_buf;
21227|      0|    ident_size = sizeof(ident_buf);
21228|      0|    ident_pos = 0;
21229|      0|    for(;;) {
21230|      0|        buf[ident_pos++] = c;
21231|      0|        c = *p;
21232|      0|        if (c >= 128 || !lre_is_id_continue_byte(c))
21233|      0|            break;
21234|      0|        p++;
21235|      0|        if (unlikely(ident_pos >= ident_size - UTF8_CHAR_LEN_MAX)) {
21236|      0|            if (ident_realloc(s->ctx, &buf, &ident_size, ident_buf)) {
21237|      0|                atom = JS_ATOM_NULL;
21238|      0|                goto done;
21239|      0|            }
21240|      0|        }
21241|      0|    }
21242|      0|    atom = JS_NewAtomLen(s->ctx, buf, ident_pos);
21243|      0| done:
21244|      0|    if (unlikely(buf != ident_buf))
21245|      0|        js_free(s->ctx, buf);
21246|      0|    *pp = p;
21247|      0|    return atom;
21248|      0|}
21249|       |
21250|       |static __exception int json_next_token(JSParseState *s)
21251|      0|{
21252|      0|    const uint8_t *p;
21253|      0|    int c;
21254|      0|    JSAtom atom;
21255|       |
21256|      0|    if (js_check_stack_overflow(s->ctx->rt, 0)) {
21257|      0|        return js_parse_error(s, "stack overflow");
21258|      0|    }
21259|       |
21260|      0|    free_token(s, &s->token);
21261|       |
21262|      0|    p = s->last_ptr = s->buf_ptr;
21263|      0| redo:
21264|      0|    s->token.ptr = p;
21265|      0|    c = *p;
21266|      0|    switch(c) {
21267|      0|    case 0:
21268|      0|        if (p >= s->buf_end) {
21269|      0|            s->token.val = TOK_EOF;
21270|      0|        } else {
21271|      0|            goto def_token;
21272|      0|        }
21273|      0|        break;
21274|      0|    case '\'':
21275|      0|        if (!s->ext_json) {
21276|       |            /* JSON does not accept single quoted strings */
21277|      0|            goto def_token;
21278|      0|        }
21279|       |        /* fall through */
21280|      0|    case '\"':
21281|      0|        if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p))
21282|      0|            goto fail;
21283|      0|        break;
21284|      0|    case '\r':  /* accept DOS and MAC newline sequences */
21285|      0|        if (p[1] == '\n') {
21286|      0|            p++;
21287|      0|        }
21288|       |        /* fall thru */
21289|      0|    case '\n':
21290|      0|        p++;
21291|      0|        goto redo;
21292|      0|    case '\f':
21293|      0|    case '\v':
21294|      0|        if (!s->ext_json) {
21295|       |            /* JSONWhitespace does not match <VT>, nor <FF> */
21296|      0|            goto def_token;
21297|      0|        }
21298|       |        /* fall through */
21299|      0|    case ' ':
21300|      0|    case '\t':
21301|      0|        p++;
21302|      0|        goto redo;
21303|      0|    case '/':
21304|      0|        if (!s->ext_json) {
21305|       |            /* JSON does not accept comments */
21306|      0|            goto def_token;
21307|      0|        }
21308|      0|        if (p[1] == '*') {
21309|       |            /* comment */
21310|      0|            p += 2;
21311|      0|            for(;;) {
21312|      0|                if (*p == '\0' && p >= s->buf_end) {
21313|      0|                    js_parse_error(s, "unexpected end of comment");
21314|      0|                    goto fail;
21315|      0|                }
21316|      0|                if (p[0] == '*' && p[1] == '/') {
21317|      0|                    p += 2;
21318|      0|                    break;
21319|      0|                }
21320|      0|                if (*p >= 0x80) {
21321|      0|                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
21322|      0|                    if (c == -1) {
21323|      0|                        p++; /* skip invalid UTF-8 */
21324|      0|                    }
21325|      0|                } else {
21326|      0|                    p++;
21327|      0|                }
21328|      0|            }
21329|      0|            goto redo;
21330|      0|        } else if (p[1] == '/') {
21331|       |            /* line comment */
21332|      0|            p += 2;
21333|      0|            for(;;) {
21334|      0|                if (*p == '\0' && p >= s->buf_end)
21335|      0|                    break;
21336|      0|                if (*p == '\r' || *p == '\n')
21337|      0|                    break;
21338|      0|                if (*p >= 0x80) {
21339|      0|                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
21340|       |                    /* LS or PS are considered as line terminator */
21341|      0|                    if (c == CP_LS || c == CP_PS) {
21342|      0|                        break;
21343|      0|                    } else if (c == -1) {
21344|      0|                        p++; /* skip invalid UTF-8 */
21345|      0|                    }
21346|      0|                } else {
21347|      0|                    p++;
21348|      0|                }
21349|      0|            }
21350|      0|            goto redo;
21351|      0|        } else {
21352|      0|            goto def_token;
21353|      0|        }
21354|      0|        break;
21355|      0|    case 'a': case 'b': case 'c': case 'd':
21356|      0|    case 'e': case 'f': case 'g': case 'h':
21357|      0|    case 'i': case 'j': case 'k': case 'l':
21358|      0|    case 'm': case 'n': case 'o': case 'p':
21359|      0|    case 'q': case 'r': case 's': case 't':
21360|      0|    case 'u': case 'v': case 'w': case 'x':
21361|      0|    case 'y': case 'z':
21362|      0|    case 'A': case 'B': case 'C': case 'D':
21363|      0|    case 'E': case 'F': case 'G': case 'H':
21364|      0|    case 'I': case 'J': case 'K': case 'L':
21365|      0|    case 'M': case 'N': case 'O': case 'P':
21366|      0|    case 'Q': case 'R': case 'S': case 'T':
21367|      0|    case 'U': case 'V': case 'W': case 'X':
21368|      0|    case 'Y': case 'Z':
21369|      0|    case '_':
21370|      0|    case '$':
21371|       |        /* identifier : only pure ascii characters are accepted */
21372|      0|        p++;
21373|      0|        atom = json_parse_ident(s, &p, c);
21374|      0|        if (atom == JS_ATOM_NULL)
21375|      0|            goto fail;
21376|      0|        s->token.u.ident.atom = atom;
21377|      0|        s->token.u.ident.has_escape = FALSE;
21378|      0|        s->token.u.ident.is_reserved = FALSE;
21379|      0|        s->token.val = TOK_IDENT;
21380|      0|        break;
21381|      0|    case '+':
21382|      0|        if (!s->ext_json || !is_digit(p[1]))
21383|      0|            goto def_token;
21384|      0|        goto parse_number;
21385|      0|    case '0':
21386|      0|        if (is_digit(p[1]))
21387|      0|            goto def_token;
21388|      0|        goto parse_number;
21389|      0|    case '-':
21390|      0|        if (!is_digit(p[1]))
21391|      0|            goto def_token;
21392|      0|        goto parse_number;
21393|      0|    case '1': case '2': case '3': case '4':
21394|      0|    case '5': case '6': case '7': case '8':
21395|      0|    case '9':
21396|       |        /* number */
21397|      0|    parse_number:
21398|      0|        {
21399|      0|            JSValue ret;
21400|      0|            int flags, radix;
21401|      0|            if (!s->ext_json) {
21402|      0|                flags = 0;
21403|      0|                radix = 10;
21404|      0|            } else {
21405|      0|                flags = ATOD_ACCEPT_BIN_OCT;
21406|      0|                radix = 0;
21407|      0|            }
21408|      0|            ret = js_atof(s->ctx, (const char *)p, (const char **)&p, radix,
21409|      0|                          flags);
21410|      0|            if (JS_IsException(ret))
21411|      0|                goto fail;
21412|      0|            s->token.val = TOK_NUMBER;
21413|      0|            s->token.u.num.val = ret;
21414|      0|        }
21415|      0|        break;
21416|      0|    default:
21417|      0|        if (c >= 128) {
21418|      0|            js_parse_error(s, "unexpected character");
21419|      0|            goto fail;
21420|      0|        }
21421|      0|    def_token:
21422|      0|        s->token.val = c;
21423|      0|        p++;
21424|      0|        break;
21425|      0|    }
21426|      0|    s->buf_ptr = p;
21427|       |
21428|       |    //    dump_token(s, &s->token);
21429|      0|    return 0;
21430|       |
21431|      0| fail:
21432|      0|    s->token.val = TOK_ERROR;
21433|      0|    return -1;
21434|      0|}
21435|       |
21436|  10.1k|static int match_identifier(const uint8_t *p, const char *s) {
21437|  10.1k|    uint32_t c;
21438|  15.4k|    while (*s) {
21439|  14.1k|        if ((uint8_t)*s++ != *p++)
21440|  8.85k|            return 0;
21441|  14.1k|    }
21442|  1.31k|    c = *p;
21443|  1.31k|    if (c >= 128)
21444|     15|        c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
21445|  1.31k|    return !lre_js_is_ident_next(c);
21446|  10.1k|}
21447|       |
21448|       |/* simple_next_token() is used to check for the next token in simple cases.
21449|       |   It is only used for ':' and '=>', 'let' or 'function' look-ahead.
21450|       |   (*pp) is only set if TOK_IMPORT is returned for JS_DetectModule()
21451|       |   Whitespace and comments are skipped correctly.
21452|       |   Then the next token is analyzed, only for specific words.
21453|       |   Return values:
21454|       |   - '\n' if !no_line_terminator
21455|       |   - TOK_ARROW, TOK_IN, TOK_IMPORT, TOK_OF, TOK_EXPORT, TOK_FUNCTION
21456|       |   - TOK_IDENT is returned for other identifiers and keywords
21457|       |   - otherwise the next character or unicode codepoint is returned.
21458|       | */
21459|       |static int simple_next_token(const uint8_t **pp, BOOL no_line_terminator)
21460|   872k|{
21461|   872k|    const uint8_t *p;
21462|   872k|    uint32_t c;
21463|       |
21464|       |    /* skip spaces and comments */
21465|   872k|    p = *pp;
21466|   953k|    for (;;) {
21467|   953k|        switch(c = *p++) {
21468|  9.05k|        case '\r':
21469|  46.6k|        case '\n':
21470|  46.6k|            if (no_line_terminator)
21471|  19.7k|                return '\n';
21472|  26.8k|            continue;
21473|  40.4k|        case ' ':
21474|  40.6k|        case '\t':
21475|  41.3k|        case '\v':
21476|  41.6k|        case '\f':
21477|  41.6k|            continue;
21478|  36.4k|        case '/':
21479|  36.4k|            if (*p == '/') {
21480|  29.2k|                if (no_line_terminator)
21481|  19.7k|                    return '\n';
21482|   332k|                while (*p && *p != '\r' && *p != '\n')
21483|   323k|                    p++;
21484|  9.49k|                continue;
21485|  29.2k|            }
21486|  7.23k|            if (*p == '*') {
21487|   158k|                while (*++p) {
21488|   157k|                    if ((*p == '\r' || *p == '\n') && no_line_terminator)
21489|  1.27k|                        return '\n';
21490|   156k|                    if (*p == '*' && p[1] == '/') {
21491|    485|                        p += 2;
21492|    485|                        break;
21493|    485|                    }
21494|   156k|                }
21495|  1.67k|                continue;
21496|  2.95k|            }
21497|  4.28k|            break;
21498|   507k|        case '=':
21499|   507k|            if (*p == '>')
21500|   178k|                return TOK_ARROW;
21501|   328k|            break;
21502|   328k|        case 'i':
21503|    777|            if (match_identifier(p, "n"))
21504|    331|                return TOK_IN;
21505|    446|            if (match_identifier(p, "mport")) {
21506|    339|                *pp = p + 5;
21507|    339|                return TOK_IMPORT;
21508|    339|            }
21509|    107|            return TOK_IDENT;
21510|  5.97k|        case 'o':
21511|  5.97k|            if (match_identifier(p, "f"))
21512|     11|                return TOK_OF;
21513|  5.96k|            return TOK_IDENT;
21514|    796|        case 'e':
21515|    796|            if (match_identifier(p, "xport"))
21516|    580|                return TOK_EXPORT;
21517|    216|            return TOK_IDENT;
21518|  2.17k|        case 'f':
21519|  2.17k|            if (match_identifier(p, "unction"))
21520|      0|                return TOK_FUNCTION;
21521|  2.17k|            return TOK_IDENT;
21522|     97|        case '\\':
21523|     97|            if (*p == 'u') {
21524|     59|                if (lre_js_is_ident_first(lre_parse_escape(&p, TRUE)))
21525|      7|                    return TOK_IDENT;
21526|     59|            }
21527|     90|            break;
21528|   311k|        default:
21529|   311k|            if (c >= 128) {
21530|  1.16k|                c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p);
21531|  1.16k|                if (no_line_terminator && (c == CP_PS || c == CP_LS))
21532|    438|                    return '\n';
21533|  1.16k|            }
21534|   311k|            if (lre_is_space(c))
21535|    443|                continue;
21536|   310k|            if (lre_js_is_ident_first(c))
21537|  13.6k|                return TOK_IDENT;
21538|   296k|            break;
21539|   953k|        }
21540|   630k|        return c;
21541|   953k|    }
21542|   872k|}
21543|       |
21544|       |static int peek_token(JSParseState *s, BOOL no_line_terminator)
21545|   854k|{
21546|   854k|    const uint8_t *p = s->buf_ptr;
21547|   854k|    return simple_next_token(&p, no_line_terminator);
21548|   854k|}
21549|       |
21550|       |static void skip_shebang(const uint8_t **pp, const uint8_t *buf_end)
21551|  35.5k|{
21552|  35.5k|    const uint8_t *p = *pp;
21553|  35.5k|    int c;
21554|       |
21555|  35.5k|    if (p[0] == '#' && p[1] == '!') {
21556|     58|        p += 2;
21557|  5.64k|        while (p < buf_end) {
21558|  5.59k|            if (*p == '\n' || *p == '\r') {
21559|      4|                break;
21560|  5.58k|            } else if (*p >= 0x80) {
21561|  2.44k|                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
21562|  2.44k|                if (c == CP_LS || c == CP_PS) {
21563|      4|                    break;
21564|  2.43k|                } else if (c == -1) {
21565|  1.97k|                    p++; /* skip invalid UTF-8 */
21566|  1.97k|                }
21567|  3.14k|            } else {
21568|  3.14k|                p++;
21569|  3.14k|            }
21570|  5.59k|        }
21571|     58|        *pp = p;
21572|     58|    }
21573|  35.5k|}
21574|       |
21575|       |/* return true if 'input' contains the source of a module
21576|       |   (heuristic). 'input' must be a zero terminated.
21577|       |
21578|       |   Heuristic: skip comments and expect 'import' keyword not followed
21579|       |   by '(' or '.' or export keyword.
21580|       |*/
21581|       |BOOL JS_DetectModule(const char *input, size_t input_len)
21582|  17.7k|{
21583|  17.7k|    const uint8_t *p = (const uint8_t *)input;
21584|  17.7k|    int tok;
21585|       |
21586|  17.7k|    skip_shebang(&p, p + input_len);
21587|  17.7k|    switch(simple_next_token(&p, FALSE)) {
21588|    330|    case TOK_IMPORT:
21589|    330|        tok = simple_next_token(&p, FALSE);
21590|    330|        return (tok != '.' && tok != '(');
21591|    565|    case TOK_EXPORT:
21592|    565|        return TRUE;
21593|  16.8k|    default:
21594|  16.8k|        return FALSE;
21595|  17.7k|    }
21596|  17.7k|}
21597|       |
21598|  1.49M|static inline int get_prev_opcode(JSFunctionDef *fd) {
21599|  1.49M|    if (fd->last_opcode_pos < 0)
21600|  1.90k|        return OP_invalid;
21601|  1.49M|    else
21602|  1.49M|        return fd->byte_code.buf[fd->last_opcode_pos];
21603|  1.49M|}
21604|       |
21605|   170k|static BOOL js_is_live_code(JSParseState *s) {
21606|   170k|    switch (get_prev_opcode(s->cur_func)) {
21607|      0|    case OP_tail_call:
21608|      0|    case OP_tail_call_method:
21609|      0|    case OP_return:
21610|      0|    case OP_return_undef:
21611|      0|    case OP_return_async:
21612|     12|    case OP_throw:
21613|     12|    case OP_throw_error:
21614|     12|    case OP_goto:
21615|     12|#if SHORT_OPCODES
21616|     12|    case OP_goto8:
21617|     12|    case OP_goto16:
21618|     12|#endif
21619|     12|    case OP_ret:
21620|     12|        return FALSE;
21621|   170k|    default:
21622|   170k|        return TRUE;
21623|   170k|    }
21624|   170k|}
21625|       |
21626|       |static void emit_u8(JSParseState *s, uint8_t val)
21627|   218k|{
21628|   218k|    dbuf_putc(&s->cur_func->byte_code, val);
21629|   218k|}
21630|       |
21631|       |static void emit_u16(JSParseState *s, uint16_t val)
21632|  2.01M|{
21633|  2.01M|    dbuf_put_u16(&s->cur_func->byte_code, val);
21634|  2.01M|}
21635|       |
21636|       |static void emit_u32(JSParseState *s, uint32_t val)
21637|  3.74M|{
21638|  3.74M|    dbuf_put_u32(&s->cur_func->byte_code, val);
21639|  3.74M|}
21640|       |
21641|       |static void emit_source_pos(JSParseState *s, const uint8_t *source_ptr)
21642|  1.16M|{
21643|  1.16M|    JSFunctionDef *fd = s->cur_func;
21644|  1.16M|    DynBuf *bc = &fd->byte_code;
21645|       |
21646|  1.16M|    if (unlikely(fd->last_opcode_source_ptr != source_ptr)) {
21647|  1.15M|        dbuf_putc(bc, OP_line_num);
21648|  1.15M|        dbuf_put_u32(bc, source_ptr - s->buf_start);
21649|  1.15M|        fd->last_opcode_source_ptr = source_ptr;
21650|  1.15M|    }
21651|  1.16M|}
21652|       |
21653|       |static void emit_op(JSParseState *s, uint8_t val)
21654|  6.98M|{
21655|  6.98M|    JSFunctionDef *fd = s->cur_func;
21656|  6.98M|    DynBuf *bc = &fd->byte_code;
21657|       |
21658|  6.98M|    fd->last_opcode_pos = bc->size;
21659|  6.98M|    dbuf_putc(bc, val);
21660|  6.98M|}
21661|       |
21662|       |static void emit_atom(JSParseState *s, JSAtom name)
21663|   539k|{
21664|   539k|    emit_u32(s, JS_DupAtom(s->ctx, name));
21665|   539k|}
21666|       |
21667|       |static int update_label(JSFunctionDef *s, int label, int delta)
21668|   729k|{
21669|   729k|    LabelSlot *ls;
21670|       |
21671|   729k|    assert(label >= 0 && label < s->label_count);
21672|   729k|    ls = &s->label_slots[label];
21673|   729k|    ls->ref_count += delta;
21674|   729k|    assert(ls->ref_count >= 0);
21675|   729k|    return ls->ref_count;
21676|   729k|}
21677|       |
21678|       |static int new_label_fd(JSFunctionDef *fd, int label)
21679|   595k|{
21680|   595k|    LabelSlot *ls;
21681|       |
21682|   595k|    if (label < 0) {
21683|   595k|        if (js_resize_array(fd->ctx, (void *)&fd->label_slots,
21684|   595k|                            sizeof(fd->label_slots[0]),
21685|   595k|                            &fd->label_size, fd->label_count + 1))
21686|      0|            return -1;
21687|   595k|        label = fd->label_count++;
21688|   595k|        ls = &fd->label_slots[label];
21689|   595k|        ls->ref_count = 0;
21690|   595k|        ls->pos = -1;
21691|   595k|        ls->pos2 = -1;
21692|   595k|        ls->addr = -1;
21693|   595k|        ls->first_reloc = NULL;
21694|   595k|    }
21695|   595k|    return label;
21696|   595k|}
21697|       |
21698|       |static int new_label(JSParseState *s)
21699|   594k|{
21700|   594k|    return new_label_fd(s->cur_func, -1);
21701|   594k|}
21702|       |
21703|       |/* don't update the last opcode and don't emit line number info */
21704|       |static void emit_label_raw(JSParseState *s, int label)
21705|    360|{
21706|    360|    emit_u8(s, OP_label);
21707|    360|    emit_u32(s, label);
21708|    360|    s->cur_func->label_slots[label].pos = s->cur_func->byte_code.size;
21709|    360|}
21710|       |
21711|       |/* return the label ID offset */
21712|       |static int emit_label(JSParseState *s, int label)
21713|   568k|{
21714|   568k|    if (label >= 0) {
21715|   568k|        emit_op(s, OP_label);
21716|   568k|        emit_u32(s, label);
21717|   568k|        s->cur_func->label_slots[label].pos = s->cur_func->byte_code.size;
21718|   568k|        return s->cur_func->byte_code.size - 4;
21719|   568k|    } else {
21720|      0|        return -1;
21721|      0|    }
21722|   568k|}
21723|       |
21724|       |/* return label or -1 if dead code */
21725|       |static int emit_goto(JSParseState *s, int opcode, int label)
21726|   170k|{
21727|   170k|    if (js_is_live_code(s)) {
21728|   170k|        if (label < 0)
21729|  64.1k|            label = new_label(s);
21730|   170k|        emit_op(s, opcode);
21731|   170k|        emit_u32(s, label);
21732|   170k|        s->cur_func->label_slots[label].ref_count++;
21733|   170k|        return label;
21734|   170k|    }
21735|     11|    return -1;
21736|   170k|}
21737|       |
21738|       |/* return the constant pool index. 'val' is not duplicated. */
21739|       |static int cpool_add(JSParseState *s, JSValue val)
21740|   817k|{
21741|   817k|    JSFunctionDef *fd = s->cur_func;
21742|       |
21743|   817k|    if (js_resize_array(s->ctx, (void *)&fd->cpool, sizeof(fd->cpool[0]),
21744|   817k|                        &fd->cpool_size, fd->cpool_count + 1))
21745|      0|        return -1;
21746|   817k|    fd->cpool[fd->cpool_count++] = val;
21747|   817k|    return fd->cpool_count - 1;
21748|   817k|}
21749|       |
21750|       |static __exception int emit_push_const(JSParseState *s, JSValueConst val,
21751|       |                                       BOOL as_atom)
21752|   895k|{
21753|   895k|    int idx;
21754|       |
21755|   895k|    if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING && as_atom) {
21756|   206k|        JSAtom atom;
21757|       |        /* warning: JS_NewAtomStr frees the string value */
21758|   206k|        JS_DupValue(s->ctx, val);
21759|   206k|        atom = JS_NewAtomStr(s->ctx, JS_VALUE_GET_STRING(val));
21760|   206k|        if (atom != JS_ATOM_NULL && !__JS_AtomIsTaggedInt(atom)) {
21761|   205k|            emit_op(s, OP_push_atom_value);
21762|   205k|            emit_u32(s, atom);
21763|   205k|            return 0;
21764|   205k|        }
21765|   206k|    }
21766|       |
21767|   689k|    idx = cpool_add(s, JS_DupValue(s->ctx, val));
21768|   689k|    if (idx < 0)
21769|      0|        return -1;
21770|   689k|    emit_op(s, OP_push_const);
21771|   689k|    emit_u32(s, idx);
21772|   689k|    return 0;
21773|   689k|}
21774|       |
21775|       |/* return the variable index or -1 if not found,
21776|       |   add ARGUMENT_VAR_OFFSET for argument variables */
21777|       |static int find_arg(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
21778|  1.32M|{
21779|  1.32M|    int i;
21780|  2.29M|    for(i = fd->arg_count; i-- > 0;) {
21781|  1.01M|        if (fd->args[i].var_name == name)
21782|  48.8k|            return i | ARGUMENT_VAR_OFFSET;
21783|  1.01M|    }
21784|  1.28M|    return -1;
21785|  1.32M|}
21786|       |
21787|       |static int find_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
21788|  1.33M|{
21789|  1.33M|    int i;
21790|  18.2M|    for(i = fd->var_count; i-- > 0;) {
21791|  16.9M|        if (fd->vars[i].var_name == name && fd->vars[i].scope_level == 0)
21792|  9.90k|            return i;
21793|  16.9M|    }
21794|  1.32M|    return find_arg(ctx, fd, name);
21795|  1.33M|}
21796|       |
21797|       |/* find a variable declaration in a given scope */
21798|       |static int find_var_in_scope(JSContext *ctx, JSFunctionDef *fd,
21799|       |                             JSAtom name, int scope_level)
21800|      0|{
21801|      0|    int scope_idx;
21802|      0|    for(scope_idx = fd->scopes[scope_level].first; scope_idx >= 0;
21803|      0|        scope_idx = fd->vars[scope_idx].scope_next) {
21804|      0|        if (fd->vars[scope_idx].scope_level != scope_level)
21805|      0|            break;
21806|      0|        if (fd->vars[scope_idx].var_name == name)
21807|      0|            return scope_idx;
21808|      0|    }
21809|      0|    return -1;
21810|      0|}
21811|       |
21812|       |/* return true if scope == parent_scope or if scope is a child of
21813|       |   parent_scope */
21814|       |static BOOL is_child_scope(JSContext *ctx, JSFunctionDef *fd,
21815|       |                           int scope, int parent_scope)
21816|  1.20k|{
21817|  5.43k|    while (scope >= 0) {
21818|  4.23k|        if (scope == parent_scope)
21819|      7|            return TRUE;
21820|  4.22k|        scope = fd->scopes[scope].parent;
21821|  4.22k|    }
21822|  1.20k|    return FALSE;
21823|  1.20k|}
21824|       |
21825|       |/* find a 'var' declaration in the same scope or a child scope */
21826|       |static int find_var_in_child_scope(JSContext *ctx, JSFunctionDef *fd,
21827|       |                                   JSAtom name, int scope_level)
21828|  27.3k|{
21829|  27.3k|    int i;
21830|   834k|    for(i = 0; i < fd->var_count; i++) {
21831|   806k|        JSVarDef *vd = &fd->vars[i];
21832|   806k|        if (vd->var_name == name && vd->scope_level == 0) {
21833|    387|            if (is_child_scope(ctx, fd, vd->scope_next,
21834|    387|                               scope_level))
21835|      1|                return i;
21836|    387|        }
21837|   806k|    }
21838|  27.3k|    return -1;
21839|  27.3k|}
21840|       |
21841|       |
21842|       |static JSGlobalVar *find_global_var(JSFunctionDef *fd, JSAtom name)
21843|  46.8k|{
21844|  46.8k|    int i;
21845|   429k|    for(i = 0; i < fd->global_var_count; i++) {
21846|   402k|        JSGlobalVar *hf = &fd->global_vars[i];
21847|   402k|        if (hf->var_name == name)
21848|  20.3k|            return hf;
21849|   402k|    }
21850|  26.4k|    return NULL;
21851|       |
21852|  46.8k|}
21853|       |
21854|       |static JSGlobalVar *find_lexical_global_var(JSFunctionDef *fd, JSAtom name)
21855|  13.4k|{
21856|  13.4k|    JSGlobalVar *hf = find_global_var(fd, name);
21857|  13.4k|    if (hf && hf->is_lexical)
21858|    271|        return hf;
21859|  13.1k|    else
21860|  13.1k|        return NULL;
21861|  13.4k|}
21862|       |
21863|       |static int find_lexical_decl(JSContext *ctx, JSFunctionDef *fd, JSAtom name,
21864|       |                             int scope_idx, BOOL check_catch_var)
21865|  56.8k|{
21866|   141k|    while (scope_idx >= 0) {
21867|  89.3k|        JSVarDef *vd = &fd->vars[scope_idx];
21868|  89.3k|        if (vd->var_name == name &&
21869|  89.3k|            (vd->is_lexical || (vd->var_kind == JS_VAR_CATCH &&
21870|      0|                                check_catch_var)))
21871|  4.32k|            return scope_idx;
21872|  85.0k|        scope_idx = vd->scope_next;
21873|  85.0k|    }
21874|       |
21875|  52.4k|    if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_GLOBAL) {
21876|  13.4k|        if (find_lexical_global_var(fd, name))
21877|    271|            return GLOBAL_VAR_OFFSET;
21878|  13.4k|    }
21879|  52.2k|    return -1;
21880|  52.4k|}
21881|       |
21882|   185k|static int push_scope(JSParseState *s) {
21883|   185k|    if (s->cur_func) {
21884|   185k|        JSFunctionDef *fd = s->cur_func;
21885|   185k|        int scope = fd->scope_count;
21886|       |        /* XXX: should check for scope overflow */
21887|   185k|        if ((fd->scope_count + 1) > fd->scope_size) {
21888|  3.41k|            int new_size;
21889|  3.41k|            size_t slack;
21890|  3.41k|            JSVarScope *new_buf;
21891|       |            /* XXX: potential arithmetic overflow */
21892|  3.41k|            new_size = max_int(fd->scope_count + 1, fd->scope_size * 3 / 2);
21893|  3.41k|            if (fd->scopes == fd->def_scope_array) {
21894|  2.09k|                new_buf = js_realloc2(s->ctx, NULL, new_size * sizeof(*fd->scopes), &slack);
21895|  2.09k|                if (!new_buf)
21896|      0|                    return -1;
21897|  2.09k|                memcpy(new_buf, fd->scopes, fd->scope_count * sizeof(*fd->scopes));
21898|  2.09k|            } else {
21899|  1.31k|                new_buf = js_realloc2(s->ctx, fd->scopes, new_size * sizeof(*fd->scopes), &slack);
21900|  1.31k|                if (!new_buf)
21901|      0|                    return -1;
21902|  1.31k|            }
21903|  3.41k|            new_size += slack / sizeof(*new_buf);
21904|  3.41k|            fd->scopes = new_buf;
21905|  3.41k|            fd->scope_size = new_size;
21906|  3.41k|        }
21907|   185k|        fd->scope_count++;
21908|   185k|        fd->scopes[scope].parent = fd->scope_level;
21909|   185k|        fd->scopes[scope].first = fd->scope_first;
21910|   185k|        emit_op(s, OP_enter_scope);
21911|   185k|        emit_u16(s, scope);
21912|   185k|        return fd->scope_level = scope;
21913|   185k|    }
21914|      0|    return 0;
21915|   185k|}
21916|       |
21917|       |static int get_first_lexical_var(JSFunctionDef *fd, int scope)
21918|  21.5k|{
21919|   261k|    while (scope >= 0) {
21920|   244k|        int scope_idx = fd->scopes[scope].first;
21921|   244k|        if (scope_idx >= 0)
21922|  4.42k|            return scope_idx;
21923|   240k|        scope = fd->scopes[scope].parent;
21924|   240k|    }
21925|  17.1k|    return -1;
21926|  21.5k|}
21927|       |
21928|  21.5k|static void pop_scope(JSParseState *s) {
21929|  21.5k|    if (s->cur_func) {
21930|       |        /* disable scoped variables */
21931|  21.5k|        JSFunctionDef *fd = s->cur_func;
21932|  21.5k|        int scope = fd->scope_level;
21933|  21.5k|        emit_op(s, OP_leave_scope);
21934|  21.5k|        emit_u16(s, scope);
21935|  21.5k|        fd->scope_level = fd->scopes[scope].parent;
21936|  21.5k|        fd->scope_first = get_first_lexical_var(fd, fd->scope_level);
21937|  21.5k|    }
21938|  21.5k|}
21939|       |
21940|       |static void close_scopes(JSParseState *s, int scope, int scope_stop)
21941|  22.7k|{
21942|  45.4k|    while (scope > scope_stop) {
21943|  22.7k|        emit_op(s, OP_leave_scope);
21944|  22.7k|        emit_u16(s, scope);
21945|  22.7k|        scope = s->cur_func->scopes[scope].parent;
21946|  22.7k|    }
21947|  22.7k|}
21948|       |
21949|       |/* return the variable index or -1 if error */
21950|       |static int add_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
21951|  51.3k|{
21952|  51.3k|    JSVarDef *vd;
21953|       |
21954|       |    /* the local variable indexes are currently stored on 16 bits */
21955|  51.3k|    if (fd->var_count >= JS_MAX_LOCAL_VARS) {
21956|      0|        JS_ThrowInternalError(ctx, "too many local variables");
21957|      0|        return -1;
21958|      0|    }
21959|  51.3k|    if (js_resize_array(ctx, (void **)&fd->vars, sizeof(fd->vars[0]),
21960|  51.3k|                        &fd->var_size, fd->var_count + 1))
21961|      0|        return -1;
21962|  51.3k|    vd = &fd->vars[fd->var_count++];
21963|  51.3k|    memset(vd, 0, sizeof(*vd));
21964|  51.3k|    vd->var_name = JS_DupAtom(ctx, name);
21965|  51.3k|    vd->func_pool_idx = -1;
21966|  51.3k|    return fd->var_count - 1;
21967|  51.3k|}
21968|       |
21969|       |static int add_scope_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name,
21970|       |                         JSVarKindEnum var_kind)
21971|  24.4k|{
21972|  24.4k|    int idx = add_var(ctx, fd, name);
21973|  24.4k|    if (idx >= 0) {
21974|  24.4k|        JSVarDef *vd = &fd->vars[idx];
21975|  24.4k|        vd->var_kind = var_kind;
21976|  24.4k|        vd->scope_level = fd->scope_level;
21977|  24.4k|        vd->scope_next = fd->scope_first;
21978|  24.4k|        fd->scopes[fd->scope_level].first = idx;
21979|  24.4k|        fd->scope_first = idx;
21980|  24.4k|    }
21981|  24.4k|    return idx;
21982|  24.4k|}
21983|       |
21984|       |static int add_func_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
21985|      0|{
21986|      0|    int idx = fd->func_var_idx;
21987|      0|    if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
21988|      0|        fd->func_var_idx = idx;
21989|      0|        fd->vars[idx].var_kind = JS_VAR_FUNCTION_NAME;
21990|      0|        if (fd->js_mode & JS_MODE_STRICT)
21991|      0|            fd->vars[idx].is_const = TRUE;
21992|      0|    }
21993|      0|    return idx;
21994|      0|}
21995|       |
21996|       |static int add_arguments_var(JSContext *ctx, JSFunctionDef *fd)
21997|      0|{
21998|      0|    int idx = fd->arguments_var_idx;
21999|      0|    if (idx < 0 && (idx = add_var(ctx, fd, JS_ATOM_arguments)) >= 0) {
22000|      0|        fd->arguments_var_idx = idx;
22001|      0|    }
22002|      0|    return idx;
22003|      0|}
22004|       |
22005|       |/* add an argument definition in the argument scope. Only needed when
22006|       |   "eval()" may be called in the argument scope. Return 0 if OK. */
22007|       |static int add_arguments_arg(JSContext *ctx, JSFunctionDef *fd)
22008|      0|{
22009|      0|    int idx;
22010|      0|    if (fd->arguments_arg_idx < 0) {
22011|      0|        idx = find_var_in_scope(ctx, fd, JS_ATOM_arguments, ARG_SCOPE_INDEX);
22012|      0|        if (idx < 0) {
22013|       |            /* XXX: the scope links are not fully updated. May be an
22014|       |               issue if there are child scopes of the argument
22015|       |               scope */
22016|      0|            idx = add_var(ctx, fd, JS_ATOM_arguments);
22017|      0|            if (idx < 0)
22018|      0|                return -1;
22019|      0|            fd->vars[idx].scope_next = fd->scopes[ARG_SCOPE_INDEX].first;
22020|      0|            fd->scopes[ARG_SCOPE_INDEX].first = idx;
22021|      0|            fd->vars[idx].scope_level = ARG_SCOPE_INDEX;
22022|      0|            fd->vars[idx].is_lexical = TRUE;
22023|       |
22024|      0|            fd->arguments_arg_idx = idx;
22025|      0|        }
22026|      0|    }
22027|      0|    return 0;
22028|      0|}
22029|       |
22030|       |static int add_arg(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
22031|   137k|{
22032|   137k|    JSVarDef *vd;
22033|       |
22034|       |    /* the local variable indexes are currently stored on 16 bits */
22035|   137k|    if (fd->arg_count >= JS_MAX_LOCAL_VARS) {
22036|      0|        JS_ThrowInternalError(ctx, "too many arguments");
22037|      0|        return -1;
22038|      0|    }
22039|   137k|    if (js_resize_array(ctx, (void **)&fd->args, sizeof(fd->args[0]),
22040|   137k|                        &fd->arg_size, fd->arg_count + 1))
22041|      0|        return -1;
22042|   137k|    vd = &fd->args[fd->arg_count++];
22043|   137k|    memset(vd, 0, sizeof(*vd));
22044|   137k|    vd->var_name = JS_DupAtom(ctx, name);
22045|   137k|    vd->func_pool_idx = -1;
22046|   137k|    return fd->arg_count - 1;
22047|   137k|}
22048|       |
22049|       |/* add a global variable definition */
22050|       |static JSGlobalVar *add_global_var(JSContext *ctx, JSFunctionDef *s,
22051|       |                                     JSAtom name)
22052|  18.8k|{
22053|  18.8k|    JSGlobalVar *hf;
22054|       |
22055|  18.8k|    if (js_resize_array(ctx, (void **)&s->global_vars,
22056|  18.8k|                        sizeof(s->global_vars[0]),
22057|  18.8k|                        &s->global_var_size, s->global_var_count + 1))
22058|      0|        return NULL;
22059|  18.8k|    hf = &s->global_vars[s->global_var_count++];
22060|  18.8k|    hf->cpool_idx = -1;
22061|  18.8k|    hf->force_init = FALSE;
22062|  18.8k|    hf->is_lexical = FALSE;
22063|  18.8k|    hf->is_const = FALSE;
22064|  18.8k|    hf->scope_level = s->scope_level;
22065|  18.8k|    hf->var_name = JS_DupAtom(ctx, name);
22066|  18.8k|    return hf;
22067|  18.8k|}
22068|       |
22069|       |typedef enum {
22070|       |    JS_VAR_DEF_WITH,
22071|       |    JS_VAR_DEF_LET,
22072|       |    JS_VAR_DEF_CONST,
22073|       |    JS_VAR_DEF_FUNCTION_DECL, /* function declaration */
22074|       |    JS_VAR_DEF_NEW_FUNCTION_DECL, /* async/generator function declaration */
22075|       |    JS_VAR_DEF_CATCH,
22076|       |    JS_VAR_DEF_VAR,
22077|       |} JSVarDefEnum;
22078|       |
22079|       |static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
22080|       |                      JSVarDefEnum var_def_type)
22081|  56.8k|{
22082|  56.8k|    JSContext *ctx = s->ctx;
22083|  56.8k|    JSVarDef *vd;
22084|  56.8k|    int idx;
22085|       |
22086|  56.8k|    switch (var_def_type) {
22087|      0|    case JS_VAR_DEF_WITH:
22088|      0|        idx = add_scope_var(ctx, fd, name, JS_VAR_NORMAL);
22089|      0|        break;
22090|       |
22091|  27.0k|    case JS_VAR_DEF_LET:
22092|  27.3k|    case JS_VAR_DEF_CONST:
22093|  27.3k|    case JS_VAR_DEF_FUNCTION_DECL:
22094|  27.3k|    case JS_VAR_DEF_NEW_FUNCTION_DECL:
22095|  27.3k|        idx = find_lexical_decl(ctx, fd, name, fd->scope_first, TRUE);
22096|  27.3k|        if (idx >= 0) {
22097|  4.58k|            if (idx < GLOBAL_VAR_OFFSET) {
22098|  4.31k|                if (fd->vars[idx].scope_level == fd->scope_level) {
22099|       |                    /* same scope: in non strict mode, functions
22100|       |                       can be redefined (annex B.3.3.4). */
22101|     13|                    if (!(!(fd->js_mode & JS_MODE_STRICT) &&
22102|     13|                          var_def_type == JS_VAR_DEF_FUNCTION_DECL &&
22103|     13|                          fd->vars[idx].var_kind == JS_VAR_FUNCTION_DECL)) {
22104|     13|                        goto redef_lex_error;
22105|     13|                    }
22106|  4.30k|                } else if (fd->vars[idx].var_kind == JS_VAR_CATCH && (fd->vars[idx].scope_level + 2) == fd->scope_level) {
22107|      0|                    goto redef_lex_error;
22108|      0|                }
22109|  4.31k|            } else {
22110|    270|                if (fd->scope_level == fd->body_scope) {
22111|     23|                redef_lex_error:
22112|       |                    /* redefining a scoped var in the same scope: error */
22113|     23|                    return js_parse_error(s, "invalid redefinition of lexical identifier");
22114|     10|                }
22115|    270|            }
22116|  4.58k|        }
22117|  27.3k|        if (var_def_type != JS_VAR_DEF_FUNCTION_DECL &&
22118|  27.3k|            var_def_type != JS_VAR_DEF_NEW_FUNCTION_DECL &&
22119|  27.3k|            fd->scope_level == fd->body_scope &&
22120|  27.3k|            find_arg(ctx, fd, name) >= 0) {
22121|       |            /* lexical variable redefines a parameter name */
22122|      1|            return js_parse_error(s, "invalid redefinition of parameter name");
22123|      1|        }
22124|       |
22125|  27.3k|        if (find_var_in_child_scope(ctx, fd, name, fd->scope_level) >= 0) {
22126|      1|            return js_parse_error(s, "invalid redefinition of a variable");
22127|      1|        }
22128|       |
22129|  27.3k|        if (fd->is_global_var) {
22130|  17.4k|            JSGlobalVar *hf;
22131|  17.4k|            hf = find_global_var(fd, name);
22132|  17.4k|            if (hf && is_child_scope(ctx, fd, hf->scope_level,
22133|    821|                                     fd->scope_level)) {
22134|      6|                return js_parse_error(s, "invalid redefinition of global identifier");
22135|      6|            }
22136|  17.4k|        }
22137|       |
22138|  27.3k|        if (fd->is_eval &&
22139|  27.3k|            (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||
22140|  17.3k|             fd->eval_type == JS_EVAL_TYPE_MODULE) &&
22141|  27.3k|            fd->scope_level == fd->body_scope) {
22142|  2.86k|            JSGlobalVar *hf;
22143|  2.86k|            hf = add_global_var(s->ctx, fd, name);
22144|  2.86k|            if (!hf)
22145|      0|                return -1;
22146|  2.86k|            hf->is_lexical = TRUE;
22147|  2.86k|            hf->is_const = (var_def_type == JS_VAR_DEF_CONST);
22148|  2.86k|            idx = GLOBAL_VAR_OFFSET;
22149|  24.4k|        } else {
22150|  24.4k|            JSVarKindEnum var_kind;
22151|  24.4k|            if (var_def_type == JS_VAR_DEF_FUNCTION_DECL)
22152|      0|                var_kind = JS_VAR_FUNCTION_DECL;
22153|  24.4k|            else if (var_def_type == JS_VAR_DEF_NEW_FUNCTION_DECL)
22154|      0|                var_kind = JS_VAR_NEW_FUNCTION_DECL;
22155|  24.4k|            else
22156|  24.4k|                var_kind = JS_VAR_NORMAL;
22157|  24.4k|            idx = add_scope_var(ctx, fd, name, var_kind);
22158|  24.4k|            if (idx >= 0) {
22159|  24.4k|                vd = &fd->vars[idx];
22160|  24.4k|                vd->is_lexical = 1;
22161|  24.4k|                vd->is_const = (var_def_type == JS_VAR_DEF_CONST);
22162|  24.4k|            }
22163|  24.4k|        }
22164|  27.3k|        break;
22165|       |
22166|  27.3k|    case JS_VAR_DEF_CATCH:
22167|      0|        idx = add_scope_var(ctx, fd, name, JS_VAR_CATCH);
22168|      0|        break;
22169|       |
22170|  29.4k|    case JS_VAR_DEF_VAR:
22171|  29.4k|        if (find_lexical_decl(ctx, fd, name, fd->scope_first,
22172|  29.4k|                              FALSE) >= 0) {
22173|     14|       invalid_lexical_redefinition:
22174|       |            /* error to redefine a var that inside a lexical scope */
22175|     14|            return js_parse_error(s, "invalid redefinition of lexical identifier");
22176|     13|        }
22177|  29.4k|        if (fd->is_global_var) {
22178|  16.0k|            JSGlobalVar *hf;
22179|  16.0k|            hf = find_global_var(fd, name);
22180|  16.0k|            if (hf && hf->is_lexical && hf->scope_level == fd->scope_level &&
22181|  16.0k|                fd->eval_type == JS_EVAL_TYPE_MODULE) {
22182|      1|                goto invalid_lexical_redefinition;
22183|      1|            }
22184|  16.0k|            hf = add_global_var(s->ctx, fd, name);
22185|  16.0k|            if (!hf)
22186|      0|                return -1;
22187|  16.0k|            idx = GLOBAL_VAR_OFFSET;
22188|  16.0k|        } else {
22189|       |            /* if the variable already exists, don't add it again  */
22190|  13.4k|            idx = find_var(ctx, fd, name);
22191|  13.4k|            if (idx >= 0)
22192|  3.89k|                break;
22193|  9.55k|            idx = add_var(ctx, fd, name);
22194|  9.55k|            if (idx >= 0) {
22195|  9.55k|                if (name == JS_ATOM_arguments && fd->has_arguments_binding)
22196|      0|                    fd->arguments_var_idx = idx;
22197|  9.55k|                fd->vars[idx].scope_next = fd->scope_level;
22198|  9.55k|            }
22199|  9.55k|        }
22200|  25.5k|        break;
22201|  25.5k|    default:
22202|      0|        abort();
22203|  56.8k|    }
22204|  56.7k|    return idx;
22205|  56.8k|}
22206|       |
22207|       |/* add a private field variable in the current scope */
22208|       |static int add_private_class_field(JSParseState *s, JSFunctionDef *fd,
22209|       |                                   JSAtom name, JSVarKindEnum var_kind, BOOL is_static)
22210|      0|{
22211|      0|    JSContext *ctx = s->ctx;
22212|      0|    JSVarDef *vd;
22213|      0|    int idx;
22214|       |
22215|      0|    idx = add_scope_var(ctx, fd, name, var_kind);
22216|      0|    if (idx < 0)
22217|      0|        return idx;
22218|      0|    vd = &fd->vars[idx];
22219|      0|    vd->is_lexical = 1;
22220|      0|    vd->is_const = 1;
22221|      0|    vd->is_static_private = is_static;
22222|      0|    return idx;
22223|      0|}
22224|       |
22225|       |static __exception int js_parse_expr(JSParseState *s);
22226|       |static __exception int js_parse_function_decl(JSParseState *s,
22227|       |                                              JSParseFunctionEnum func_type,
22228|       |                                              JSFunctionKindEnum func_kind,
22229|       |                                              JSAtom func_name, const uint8_t *ptr);
22230|       |static JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s);
22231|       |static __exception int js_parse_function_decl2(JSParseState *s,
22232|       |                                               JSParseFunctionEnum func_type,
22233|       |                                               JSFunctionKindEnum func_kind,
22234|       |                                               JSAtom func_name,
22235|       |                                               const uint8_t *ptr,
22236|       |                                               JSParseExportEnum export_flag,
22237|       |                                               JSFunctionDef **pfd);
22238|       |static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags);
22239|       |static __exception int js_parse_assign_expr(JSParseState *s);
22240|       |static __exception int js_parse_unary(JSParseState *s, int parse_flags);
22241|       |static void push_break_entry(JSFunctionDef *fd, BlockEnv *be,
22242|       |                             JSAtom label_name,
22243|       |                             int label_break, int label_cont,
22244|       |                             int drop_count);
22245|       |static void pop_break_entry(JSFunctionDef *fd);
22246|       |static JSExportEntry *add_export_entry(JSParseState *s, JSModuleDef *m,
22247|       |                                       JSAtom local_name, JSAtom export_name,
22248|       |                                       JSExportTypeEnum export_type);
22249|       |
22250|       |/* Note: all the fields are already sealed except length */
22251|       |static int seal_template_obj(JSContext *ctx, JSValueConst obj)
22252|  1.06M|{
22253|  1.06M|    JSObject *p;
22254|  1.06M|    JSShapeProperty *prs;
22255|       |
22256|  1.06M|    p = JS_VALUE_GET_OBJ(obj);
22257|  1.06M|    prs = find_own_property1(p, JS_ATOM_length);
22258|  1.06M|    if (prs) {
22259|  1.06M|        if (js_update_property_flags(ctx, p, &prs,
22260|  1.06M|                                     prs->flags & ~(JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)))
22261|      0|            return -1;
22262|  1.06M|    }
22263|  1.06M|    p->extensible = FALSE;
22264|  1.06M|    return 0;
22265|  1.06M|}
22266|       |
22267|       |static __exception int js_parse_template(JSParseState *s, int call, int *argc)
22268|   539k|{
22269|   539k|    JSContext *ctx = s->ctx;
22270|   539k|    JSValue raw_array, template_object;
22271|   539k|    JSToken cooked;
22272|   539k|    int depth, ret;
22273|       |
22274|   539k|    raw_array = JS_UNDEFINED; /* avoid warning */
22275|   539k|    template_object = JS_UNDEFINED; /* avoid warning */
22276|   539k|    if (call) {
22277|       |        /* Create a template object: an array of cooked strings */
22278|       |        /* Create an array of raw strings and store it to the raw property */
22279|   534k|        template_object = JS_NewArray(ctx);
22280|   534k|        if (JS_IsException(template_object))
22281|      0|            return -1;
22282|       |        //        pool_idx = s->cur_func->cpool_count;
22283|   534k|        ret = emit_push_const(s, template_object, 0);
22284|   534k|        JS_FreeValue(ctx, template_object);
22285|   534k|        if (ret)
22286|      0|            return -1;
22287|   534k|        raw_array = JS_NewArray(ctx);
22288|   534k|        if (JS_IsException(raw_array))
22289|      0|            return -1;
22290|   534k|        if (JS_DefinePropertyValue(ctx, template_object, JS_ATOM_raw,
22291|   534k|                                   raw_array, JS_PROP_THROW) < 0) {
22292|      0|            return -1;
22293|      0|        }
22294|   534k|    }
22295|       |
22296|   539k|    depth = 0;
22297|   542k|    while (s->token.val == TOK_TEMPLATE) {
22298|   542k|        const uint8_t *p = s->token.ptr + 1;
22299|   542k|        cooked = s->token;
22300|   542k|        if (call) {
22301|   534k|            if (JS_DefinePropertyValueUint32(ctx, raw_array, depth,
22302|   534k|                                             JS_DupValue(ctx, s->token.u.str.str),
22303|   534k|                                             JS_PROP_ENUMERABLE | JS_PROP_THROW) < 0) {
22304|      0|                return -1;
22305|      0|            }
22306|       |            /* re-parse the string with escape sequences but do not throw a
22307|       |               syntax error if it contains invalid sequences
22308|       |             */
22309|   534k|            if (js_parse_string(s, '`', FALSE, p, &cooked, &p)) {
22310|     51|                cooked.u.str.str = JS_UNDEFINED;
22311|     51|            }
22312|   534k|            if (JS_DefinePropertyValueUint32(ctx, template_object, depth,
22313|   534k|                                             cooked.u.str.str,
22314|   534k|                                             JS_PROP_ENUMERABLE | JS_PROP_THROW) < 0) {
22315|      0|                return -1;
22316|      0|            }
22317|   534k|        } else {
22318|  7.40k|            JSString *str;
22319|       |            /* re-parse the string with escape sequences and throw a
22320|       |               syntax error if it contains invalid sequences
22321|       |             */
22322|  7.40k|            JS_FreeValue(ctx, s->token.u.str.str);
22323|  7.40k|            s->token.u.str.str = JS_UNDEFINED;
22324|  7.40k|            if (js_parse_string(s, '`', TRUE, p, &cooked, &p))
22325|      4|                return -1;
22326|  7.39k|            str = JS_VALUE_GET_STRING(cooked.u.str.str);
22327|  7.39k|            if (str->len != 0 || depth == 0) {
22328|  7.23k|                ret = emit_push_const(s, cooked.u.str.str, 1);
22329|  7.23k|                JS_FreeValue(s->ctx, cooked.u.str.str);
22330|  7.23k|                if (ret)
22331|      0|                    return -1;
22332|  7.23k|                if (depth == 0) {
22333|  4.31k|                    if (s->token.u.str.sep == '`')
22334|  1.54k|                        goto done1;
22335|  2.76k|                    emit_op(s, OP_get_field2);
22336|  2.76k|                    emit_atom(s, JS_ATOM_concat);
22337|  2.76k|                }
22338|  5.68k|                depth++;
22339|  5.68k|            } else {
22340|    164|                JS_FreeValue(s->ctx, cooked.u.str.str);
22341|    164|            }
22342|  7.39k|        }
22343|   540k|        if (s->token.u.str.sep == '`')
22344|   536k|            goto done;
22345|  4.65k|        if (next_token(s))
22346|     11|            return -1;
22347|  4.64k|        if (js_parse_expr(s))
22348|  1.49k|            return -1;
22349|  3.15k|        depth++;
22350|  3.15k|        if (s->token.val != '}') {
22351|     12|            return js_parse_error(s, "expected '}' after template expression");
22352|     12|        }
22353|       |        /* XXX: should convert to string at this stage? */
22354|  3.14k|        free_token(s, &s->token);
22355|       |        /* Resume TOK_TEMPLATE parsing (s->token.line_num and
22356|       |         * s->token.ptr are OK) */
22357|  3.14k|        s->got_lf = FALSE;
22358|  3.14k|        if (js_parse_template_part(s, s->buf_ptr))
22359|      6|            return -1;
22360|  3.14k|    }
22361|      0|    return js_parse_expect(s, TOK_TEMPLATE);
22362|       |
22363|   536k| done:
22364|   536k|    if (call) {
22365|       |        /* Seal the objects */
22366|   534k|        seal_template_obj(ctx, raw_array);
22367|   534k|        seal_template_obj(ctx, template_object);
22368|   534k|        *argc = depth + 1;
22369|   534k|    } else {
22370|  1.99k|        emit_op(s, OP_call_method);
22371|  1.99k|        emit_u16(s, depth - 1);
22372|  1.99k|    }
22373|   537k| done1:
22374|   537k|    return next_token(s);
22375|   536k|}
22376|       |
22377|       |
22378|   133k|#define PROP_TYPE_IDENT 0
22379|  65.9k|#define PROP_TYPE_VAR   1
22380|  8.15k|#define PROP_TYPE_GET   2
22381|  3.98k|#define PROP_TYPE_SET   3
22382|  3.93k|#define PROP_TYPE_STAR  4
22383|  3.92k|#define PROP_TYPE_ASYNC 5
22384|  3.92k|#define PROP_TYPE_ASYNC_STAR 6
22385|       |
22386|      0|#define PROP_TYPE_PRIVATE (1 << 4)
22387|       |
22388|       |static BOOL token_is_ident(int tok)
22389|  39.5k|{
22390|       |    /* Accept keywords and reserved words as property names */
22391|  39.5k|    return (tok == TOK_IDENT ||
22392|  39.5k|            (tok >= TOK_FIRST_KEYWORD &&
22393|  5.68k|             tok <= TOK_LAST_KEYWORD));
22394|  39.5k|}
22395|       |
22396|       |/* if the property is an expression, name = JS_ATOM_NULL */
22397|       |static int __exception js_parse_property_name(JSParseState *s,
22398|       |                                              JSAtom *pname,
22399|       |                                              BOOL allow_method, BOOL allow_var,
22400|       |                                              BOOL allow_private)
22401|  26.0k|{
22402|  26.0k|    int is_private = 0;
22403|  26.0k|    BOOL is_non_reserved_ident;
22404|  26.0k|    JSAtom name;
22405|  26.0k|    int prop_type;
22406|       |
22407|  26.0k|    prop_type = PROP_TYPE_IDENT;
22408|  26.0k|    if (allow_method) {
22409|       |        /* if allow_private is true (for class field parsing) and
22410|       |           get/set is following by ';' (or LF with ASI), then it
22411|       |           is a field name */
22412|  10.2k|        if ((token_is_pseudo_keyword(s, JS_ATOM_get) ||
22413|  10.2k|             token_is_pseudo_keyword(s, JS_ATOM_set)) &&
22414|  10.2k|            (!allow_private || peek_token(s, TRUE) != '\n')) {
22415|       |            /* get x(), set x() */
22416|    567|            name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
22417|    567|            if (next_token(s))
22418|     10|                goto fail1;
22419|    557|            if (s->token.val == ':' || s->token.val == ',' ||
22420|    557|                s->token.val == '}' || s->token.val == '(' ||
22421|    557|                s->token.val == '=' ||
22422|    557|                (s->token.val == ';' && allow_private)) {
22423|    445|                is_non_reserved_ident = TRUE;
22424|    445|                goto ident_found;
22425|    445|            }
22426|    112|            prop_type = PROP_TYPE_GET + (name == JS_ATOM_set);
22427|    112|            JS_FreeAtom(s->ctx, name);
22428|  9.70k|        } else if (s->token.val == '*') {
22429|      6|            if (next_token(s))
22430|      1|                goto fail;
22431|      5|            prop_type = PROP_TYPE_STAR;
22432|  9.70k|        } else if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
22433|  9.70k|                   peek_token(s, TRUE) != '\n') {
22434|      0|            name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
22435|      0|            if (next_token(s))
22436|      0|                goto fail1;
22437|      0|            if (s->token.val == ':' || s->token.val == ',' ||
22438|      0|                s->token.val == '}' || s->token.val == '(' ||
22439|      0|                s->token.val == '=') {
22440|      0|                is_non_reserved_ident = TRUE;
22441|      0|                goto ident_found;
22442|      0|            }
22443|      0|            JS_FreeAtom(s->ctx, name);
22444|      0|            if (s->token.val == '*') {
22445|      0|                if (next_token(s))
22446|      0|                    goto fail;
22447|      0|                prop_type = PROP_TYPE_ASYNC_STAR;
22448|      0|            } else {
22449|      0|                prop_type = PROP_TYPE_ASYNC;
22450|      0|            }
22451|      0|        }
22452|  10.2k|    }
22453|       |
22454|  25.6k|    if (token_is_ident(s->token.val)) {
22455|       |        /* variable can only be a non-reserved identifier */
22456|  20.0k|        is_non_reserved_ident =
22457|  20.0k|            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved);
22458|       |        /* keywords and reserved words have a valid atom */
22459|  20.0k|        name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
22460|  20.0k|        if (next_token(s))
22461|     21|            goto fail1;
22462|  20.4k|    ident_found:
22463|  20.4k|        if (is_non_reserved_ident &&
22464|  20.4k|            prop_type == PROP_TYPE_IDENT && allow_var) {
22465|  20.3k|            if (!(s->token.val == ':' ||
22466|  20.3k|                  (s->token.val == '(' && allow_method))) {
22467|  15.1k|                prop_type = PROP_TYPE_VAR;
22468|  15.1k|            }
22469|  20.3k|        }
22470|  20.4k|    } else if (s->token.val == TOK_STRING) {
22471|      4|        name = JS_ValueToAtom(s->ctx, s->token.u.str.str);
22472|      4|        if (name == JS_ATOM_NULL)
22473|      0|            goto fail;
22474|      4|        if (next_token(s))
22475|      1|            goto fail1;
22476|  5.61k|    } else if (s->token.val == TOK_NUMBER) {
22477|  2.13k|        JSValue val;
22478|  2.13k|        val = s->token.u.num.val;
22479|  2.13k|        name = JS_ValueToAtom(s->ctx, val);
22480|  2.13k|        if (name == JS_ATOM_NULL)
22481|      0|            goto fail;
22482|  2.13k|        if (next_token(s))
22483|      7|            goto fail1;
22484|  3.47k|    } else if (s->token.val == '[') {
22485|  3.43k|        if (next_token(s))
22486|      2|            goto fail;
22487|  3.43k|        if (js_parse_expr(s))
22488|    586|            goto fail;
22489|  2.84k|        if (js_parse_expect(s, ']'))
22490|      8|            goto fail;
22491|  2.83k|        name = JS_ATOM_NULL;
22492|  2.83k|    } else if (s->token.val == TOK_PRIVATE_NAME && allow_private) {
22493|      0|        name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
22494|      0|        if (next_token(s))
22495|      0|            goto fail1;
22496|      0|        is_private = PROP_TYPE_PRIVATE;
22497|     40|    } else {
22498|     40|        goto invalid_prop;
22499|     40|    }
22500|  25.4k|    if (prop_type != PROP_TYPE_IDENT && prop_type != PROP_TYPE_VAR &&
22501|  25.4k|        s->token.val != '(') {
22502|      5|        JS_FreeAtom(s->ctx, name);
22503|     45|    invalid_prop:
22504|     45|        js_parse_error(s, "invalid property name");
22505|     45|        goto fail;
22506|      5|    }
22507|  25.4k|    *pname = name;
22508|  25.4k|    return prop_type | is_private;
22509|     39| fail1:
22510|     39|    JS_FreeAtom(s->ctx, name);
22511|    681| fail:
22512|    681|    *pname = JS_ATOM_NULL;
22513|    681|    return -1;
22514|     39|}
22515|       |
22516|       |typedef struct JSParsePos {
22517|       |    BOOL got_lf;
22518|       |    const uint8_t *ptr;
22519|       |} JSParsePos;
22520|       |
22521|       |static int js_parse_get_pos(JSParseState *s, JSParsePos *sp)
22522|   182k|{
22523|   182k|    sp->ptr = s->token.ptr;
22524|   182k|    sp->got_lf = s->got_lf;
22525|   182k|    return 0;
22526|   182k|}
22527|       |
22528|       |static __exception int js_parse_seek_token(JSParseState *s, const JSParsePos *sp)
22529|   182k|{
22530|   182k|    s->buf_ptr = sp->ptr;
22531|   182k|    s->got_lf = sp->got_lf;
22532|   182k|    return next_token(s);
22533|   182k|}
22534|       |
22535|       |/* return TRUE if a regexp literal is allowed after this token */
22536|       |static BOOL is_regexp_allowed(int tok)
22537|  79.2k|{
22538|  79.2k|    switch (tok) {
22539|  10.1k|    case TOK_NUMBER:
22540|  10.4k|    case TOK_STRING:
22541|  13.2k|    case TOK_REGEXP:
22542|  13.4k|    case TOK_DEC:
22543|  13.9k|    case TOK_INC:
22544|  13.9k|    case TOK_NULL:
22545|  13.9k|    case TOK_FALSE:
22546|  13.9k|    case TOK_TRUE:
22547|  13.9k|    case TOK_THIS:
22548|  14.5k|    case ')':
22549|  16.6k|    case ']':
22550|  16.9k|    case '}': /* XXX: regexp may occur after */
22551|  53.3k|    case TOK_IDENT:
22552|  53.3k|        return FALSE;
22553|  25.9k|    default:
22554|  25.9k|        return TRUE;
22555|  79.2k|    }
22556|  79.2k|}
22557|       |
22558|  20.4k|#define SKIP_HAS_SEMI       (1 << 0)
22559|  30.1k|#define SKIP_HAS_ELLIPSIS   (1 << 1)
22560|   992k|#define SKIP_HAS_ASSIGNMENT (1 << 2)
22561|       |
22562|       |static BOOL has_lf_in_range(const uint8_t *p1, const uint8_t *p2)
22563|  6.63k|{
22564|  6.63k|    const uint8_t *tmp;
22565|  6.63k|    if (p1 > p2) {
22566|      0|        tmp = p1;
22567|      0|        p1 = p2;
22568|      0|        p2 = tmp;
22569|      0|    }
22570|  6.63k|    return (memchr(p1, '\n', p2 - p1) != NULL);
22571|  6.63k|}
22572|       |
22573|       |/* XXX: improve speed with early bailout */
22574|       |/* XXX: no longer works if regexps are present. Could use previous
22575|       |   regexp parsing heuristics to handle most cases */
22576|       |static int js_parse_skip_parens_token(JSParseState *s, int *pbits, BOOL no_line_terminator)
22577|   176k|{
22578|   176k|    char state[256];
22579|   176k|    size_t level = 0;
22580|   176k|    JSParsePos pos;
22581|   176k|    int last_tok, tok = TOK_EOF;
22582|   176k|    int c, tok_len, bits = 0;
22583|   176k|    const uint8_t *last_token_ptr;
22584|       |    
22585|       |    /* protect from underflow */
22586|   176k|    state[level++] = 0;
22587|       |
22588|   176k|    js_parse_get_pos(s, &pos);
22589|   176k|    last_tok = 0;
22590|  19.3M|    for (;;) {
22591|  19.3M|        switch(s->token.val) {
22592|  6.86M|        case '(':
22593|  10.3M|        case '[':
22594|  10.7M|        case '{':
22595|  10.7M|            if (level >= sizeof(state))
22596|  14.0k|                goto done;
22597|  10.7M|            state[level++] = s->token.val;
22598|  10.7M|            break;
22599|   170k|        case ')':
22600|   170k|            if (state[--level] != '(')
22601|  2.40k|                goto done;
22602|   167k|            break;
22603|   971k|        case ']':
22604|   971k|            if (state[--level] != '[')
22605|  5.50k|                goto done;
22606|   965k|            break;
22607|   965k|        case '}':
22608|  72.3k|            c = state[--level];
22609|  72.3k|            if (c == '`') {
22610|       |                /* continue the parsing of the template */
22611|  11.8k|                free_token(s, &s->token);
22612|       |                /* Resume TOK_TEMPLATE parsing (s->token.line_num and
22613|       |                 * s->token.ptr are OK) */
22614|  11.8k|                s->got_lf = FALSE;
22615|  11.8k|                if (js_parse_template_part(s, s->buf_ptr))
22616|    254|                    goto done;
22617|  11.6k|                goto handle_template;
22618|  60.5k|            } else if (c != '{') {
22619|    503|                goto done;
22620|    503|            }
22621|  60.0k|            break;
22622|   829k|        case TOK_TEMPLATE:
22623|   841k|        handle_template:
22624|   841k|            if (s->token.u.str.sep != '`') {
22625|       |                /* '${' inside the template : closing '}' and continue
22626|       |                   parsing the template */
22627|  42.9k|                if (level >= sizeof(state))
22628|    100|                    goto done;
22629|  42.8k|                state[level++] = '`';
22630|  42.8k|            }
22631|   840k|            break;
22632|   840k|        case TOK_EOF:
22633|  19.7k|            goto done;
22634|  28.3k|        case ';':
22635|  28.3k|            if (level == 2) {
22636|  6.50k|                bits |= SKIP_HAS_SEMI;
22637|  6.50k|            }
22638|  28.3k|            break;
22639|   136k|        case TOK_ELLIPSIS:
22640|   136k|            if (level == 2) {
22641|  3.04k|                bits |= SKIP_HAS_ELLIPSIS;
22642|  3.04k|            }
22643|   136k|            break;
22644|   988k|        case '=':
22645|   988k|            bits |= SKIP_HAS_ASSIGNMENT;
22646|   988k|            break;
22647|       |
22648|    512|        case TOK_DIV_ASSIGN:
22649|    512|            tok_len = 2;
22650|    512|            goto parse_regexp;
22651|  78.7k|        case '/':
22652|  78.7k|            tok_len = 1;
22653|  79.2k|        parse_regexp:
22654|  79.2k|            if (is_regexp_allowed(last_tok)) {
22655|  25.9k|                s->buf_ptr -= tok_len;
22656|  25.9k|                if (js_parse_regexp(s)) {
22657|       |                    /* XXX: should clear the exception */
22658|  5.42k|                    goto done;
22659|  5.42k|                }
22660|  25.9k|            }
22661|  73.8k|            break;
22662|  19.3M|        }
22663|       |        /* last_tok is only used to recognize regexps */
22664|  19.3M|        if (s->token.val == TOK_IDENT &&
22665|  19.3M|            (token_is_pseudo_keyword(s, JS_ATOM_of) ||
22666|  2.71M|             token_is_pseudo_keyword(s, JS_ATOM_yield))) {
22667|  39.7k|            last_tok = TOK_OF;
22668|  19.2M|        } else {
22669|  19.2M|            last_tok = s->token.val;
22670|  19.2M|        }
22671|  19.3M|        last_token_ptr = s->token.ptr;
22672|  19.3M|        if (next_token(s)) {
22673|       |            /* XXX: should clear the exception generated by next_token() */
22674|  69.2k|            break;
22675|  69.2k|        }
22676|  19.2M|        if (level <= 1) {
22677|  59.2k|            tok = s->token.val;
22678|  59.2k|            if (token_is_pseudo_keyword(s, JS_ATOM_of))
22679|     10|                tok = TOK_OF;
22680|  59.2k|            if (no_line_terminator && has_lf_in_range(last_token_ptr, s->token.ptr))
22681|     17|                tok = '\n';
22682|  59.2k|            break;
22683|  59.2k|        }
22684|  19.2M|    }
22685|   176k| done:
22686|   176k|    if (pbits) {
22687|  87.1k|        *pbits = bits;
22688|  87.1k|    }
22689|   176k|    if (js_parse_seek_token(s, &pos))
22690|      2|        return -1;
22691|   176k|    return tok;
22692|   176k|}
22693|       |
22694|       |static void set_object_name(JSParseState *s, JSAtom name)
22695|   302k|{
22696|   302k|    JSFunctionDef *fd = s->cur_func;
22697|   302k|    int opcode;
22698|       |
22699|   302k|    opcode = get_prev_opcode(fd);
22700|   302k|    if (opcode == OP_set_name) {
22701|       |        /* XXX: should free atom after OP_set_name? */
22702|  58.5k|        fd->byte_code.size = fd->last_opcode_pos;
22703|  58.5k|        fd->last_opcode_pos = -1;
22704|  58.5k|        emit_op(s, OP_set_name);
22705|  58.5k|        emit_atom(s, name);
22706|   244k|    } else if (opcode == OP_set_class_name) {
22707|      0|        int define_class_pos;
22708|      0|        JSAtom atom;
22709|      0|        define_class_pos = fd->last_opcode_pos + 1 -
22710|      0|            get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
22711|      0|        assert(fd->byte_code.buf[define_class_pos] == OP_define_class);
22712|       |        /* for consistency we free the previous atom which is
22713|       |           JS_ATOM_empty_string */
22714|      0|        atom = get_u32(fd->byte_code.buf + define_class_pos + 1);
22715|      0|        JS_FreeAtom(s->ctx, atom);
22716|      0|        put_u32(fd->byte_code.buf + define_class_pos + 1,
22717|      0|                JS_DupAtom(s->ctx, name));
22718|      0|        fd->last_opcode_pos = -1;
22719|      0|    }
22720|   302k|}
22721|       |
22722|       |static void set_object_name_computed(JSParseState *s)
22723|      0|{
22724|      0|    JSFunctionDef *fd = s->cur_func;
22725|      0|    int opcode;
22726|       |
22727|      0|    opcode = get_prev_opcode(fd);
22728|      0|    if (opcode == OP_set_name) {
22729|       |        /* XXX: should free atom after OP_set_name? */
22730|      0|        fd->byte_code.size = fd->last_opcode_pos;
22731|      0|        fd->last_opcode_pos = -1;
22732|      0|        emit_op(s, OP_set_name_computed);
22733|      0|    } else if (opcode == OP_set_class_name) {
22734|      0|        int define_class_pos;
22735|      0|        define_class_pos = fd->last_opcode_pos + 1 -
22736|      0|            get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
22737|      0|        assert(fd->byte_code.buf[define_class_pos] == OP_define_class);
22738|      0|        fd->byte_code.buf[define_class_pos] = OP_define_class_computed;
22739|      0|        fd->last_opcode_pos = -1;
22740|      0|    }
22741|      0|}
22742|       |
22743|       |static __exception int js_parse_object_literal(JSParseState *s)
22744|  9.82k|{
22745|  9.82k|    JSAtom name = JS_ATOM_NULL;
22746|  9.82k|    const uint8_t *start_ptr;
22747|  9.82k|    int prop_type;
22748|  9.82k|    BOOL has_proto;
22749|       |
22750|  9.82k|    if (next_token(s))
22751|     23|        goto fail;
22752|       |    /* XXX: add an initial length that will be patched back */
22753|  9.80k|    emit_op(s, OP_object);
22754|  9.80k|    has_proto = FALSE;
22755|  10.4k|    while (s->token.val != '}') {
22756|       |        /* specific case for getter/setter */
22757|  10.3k|        start_ptr = s->token.ptr;
22758|       |
22759|  10.3k|        if (s->token.val == TOK_ELLIPSIS) {
22760|     31|            if (next_token(s))
22761|      1|                return -1;
22762|     30|            if (js_parse_assign_expr(s))
22763|     12|                return -1;
22764|     18|            emit_op(s, OP_null);  /* dummy excludeList */
22765|     18|            emit_op(s, OP_copy_data_properties);
22766|     18|            emit_u8(s, 2 | (1 << 2) | (0 << 5));
22767|     18|            emit_op(s, OP_drop); /* pop excludeList */
22768|     18|            emit_op(s, OP_drop); /* pop src object */
22769|     18|            goto next;
22770|     30|        }
22771|       |
22772|  10.2k|        prop_type = js_parse_property_name(s, &name, TRUE, TRUE, FALSE);
22773|  10.2k|        if (prop_type < 0)
22774|    131|            goto fail;
22775|       |
22776|  10.1k|        if (prop_type == PROP_TYPE_VAR) {
22777|       |            /* shortcut for x: x */
22778|  4.44k|            emit_op(s, OP_scope_get_var);
22779|  4.44k|            emit_atom(s, name);
22780|  4.44k|            emit_u16(s, s->cur_func->scope_level);
22781|  4.44k|            emit_op(s, OP_define_field);
22782|  4.44k|            emit_atom(s, name);
22783|  5.69k|        } else if (s->token.val == '(') {
22784|  3.98k|            BOOL is_getset = (prop_type == PROP_TYPE_GET ||
22785|  3.98k|                              prop_type == PROP_TYPE_SET);
22786|  3.98k|            JSParseFunctionEnum func_type;
22787|  3.98k|            JSFunctionKindEnum func_kind;
22788|  3.98k|            int op_flags;
22789|       |
22790|  3.98k|            func_kind = JS_FUNC_NORMAL;
22791|  3.98k|            if (is_getset) {
22792|     63|                func_type = JS_PARSE_FUNC_GETTER + prop_type - PROP_TYPE_GET;
22793|  3.92k|            } else {
22794|  3.92k|                func_type = JS_PARSE_FUNC_METHOD;
22795|  3.92k|                if (prop_type == PROP_TYPE_STAR)
22796|      2|                    func_kind = JS_FUNC_GENERATOR;
22797|  3.92k|                else if (prop_type == PROP_TYPE_ASYNC)
22798|      0|                    func_kind = JS_FUNC_ASYNC;
22799|  3.92k|                else if (prop_type == PROP_TYPE_ASYNC_STAR)
22800|      0|                    func_kind = JS_FUNC_ASYNC_GENERATOR;
22801|  3.92k|            }
22802|  3.98k|            if (js_parse_function_decl(s, func_type, func_kind, JS_ATOM_NULL,
22803|  3.98k|                                       start_ptr))
22804|  3.94k|                goto fail;
22805|     47|            if (name == JS_ATOM_NULL) {
22806|      0|                emit_op(s, OP_define_method_computed);
22807|     47|            } else {
22808|     47|                emit_op(s, OP_define_method);
22809|     47|                emit_atom(s, name);
22810|     47|            }
22811|     47|            if (is_getset) {
22812|      3|                op_flags = OP_DEFINE_METHOD_GETTER +
22813|      3|                    prop_type - PROP_TYPE_GET;
22814|     44|            } else {
22815|     44|                op_flags = OP_DEFINE_METHOD_METHOD;
22816|     44|            }
22817|     47|            emit_u8(s, op_flags | OP_DEFINE_METHOD_ENUMERABLE);
22818|  1.71k|        } else {
22819|  1.71k|            if (name == JS_ATOM_NULL) {
22820|       |                /* must be done before evaluating expr */
22821|      1|                emit_op(s, OP_to_propkey);
22822|      1|            }
22823|  1.71k|            if (js_parse_expect(s, ':'))
22824|     61|                goto fail;
22825|  1.65k|            if (js_parse_assign_expr(s))
22826|  1.60k|                goto fail;
22827|     42|            if (name == JS_ATOM_NULL) {
22828|      0|                set_object_name_computed(s);
22829|      0|                emit_op(s, OP_define_array_el);
22830|      0|                emit_op(s, OP_drop);
22831|     42|            } else if (name == JS_ATOM___proto__) {
22832|      0|                if (has_proto) {
22833|      0|                    js_parse_error(s, "duplicate __proto__ property name");
22834|      0|                    goto fail;
22835|      0|                }
22836|      0|                emit_op(s, OP_set_proto);
22837|      0|                has_proto = TRUE;
22838|     42|            } else {
22839|     42|                set_object_name(s, name);
22840|     42|                emit_op(s, OP_define_field);
22841|     42|                emit_atom(s, name);
22842|     42|            }
22843|     42|        }
22844|  4.53k|        JS_FreeAtom(s->ctx, name);
22845|  4.55k|    next:
22846|  4.55k|        name = JS_ATOM_NULL;
22847|  4.55k|        if (s->token.val != ',')
22848|  3.92k|            break;
22849|    633|        if (next_token(s))
22850|      1|            goto fail;
22851|    633|    }
22852|  4.04k|    if (js_parse_expect(s, '}'))
22853|     65|        goto fail;
22854|  3.98k|    return 0;
22855|  5.83k| fail:
22856|  5.83k|    JS_FreeAtom(s->ctx, name);
22857|  5.83k|    return -1;
22858|  4.04k|}
22859|       |
22860|       |/* allow the 'in' binary operator */
22861|   640k|#define PF_IN_ACCEPTED  (1 << 0)
22862|       |/* allow function calls parsing in js_parse_postfix_expr() */
22863|  2.54M|#define PF_POSTFIX_CALL (1 << 1)
22864|       |/* allow the exponentiation operator in js_parse_unary() */
22865|  2.43M|#define PF_POW_ALLOWED  (1 << 2)
22866|       |/* forbid the exponentiation operator in js_parse_unary() */
22867|  1.26M|#define PF_POW_FORBIDDEN (1 << 3)
22868|       |
22869|       |static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags);
22870|       |static void emit_class_field_init(JSParseState *s);
22871|       |static JSFunctionDef *js_new_function_def(JSContext *ctx,
22872|       |                                          JSFunctionDef *parent,
22873|       |                                          BOOL is_eval,
22874|       |                                          BOOL is_func_expr,
22875|       |                                          const char *filename,
22876|       |                                          const uint8_t *source_ptr,
22877|       |                                          GetLineColCache *get_line_col_cache);
22878|       |static void emit_return(JSParseState *s, BOOL hasval);
22879|       |
22880|       |static __exception int js_parse_left_hand_side_expr(JSParseState *s)
22881|  23.9k|{
22882|  23.9k|    return js_parse_postfix_expr(s, PF_POSTFIX_CALL);
22883|  23.9k|}
22884|       |
22885|       |static __exception int js_parse_class_default_ctor(JSParseState *s,
22886|       |                                                   BOOL has_super,
22887|       |                                                   JSFunctionDef **pfd)
22888|      0|{
22889|      0|    JSParseFunctionEnum func_type;
22890|      0|    JSFunctionDef *fd = s->cur_func;
22891|      0|    int idx;
22892|       |
22893|      0|    fd = js_new_function_def(s->ctx, fd, FALSE, FALSE, s->filename,
22894|      0|                             s->token.ptr, &s->get_line_col_cache);
22895|      0|    if (!fd)
22896|      0|        return -1;
22897|       |
22898|      0|    s->cur_func = fd;
22899|      0|    fd->has_home_object = TRUE;
22900|      0|    fd->super_allowed = TRUE;
22901|      0|    fd->has_prototype = FALSE;
22902|      0|    fd->has_this_binding = TRUE;
22903|      0|    fd->new_target_allowed = TRUE;
22904|       |
22905|      0|    push_scope(s);  /* enter body scope */
22906|      0|    fd->body_scope = fd->scope_level;
22907|      0|    if (has_super) {
22908|      0|        fd->is_derived_class_constructor = TRUE;
22909|      0|        fd->super_call_allowed = TRUE;
22910|      0|        fd->arguments_allowed = TRUE;
22911|      0|        fd->has_arguments_binding = TRUE;
22912|      0|        func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
22913|      0|        emit_op(s, OP_init_ctor);
22914|       |        // TODO(bnoordhuis) roll into OP_init_ctor
22915|      0|        emit_op(s, OP_scope_put_var_init);
22916|      0|        emit_atom(s, JS_ATOM_this);
22917|      0|        emit_u16(s, 0);
22918|      0|        emit_class_field_init(s);
22919|      0|    } else {
22920|      0|        func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
22921|       |        /* error if not invoked as a constructor */
22922|      0|        emit_op(s, OP_check_ctor);
22923|      0|        emit_class_field_init(s);
22924|      0|    }
22925|       |
22926|      0|    fd->func_kind = JS_FUNC_NORMAL;
22927|      0|    fd->func_type = func_type;
22928|      0|    emit_return(s, FALSE);
22929|       |
22930|      0|    s->cur_func = fd->parent;
22931|      0|    if (pfd)
22932|      0|        *pfd = fd;
22933|       |
22934|       |    /* the real object will be set at the end of the compilation */
22935|      0|    idx = cpool_add(s, JS_NULL);
22936|      0|    fd->parent_cpool_idx = idx;
22937|       |
22938|      0|    return 0;
22939|      0|}
22940|       |
22941|       |/* find field in the current scope */
22942|       |static int find_private_class_field(JSContext *ctx, JSFunctionDef *fd,
22943|       |                                    JSAtom name, int scope_level)
22944|      0|{
22945|      0|    int idx;
22946|      0|    idx = fd->scopes[scope_level].first;
22947|      0|    while (idx != -1) {
22948|      0|        if (fd->vars[idx].scope_level != scope_level)
22949|      0|            break;
22950|      0|        if (fd->vars[idx].var_name == name)
22951|      0|            return idx;
22952|      0|        idx = fd->vars[idx].scope_next;
22953|      0|    }
22954|      0|    return -1;
22955|      0|}
22956|       |
22957|       |/* initialize the class fields, called by the constructor. Note:
22958|       |   super() can be called in an arrow function, so <this> and
22959|       |   <class_fields_init> can be variable references */
22960|       |static void emit_class_field_init(JSParseState *s)
22961|      0|{
22962|      0|    int label_next;
22963|       |
22964|      0|    emit_op(s, OP_scope_get_var);
22965|      0|    emit_atom(s, JS_ATOM_class_fields_init);
22966|      0|    emit_u16(s, s->cur_func->scope_level);
22967|       |
22968|       |    /* no need to call the class field initializer if not defined */
22969|      0|    emit_op(s, OP_dup);
22970|      0|    label_next = emit_goto(s, OP_if_false, -1);
22971|       |
22972|      0|    emit_op(s, OP_scope_get_var);
22973|      0|    emit_atom(s, JS_ATOM_this);
22974|      0|    emit_u16(s, 0);
22975|       |
22976|      0|    emit_op(s, OP_swap);
22977|       |
22978|      0|    emit_op(s, OP_call_method);
22979|      0|    emit_u16(s, 0);
22980|       |
22981|      0|    emit_label(s, label_next);
22982|      0|    emit_op(s, OP_drop);
22983|      0|}
22984|       |
22985|       |/* build a private setter function name from the private getter name */
22986|       |static JSAtom get_private_setter_name(JSContext *ctx, JSAtom name)
22987|      0|{
22988|      0|    return js_atom_concat_str(ctx, name, "<set>");
22989|      0|}
22990|       |
22991|       |typedef struct {
22992|       |    JSFunctionDef *fields_init_fd;
22993|       |    int computed_fields_count;
22994|       |    BOOL need_brand;
22995|       |    int brand_push_pos;
22996|       |    BOOL is_static;
22997|       |} ClassFieldsDef;
22998|       |
22999|       |static __exception int emit_class_init_start(JSParseState *s,
23000|       |                                             ClassFieldsDef *cf)
23001|      0|{
23002|      0|    int label_add_brand;
23003|       |
23004|      0|    cf->fields_init_fd = js_parse_function_class_fields_init(s);
23005|      0|    if (!cf->fields_init_fd)
23006|      0|        return -1;
23007|       |
23008|      0|    s->cur_func = cf->fields_init_fd;
23009|       |
23010|      0|    if (!cf->is_static) {
23011|       |        /* add the brand to the newly created instance */
23012|       |        /* XXX: would be better to add the code only if needed, maybe in a
23013|       |           later pass */
23014|      0|        emit_op(s, OP_push_false); /* will be patched later */
23015|      0|        cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;
23016|      0|        label_add_brand = emit_goto(s, OP_if_false, -1);
23017|       |
23018|      0|        emit_op(s, OP_scope_get_var);
23019|      0|        emit_atom(s, JS_ATOM_this);
23020|      0|        emit_u16(s, 0);
23021|       |
23022|      0|        emit_op(s, OP_scope_get_var);
23023|      0|        emit_atom(s, JS_ATOM_home_object);
23024|      0|        emit_u16(s, 0);
23025|       |
23026|      0|        emit_op(s, OP_add_brand);
23027|       |
23028|      0|        emit_label(s, label_add_brand);
23029|      0|    }
23030|      0|    s->cur_func = s->cur_func->parent;
23031|      0|    return 0;
23032|      0|}
23033|       |
23034|       |static void emit_class_init_end(JSParseState *s, ClassFieldsDef *cf)
23035|      0|{
23036|      0|    int cpool_idx;
23037|       |
23038|      0|    s->cur_func = cf->fields_init_fd;
23039|      0|    emit_op(s, OP_return_undef);
23040|      0|    s->cur_func = s->cur_func->parent;
23041|       |
23042|      0|    cpool_idx = cpool_add(s, JS_NULL);
23043|      0|    cf->fields_init_fd->parent_cpool_idx = cpool_idx;
23044|      0|    emit_op(s, OP_fclosure);
23045|      0|    emit_u32(s, cpool_idx);
23046|      0|    emit_op(s, OP_set_home_object);
23047|      0|}
23048|       |
23049|       |
23050|       |static __exception int js_parse_class(JSParseState *s, BOOL is_class_expr,
23051|       |                                      JSParseExportEnum export_flag)
23052|      0|{
23053|      0|    JSContext *ctx = s->ctx;
23054|      0|    JSFunctionDef *fd = s->cur_func;
23055|      0|    JSAtom name = JS_ATOM_NULL, class_name = JS_ATOM_NULL, class_name1;
23056|      0|    JSAtom class_var_name = JS_ATOM_NULL;
23057|      0|    JSFunctionDef *method_fd, *ctor_fd;
23058|      0|    int saved_js_mode, class_name_var_idx, prop_type, ctor_cpool_offset;
23059|      0|    int class_flags = 0, i, define_class_offset;
23060|      0|    BOOL is_static, is_private;
23061|      0|    const uint8_t *class_start_ptr = s->token.ptr;
23062|      0|    const uint8_t *start_ptr;
23063|      0|    ClassFieldsDef class_fields[2];
23064|       |
23065|       |    /* classes are parsed and executed in strict mode */
23066|      0|    saved_js_mode = fd->js_mode;
23067|      0|    fd->js_mode |= JS_MODE_STRICT;
23068|      0|    if (next_token(s))
23069|      0|        goto fail;
23070|      0|    if (s->token.val == TOK_IDENT) {
23071|      0|        if (s->token.u.ident.is_reserved) {
23072|      0|            js_parse_error_reserved_identifier(s);
23073|      0|            goto fail;
23074|      0|        }
23075|      0|        class_name = JS_DupAtom(ctx, s->token.u.ident.atom);
23076|      0|        if (next_token(s))
23077|      0|            goto fail;
23078|      0|    } else if (!is_class_expr && export_flag != JS_PARSE_EXPORT_DEFAULT) {
23079|      0|        js_parse_error(s, "class statement requires a name");
23080|      0|        goto fail;
23081|      0|    }
23082|      0|    if (!is_class_expr) {
23083|      0|        if (class_name == JS_ATOM_NULL)
23084|      0|            class_var_name = JS_ATOM__default_; /* export default */
23085|      0|        else
23086|      0|            class_var_name = class_name;
23087|      0|        class_var_name = JS_DupAtom(ctx, class_var_name);
23088|      0|    }
23089|       |
23090|      0|    push_scope(s);
23091|       |
23092|      0|    if (s->token.val == TOK_EXTENDS) {
23093|      0|        class_flags = JS_DEFINE_CLASS_HAS_HERITAGE;
23094|      0|        if (next_token(s))
23095|      0|            goto fail;
23096|      0|        if (js_parse_left_hand_side_expr(s))
23097|      0|            goto fail;
23098|      0|    } else {
23099|      0|        emit_op(s, OP_undefined);
23100|      0|    }
23101|       |
23102|       |    /* add a 'const' definition for the class name */
23103|      0|    if (class_name != JS_ATOM_NULL) {
23104|      0|        class_name_var_idx = define_var(s, fd, class_name, JS_VAR_DEF_CONST);
23105|      0|        if (class_name_var_idx < 0)
23106|      0|            goto fail;
23107|      0|    }
23108|       |
23109|      0|    if (js_parse_expect(s, '{'))
23110|      0|        goto fail;
23111|       |
23112|       |    /* this scope contains the private fields */
23113|      0|    push_scope(s);
23114|       |
23115|      0|    emit_op(s, OP_push_const);
23116|      0|    ctor_cpool_offset = fd->byte_code.size;
23117|      0|    emit_u32(s, 0); /* will be patched at the end of the class parsing */
23118|       |
23119|      0|    if (class_name == JS_ATOM_NULL) {
23120|      0|        if (class_var_name != JS_ATOM_NULL)
23121|      0|            class_name1 = JS_ATOM_default;
23122|      0|        else
23123|      0|            class_name1 = JS_ATOM_empty_string;
23124|      0|    } else {
23125|      0|        class_name1 = class_name;
23126|      0|    }
23127|       |
23128|      0|    emit_op(s, OP_define_class);
23129|      0|    emit_atom(s, class_name1);
23130|      0|    emit_u8(s, class_flags);
23131|      0|    define_class_offset = fd->last_opcode_pos;
23132|       |
23133|      0|    for(i = 0; i < 2; i++) {
23134|      0|        ClassFieldsDef *cf = &class_fields[i];
23135|      0|        cf->fields_init_fd = NULL;
23136|      0|        cf->computed_fields_count = 0;
23137|      0|        cf->need_brand = FALSE;
23138|      0|        cf->is_static = i;
23139|      0|    }
23140|       |
23141|      0|    ctor_fd = NULL;
23142|      0|    while (s->token.val != '}') {
23143|      0|        if (s->token.val == ';') {
23144|      0|            if (next_token(s))
23145|      0|                goto fail;
23146|      0|            continue;
23147|      0|        }
23148|      0|        is_static = FALSE;
23149|      0|        if (s->token.val == TOK_STATIC) {
23150|      0|            int next = peek_token(s, TRUE);
23151|      0|            if (!(next == ';' || next == '}' || next == '(' || next == '='))
23152|      0|                is_static = TRUE;
23153|      0|        }
23154|      0|        prop_type = -1;
23155|      0|        if (is_static) {
23156|      0|            if (next_token(s))
23157|      0|                goto fail;
23158|      0|            if (s->token.val == '{') {
23159|      0|                ClassFieldsDef *cf = &class_fields[is_static];
23160|      0|                JSFunctionDef *init;
23161|      0|                if (!cf->fields_init_fd) {
23162|      0|                    if (emit_class_init_start(s, cf))
23163|      0|                        goto fail;
23164|      0|                }
23165|      0|                s->cur_func = cf->fields_init_fd;
23166|       |                /* XXX: could try to avoid creating a new function and
23167|       |                   reuse 'fields_init_fd' with a specific 'var'
23168|       |                   scope */
23169|       |                // stack is now: <empty>
23170|      0|                if (js_parse_function_decl2(s, JS_PARSE_FUNC_CLASS_STATIC_INIT,
23171|      0|                                            JS_FUNC_NORMAL, JS_ATOM_NULL,
23172|      0|                                            s->token.ptr,
23173|      0|                                            JS_PARSE_EXPORT_NONE, &init) < 0) {
23174|      0|                    goto fail;
23175|      0|                }
23176|       |                // stack is now: fclosure
23177|      0|                push_scope(s);
23178|      0|                emit_op(s, OP_scope_get_var);
23179|      0|                emit_atom(s, JS_ATOM_this);
23180|      0|                emit_u16(s, 0);
23181|       |                // stack is now: fclosure this
23182|      0|                emit_op(s, OP_swap);
23183|       |                // stack is now: this fclosure
23184|      0|                emit_op(s, OP_call_method);
23185|      0|                emit_u16(s, 0);
23186|       |                // stack is now: returnvalue
23187|      0|                emit_op(s, OP_drop);
23188|       |                // stack is now: <empty>
23189|      0|                pop_scope(s);
23190|      0|                s->cur_func = s->cur_func->parent;
23191|      0|                continue;
23192|      0|            }
23193|       |            /* allow "static" field name */
23194|      0|            if (s->token.val == ';' || s->token.val == '=') {
23195|      0|                is_static = FALSE;
23196|      0|                name = JS_DupAtom(ctx, JS_ATOM_static);
23197|      0|                prop_type = PROP_TYPE_IDENT;
23198|      0|            }
23199|      0|        }
23200|      0|        if (is_static)
23201|      0|            emit_op(s, OP_swap);
23202|      0|        start_ptr = s->token.ptr;
23203|      0|        if (prop_type < 0) {
23204|      0|            prop_type = js_parse_property_name(s, &name, TRUE, FALSE, TRUE);
23205|      0|            if (prop_type < 0)
23206|      0|                goto fail;
23207|      0|        }
23208|      0|        is_private = prop_type & PROP_TYPE_PRIVATE;
23209|      0|        prop_type &= ~PROP_TYPE_PRIVATE;
23210|       |
23211|      0|        if ((name == JS_ATOM_constructor && !is_static &&
23212|      0|             prop_type != PROP_TYPE_IDENT) ||
23213|      0|            (name == JS_ATOM_prototype && is_static) ||
23214|      0|            name == JS_ATOM_hash_constructor) {
23215|      0|            js_parse_error(s, "invalid method name");
23216|      0|            goto fail;
23217|      0|        }
23218|      0|        if (prop_type == PROP_TYPE_GET || prop_type == PROP_TYPE_SET) {
23219|      0|            BOOL is_set = prop_type - PROP_TYPE_GET;
23220|      0|            JSFunctionDef *method_fd;
23221|       |
23222|      0|            if (is_private) {
23223|      0|                int idx, var_kind, is_static1;
23224|      0|                idx = find_private_class_field(ctx, fd, name, fd->scope_level);
23225|      0|                if (idx >= 0) {
23226|      0|                    var_kind = fd->vars[idx].var_kind;
23227|      0|                    is_static1 = fd->vars[idx].is_static_private;
23228|      0|                    if (var_kind == JS_VAR_PRIVATE_FIELD ||
23229|      0|                        var_kind == JS_VAR_PRIVATE_METHOD ||
23230|      0|                        var_kind == JS_VAR_PRIVATE_GETTER_SETTER ||
23231|      0|                        var_kind == (JS_VAR_PRIVATE_GETTER + is_set) ||
23232|      0|                        (var_kind == (JS_VAR_PRIVATE_GETTER + 1 - is_set) &&
23233|      0|                         is_static != is_static1)) {
23234|      0|                        goto private_field_already_defined;
23235|      0|                    }
23236|      0|                    fd->vars[idx].var_kind = JS_VAR_PRIVATE_GETTER_SETTER;
23237|      0|                } else {
23238|      0|                    if (add_private_class_field(s, fd, name,
23239|      0|                                                JS_VAR_PRIVATE_GETTER + is_set, is_static) < 0)
23240|      0|                        goto fail;
23241|      0|                }
23242|      0|                class_fields[is_static].need_brand = TRUE;
23243|      0|            }
23244|       |
23245|      0|            if (js_parse_function_decl2(s, JS_PARSE_FUNC_GETTER + is_set,
23246|      0|                                        JS_FUNC_NORMAL, JS_ATOM_NULL,
23247|      0|                                        start_ptr,
23248|      0|                                        JS_PARSE_EXPORT_NONE, &method_fd))
23249|      0|                goto fail;
23250|      0|            if (is_private) {
23251|      0|                method_fd->need_home_object = TRUE; /* needed for brand check */
23252|      0|                emit_op(s, OP_set_home_object);
23253|       |                /* XXX: missing function name */
23254|      0|                emit_op(s, OP_scope_put_var_init);
23255|      0|                if (is_set) {
23256|      0|                    JSAtom setter_name;
23257|      0|                    int ret;
23258|       |
23259|      0|                    setter_name = get_private_setter_name(ctx, name);
23260|      0|                    if (setter_name == JS_ATOM_NULL)
23261|      0|                        goto fail;
23262|      0|                    emit_atom(s, setter_name);
23263|      0|                    ret = add_private_class_field(s, fd, setter_name,
23264|      0|                                                  JS_VAR_PRIVATE_SETTER, is_static);
23265|      0|                    JS_FreeAtom(ctx, setter_name);
23266|      0|                    if (ret < 0)
23267|      0|                        goto fail;
23268|      0|                } else {
23269|      0|                    emit_atom(s, name);
23270|      0|                }
23271|      0|                emit_u16(s, s->cur_func->scope_level);
23272|      0|            } else {
23273|      0|                if (name == JS_ATOM_NULL) {
23274|      0|                    emit_op(s, OP_define_method_computed);
23275|      0|                } else {
23276|      0|                    emit_op(s, OP_define_method);
23277|      0|                    emit_atom(s, name);
23278|      0|                }
23279|      0|                emit_u8(s, OP_DEFINE_METHOD_GETTER + is_set);
23280|      0|            }
23281|      0|        } else if (prop_type == PROP_TYPE_IDENT && s->token.val != '(') {
23282|      0|            ClassFieldsDef *cf = &class_fields[is_static];
23283|      0|            JSAtom field_var_name = JS_ATOM_NULL;
23284|       |
23285|       |            /* class field */
23286|       |
23287|       |            /* XXX: spec: not consistent with method name checks */
23288|      0|            if (name == JS_ATOM_constructor || name == JS_ATOM_prototype) {
23289|      0|                js_parse_error(s, "invalid field name");
23290|      0|                goto fail;
23291|      0|            }
23292|       |
23293|      0|            if (is_private) {
23294|      0|                if (find_private_class_field(ctx, fd, name,
23295|      0|                                             fd->scope_level) >= 0) {
23296|      0|                    goto private_field_already_defined;
23297|      0|                }
23298|      0|                if (add_private_class_field(s, fd, name,
23299|      0|                                            JS_VAR_PRIVATE_FIELD, is_static) < 0)
23300|      0|                    goto fail;
23301|      0|                emit_op(s, OP_private_symbol);
23302|      0|                emit_atom(s, name);
23303|      0|                emit_op(s, OP_scope_put_var_init);
23304|      0|                emit_atom(s, name);
23305|      0|                emit_u16(s, s->cur_func->scope_level);
23306|      0|            }
23307|       |
23308|      0|            if (!cf->fields_init_fd) {
23309|      0|                if (emit_class_init_start(s, cf))
23310|      0|                    goto fail;
23311|      0|            }
23312|      0|            if (name == JS_ATOM_NULL ) {
23313|       |                /* save the computed field name into a variable */
23314|      0|                field_var_name = js_atom_concat_num(ctx, JS_ATOM_computed_field + is_static, cf->computed_fields_count);
23315|      0|                if (field_var_name == JS_ATOM_NULL)
23316|      0|                    goto fail;
23317|      0|                if (define_var(s, fd, field_var_name, JS_VAR_DEF_CONST) < 0) {
23318|      0|                    JS_FreeAtom(ctx, field_var_name);
23319|      0|                    goto fail;
23320|      0|                }
23321|      0|                emit_op(s, OP_to_propkey);
23322|      0|                emit_op(s, OP_scope_put_var_init);
23323|      0|                emit_atom(s, field_var_name);
23324|      0|                emit_u16(s, s->cur_func->scope_level);
23325|      0|            }
23326|      0|            s->cur_func = cf->fields_init_fd;
23327|      0|            emit_op(s, OP_scope_get_var);
23328|      0|            emit_atom(s, JS_ATOM_this);
23329|      0|            emit_u16(s, 0);
23330|       |
23331|      0|            if (name == JS_ATOM_NULL) {
23332|      0|                emit_op(s, OP_scope_get_var);
23333|      0|                emit_atom(s, field_var_name);
23334|      0|                emit_u16(s, s->cur_func->scope_level);
23335|      0|                cf->computed_fields_count++;
23336|      0|                JS_FreeAtom(ctx, field_var_name);
23337|      0|            } else if (is_private) {
23338|      0|                emit_op(s, OP_scope_get_var);
23339|      0|                emit_atom(s, name);
23340|      0|                emit_u16(s, s->cur_func->scope_level);
23341|      0|            }
23342|       |
23343|      0|            if (s->token.val == '=') {
23344|      0|                if (next_token(s))
23345|      0|                    goto fail;
23346|      0|                if (js_parse_assign_expr(s))
23347|      0|                    goto fail;
23348|      0|            } else {
23349|      0|                emit_op(s, OP_undefined);
23350|      0|            }
23351|      0|            if (is_private) {
23352|      0|                set_object_name_computed(s);
23353|      0|                emit_op(s, OP_define_private_field);
23354|      0|            } else if (name == JS_ATOM_NULL) {
23355|      0|                set_object_name_computed(s);
23356|      0|                emit_op(s, OP_define_array_el);
23357|      0|                emit_op(s, OP_drop);
23358|      0|            } else {
23359|      0|                set_object_name(s, name);
23360|      0|                emit_op(s, OP_define_field);
23361|      0|                emit_atom(s, name);
23362|      0|            }
23363|      0|            s->cur_func = s->cur_func->parent;
23364|      0|            if (js_parse_expect_semi(s))
23365|      0|                goto fail;
23366|      0|        } else {
23367|      0|            JSParseFunctionEnum func_type;
23368|      0|            JSFunctionKindEnum func_kind;
23369|       |
23370|      0|            func_type = JS_PARSE_FUNC_METHOD;
23371|      0|            func_kind = JS_FUNC_NORMAL;
23372|      0|            if (prop_type == PROP_TYPE_STAR) {
23373|      0|                func_kind = JS_FUNC_GENERATOR;
23374|      0|            } else if (prop_type == PROP_TYPE_ASYNC) {
23375|      0|                func_kind = JS_FUNC_ASYNC;
23376|      0|            } else if (prop_type == PROP_TYPE_ASYNC_STAR) {
23377|      0|                func_kind = JS_FUNC_ASYNC_GENERATOR;
23378|      0|            } else if (name == JS_ATOM_constructor && !is_static) {
23379|      0|                if (ctor_fd) {
23380|      0|                    js_parse_error(s, "property constructor appears more than once");
23381|      0|                    goto fail;
23382|      0|                }
23383|      0|                if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE)
23384|      0|                    func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
23385|      0|                else
23386|      0|                    func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
23387|      0|            }
23388|      0|            if (is_private) {
23389|      0|                class_fields[is_static].need_brand = TRUE;
23390|      0|            }
23391|      0|            if (js_parse_function_decl2(s, func_type, func_kind, JS_ATOM_NULL, start_ptr, JS_PARSE_EXPORT_NONE, &method_fd))
23392|      0|                goto fail;
23393|      0|            if (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR ||
23394|      0|                func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
23395|      0|                ctor_fd = method_fd;
23396|      0|            } else if (is_private) {
23397|      0|                method_fd->need_home_object = TRUE; /* needed for brand check */
23398|      0|                if (find_private_class_field(ctx, fd, name,
23399|      0|                                             fd->scope_level) >= 0) {
23400|      0|                private_field_already_defined:
23401|      0|                    js_parse_error(s, "private class field is already defined");
23402|      0|                    goto fail;
23403|      0|                }
23404|      0|                if (add_private_class_field(s, fd, name,
23405|      0|                                            JS_VAR_PRIVATE_METHOD, is_static) < 0)
23406|      0|                    goto fail;
23407|      0|                emit_op(s, OP_set_home_object);
23408|      0|                emit_op(s, OP_set_name);
23409|      0|                emit_atom(s, name);
23410|      0|                emit_op(s, OP_scope_put_var_init);
23411|      0|                emit_atom(s, name);
23412|      0|                emit_u16(s, s->cur_func->scope_level);
23413|      0|            } else {
23414|      0|                if (name == JS_ATOM_NULL) {
23415|      0|                    emit_op(s, OP_define_method_computed);
23416|      0|                } else {
23417|      0|                    emit_op(s, OP_define_method);
23418|      0|                    emit_atom(s, name);
23419|      0|                }
23420|      0|                emit_u8(s, OP_DEFINE_METHOD_METHOD);
23421|      0|            }
23422|      0|        }
23423|      0|        if (is_static)
23424|      0|            emit_op(s, OP_swap);
23425|      0|        JS_FreeAtom(ctx, name);
23426|      0|        name = JS_ATOM_NULL;
23427|      0|    }
23428|       |
23429|      0|    if (s->token.val != '}') {
23430|      0|        js_parse_error(s, "expecting '%c'", '}');
23431|      0|        goto fail;
23432|      0|    }
23433|       |
23434|      0|    if (!ctor_fd) {
23435|      0|        if (js_parse_class_default_ctor(s, class_flags & JS_DEFINE_CLASS_HAS_HERITAGE, &ctor_fd))
23436|      0|            goto fail;
23437|      0|    }
23438|       |    /* patch the constant pool index for the constructor */
23439|      0|    put_u32(fd->byte_code.buf + ctor_cpool_offset, ctor_fd->parent_cpool_idx);
23440|       |
23441|       |    /* store the class source code in the constructor. */
23442|      0|    if (!fd->strip_source) {
23443|      0|        js_free(ctx, ctor_fd->source);
23444|      0|        ctor_fd->source_len = s->buf_ptr - class_start_ptr;
23445|      0|        ctor_fd->source = js_strndup(ctx, (const char *)class_start_ptr,
23446|      0|                                     ctor_fd->source_len);
23447|      0|        if (!ctor_fd->source)
23448|      0|            goto fail;
23449|      0|    }
23450|       |
23451|       |    /* consume the '}' */
23452|      0|    if (next_token(s))
23453|      0|        goto fail;
23454|       |
23455|      0|    {
23456|      0|        ClassFieldsDef *cf = &class_fields[0];
23457|      0|        int var_idx;
23458|       |
23459|      0|        if (cf->need_brand) {
23460|       |            /* add a private brand to the prototype */
23461|      0|            emit_op(s, OP_dup);
23462|      0|            emit_op(s, OP_null);
23463|      0|            emit_op(s, OP_swap);
23464|      0|            emit_op(s, OP_add_brand);
23465|       |
23466|       |            /* define the brand field in 'this' of the initializer */
23467|      0|            if (!cf->fields_init_fd) {
23468|      0|                if (emit_class_init_start(s, cf))
23469|      0|                    goto fail;
23470|      0|            }
23471|       |            /* patch the start of the function to enable the
23472|       |               OP_add_brand_instance code */
23473|      0|            cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;
23474|      0|        }
23475|       |
23476|       |        /* store the function to initialize the fields to that it can be
23477|       |           referenced by the constructor */
23478|      0|        var_idx = define_var(s, fd, JS_ATOM_class_fields_init,
23479|      0|                             JS_VAR_DEF_CONST);
23480|      0|        if (var_idx < 0)
23481|      0|            goto fail;
23482|      0|        if (cf->fields_init_fd) {
23483|      0|            emit_class_init_end(s, cf);
23484|      0|        } else {
23485|      0|            emit_op(s, OP_undefined);
23486|      0|        }
23487|      0|        emit_op(s, OP_scope_put_var_init);
23488|      0|        emit_atom(s, JS_ATOM_class_fields_init);
23489|      0|        emit_u16(s, s->cur_func->scope_level);
23490|      0|    }
23491|       |
23492|       |    /* drop the prototype */
23493|      0|    emit_op(s, OP_drop);
23494|       |
23495|      0|    if (class_fields[1].need_brand) {
23496|       |        /* add a private brand to the class */
23497|      0|        emit_op(s, OP_dup);
23498|      0|        emit_op(s, OP_dup);
23499|      0|        emit_op(s, OP_add_brand);
23500|      0|    }
23501|       |
23502|      0|    if (class_name != JS_ATOM_NULL) {
23503|       |        /* store the class name in the scoped class name variable (it
23504|       |           is independent from the class statement variable
23505|       |           definition) */
23506|      0|        emit_op(s, OP_dup);
23507|      0|        emit_op(s, OP_scope_put_var_init);
23508|      0|        emit_atom(s, class_name);
23509|      0|        emit_u16(s, fd->scope_level);
23510|      0|    }
23511|       |
23512|       |    /* initialize the static fields */
23513|      0|    if (class_fields[1].fields_init_fd != NULL) {
23514|      0|        ClassFieldsDef *cf = &class_fields[1];
23515|      0|        emit_op(s, OP_dup);
23516|      0|        emit_class_init_end(s, cf);
23517|      0|        emit_op(s, OP_call_method);
23518|      0|        emit_u16(s, 0);
23519|      0|        emit_op(s, OP_drop);
23520|      0|    }
23521|       |
23522|      0|    pop_scope(s);
23523|      0|    pop_scope(s);
23524|       |
23525|       |    /* the class statements have a block level scope */
23526|      0|    if (class_var_name != JS_ATOM_NULL) {
23527|      0|        if (define_var(s, fd, class_var_name, JS_VAR_DEF_LET) < 0)
23528|      0|            goto fail;
23529|      0|        emit_op(s, OP_scope_put_var_init);
23530|      0|        emit_atom(s, class_var_name);
23531|      0|        emit_u16(s, fd->scope_level);
23532|      0|    } else {
23533|      0|        if (class_name == JS_ATOM_NULL) {
23534|       |            /* cannot use OP_set_name because the name of the class
23535|       |               must be defined before the static initializers are
23536|       |               executed */
23537|      0|            emit_op(s, OP_set_class_name);
23538|      0|            emit_u32(s, fd->last_opcode_pos + 1 - define_class_offset);
23539|      0|        }
23540|      0|    }
23541|       |
23542|      0|    if (export_flag != JS_PARSE_EXPORT_NONE) {
23543|      0|        if (!add_export_entry(s, fd->module,
23544|      0|                              class_var_name,
23545|      0|                              export_flag == JS_PARSE_EXPORT_NAMED ? class_var_name : JS_ATOM_default,
23546|      0|                              JS_EXPORT_TYPE_LOCAL))
23547|      0|            goto fail;
23548|      0|    }
23549|       |
23550|      0|    JS_FreeAtom(ctx, class_name);
23551|      0|    JS_FreeAtom(ctx, class_var_name);
23552|      0|    fd->js_mode = saved_js_mode;
23553|      0|    return 0;
23554|      0| fail:
23555|      0|    JS_FreeAtom(ctx, name);
23556|      0|    JS_FreeAtom(ctx, class_name);
23557|      0|    JS_FreeAtom(ctx, class_var_name);
23558|      0|    fd->js_mode = saved_js_mode;
23559|      0|    return -1;
23560|      0|}
23561|       |
23562|       |static __exception int js_parse_array_literal(JSParseState *s)
23563|  37.7k|{
23564|  37.7k|    uint32_t idx;
23565|  37.7k|    BOOL need_length;
23566|       |
23567|  37.7k|    if (next_token(s))
23568|     71|        return -1;
23569|       |    /* small regular arrays are created on the stack */
23570|  37.6k|    idx = 0;
23571|  45.1k|    while (s->token.val != ']' && idx < 32) {
23572|  34.7k|        if (s->token.val == ',' || s->token.val == TOK_ELLIPSIS)
23573|  5.39k|            break;
23574|  29.3k|        if (js_parse_assign_expr(s))
23575|  21.7k|            return -1;
23576|  7.61k|        idx++;
23577|       |        /* accept trailing comma */
23578|  7.61k|        if (s->token.val == ',') {
23579|  2.47k|            if (next_token(s))
23580|      1|                return -1;
23581|  2.47k|        } else
23582|  5.13k|        if (s->token.val != ']')
23583|    133|            goto done;
23584|  7.61k|    }
23585|  15.7k|    emit_op(s, OP_array_from);
23586|  15.7k|    emit_u16(s, idx);
23587|       |
23588|       |    /* larger arrays and holes are handled with explicit indices */
23589|  15.7k|    need_length = FALSE;
23590|   158k|    while (s->token.val != ']' && idx < 0x7fffffff) {
23591|   143k|        if (s->token.val == TOK_ELLIPSIS)
23592|    524|            break;
23593|   142k|        need_length = TRUE;
23594|   142k|        if (s->token.val != ',') {
23595|  74.3k|            if (js_parse_assign_expr(s))
23596|    242|                return -1;
23597|  74.1k|            emit_op(s, OP_define_field);
23598|  74.1k|            emit_u32(s, __JS_AtomFromUInt32(idx));
23599|  74.1k|            need_length = FALSE;
23600|  74.1k|        }
23601|   142k|        idx++;
23602|       |        /* accept trailing comma */
23603|   142k|        if (s->token.val == ',') {
23604|  87.1k|            if (next_token(s))
23605|      3|                return -1;
23606|  87.1k|        }
23607|   142k|    }
23608|  15.5k|    if (s->token.val == ']') {
23609|  14.9k|        if (need_length) {
23610|       |            /* Set the length: Cannot use OP_define_field because
23611|       |               length is not configurable */
23612|  2.13k|            emit_op(s, OP_dup);
23613|  2.13k|            emit_op(s, OP_push_i32);
23614|  2.13k|            emit_u32(s, idx);
23615|  2.13k|            emit_op(s, OP_put_field);
23616|  2.13k|            emit_atom(s, JS_ATOM_length);
23617|  2.13k|        }
23618|  14.9k|        goto done;
23619|  14.9k|    }
23620|       |
23621|       |    /* huge arrays and spread elements require a dynamic index on the stack */
23622|    524|    emit_op(s, OP_push_i32);
23623|    524|    emit_u32(s, idx);
23624|       |
23625|       |    /* stack has array, index */
23626|  1.36k|    while (s->token.val != ']') {
23627|  1.07k|        if (s->token.val == TOK_ELLIPSIS) {
23628|    527|            if (next_token(s))
23629|      1|                return -1;
23630|    526|            if (js_parse_assign_expr(s))
23631|    132|                return -1;
23632|    394|#if 1
23633|    394|            emit_op(s, OP_append);
23634|       |#else
23635|       |            int label_next, label_done;
23636|       |            label_next = new_label(s);
23637|       |            label_done = new_label(s);
23638|       |            /* enumerate object */
23639|       |            emit_op(s, OP_for_of_start);
23640|       |            emit_op(s, OP_rot5l);
23641|       |            emit_op(s, OP_rot5l);
23642|       |            emit_label(s, label_next);
23643|       |            /* on stack: enum_rec array idx */
23644|       |            emit_op(s, OP_for_of_next);
23645|       |            emit_u8(s, 2);
23646|       |            emit_goto(s, OP_if_true, label_done);
23647|       |            /* append element */
23648|       |            /* enum_rec array idx val -> enum_rec array new_idx */
23649|       |            emit_op(s, OP_define_array_el);
23650|       |            emit_op(s, OP_inc);
23651|       |            emit_goto(s, OP_goto, label_next);
23652|       |            emit_label(s, label_done);
23653|       |            /* close enumeration */
23654|       |            emit_op(s, OP_drop); /* drop undef val */
23655|       |            emit_op(s, OP_nip1); /* drop enum_rec */
23656|       |            emit_op(s, OP_nip1);
23657|       |            emit_op(s, OP_nip1);
23658|       |#endif
23659|    552|        } else {
23660|    552|            need_length = TRUE;
23661|    552|            if (s->token.val != ',') {
23662|    299|                if (js_parse_assign_expr(s))
23663|     29|                    return -1;
23664|       |                /* a idx val */
23665|    270|                emit_op(s, OP_define_array_el);
23666|    270|                need_length = FALSE;
23667|    270|            }
23668|    523|            emit_op(s, OP_inc);
23669|    523|        }
23670|    917|        if (s->token.val != ',')
23671|     71|            break;
23672|    846|        if (next_token(s))
23673|      1|            return -1;
23674|    846|    }
23675|    361|    if (need_length) {
23676|       |        /* Set the length: cannot use OP_define_field because
23677|       |           length is not configurable */
23678|     19|        emit_op(s, OP_dup1);    /* array length - array array length */
23679|     19|        emit_op(s, OP_put_field);
23680|     19|        emit_atom(s, JS_ATOM_length);
23681|    342|    } else {
23682|    342|        emit_op(s, OP_drop);    /* array length - array */
23683|    342|    }
23684|  15.4k|done:
23685|  15.4k|    return js_parse_expect(s, ']');
23686|    361|}
23687|       |
23688|       |/* XXX: remove */
23689|       |static BOOL has_with_scope(JSFunctionDef *s, int scope_level)
23690|  28.5k|{
23691|       |    /* check if scope chain contains a with statement */
23692|   156k|    while (s) {
23693|   127k|        int scope_idx = s->scopes[scope_level].first;
23694|   218k|        while (scope_idx >= 0) {
23695|  90.9k|            JSVarDef *vd = &s->vars[scope_idx];
23696|       |
23697|  90.9k|            if (vd->var_name == JS_ATOM__with_)
23698|      0|                return TRUE;
23699|  90.9k|            scope_idx = vd->scope_next;
23700|  90.9k|        }
23701|       |        /* check parent scopes */
23702|   127k|        scope_level = s->parent_scope_level;
23703|   127k|        s = s->parent;
23704|   127k|    }
23705|  28.5k|    return FALSE;
23706|  28.5k|}
23707|       |
23708|       |static __exception int get_lvalue(JSParseState *s, int *popcode, int *pscope,
23709|       |                                  JSAtom *pname, int *plabel, int *pdepth, BOOL keep,
23710|       |                                  int tok)
23711|   412k|{
23712|   412k|    JSFunctionDef *fd;
23713|   412k|    int opcode, scope, label, depth;
23714|   412k|    JSAtom name;
23715|       |
23716|       |    /* we check the last opcode to get the lvalue type */
23717|   412k|    fd = s->cur_func;
23718|   412k|    scope = 0;
23719|   412k|    name = JS_ATOM_NULL;
23720|   412k|    label = -1;
23721|   412k|    depth = 0;
23722|   412k|    switch(opcode = get_prev_opcode(fd)) {
23723|   398k|    case OP_scope_get_var:
23724|   398k|        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
23725|   398k|        scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
23726|   398k|        if ((name == JS_ATOM_arguments || name == JS_ATOM_eval) &&
23727|   398k|            (fd->js_mode & JS_MODE_STRICT)) {
23728|      0|            return js_parse_error(s, "invalid lvalue in strict mode");
23729|      0|        }
23730|   398k|        if (name == JS_ATOM_this || name == JS_ATOM_new_target)
23731|      0|            goto invalid_lvalue;
23732|   398k|        depth = 2;  /* will generate OP_get_ref_value */
23733|   398k|        break;
23734|  9.41k|    case OP_get_field:
23735|  9.41k|        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
23736|  9.41k|        depth = 1;
23737|  9.41k|        break;
23738|    879|    case OP_scope_get_private_field:
23739|    879|        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
23740|    879|        scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
23741|    879|        depth = 1;
23742|    879|        break;
23743|  4.00k|    case OP_get_array_el:
23744|  4.00k|        depth = 2;
23745|  4.00k|        break;
23746|      0|    case OP_get_super_value:
23747|      0|        depth = 3;
23748|      0|        break;
23749|    120|    default:
23750|    120|    invalid_lvalue:
23751|    120|        if (tok == TOK_FOR) {
23752|      1|            return js_parse_error(s, "invalid for in/of left hand-side");
23753|    119|        } else if (tok == TOK_INC || tok == TOK_DEC) {
23754|     42|            return js_parse_error(s, "invalid increment/decrement operand");
23755|     77|        } else if (tok == '[' || tok == '{') {
23756|     16|            return js_parse_error(s, "invalid destructuring target");
23757|     61|        } else {
23758|     61|            return js_parse_error(s, "invalid assignment left-hand side");
23759|     61|        }
23760|   412k|    }
23761|       |    /* remove the last opcode */
23762|   412k|    fd->byte_code.size = fd->last_opcode_pos;
23763|   412k|    fd->last_opcode_pos = -1;
23764|       |
23765|   412k|    if (keep) {
23766|       |        /* get the value but keep the object/fields on the stack */
23767|  90.0k|        switch(opcode) {
23768|  81.8k|        case OP_scope_get_var:
23769|  81.8k|            label = new_label(s);
23770|  81.8k|            emit_op(s, OP_scope_make_ref);
23771|  81.8k|            emit_atom(s, name);
23772|  81.8k|            emit_u32(s, label);
23773|  81.8k|            emit_u16(s, scope);
23774|  81.8k|            update_label(fd, label, 1);
23775|  81.8k|            emit_op(s, OP_get_ref_value);
23776|  81.8k|            opcode = OP_get_ref_value;
23777|  81.8k|            break;
23778|  7.13k|        case OP_get_field:
23779|  7.13k|            emit_op(s, OP_get_field2);
23780|  7.13k|            emit_atom(s, name);
23781|  7.13k|            break;
23782|    677|        case OP_scope_get_private_field:
23783|    677|            emit_op(s, OP_scope_get_private_field2);
23784|    677|            emit_atom(s, name);
23785|    677|            emit_u16(s, scope);
23786|    677|            break;
23787|    340|        case OP_get_array_el:
23788|       |            /* XXX: replace by a single opcode ? */
23789|    340|            emit_op(s, OP_to_propkey2);
23790|    340|            emit_op(s, OP_dup2);
23791|    340|            emit_op(s, OP_get_array_el);
23792|    340|            break;
23793|      0|        case OP_get_super_value:
23794|      0|            emit_op(s, OP_to_propkey);
23795|      0|            emit_op(s, OP_dup3);
23796|      0|            emit_op(s, OP_get_super_value);
23797|      0|            break;
23798|      0|        default:
23799|      0|            abort();
23800|  90.0k|        }
23801|   322k|    } else {
23802|   322k|        switch(opcode) {
23803|   316k|        case OP_scope_get_var:
23804|   316k|            label = new_label(s);
23805|   316k|            emit_op(s, OP_scope_make_ref);
23806|   316k|            emit_atom(s, name);
23807|   316k|            emit_u32(s, label);
23808|   316k|            emit_u16(s, scope);
23809|   316k|            update_label(fd, label, 1);
23810|   316k|            opcode = OP_get_ref_value;
23811|   316k|            break;
23812|  6.14k|        default:
23813|  6.14k|            break;
23814|   322k|        }
23815|   322k|    }
23816|       |
23817|   412k|    *popcode = opcode;
23818|   412k|    *pscope = scope;
23819|       |    /* name has refcount for OP_get_field and OP_get_ref_value,
23820|       |       and JS_ATOM_NULL for other opcodes */
23821|   412k|    *pname = name;
23822|   412k|    *plabel = label;
23823|   412k|    if (pdepth)
23824|  30.8k|        *pdepth = depth;
23825|   412k|    return 0;
23826|   412k|}
23827|       |
23828|       |typedef enum {
23829|       |    PUT_LVALUE_NOKEEP, /* [depth] v -> */
23830|       |    PUT_LVALUE_NOKEEP_DEPTH, /* [depth] v -> , keep depth (currently
23831|       |                                just disable optimizations) */
23832|       |    PUT_LVALUE_KEEP_TOP,  /* [depth] v -> v */
23833|       |    PUT_LVALUE_KEEP_SECOND, /* [depth] v0 v -> v0 */
23834|       |    PUT_LVALUE_NOKEEP_BOTTOM, /* v [depth] -> */
23835|       |} PutLValueEnum;
23836|       |
23837|       |/* name has a live reference. 'is_let' is only used with opcode =
23838|       |   OP_scope_get_var which is never generated by get_lvalue(). */
23839|       |static void put_lvalue(JSParseState *s, int opcode, int scope,
23840|       |                       JSAtom name, int label, PutLValueEnum special,
23841|       |                       BOOL is_let)
23842|   410k|{
23843|   410k|    switch(opcode) {
23844|  8.76k|    case OP_get_field:
23845|  9.35k|    case OP_scope_get_private_field:
23846|       |        /* depth = 1 */
23847|  9.35k|        switch(special) {
23848|      0|        case PUT_LVALUE_NOKEEP:
23849|    239|        case PUT_LVALUE_NOKEEP_DEPTH:
23850|    239|            break;
23851|  1.82k|        case PUT_LVALUE_KEEP_TOP:
23852|  1.82k|            emit_op(s, OP_insert2); /* obj v -> v obj v */
23853|  1.82k|            break;
23854|  7.17k|        case PUT_LVALUE_KEEP_SECOND:
23855|  7.17k|            emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */
23856|  7.17k|            break;
23857|    124|        case PUT_LVALUE_NOKEEP_BOTTOM:
23858|    124|            emit_op(s, OP_swap);
23859|    124|            break;
23860|      0|        default:
23861|      0|            abort();
23862|  9.35k|        }
23863|  9.35k|        break;
23864|  9.35k|    case OP_get_array_el:
23865|   396k|    case OP_get_ref_value:
23866|       |        /* depth = 2 */
23867|   396k|        if (opcode == OP_get_ref_value) {
23868|   392k|            JS_FreeAtom(s->ctx, name);
23869|   392k|            emit_label(s, label);
23870|   392k|        }
23871|   396k|        switch(special) {
23872|  6.46k|        case PUT_LVALUE_NOKEEP:
23873|  6.46k|            emit_op(s, OP_nop); /* will trigger optimization */
23874|  6.46k|            break;
23875|  29.5k|        case PUT_LVALUE_NOKEEP_DEPTH:
23876|  29.5k|            break;
23877|   280k|        case PUT_LVALUE_KEEP_TOP:
23878|   280k|            emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */
23879|   280k|            break;
23880|  69.5k|        case PUT_LVALUE_KEEP_SECOND:
23881|  69.5k|            emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */
23882|  69.5k|            break;
23883|  10.1k|        case PUT_LVALUE_NOKEEP_BOTTOM:
23884|  10.1k|            emit_op(s, OP_rot3l);
23885|  10.1k|            break;
23886|      0|        default:
23887|      0|            abort();
23888|   396k|        }
23889|   396k|        break;
23890|   396k|    case OP_get_super_value:
23891|       |        /* depth = 3 */
23892|      0|        switch(special) {
23893|      0|        case PUT_LVALUE_NOKEEP:
23894|      0|        case PUT_LVALUE_NOKEEP_DEPTH:
23895|      0|            break;
23896|      0|        case PUT_LVALUE_KEEP_TOP:
23897|      0|            emit_op(s, OP_insert4); /* this obj prop v -> v this obj prop v */
23898|      0|            break;
23899|      0|        case PUT_LVALUE_KEEP_SECOND:
23900|      0|            emit_op(s, OP_perm5); /* this obj prop v0 v -> v0 this obj prop v */
23901|      0|            break;
23902|      0|        case PUT_LVALUE_NOKEEP_BOTTOM:
23903|      0|            emit_op(s, OP_rot4l);
23904|      0|            break;
23905|      0|        default:
23906|      0|            abort();
23907|      0|        }
23908|      0|        break;
23909|  4.56k|    default:
23910|  4.56k|        break;
23911|   410k|    }
23912|       |
23913|   410k|    switch(opcode) {
23914|  4.56k|    case OP_scope_get_var:  /* val -- */
23915|  4.56k|        assert(special == PUT_LVALUE_NOKEEP ||
23916|  4.56k|               special == PUT_LVALUE_NOKEEP_DEPTH);
23917|  4.56k|        emit_op(s, is_let ? OP_scope_put_var_init : OP_scope_put_var);
23918|  4.56k|        emit_u32(s, name);  /* has refcount */
23919|  4.56k|        emit_u16(s, scope);
23920|  4.56k|        break;
23921|  8.76k|    case OP_get_field:
23922|  8.76k|        emit_op(s, OP_put_field);
23923|  8.76k|        emit_u32(s, name);  /* name has refcount */
23924|  8.76k|        break;
23925|    592|    case OP_scope_get_private_field:
23926|    592|        emit_op(s, OP_scope_put_private_field);
23927|    592|        emit_u32(s, name);  /* name has refcount */
23928|    592|        emit_u16(s, scope);
23929|    592|        break;
23930|  3.30k|    case OP_get_array_el:
23931|  3.30k|        emit_op(s, OP_put_array_el);
23932|  3.30k|        break;
23933|   392k|    case OP_get_ref_value:
23934|   392k|        emit_op(s, OP_put_ref_value);
23935|   392k|        break;
23936|      0|    case OP_get_super_value:
23937|      0|        emit_op(s, OP_put_super_value);
23938|      0|        break;
23939|      0|    default:
23940|      0|        abort();
23941|   410k|    }
23942|   410k|}
23943|       |
23944|       |static __exception int js_parse_expr_paren(JSParseState *s)
23945|  90.1k|{
23946|  90.1k|    if (js_parse_expect(s, '('))
23947|    310|        return -1;
23948|  89.8k|    if (js_parse_expr(s))
23949|  88.1k|        return -1;
23950|  1.75k|    if (js_parse_expect(s, ')'))
23951|    680|        return -1;
23952|  1.07k|    return 0;
23953|  1.75k|}
23954|       |
23955|       |static int js_unsupported_keyword(JSParseState *s, JSAtom atom)
23956|      2|{
23957|      2|    char buf[ATOM_GET_STR_BUF_SIZE];
23958|      2|    return js_parse_error(s, "unsupported keyword: %s",
23959|      2|                          JS_AtomGetStr(s->ctx, buf, sizeof(buf), atom));
23960|      2|}
23961|       |
23962|       |static __exception int js_define_var(JSParseState *s, JSAtom name, int tok)
23963|  53.2k|{
23964|  53.2k|    JSFunctionDef *fd = s->cur_func;
23965|  53.2k|    JSVarDefEnum var_def_type;
23966|       |
23967|  53.2k|    if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {
23968|      0|        return js_parse_error(s, "yield is a reserved identifier");
23969|      0|    }
23970|  53.2k|    if ((name == JS_ATOM_arguments || name == JS_ATOM_eval)
23971|  53.2k|    &&  (fd->js_mode & JS_MODE_STRICT)) {
23972|      0|        return js_parse_error(s, "invalid variable name in strict mode");
23973|      0|    }
23974|  53.2k|    if (name == JS_ATOM_let
23975|  53.2k|    &&  (tok == TOK_LET || tok == TOK_CONST)) {
23976|      4|        return js_parse_error(s, "invalid lexical variable name");
23977|      4|    }
23978|  53.2k|    switch(tok) {
23979|  23.5k|    case TOK_LET:
23980|  23.5k|        var_def_type = JS_VAR_DEF_LET;
23981|  23.5k|        break;
23982|    326|    case TOK_CONST:
23983|    326|        var_def_type = JS_VAR_DEF_CONST;
23984|    326|        break;
23985|  29.4k|    case TOK_VAR:
23986|  29.4k|        var_def_type = JS_VAR_DEF_VAR;
23987|  29.4k|        break;
23988|      0|    case TOK_CATCH:
23989|      0|        var_def_type = JS_VAR_DEF_CATCH;
23990|      0|        break;
23991|      0|    default:
23992|      0|        abort();
23993|  53.2k|    }
23994|  53.2k|    if (define_var(s, fd, name, var_def_type) < 0)
23995|     45|        return -1;
23996|  53.2k|    return 0;
23997|  53.2k|}
23998|       |
23999|       |static void js_emit_spread_code(JSParseState *s, int depth)
24000|     91|{
24001|     91|    int label_rest_next, label_rest_done;
24002|       |
24003|       |    /* XXX: could check if enum object is an actual array and optimize
24004|       |       slice extraction. enumeration record and target array are in a
24005|       |       different order from OP_append case. */
24006|       |    /* enum_rec xxx -- enum_rec xxx array 0 */
24007|     91|    emit_op(s, OP_array_from);
24008|     91|    emit_u16(s, 0);
24009|     91|    emit_op(s, OP_push_i32);
24010|     91|    emit_u32(s, 0);
24011|     91|    emit_label(s, label_rest_next = new_label(s));
24012|     91|    emit_op(s, OP_for_of_next);
24013|     91|    emit_u8(s, 2 + depth);
24014|     91|    label_rest_done = emit_goto(s, OP_if_true, -1);
24015|       |    /* array idx val -- array idx */
24016|     91|    emit_op(s, OP_define_array_el);
24017|     91|    emit_op(s, OP_inc);
24018|     91|    emit_goto(s, OP_goto, label_rest_next);
24019|     91|    emit_label(s, label_rest_done);
24020|       |    /* enum_rec xxx array idx undef -- enum_rec xxx array */
24021|     91|    emit_op(s, OP_drop);
24022|     91|    emit_op(s, OP_drop);
24023|     91|}
24024|       |
24025|       |static int js_parse_check_duplicate_parameter(JSParseState *s, JSAtom name)
24026|  14.7k|{
24027|       |    /* Check for duplicate parameter names */
24028|  14.7k|    JSFunctionDef *fd = s->cur_func;
24029|  14.7k|    int i;
24030|  29.8k|    for (i = 0; i < fd->arg_count; i++) {
24031|  15.1k|        if (fd->args[i].var_name == name)
24032|     15|            goto duplicate;
24033|  15.1k|    }
24034|  59.1k|    for (i = 0; i < fd->var_count; i++) {
24035|  44.4k|        if (fd->vars[i].var_name == name)
24036|     21|            goto duplicate;
24037|  44.4k|    }
24038|  14.7k|    return 0;
24039|       |
24040|     36|duplicate:
24041|     36|    return js_parse_error(s, "duplicate parameter names not allowed in this context");
24042|  14.7k|}
24043|       |
24044|       |/* tok = TOK_VAR, TOK_LET or TOK_CONST. Return whether a reference
24045|       |   must be taken to the variable for proper 'with' or global variable
24046|       |   evaluation */
24047|       |/* Note: this function is needed only because variable references are
24048|       |   not yet optimized in destructuring */
24049|       |static BOOL need_var_reference(JSParseState *s, int tok)
24050|  27.4k|{
24051|  27.4k|    JSFunctionDef *fd = s->cur_func;
24052|  27.4k|    if (tok != TOK_VAR)
24053|  7.34k|        return FALSE; /* no reference for let/const */
24054|  20.1k|    if (fd->js_mode & JS_MODE_STRICT) {
24055|  7.28k|        if (!fd->is_global_var)
24056|  2.38k|            return FALSE; /* local definitions in strict mode in function or direct eval */
24057|  4.89k|        if (s->is_module)
24058|  4.89k|            return FALSE; /* in a module global variables are like closure variables */
24059|  4.89k|    }
24060|  12.8k|    return TRUE;
24061|  20.1k|}
24062|       |
24063|       |static JSAtom js_parse_destructuring_var(JSParseState *s, int tok, int is_arg)
24064|  4.69k|{
24065|  4.69k|    JSAtom name;
24066|       |
24067|  4.69k|    if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)
24068|  4.69k|    ||  ((s->cur_func->js_mode & JS_MODE_STRICT) &&
24069|  4.64k|         (s->token.u.ident.atom == JS_ATOM_eval || s->token.u.ident.atom == JS_ATOM_arguments))) {
24070|     53|        js_parse_error(s, "invalid destructuring target");
24071|     53|        return JS_ATOM_NULL;
24072|     53|    }
24073|  4.64k|    name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
24074|  4.64k|    if (is_arg && js_parse_check_duplicate_parameter(s, name))
24075|     14|        goto fail;
24076|  4.63k|    if (next_token(s))
24077|      5|        goto fail;
24078|       |
24079|  4.62k|    return name;
24080|     19|fail:
24081|     19|    JS_FreeAtom(s->ctx, name);
24082|     19|    return JS_ATOM_NULL;
24083|  4.63k|}
24084|       |
24085|       |/* Return -1 if error, 0 if no initializer, 1 if an initializer is
24086|       |   present at the top level. */
24087|       |static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
24088|       |                                        int hasval, int has_ellipsis,
24089|       |                                        BOOL allow_initializer, BOOL export_flag)
24090|  27.1k|{
24091|  27.1k|    int label_parse, label_assign, label_done, label_lvalue, depth_lvalue;
24092|  27.1k|    int start_addr, assign_addr;
24093|  27.1k|    JSAtom prop_name, var_name;
24094|  27.1k|    int opcode, scope, tok1, skip_bits;
24095|  27.1k|    BOOL has_initializer;
24096|       |
24097|  27.1k|    if (has_ellipsis < 0) {
24098|       |        /* pre-parse destructuration target for spread detection */
24099|  5.22k|        js_parse_skip_parens_token(s, &skip_bits, FALSE);
24100|  5.22k|        has_ellipsis = skip_bits & SKIP_HAS_ELLIPSIS;
24101|  5.22k|    }
24102|       |
24103|  27.1k|    label_parse = new_label(s);
24104|  27.1k|    label_assign = new_label(s);
24105|       |
24106|  27.1k|    start_addr = s->cur_func->byte_code.size;
24107|  27.1k|    if (hasval) {
24108|       |        /* consume value from the stack */
24109|  13.0k|        emit_op(s, OP_dup);
24110|  13.0k|        emit_op(s, OP_undefined);
24111|  13.0k|        emit_op(s, OP_strict_eq);
24112|  13.0k|        emit_goto(s, OP_if_true, label_parse);
24113|  13.0k|        emit_label(s, label_assign);
24114|  14.0k|    } else {
24115|  14.0k|        emit_goto(s, OP_goto, label_parse);
24116|  14.0k|        emit_label(s, label_assign);
24117|       |        /* leave value on the stack */
24118|  14.0k|        emit_op(s, OP_dup);
24119|  14.0k|    }
24120|  27.1k|    assign_addr = s->cur_func->byte_code.size;
24121|  27.1k|    if (s->token.val == '{') {
24122|  6.22k|        if (next_token(s))
24123|      7|            return -1;
24124|       |        /* throw an exception if the value cannot be converted to an object */
24125|  6.21k|        emit_op(s, OP_to_object);
24126|  6.21k|        if (has_ellipsis) {
24127|       |            /* add excludeList on stack just below src object */
24128|    263|            emit_op(s, OP_object);
24129|    263|            emit_op(s, OP_swap);
24130|    263|        }
24131|  15.8k|        while (s->token.val != '}') {
24132|  15.8k|            int prop_type;
24133|  15.8k|            if (s->token.val == TOK_ELLIPSIS) {
24134|     13|                if (!has_ellipsis) {
24135|      1|                    JS_ThrowInternalError(s->ctx, "unexpected ellipsis token");
24136|      1|                    return -1;
24137|      1|                }
24138|     12|                if (next_token(s))
24139|      1|                    return -1;
24140|     11|                if (tok) {
24141|      8|                    var_name = js_parse_destructuring_var(s, tok, is_arg);
24142|      8|                    if (var_name == JS_ATOM_NULL)
24143|      3|                        return -1;
24144|      5|                    if (need_var_reference(s, tok)) {
24145|       |                        /* Must make a reference for proper `with` semantics */
24146|      3|                        emit_op(s, OP_scope_get_var);
24147|      3|                        emit_atom(s, var_name);
24148|      3|                        emit_u16(s, s->cur_func->scope_level);
24149|      3|                        JS_FreeAtom(s->ctx, var_name);
24150|      3|                        goto lvalue0;
24151|      3|                    } else {
24152|      2|                        opcode = OP_scope_get_var;
24153|      2|                        scope = s->cur_func->scope_level;
24154|      2|                        label_lvalue = -1;
24155|      2|                        depth_lvalue = 0;
24156|      2|                    }
24157|      5|                } else {
24158|      3|                    if (js_parse_left_hand_side_expr(s))
24159|      1|                        return -1;
24160|      5|                lvalue0:
24161|      5|                    if (get_lvalue(s, &opcode, &scope, &var_name,
24162|      5|                                   &label_lvalue, &depth_lvalue, FALSE, '{'))
24163|      1|                        return -1;
24164|      5|                }
24165|      6|                if (s->token.val != '}') {
24166|      5|                    js_parse_error(s, "assignment rest property must be last");
24167|      5|                    goto var_error;
24168|      5|                }
24169|      1|                emit_op(s, OP_object);  /* target */
24170|      1|                emit_op(s, OP_copy_data_properties);
24171|      1|                emit_u8(s, 0 | ((depth_lvalue + 1) << 2) | ((depth_lvalue + 2) << 5));
24172|      1|                goto set_val;
24173|      6|            }
24174|  15.8k|            prop_type = js_parse_property_name(s, &prop_name, FALSE, TRUE, FALSE);
24175|  15.8k|            if (prop_type < 0)
24176|    550|                return -1;
24177|  15.2k|            var_name = JS_ATOM_NULL;
24178|  15.2k|            if (prop_type == PROP_TYPE_IDENT) {
24179|  4.53k|                if (next_token(s))
24180|      1|                    goto prop_error;
24181|  4.52k|                if ((s->token.val == '[' || s->token.val == '{')
24182|  4.52k|                    &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == ',' ||
24183|  2.36k|                         tok1 == '=' || tok1 == '}')) {
24184|  2.35k|                    if (prop_name == JS_ATOM_NULL) {
24185|       |                        /* computed property name on stack */
24186|  1.96k|                        if (has_ellipsis) {
24187|       |                            /* define the property in excludeList */
24188|    550|                            emit_op(s, OP_to_propkey); /* avoid calling ToString twice */
24189|    550|                            emit_op(s, OP_perm3); /* TOS: src excludeList prop */
24190|    550|                            emit_op(s, OP_null); /* TOS: src excludeList prop null */
24191|    550|                            emit_op(s, OP_define_array_el); /* TOS: src excludeList prop */
24192|    550|                            emit_op(s, OP_perm3); /* TOS: excludeList src prop */
24193|    550|                        }
24194|       |                        /* get the computed property from the source object */
24195|  1.96k|                        emit_op(s, OP_get_array_el2);
24196|  1.96k|                    } else {
24197|       |                        /* named property */
24198|    384|                        if (has_ellipsis) {
24199|       |                            /* define the property in excludeList */
24200|    218|                            emit_op(s, OP_swap); /* TOS: src excludeList */
24201|    218|                            emit_op(s, OP_null); /* TOS: src excludeList null */
24202|    218|                            emit_op(s, OP_define_field); /* TOS: src excludeList */
24203|    218|                            emit_atom(s, prop_name);
24204|    218|                            emit_op(s, OP_swap); /* TOS: excludeList src */
24205|    218|                        }
24206|       |                        /* get the named property from the source object */
24207|    384|                        emit_op(s, OP_get_field2);
24208|    384|                        emit_u32(s, prop_name);
24209|    384|                    }
24210|  2.35k|                    if (js_parse_destructuring_element(s, tok, is_arg, TRUE, -1, TRUE, export_flag) < 0)
24211|     30|                        return -1;
24212|  2.32k|                    if (s->token.val == '}')
24213|      1|                        break;
24214|       |                    /* accept a trailing comma before the '}' */
24215|  2.32k|                    if (js_parse_expect(s, ','))
24216|      2|                        return -1;
24217|  2.31k|                    continue;
24218|  2.32k|                }
24219|  2.17k|                if (prop_name == JS_ATOM_NULL) {
24220|    869|                    emit_op(s, OP_to_propkey2);
24221|    869|                    if (has_ellipsis) {
24222|       |                        /* define the property in excludeList */
24223|    260|                        emit_op(s, OP_perm3);
24224|    260|                        emit_op(s, OP_null);
24225|    260|                        emit_op(s, OP_define_array_el);
24226|    260|                        emit_op(s, OP_perm3);
24227|    260|                    }
24228|       |                    /* source prop -- source source prop */
24229|    869|                    emit_op(s, OP_dup1);
24230|  1.30k|                } else {
24231|  1.30k|                    if (has_ellipsis) {
24232|       |                        /* define the property in excludeList */
24233|     32|                        emit_op(s, OP_swap);
24234|     32|                        emit_op(s, OP_null);
24235|     32|                        emit_op(s, OP_define_field);
24236|     32|                        emit_atom(s, prop_name);
24237|     32|                        emit_op(s, OP_swap);
24238|     32|                    }
24239|       |                    /* source -- source source */
24240|  1.30k|                    emit_op(s, OP_dup);
24241|  1.30k|                }
24242|  2.17k|                if (tok) {
24243|  2.16k|                    var_name = js_parse_destructuring_var(s, tok, is_arg);
24244|  2.16k|                    if (var_name == JS_ATOM_NULL)
24245|     36|                        goto prop_error;
24246|  2.13k|                    if (need_var_reference(s, tok)) {
24247|       |                        /* Must make a reference for proper `with` semantics */
24248|  1.26k|                        emit_op(s, OP_scope_get_var);
24249|  1.26k|                        emit_atom(s, var_name);
24250|  1.26k|                        emit_u16(s, s->cur_func->scope_level);
24251|  1.26k|                        JS_FreeAtom(s->ctx, var_name);
24252|  1.26k|                        goto lvalue1;
24253|  1.26k|                    } else {
24254|       |                        /* no need to make a reference for let/const */
24255|    865|                        opcode = OP_scope_get_var;
24256|    865|                        scope = s->cur_func->scope_level;
24257|    865|                        label_lvalue = -1;
24258|    865|                        depth_lvalue = 0;
24259|    865|                    }
24260|  2.13k|                } else {
24261|      9|                    if (js_parse_left_hand_side_expr(s))
24262|      1|                        goto prop_error;
24263|  9.32k|                lvalue1:
24264|  9.32k|                    if (get_lvalue(s, &opcode, &scope, &var_name,
24265|  9.32k|                                   &label_lvalue, &depth_lvalue, FALSE, '{'))
24266|      1|                        goto prop_error;
24267|       |                    /* swap ref and lvalue object if any */
24268|  9.32k|                    if (prop_name == JS_ATOM_NULL) {
24269|    430|                        switch(depth_lvalue) {
24270|      0|                        case 1:
24271|       |                            /* source prop x -> x source prop */
24272|      0|                            emit_op(s, OP_rot3r);
24273|      0|                            break;
24274|    430|                        case 2:
24275|       |                            /* source prop x y -> x y source prop */
24276|    430|                            emit_op(s, OP_swap2);   /* t p2 s p1 */
24277|    430|                            break;
24278|      0|                        case 3:
24279|       |                            /* source prop x y z -> x y z source prop */
24280|      0|                            emit_op(s, OP_rot5l);
24281|      0|                            emit_op(s, OP_rot5l);
24282|      0|                            break;
24283|    430|                        }
24284|  8.89k|                    } else {
24285|  8.89k|                        switch(depth_lvalue) {
24286|      1|                        case 1:
24287|       |                            /* source x -> x source */
24288|      1|                            emit_op(s, OP_swap);
24289|      1|                            break;
24290|  8.88k|                        case 2:
24291|       |                            /* source x y -> x y source */
24292|  8.88k|                            emit_op(s, OP_rot3l);
24293|  8.88k|                            break;
24294|      0|                        case 3:
24295|       |                            /* source x y z -> x y z source */
24296|      0|                            emit_op(s, OP_rot4l);
24297|      0|                            break;
24298|  8.89k|                        }
24299|  8.89k|                    }
24300|  9.32k|                }
24301|  10.1k|                if (prop_name == JS_ATOM_NULL) {
24302|       |                    /* computed property name on stack */
24303|       |                    /* XXX: should have OP_get_array_el2x with depth */
24304|       |                    /* source prop -- val */
24305|    843|                    emit_op(s, OP_get_array_el);
24306|  9.34k|                } else {
24307|       |                    /* named property */
24308|       |                    /* XXX: should have OP_get_field2x with depth */
24309|       |                    /* source -- val */
24310|  9.34k|                    emit_op(s, OP_get_field);
24311|  9.34k|                    emit_u32(s, prop_name);
24312|  9.34k|                }
24313|  10.7k|            } else {
24314|       |                /* prop_type = PROP_TYPE_VAR, cannot be a computed property */
24315|  10.7k|                if (is_arg && js_parse_check_duplicate_parameter(s, prop_name))
24316|     10|                    goto prop_error;
24317|  10.7k|                if ((s->cur_func->js_mode & JS_MODE_STRICT) &&
24318|  10.7k|                    (prop_name == JS_ATOM_eval || prop_name == JS_ATOM_arguments)) {
24319|      0|                    js_parse_error(s, "invalid destructuring target");
24320|      0|                    goto prop_error;
24321|      0|                }
24322|  10.7k|                if (has_ellipsis) {
24323|       |                    /* define the property in excludeList */
24324|     78|                    emit_op(s, OP_swap);
24325|     78|                    emit_op(s, OP_null);
24326|     78|                    emit_op(s, OP_define_field);
24327|     78|                    emit_atom(s, prop_name);
24328|     78|                    emit_op(s, OP_swap);
24329|     78|                }
24330|  10.7k|                if (!tok || need_var_reference(s, tok)) {
24331|       |                    /* generate reference */
24332|       |                    /* source -- source source */
24333|  8.04k|                    emit_op(s, OP_dup);
24334|  8.04k|                    emit_op(s, OP_scope_get_var);
24335|  8.04k|                    emit_atom(s, prop_name);
24336|  8.04k|                    emit_u16(s, s->cur_func->scope_level);
24337|  8.04k|                    goto lvalue1;
24338|  8.04k|                } else {
24339|       |                    /* no need to make a reference for let/const */
24340|  2.68k|                    var_name = JS_DupAtom(s->ctx, prop_name);
24341|  2.68k|                    opcode = OP_scope_get_var;
24342|  2.68k|                    scope = s->cur_func->scope_level;
24343|  2.68k|                    label_lvalue = -1;
24344|  2.68k|                    depth_lvalue = 0;
24345|       |                    
24346|       |                    /* source -- source val */
24347|  2.68k|                    emit_op(s, OP_get_field2);
24348|  2.68k|                    emit_u32(s, prop_name);
24349|  2.68k|                }
24350|  10.7k|            }
24351|  12.8k|        set_val:
24352|  12.8k|            if (tok) {
24353|  9.27k|                if (js_define_var(s, var_name, tok))
24354|      2|                    goto var_error;
24355|  9.27k|                if (export_flag) {
24356|     23|                    if (!add_export_entry(s, s->cur_func->module, var_name, var_name,
24357|     23|                                          JS_EXPORT_TYPE_LOCAL))
24358|      0|                        goto var_error;
24359|     23|                }
24360|  9.27k|                scope = s->cur_func->scope_level; /* XXX: check */
24361|  9.27k|            }
24362|  12.8k|            if (s->token.val == '=') {  /* handle optional default value */
24363|  6.85k|                int label_hasval;
24364|  6.85k|                emit_op(s, OP_dup);
24365|  6.85k|                emit_op(s, OP_undefined);
24366|  6.85k|                emit_op(s, OP_strict_eq);
24367|  6.85k|                label_hasval = emit_goto(s, OP_if_false, -1);
24368|  6.85k|                if (next_token(s))
24369|      8|                    goto var_error;
24370|  6.84k|                emit_op(s, OP_drop);
24371|  6.84k|                if (js_parse_assign_expr(s))
24372|  1.24k|                    goto var_error;
24373|  5.60k|                if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
24374|  5.60k|                    set_object_name(s, var_name);
24375|  5.60k|                emit_label(s, label_hasval);
24376|  5.60k|            }
24377|       |            /* store value into lvalue object */
24378|  11.6k|            put_lvalue(s, opcode, scope, var_name, label_lvalue,
24379|  11.6k|                       PUT_LVALUE_NOKEEP_DEPTH,
24380|  11.6k|                       (tok == TOK_CONST || tok == TOK_LET));
24381|  11.6k|            if (s->token.val == '}')
24382|  4.18k|                break;
24383|       |            /* accept a trailing comma before the '}' */
24384|  7.43k|            if (js_parse_expect(s, ','))
24385|    107|                return -1;
24386|  7.43k|        }
24387|       |        /* drop the source object */
24388|  4.20k|        emit_op(s, OP_drop);
24389|  4.20k|        if (has_ellipsis) {
24390|      1|            emit_op(s, OP_drop); /* pop excludeList */
24391|      1|        }
24392|  4.20k|        if (next_token(s))
24393|      1|            return -1;
24394|  20.9k|    } else if (s->token.val == '[') {
24395|  20.9k|        BOOL has_spread;
24396|  20.9k|        int enum_depth;
24397|  20.9k|        BlockEnv block_env;
24398|       |
24399|  20.9k|        if (next_token(s))
24400|      1|            return -1;
24401|       |        /* the block environment is only needed in generators in case
24402|       |           'yield' triggers a 'return' */
24403|  20.9k|        push_break_entry(s->cur_func, &block_env,
24404|  20.9k|                         JS_ATOM_NULL, -1, -1, 2);
24405|  20.9k|        block_env.has_iterator = TRUE;
24406|  20.9k|        emit_op(s, OP_for_of_start);
24407|  20.9k|        has_spread = FALSE;
24408|   223k|        while (s->token.val != ']') {
24409|       |            /* get the next value */
24410|   218k|            if (s->token.val == TOK_ELLIPSIS) {
24411|     96|                if (next_token(s))
24412|      1|                    return -1;
24413|     95|                if (s->token.val == ',' || s->token.val == ']')
24414|      2|                    return js_parse_error(s, "missing binding pattern...");
24415|     93|                has_spread = TRUE;
24416|     93|            }
24417|   218k|            if (s->token.val == ',') {
24418|       |                /* do nothing, skip the value, has_spread is false */
24419|   194k|                emit_op(s, OP_for_of_next);
24420|   194k|                emit_u8(s, 0);
24421|   194k|                emit_op(s, OP_drop);
24422|   194k|                emit_op(s, OP_drop);
24423|   194k|            } else if ((s->token.val == '[' || s->token.val == '{')
24424|  23.6k|                   &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == ',' ||
24425|  7.46k|                        tok1 == '=' || tok1 == ']')) {
24426|  7.41k|                if (has_spread) {
24427|      4|                    if (tok1 == '=')
24428|      1|                        return js_parse_error(s, "rest element cannot have a default value");
24429|      3|                    js_emit_spread_code(s, 0);
24430|  7.40k|                } else {
24431|  7.40k|                    emit_op(s, OP_for_of_next);
24432|  7.40k|                    emit_u8(s, 0);
24433|  7.40k|                    emit_op(s, OP_drop);
24434|  7.40k|                }
24435|  7.41k|                if (js_parse_destructuring_element(s, tok, is_arg, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE, export_flag) < 0)
24436|    147|                    return -1;
24437|  16.2k|            } else {
24438|  16.2k|                var_name = JS_ATOM_NULL;
24439|  16.2k|                if (tok) {
24440|  2.52k|                    var_name = js_parse_destructuring_var(s, tok, is_arg);
24441|  2.52k|                    if (var_name == JS_ATOM_NULL)
24442|     33|                        goto var_error;
24443|  2.48k|                    if (js_define_var(s, var_name, tok))
24444|      6|                        goto var_error;
24445|  2.48k|                    if (need_var_reference(s, tok)) {
24446|       |                        /* Must make a reference for proper `with` semantics */
24447|    663|                        emit_op(s, OP_scope_get_var);
24448|    663|                        emit_atom(s, var_name);
24449|    663|                        emit_u16(s, s->cur_func->scope_level);
24450|    663|                        JS_FreeAtom(s->ctx, var_name);
24451|    663|                        goto lvalue2;
24452|  1.82k|                    } else {
24453|       |                        /* no need to make a reference for let/const */
24454|  1.82k|                        opcode = OP_scope_get_var;
24455|  1.82k|                        scope = s->cur_func->scope_level;
24456|  1.82k|                        label_lvalue = -1;
24457|  1.82k|                        enum_depth = 0;
24458|  1.82k|                    }
24459|  13.7k|                } else {
24460|  13.7k|                    if (js_parse_left_hand_side_expr(s))
24461|     21|                        return -1;
24462|  14.3k|                lvalue2:
24463|  14.3k|                    if (get_lvalue(s, &opcode, &scope, &var_name,
24464|  14.3k|                                   &label_lvalue, &enum_depth, FALSE, '[')) {
24465|     14|                        return -1;
24466|     14|                    }
24467|  14.3k|                }
24468|  16.1k|                if (has_spread) {
24469|     88|                    js_emit_spread_code(s, enum_depth);
24470|  16.0k|                } else {
24471|  16.0k|                    emit_op(s, OP_for_of_next);
24472|  16.0k|                    emit_u8(s, enum_depth);
24473|  16.0k|                    emit_op(s, OP_drop);
24474|  16.0k|                }
24475|  16.1k|                if (s->token.val == '=' && !has_spread) {
24476|       |                    /* handle optional default value */
24477|  1.55k|                    int label_hasval;
24478|  1.55k|                    emit_op(s, OP_dup);
24479|  1.55k|                    emit_op(s, OP_undefined);
24480|  1.55k|                    emit_op(s, OP_strict_eq);
24481|  1.55k|                    label_hasval = emit_goto(s, OP_if_false, -1);
24482|  1.55k|                    if (next_token(s))
24483|      4|                        goto var_error;
24484|  1.55k|                    emit_op(s, OP_drop);
24485|  1.55k|                    if (js_parse_assign_expr(s))
24486|    256|                        goto var_error;
24487|  1.29k|                    if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
24488|  1.05k|                        set_object_name(s, var_name);
24489|  1.29k|                    emit_label(s, label_hasval);
24490|  1.29k|                }
24491|       |                /* store value into lvalue object */
24492|  15.9k|                put_lvalue(s, opcode, scope, var_name,
24493|  15.9k|                           label_lvalue, PUT_LVALUE_NOKEEP_DEPTH,
24494|  15.9k|                           (tok == TOK_CONST || tok == TOK_LET));
24495|  15.9k|            }
24496|   217k|            if (s->token.val == ']')
24497|  15.1k|                break;
24498|   202k|            if (has_spread)
24499|      1|                return js_parse_error(s, "rest element must be the last one");
24500|       |            /* accept a trailing comma before the ']' */
24501|   202k|            if (js_parse_expect(s, ','))
24502|     48|                return -1;
24503|   202k|        }
24504|       |        /* close iterator object:
24505|       |           if completed, enum_obj has been replaced by undefined */
24506|  20.3k|        emit_op(s, OP_iterator_close);
24507|  20.3k|        pop_break_entry(s->cur_func);
24508|  20.3k|        if (next_token(s))
24509|      1|            return -1;
24510|  20.3k|    } else {
24511|      0|        return js_parse_error(s, "invalid assignment syntax");
24512|      0|    }
24513|  24.6k|    if (s->token.val == '=' && allow_initializer) {
24514|  19.4k|        label_done = emit_goto(s, OP_goto, -1);
24515|  19.4k|        if (next_token(s))
24516|      3|            return -1;
24517|  19.4k|        emit_label(s, label_parse);
24518|  19.4k|        if (hasval)
24519|  5.46k|            emit_op(s, OP_drop);
24520|  19.4k|        if (js_parse_assign_expr(s))
24521|  1.43k|            return -1;
24522|  18.0k|        emit_goto(s, OP_goto, label_assign);
24523|  18.0k|        emit_label(s, label_done);
24524|  18.0k|        has_initializer = TRUE;
24525|  18.0k|    } else {
24526|       |        /* normally hasval is true except if
24527|       |           js_parse_skip_parens_token() was wrong in the parsing */
24528|       |        //        assert(hasval);
24529|  5.16k|        if (!hasval) {
24530|      0|            js_parse_error(s, "too complicated destructuring expression");
24531|      0|            return -1;
24532|      0|        }
24533|       |        /* remove test and decrement label ref count */
24534|  5.16k|        memset(s->cur_func->byte_code.buf + start_addr, OP_nop,
24535|  5.16k|               assign_addr - start_addr);
24536|  5.16k|        s->cur_func->label_slots[label_parse].ref_count--;
24537|  5.16k|        has_initializer = FALSE;
24538|  5.16k|    }
24539|  23.1k|    return has_initializer;
24540|       |
24541|     49| prop_error:
24542|     49|    JS_FreeAtom(s->ctx, prop_name);
24543|  1.60k| var_error:
24544|  1.60k|    JS_FreeAtom(s->ctx, var_name);
24545|  1.60k|    return -1;
24546|     49|}
24547|       |
24548|       |typedef enum FuncCallType {
24549|       |    FUNC_CALL_NORMAL,
24550|       |    FUNC_CALL_NEW,
24551|       |    FUNC_CALL_SUPER_CTOR,
24552|       |    FUNC_CALL_TEMPLATE,
24553|       |} FuncCallType;
24554|       |
24555|       |static void optional_chain_test(JSParseState *s, int *poptional_chaining_label,
24556|       |                                int drop_count)
24557|  1.52k|{
24558|  1.52k|    int label_next, i;
24559|  1.52k|    if (*poptional_chaining_label < 0)
24560|  1.36k|        *poptional_chaining_label = new_label(s);
24561|       |   /* XXX: could be more efficient with a specific opcode */
24562|  1.52k|    emit_op(s, OP_dup);
24563|  1.52k|    emit_op(s, OP_is_undefined_or_null);
24564|  1.52k|    label_next = emit_goto(s, OP_if_false, -1);
24565|  3.09k|    for(i = 0; i < drop_count; i++)
24566|  1.57k|        emit_op(s, OP_drop);
24567|  1.52k|    emit_op(s, OP_undefined);
24568|  1.52k|    emit_goto(s, OP_goto, *poptional_chaining_label);
24569|  1.52k|    emit_label(s, label_next);
24570|  1.52k|}
24571|       |
24572|       |/* allowed parse_flags: PF_POSTFIX_CALL */
24573|       |static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
24574|  1.27M|{
24575|  1.27M|    FuncCallType call_type;
24576|  1.27M|    int optional_chaining_label;
24577|  1.27M|    BOOL accept_lparen = (parse_flags & PF_POSTFIX_CALL) != 0;
24578|  1.27M|    const uint8_t *op_token_ptr;
24579|       |    
24580|  1.27M|    call_type = FUNC_CALL_NORMAL;
24581|  1.27M|    switch(s->token.val) {
24582|   307k|    case TOK_NUMBER:
24583|   307k|        {
24584|   307k|            JSValue val;
24585|   307k|            val = s->token.u.num.val;
24586|       |
24587|   307k|            if (JS_VALUE_GET_TAG(val) == JS_TAG_INT) {
24588|   165k|                emit_op(s, OP_push_i32);
24589|   165k|                emit_u32(s, JS_VALUE_GET_INT(val));
24590|   165k|            } else if (JS_VALUE_GET_TAG(val) == JS_TAG_SHORT_BIG_INT) {
24591|  78.2k|                int64_t v;
24592|  78.2k|                v = JS_VALUE_GET_SHORT_BIG_INT(val);
24593|  78.2k|                if (v >= INT32_MIN && v <= INT32_MAX) {
24594|  65.1k|                    emit_op(s, OP_push_bigint_i32);
24595|  65.1k|                    emit_u32(s, v);
24596|  65.1k|                } else {
24597|  13.0k|                    goto large_number;
24598|  13.0k|                }
24599|  78.2k|            } else {
24600|  76.6k|            large_number:
24601|  76.6k|                if (emit_push_const(s, val, 0) < 0)
24602|      0|                    return -1;
24603|  76.6k|            }
24604|   307k|        }
24605|   307k|        if (next_token(s))
24606|     72|            return -1;
24607|   307k|        break;
24608|   307k|    case TOK_TEMPLATE:
24609|  4.32k|        if (js_parse_template(s, 0, NULL))
24610|    776|            return -1;
24611|  3.54k|        break;
24612|   198k|    case TOK_STRING:
24613|   198k|        if (emit_push_const(s, s->token.u.str.str, 1))
24614|      0|            return -1;
24615|   198k|        if (next_token(s))
24616|     23|            return -1;
24617|   198k|        break;
24618|       |
24619|   198k|    case TOK_DIV_ASSIGN:
24620|     86|        s->buf_ptr -= 2;
24621|     86|        goto parse_regexp;
24622|  39.4k|    case '/':
24623|  39.4k|        s->buf_ptr--;
24624|  39.5k|    parse_regexp:
24625|  39.5k|        {
24626|  39.5k|            JSValue str;
24627|  39.5k|            int ret;
24628|  39.5k|            if (!s->ctx->compile_regexp)
24629|      0|                return js_parse_error(s, "RegExp are not supported");
24630|       |            /* the previous token is '/' or '/=', so no need to free */
24631|  39.5k|            if (js_parse_regexp(s))
24632|    195|                return -1;
24633|  39.3k|            ret = emit_push_const(s, s->token.u.regexp.body, 0);
24634|  39.3k|            str = s->ctx->compile_regexp(s->ctx, s->token.u.regexp.body,
24635|  39.3k|                                         s->token.u.regexp.flags);
24636|  39.3k|            if (JS_IsException(str)) {
24637|       |                /* add the line number info */
24638|  1.14k|                int line_num, col_num;
24639|  1.14k|                line_num = get_line_col(&col_num, s->buf_start, s->token.ptr - s->buf_start);
24640|  1.14k|                build_backtrace(s->ctx, s->ctx->rt->current_exception,
24641|  1.14k|                                s->filename, line_num + 1, col_num + 1, 0);
24642|  1.14k|                return -1;
24643|  1.14k|            }
24644|  38.1k|            ret = emit_push_const(s, str, 0);
24645|  38.1k|            JS_FreeValue(s->ctx, str);
24646|  38.1k|            if (ret)
24647|      0|                return -1;
24648|       |            /* we use a specific opcode to be sure the correct
24649|       |               function is called (otherwise the bytecode would have
24650|       |               to be verified by the RegExp constructor) */
24651|  38.1k|            emit_op(s, OP_regexp);
24652|  38.1k|            if (next_token(s))
24653|     42|                return -1;
24654|  38.1k|        }
24655|  38.1k|        break;
24656|  89.8k|    case '(':
24657|  89.8k|        if (js_parse_expr_paren(s))
24658|  88.9k|            return -1;
24659|    918|        break;
24660|    918|    case TOK_FUNCTION:
24661|      0|        if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR,
24662|      0|                                   JS_FUNC_NORMAL, JS_ATOM_NULL,
24663|      0|                                   s->token.ptr))
24664|      0|            return -1;
24665|      0|        break;
24666|      0|    case TOK_CLASS:
24667|      0|        if (js_parse_class(s, TRUE, JS_PARSE_EXPORT_NONE))
24668|      0|            return -1;
24669|      0|        break;
24670|      0|    case TOK_NULL:
24671|      0|        if (next_token(s))
24672|      0|            return -1;
24673|      0|        emit_op(s, OP_null);
24674|      0|        break;
24675|      0|    case TOK_THIS:
24676|      0|        if (next_token(s))
24677|      0|            return -1;
24678|      0|        emit_op(s, OP_scope_get_var);
24679|      0|        emit_atom(s, JS_ATOM_this);
24680|      0|        emit_u16(s, 0);
24681|      0|        break;
24682|      0|    case TOK_FALSE:
24683|      0|        if (next_token(s))
24684|      0|            return -1;
24685|      0|        emit_op(s, OP_push_false);
24686|      0|        break;
24687|      0|    case TOK_TRUE:
24688|      0|        if (next_token(s))
24689|      0|            return -1;
24690|      0|        emit_op(s, OP_push_true);
24691|      0|        break;
24692|   583k|    case TOK_IDENT:
24693|   583k|        {
24694|   583k|            JSAtom name;
24695|   583k|            if (s->token.u.ident.is_reserved) {
24696|     13|                return js_parse_error_reserved_identifier(s);
24697|     13|            }
24698|   583k|            if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
24699|   583k|                peek_token(s, TRUE) != '\n') {
24700|      0|                const uint8_t *source_ptr;
24701|       |
24702|      0|                source_ptr = s->token.ptr;
24703|      0|                if (next_token(s))
24704|      0|                    return -1;
24705|      0|                if (s->token.val == TOK_FUNCTION) {
24706|      0|                    if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR,
24707|      0|                                               JS_FUNC_ASYNC, JS_ATOM_NULL,
24708|      0|                                               source_ptr))
24709|      0|                        return -1;
24710|      0|                } else {
24711|      0|                    name = JS_DupAtom(s->ctx, JS_ATOM_async);
24712|      0|                    goto do_get_var;
24713|      0|                }
24714|   583k|            } else {
24715|   583k|                if (s->token.u.ident.atom == JS_ATOM_arguments &&
24716|   583k|                    !s->cur_func->arguments_allowed) {
24717|      0|                    js_parse_error(s, "'arguments' identifier is not allowed in class field initializer");
24718|      0|                    return -1;
24719|      0|                }
24720|   583k|                name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
24721|   583k|                if (next_token(s)) {  /* update line number before emitting code */
24722|    401|                    JS_FreeAtom(s->ctx, name);
24723|    401|                    return -1;
24724|    401|                }
24725|   583k|            do_get_var:
24726|   583k|                emit_op(s, OP_scope_get_var);
24727|   583k|                emit_u32(s, name);
24728|   583k|                emit_u16(s, s->cur_func->scope_level);
24729|   583k|            }
24730|   583k|        }
24731|   583k|        break;
24732|   583k|    case '{':
24733|  47.5k|    case '[':
24734|  47.5k|        if (s->token.val == '{') {
24735|  9.82k|            if (js_parse_object_literal(s))
24736|  5.84k|                return -1;
24737|  37.7k|        } else {
24738|  37.7k|            if (js_parse_array_literal(s))
24739|  22.3k|                return -1;
24740|  37.7k|        }
24741|  19.3k|        break;
24742|  19.3k|    case TOK_NEW:
24743|     55|        if (next_token(s))
24744|      1|            return -1;
24745|     54|        if (s->token.val == '.') {
24746|      3|            if (next_token(s))
24747|      1|                return -1;
24748|      2|            if (!token_is_pseudo_keyword(s, JS_ATOM_target))
24749|      2|                return js_parse_error(s, "expecting target");
24750|      0|            if (!s->cur_func->new_target_allowed)
24751|      0|                return js_parse_error(s, "new.target only allowed within functions");
24752|      0|            if (next_token(s))
24753|      0|                return -1;
24754|      0|            emit_op(s, OP_scope_get_var);
24755|      0|            emit_atom(s, JS_ATOM_new_target);
24756|      0|            emit_u16(s, 0);
24757|     51|        } else {
24758|     51|            if (js_parse_postfix_expr(s, 0))
24759|      3|                return -1;
24760|     48|            accept_lparen = TRUE;
24761|     48|            if (s->token.val != '(') {
24762|       |                /* new operator on an object */
24763|     16|                emit_source_pos(s, s->token.ptr);
24764|     16|                emit_op(s, OP_dup);
24765|     16|                emit_op(s, OP_call_constructor);
24766|     16|                emit_u16(s, 0);
24767|     32|            } else {
24768|     32|                call_type = FUNC_CALL_NEW;
24769|     32|            }
24770|     48|        }
24771|     48|        break;
24772|     48|    case TOK_SUPER:
24773|      0|        if (next_token(s))
24774|      0|            return -1;
24775|      0|        if (s->token.val == '(') {
24776|      0|            if (!s->cur_func->super_call_allowed)
24777|      0|                return js_parse_error(s, "super() is only valid in a derived class constructor");
24778|      0|            call_type = FUNC_CALL_SUPER_CTOR;
24779|      0|        } else if (s->token.val == '.' || s->token.val == '[') {
24780|      0|            if (!s->cur_func->super_allowed)
24781|      0|                return js_parse_error(s, "'super' is only valid in a method");
24782|      0|            emit_op(s, OP_scope_get_var);
24783|      0|            emit_atom(s, JS_ATOM_this);
24784|      0|            emit_u16(s, 0);
24785|      0|            emit_op(s, OP_scope_get_var);
24786|      0|            emit_atom(s, JS_ATOM_home_object);
24787|      0|            emit_u16(s, 0);
24788|      0|            emit_op(s, OP_get_super);
24789|      0|        } else {
24790|      0|            return js_parse_error(s, "invalid use of 'super'");
24791|      0|        }
24792|      0|        break;
24793|     28|    case TOK_IMPORT:
24794|     28|        if (next_token(s))
24795|      1|            return -1;
24796|     27|        if (s->token.val == '.') {
24797|      4|            if (next_token(s))
24798|      1|                return -1;
24799|      3|            if (!token_is_pseudo_keyword(s, JS_ATOM_meta))
24800|      3|                return js_parse_error(s, "meta expected");
24801|      0|            if (!s->is_module)
24802|      0|                return js_parse_error(s, "import.meta only valid in module code");
24803|      0|            if (next_token(s))
24804|      0|                return -1;
24805|      0|            emit_op(s, OP_special_object);
24806|      0|            emit_u8(s, OP_SPECIAL_OBJECT_IMPORT_META);
24807|     23|        } else {
24808|     23|            if (js_parse_expect(s, '('))
24809|      2|                return -1;
24810|     21|            if (!accept_lparen)
24811|      0|                return js_parse_error(s, "invalid use of 'import()'");
24812|     21|            if (js_parse_assign_expr(s))
24813|     19|                return -1;
24814|      2|            if (js_parse_expect(s, ')'))
24815|      1|                return -1;
24816|      1|            emit_op(s, OP_import);
24817|      1|        }
24818|      1|        break;
24819|  2.38k|    default:
24820|  2.38k|        return js_parse_error(s, "unexpected token in expression: '%.*s'",
24821|  2.38k|                              (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
24822|  1.27M|    }
24823|       |
24824|  1.15M|    optional_chaining_label = -1;
24825|  1.74M|    for(;;) {
24826|  1.74M|        JSFunctionDef *fd = s->cur_func;
24827|  1.74M|        BOOL has_optional_chain = FALSE;
24828|       |
24829|  1.74M|        if (s->token.val == TOK_QUESTION_MARK_DOT) {
24830|  1.52k|            op_token_ptr = s->token.ptr;
24831|       |            /* optional chaining */
24832|  1.52k|            if (next_token(s))
24833|      3|                return -1;
24834|  1.52k|            has_optional_chain = TRUE;
24835|  1.52k|            if (s->token.val == '(' && accept_lparen) {
24836|    300|                goto parse_func_call;
24837|  1.22k|            } else if (s->token.val == '[') {
24838|    741|                goto parse_array_access;
24839|    741|            } else {
24840|    484|                goto parse_property;
24841|    484|            }
24842|  1.74M|        } else if (s->token.val == TOK_TEMPLATE &&
24843|  1.74M|                   call_type == FUNC_CALL_NORMAL) {
24844|   534k|            if (optional_chaining_label >= 0) {
24845|     23|                return js_parse_error(s, "template literal cannot appear in an optional chain");
24846|     23|            }
24847|   534k|            call_type = FUNC_CALL_TEMPLATE;
24848|   534k|            op_token_ptr = s->token.ptr; /* XXX: check if right position */
24849|   534k|            goto parse_func_call2;
24850|  1.20M|        } else if (s->token.val == '(' && accept_lparen) {
24851|  51.2k|            int opcode, arg_count, drop_count;
24852|       |
24853|       |            /* function call */
24854|  51.5k|        parse_func_call:
24855|  51.5k|            op_token_ptr = s->token.ptr;
24856|  51.5k|            if (next_token(s))
24857|    112|                return -1;
24858|       |
24859|  51.3k|            if (call_type == FUNC_CALL_NORMAL) {
24860|   586k|            parse_func_call2:
24861|   586k|                switch(opcode = get_prev_opcode(fd)) {
24862|  2.15k|                case OP_get_field:
24863|       |                    /* keep the object on the stack */
24864|  2.15k|                    fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
24865|  2.15k|                    drop_count = 2;
24866|  2.15k|                    break;
24867|      1|                case OP_get_field_opt_chain:
24868|      1|                    {
24869|      1|                        int opt_chain_label, next_label;
24870|      1|                        opt_chain_label = get_u32(fd->byte_code.buf +
24871|      1|                                                  fd->last_opcode_pos + 1 + 4 + 1);
24872|       |                        /* keep the object on the stack */
24873|      1|                        fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
24874|      1|                        fd->byte_code.size = fd->last_opcode_pos + 1 + 4;
24875|      1|                        next_label = emit_goto(s, OP_goto, -1);
24876|      1|                        emit_label(s, opt_chain_label);
24877|       |                        /* need an additional undefined value for the
24878|       |                           case where the optional field does not
24879|       |                           exists */
24880|      1|                        emit_op(s, OP_undefined);
24881|      1|                        emit_label(s, next_label);
24882|      1|                        drop_count = 2;
24883|      1|                        opcode = OP_get_field;
24884|      1|                    }
24885|      1|                    break;
24886|     45|                case OP_scope_get_private_field:
24887|       |                    /* keep the object on the stack */
24888|     45|                    fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_private_field2;
24889|     45|                    drop_count = 2;
24890|     45|                    break;
24891|     64|                case OP_get_array_el:
24892|       |                    /* keep the object on the stack */
24893|     64|                    fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
24894|     64|                    drop_count = 2;
24895|     64|                    break;
24896|      0|                case OP_get_array_el_opt_chain:
24897|      0|                    {
24898|      0|                        int opt_chain_label, next_label;
24899|      0|                        opt_chain_label = get_u32(fd->byte_code.buf +
24900|      0|                                                  fd->last_opcode_pos + 1 + 1);
24901|       |                        /* keep the object on the stack */
24902|      0|                        fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
24903|      0|                        fd->byte_code.size = fd->last_opcode_pos + 1;
24904|      0|                        next_label = emit_goto(s, OP_goto, -1);
24905|      0|                        emit_label(s, opt_chain_label);
24906|       |                        /* need an additional undefined value for the
24907|       |                           case where the optional field does not
24908|       |                           exists */
24909|      0|                        emit_op(s, OP_undefined);
24910|      0|                        emit_label(s, next_label);
24911|      0|                        drop_count = 2;
24912|      0|                        opcode = OP_get_array_el;
24913|      0|                    }
24914|      0|                    break;
24915|  28.5k|                case OP_scope_get_var:
24916|  28.5k|                    {
24917|  28.5k|                        JSAtom name;
24918|  28.5k|                        int scope;
24919|  28.5k|                        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
24920|  28.5k|                        scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
24921|  28.5k|                        if (name == JS_ATOM_eval && call_type == FUNC_CALL_NORMAL && !has_optional_chain) {
24922|       |                            /* direct 'eval' */
24923|      0|                            opcode = OP_eval;
24924|  28.5k|                        } else {
24925|       |                            /* verify if function name resolves to a simple
24926|       |                               get_loc/get_arg: a function call inside a `with`
24927|       |                               statement can resolve to a method call of the
24928|       |                               `with` context object
24929|       |                             */
24930|       |                            /* XXX: always generate the OP_scope_get_ref
24931|       |                               and remove it in variable resolution
24932|       |                               pass ? */
24933|  28.5k|                            if (has_with_scope(fd, scope)) {
24934|      0|                                opcode = OP_scope_get_ref;
24935|      0|                                fd->byte_code.buf[fd->last_opcode_pos] = opcode;
24936|      0|                            }
24937|  28.5k|                        }
24938|  28.5k|                        drop_count = 1;
24939|  28.5k|                    }
24940|  28.5k|                    break;
24941|      0|                case OP_get_super_value:
24942|      0|                    fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el;
24943|       |                    /* on stack: this func_obj */
24944|      0|                    opcode = OP_get_array_el;
24945|      0|                    drop_count = 2;
24946|      0|                    break;
24947|   555k|                default:
24948|   555k|                    opcode = OP_invalid;
24949|   555k|                    drop_count = 1;
24950|   555k|                    break;
24951|   586k|                }
24952|   586k|                if (has_optional_chain) {
24953|    300|                    optional_chain_test(s, &optional_chaining_label,
24954|    300|                                        drop_count);
24955|    300|                }
24956|   586k|            } else {
24957|     32|                opcode = OP_invalid;
24958|     32|            }
24959|       |
24960|   586k|            if (call_type == FUNC_CALL_TEMPLATE) {
24961|   534k|                if (js_parse_template(s, 1, &arg_count))
24962|    865|                    return -1;
24963|   534k|                goto emit_func_call;
24964|   534k|            } else if (call_type == FUNC_CALL_SUPER_CTOR) {
24965|      0|                emit_op(s, OP_scope_get_var);
24966|      0|                emit_atom(s, JS_ATOM_this_active_func);
24967|      0|                emit_u16(s, 0);
24968|       |
24969|      0|                emit_op(s, OP_get_super);
24970|       |
24971|      0|                emit_op(s, OP_scope_get_var);
24972|      0|                emit_atom(s, JS_ATOM_new_target);
24973|      0|                emit_u16(s, 0);
24974|  51.3k|            } else if (call_type == FUNC_CALL_NEW) {
24975|     32|                emit_op(s, OP_dup); /* new.target = function */
24976|     32|            }
24977|       |
24978|       |            /* parse arguments */
24979|  51.3k|            arg_count = 0;
24980|  85.3k|            while (s->token.val != ')') {
24981|  47.7k|                if (arg_count >= 65535) {
24982|      0|                    return js_parse_error(s, "Too many call arguments");
24983|      0|                }
24984|  47.7k|                if (s->token.val == TOK_ELLIPSIS)
24985|    327|                    break;
24986|  47.4k|                if (js_parse_assign_expr(s))
24987|  10.3k|                    return -1;
24988|  37.1k|                arg_count++;
24989|  37.1k|                if (s->token.val == ')')
24990|  3.02k|                    break;
24991|       |                /* accept a trailing comma before the ')' */
24992|  34.1k|                if (js_parse_expect(s, ','))
24993|    177|                    return -1;
24994|  34.1k|            }
24995|  40.9k|            if (s->token.val == TOK_ELLIPSIS) {
24996|    327|                emit_op(s, OP_array_from);
24997|    327|                emit_u16(s, arg_count);
24998|    327|                emit_op(s, OP_push_i32);
24999|    327|                emit_u32(s, arg_count);
25000|       |
25001|       |                /* on stack: array idx */
25002|    813|                while (s->token.val != ')') {
25003|    810|                    if (s->token.val == TOK_ELLIPSIS) {
25004|    327|                        if (next_token(s))
25005|      1|                            return -1;
25006|    326|                        if (js_parse_assign_expr(s))
25007|     57|                            return -1;
25008|    269|#if 1
25009|       |                        /* XXX: could pass is_last indicator? */
25010|    269|                        emit_op(s, OP_append);
25011|       |#else
25012|       |                        int label_next, label_done;
25013|       |                        label_next = new_label(s);
25014|       |                        label_done = new_label(s);
25015|       |                        /* push enumerate object below array/idx pair */
25016|       |                        emit_op(s, OP_for_of_start);
25017|       |                        emit_op(s, OP_rot5l);
25018|       |                        emit_op(s, OP_rot5l);
25019|       |                        emit_label(s, label_next);
25020|       |                        /* on stack: enum_rec array idx */
25021|       |                        emit_op(s, OP_for_of_next);
25022|       |                        emit_u8(s, 2);
25023|       |                        emit_goto(s, OP_if_true, label_done);
25024|       |                        /* append element */
25025|       |                        /* enum_rec array idx val -> enum_rec array new_idx */
25026|       |                        emit_op(s, OP_define_array_el);
25027|       |                        emit_op(s, OP_inc);
25028|       |                        emit_goto(s, OP_goto, label_next);
25029|       |                        emit_label(s, label_done);
25030|       |                        /* close enumeration, drop enum_rec and idx */
25031|       |                        emit_op(s, OP_drop); /* drop undef */
25032|       |                        emit_op(s, OP_nip1); /* drop enum_rec */
25033|       |                        emit_op(s, OP_nip1);
25034|       |                        emit_op(s, OP_nip1);
25035|       |#endif
25036|    483|                    } else {
25037|    483|                        if (js_parse_assign_expr(s))
25038|    180|                            return -1;
25039|       |                        /* array idx val */
25040|    303|                        emit_op(s, OP_define_array_el);
25041|    303|                        emit_op(s, OP_inc);
25042|    303|                    }
25043|    572|                    if (s->token.val == ')')
25044|     81|                        break;
25045|       |                    /* accept a trailing comma before the ')' */
25046|    491|                    if (js_parse_expect(s, ','))
25047|      5|                        return -1;
25048|    491|                }
25049|     84|                if (next_token(s))
25050|      1|                    return -1;
25051|       |                /* drop the index */
25052|     83|                emit_op(s, OP_drop);
25053|       |
25054|     83|                emit_source_pos(s, op_token_ptr);
25055|       |                /* apply function call */
25056|     83|                switch(opcode) {
25057|     21|                case OP_get_field:
25058|     21|                case OP_scope_get_private_field:
25059|     21|                case OP_get_array_el:
25060|     21|                case OP_scope_get_ref:
25061|       |                    /* obj func array -> func obj array */
25062|     21|                    emit_op(s, OP_perm3);
25063|     21|                    emit_op(s, OP_apply);
25064|     21|                    emit_u16(s, call_type == FUNC_CALL_NEW);
25065|     21|                    break;
25066|      0|                case OP_eval:
25067|      0|                    emit_op(s, OP_apply_eval);
25068|      0|                    emit_u16(s, fd->scope_level);
25069|      0|                    fd->has_eval_call = TRUE;
25070|      0|                    break;
25071|     62|                default:
25072|     62|                    if (call_type == FUNC_CALL_SUPER_CTOR) {
25073|      0|                        emit_op(s, OP_apply);
25074|      0|                        emit_u16(s, 1);
25075|       |                        /* set the 'this' value */
25076|      0|                        emit_op(s, OP_dup);
25077|      0|                        emit_op(s, OP_scope_put_var_init);
25078|      0|                        emit_atom(s, JS_ATOM_this);
25079|      0|                        emit_u16(s, 0);
25080|       |
25081|      0|                        emit_class_field_init(s);
25082|     62|                    } else if (call_type == FUNC_CALL_NEW) {
25083|       |                        /* obj func array -> func obj array */
25084|      0|                        emit_op(s, OP_perm3);
25085|      0|                        emit_op(s, OP_apply);
25086|      0|                        emit_u16(s, 1);
25087|     62|                    } else {
25088|       |                        /* func array -> func undef array */
25089|     62|                        emit_op(s, OP_undefined);
25090|     62|                        emit_op(s, OP_swap);
25091|     62|                        emit_op(s, OP_apply);
25092|     62|                        emit_u16(s, 0);
25093|     62|                    }
25094|     62|                    break;
25095|     83|                }
25096|  40.5k|            } else {
25097|  40.5k|                if (next_token(s))
25098|      5|                    return -1;
25099|   574k|            emit_func_call:
25100|   574k|                emit_source_pos(s, op_token_ptr);
25101|   574k|                switch(opcode) {
25102|  1.48k|                case OP_get_field:
25103|  1.52k|                case OP_scope_get_private_field:
25104|  1.53k|                case OP_get_array_el:
25105|  1.53k|                case OP_scope_get_ref:
25106|  1.53k|                    emit_op(s, OP_call_method);
25107|  1.53k|                    emit_u16(s, arg_count);
25108|  1.53k|                    break;
25109|      0|                case OP_eval:
25110|      0|                    emit_op(s, OP_eval);
25111|      0|                    emit_u16(s, arg_count);
25112|      0|                    emit_u16(s, fd->scope_level);
25113|      0|                    fd->has_eval_call = TRUE;
25114|      0|                    break;
25115|   573k|                default:
25116|   573k|                    if (call_type == FUNC_CALL_SUPER_CTOR) {
25117|      0|                        emit_op(s, OP_call_constructor);
25118|      0|                        emit_u16(s, arg_count);
25119|       |
25120|       |                        /* set the 'this' value */
25121|      0|                        emit_op(s, OP_dup);
25122|      0|                        emit_op(s, OP_scope_put_var_init);
25123|      0|                        emit_atom(s, JS_ATOM_this);
25124|      0|                        emit_u16(s, 0);
25125|       |
25126|      0|                        emit_class_field_init(s);
25127|   573k|                    } else if (call_type == FUNC_CALL_NEW) {
25128|     20|                        emit_op(s, OP_call_constructor);
25129|     20|                        emit_u16(s, arg_count);
25130|   573k|                    } else {
25131|   573k|                        emit_op(s, OP_call);
25132|   573k|                        emit_u16(s, arg_count);
25133|   573k|                    }
25134|   573k|                    break;
25135|   574k|                }
25136|   574k|            }
25137|   574k|            call_type = FUNC_CALL_NORMAL;
25138|  1.15M|        } else if (s->token.val == '.') {
25139|  14.1k|            op_token_ptr = s->token.ptr;
25140|  14.1k|            if (next_token(s))
25141|     15|                return -1;
25142|  14.5k|        parse_property:
25143|  14.5k|            emit_source_pos(s, op_token_ptr);
25144|  14.5k|            if (s->token.val == TOK_PRIVATE_NAME) {
25145|       |                /* private class field */
25146|    964|                if (get_prev_opcode(fd) == OP_get_super) {
25147|      0|                    return js_parse_error(s, "private class field forbidden after super");
25148|      0|                }
25149|    964|                if (has_optional_chain) {
25150|     10|                    optional_chain_test(s, &optional_chaining_label, 1);
25151|     10|                }
25152|    964|                emit_op(s, OP_scope_get_private_field);
25153|    964|                emit_atom(s, s->token.u.ident.atom);
25154|    964|                emit_u16(s, s->cur_func->scope_level);
25155|  13.6k|            } else {
25156|  13.6k|                if (!token_is_ident(s->token.val)) {
25157|     49|                    return js_parse_error(s, "expecting field name");
25158|     49|                }
25159|  13.5k|                if (get_prev_opcode(fd) == OP_get_super) {
25160|      0|                    JSValue val;
25161|      0|                    int ret;
25162|      0|                    val = JS_AtomToValue(s->ctx, s->token.u.ident.atom);
25163|      0|                    ret = emit_push_const(s, val, 1);
25164|      0|                    JS_FreeValue(s->ctx, val);
25165|      0|                    if (ret)
25166|      0|                        return -1;
25167|      0|                    emit_op(s, OP_get_super_value);
25168|  13.5k|                } else {
25169|  13.5k|                    if (has_optional_chain) {
25170|    473|                        optional_chain_test(s, &optional_chaining_label, 1);
25171|    473|                    }
25172|  13.5k|                    emit_op(s, OP_get_field);
25173|  13.5k|                    emit_atom(s, s->token.u.ident.atom);
25174|  13.5k|                }
25175|  13.5k|            }
25176|  14.5k|            if (next_token(s))
25177|     36|                return -1;
25178|  1.14M|        } else if (s->token.val == '[') {
25179|  6.71k|            int prev_op;
25180|  6.71k|            op_token_ptr = s->token.ptr;
25181|  7.45k|        parse_array_access:
25182|  7.45k|            prev_op = get_prev_opcode(fd);
25183|  7.45k|            if (has_optional_chain) {
25184|    741|                optional_chain_test(s, &optional_chaining_label, 1);
25185|    741|            }
25186|  7.45k|            if (next_token(s))
25187|     16|                return -1;
25188|  7.43k|            if (js_parse_expr(s))
25189|  2.43k|                return -1;
25190|  5.00k|            if (js_parse_expect(s, ']'))
25191|     32|                return -1;
25192|  4.97k|            emit_source_pos(s, op_token_ptr);
25193|  4.97k|            if (prev_op == OP_get_super) {
25194|      0|                emit_op(s, OP_get_super_value);
25195|  4.97k|            } else {
25196|  4.97k|                emit_op(s, OP_get_array_el);
25197|  4.97k|            }
25198|  1.13M|        } else {
25199|  1.13M|            break;
25200|  1.13M|        }
25201|  1.74M|    }
25202|  1.13M|    if (optional_chaining_label >= 0) {
25203|    360|        JSFunctionDef *fd = s->cur_func;
25204|    360|        int opcode;
25205|    360|        emit_label_raw(s, optional_chaining_label);
25206|       |        /* modify the last opcode so that it is an indicator of an
25207|       |           optional chain */
25208|    360|        opcode = get_prev_opcode(fd);
25209|    360|        if (opcode == OP_get_field || opcode == OP_get_array_el) {
25210|    213|            if (opcode == OP_get_field)
25211|    138|                opcode = OP_get_field_opt_chain;
25212|     75|            else
25213|     75|                opcode = OP_get_array_el_opt_chain;
25214|    213|            fd->byte_code.buf[fd->last_opcode_pos] = opcode;
25215|    213|        } else {
25216|    147|            fd->last_opcode_pos = -1;
25217|    147|        }
25218|    360|    }
25219|  1.13M|    return 0;
25220|  1.15M|}
25221|       |
25222|       |static __exception int js_parse_delete(JSParseState *s)
25223|      0|{
25224|      0|    JSFunctionDef *fd = s->cur_func;
25225|      0|    JSAtom name;
25226|      0|    int opcode;
25227|       |
25228|      0|    if (next_token(s))
25229|      0|        return -1;
25230|      0|    if (js_parse_unary(s, PF_POW_FORBIDDEN))
25231|      0|        return -1;
25232|      0|    switch(opcode = get_prev_opcode(fd)) {
25233|      0|    case OP_get_field:
25234|      0|    case OP_get_field_opt_chain:
25235|      0|        {
25236|      0|            JSValue val;
25237|      0|            int ret, opt_chain_label, next_label;
25238|      0|            if (opcode == OP_get_field_opt_chain) {
25239|      0|                opt_chain_label = get_u32(fd->byte_code.buf +
25240|      0|                                          fd->last_opcode_pos + 1 + 4 + 1);
25241|      0|            } else {
25242|      0|                opt_chain_label = -1;
25243|      0|            }
25244|      0|            name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
25245|      0|            fd->byte_code.size = fd->last_opcode_pos;
25246|      0|            val = JS_AtomToValue(s->ctx, name);
25247|      0|            ret = emit_push_const(s, val, 1);
25248|      0|            JS_FreeValue(s->ctx, val);
25249|      0|            JS_FreeAtom(s->ctx, name);
25250|      0|            if (ret)
25251|      0|                return ret;
25252|      0|            emit_op(s, OP_delete);
25253|      0|            if (opt_chain_label >= 0) {
25254|      0|                next_label = emit_goto(s, OP_goto, -1);
25255|      0|                emit_label(s, opt_chain_label);
25256|       |                /* if the optional chain is not taken, return 'true' */
25257|      0|                emit_op(s, OP_drop);
25258|      0|                emit_op(s, OP_push_true);
25259|      0|                emit_label(s, next_label);
25260|      0|            }
25261|      0|            fd->last_opcode_pos = -1;
25262|      0|        }
25263|      0|        break;
25264|      0|    case OP_get_array_el:
25265|      0|        fd->byte_code.size = fd->last_opcode_pos;
25266|      0|        fd->last_opcode_pos = -1;
25267|      0|        emit_op(s, OP_delete);
25268|      0|        break;
25269|      0|    case OP_get_array_el_opt_chain:
25270|      0|        {
25271|      0|            int opt_chain_label, next_label;
25272|      0|            opt_chain_label = get_u32(fd->byte_code.buf +
25273|      0|                                      fd->last_opcode_pos + 1 + 1);
25274|      0|            fd->byte_code.size = fd->last_opcode_pos;
25275|      0|            emit_op(s, OP_delete);
25276|      0|            next_label = emit_goto(s, OP_goto, -1);
25277|      0|            emit_label(s, opt_chain_label);
25278|       |            /* if the optional chain is not taken, return 'true' */
25279|      0|            emit_op(s, OP_drop);
25280|      0|            emit_op(s, OP_push_true);
25281|      0|            emit_label(s, next_label);
25282|      0|            fd->last_opcode_pos = -1;
25283|      0|        }
25284|      0|        break;
25285|      0|    case OP_scope_get_var:
25286|       |        /* 'delete this': this is not a reference */
25287|      0|        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
25288|      0|        if (name == JS_ATOM_this || name == JS_ATOM_new_target)
25289|      0|            goto ret_true;
25290|      0|        if (fd->js_mode & JS_MODE_STRICT) {
25291|      0|            return js_parse_error(s, "cannot delete a direct reference in strict mode");
25292|      0|        } else {
25293|      0|            fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_delete_var;
25294|      0|        }
25295|      0|        break;
25296|      0|    case OP_scope_get_private_field:
25297|      0|        return js_parse_error(s, "cannot delete a private class field");
25298|      0|    case OP_get_super_value:
25299|      0|        fd->byte_code.size = fd->last_opcode_pos;
25300|      0|        fd->last_opcode_pos = -1;
25301|      0|        emit_op(s, OP_throw_error);
25302|      0|        emit_atom(s, JS_ATOM_NULL);
25303|      0|        emit_u8(s, JS_THROW_ERROR_DELETE_SUPER);
25304|      0|        break;
25305|      0|    default:
25306|      0|    ret_true:
25307|      0|        emit_op(s, OP_drop);
25308|      0|        emit_op(s, OP_push_true);
25309|      0|        break;
25310|      0|    }
25311|      0|    return 0;
25312|      0|}
25313|       |
25314|       |/* allowed parse_flags: PF_POW_ALLOWED, PF_POW_FORBIDDEN */
25315|       |static __exception int js_parse_unary(JSParseState *s, int parse_flags)
25316|  1.32M|{
25317|  1.32M|    int op;
25318|       |
25319|  1.32M|    switch(s->token.val) {
25320|  5.29k|    case '+':
25321|  55.1k|    case '-':
25322|  60.2k|    case '!':
25323|  68.2k|    case '~':
25324|  68.2k|    case TOK_VOID:
25325|  68.2k|        op = s->token.val;
25326|  68.2k|        if (next_token(s))
25327|     30|            return -1;
25328|  68.1k|        if (js_parse_unary(s, PF_POW_FORBIDDEN))
25329|  1.12k|            return -1;
25330|  67.0k|        switch(op) {
25331|  49.6k|        case '-':
25332|  49.6k|            emit_op(s, OP_neg);
25333|  49.6k|            break;
25334|  5.05k|        case '+':
25335|  5.05k|            emit_op(s, OP_plus);
25336|  5.05k|            break;
25337|  4.67k|        case '!':
25338|  4.67k|            emit_op(s, OP_lnot);
25339|  4.67k|            break;
25340|  7.72k|        case '~':
25341|  7.72k|            emit_op(s, OP_not);
25342|  7.72k|            break;
25343|      0|        case TOK_VOID:
25344|      0|            emit_op(s, OP_drop);
25345|      0|            emit_op(s, OP_undefined);
25346|      0|            break;
25347|      0|        default:
25348|      0|            abort();
25349|  67.0k|        }
25350|  67.0k|        parse_flags = 0;
25351|  67.0k|        break;
25352|  1.16k|    case TOK_DEC:
25353|  2.94k|    case TOK_INC:
25354|  2.94k|        {
25355|  2.94k|            int opcode, op, scope, label;
25356|  2.94k|            JSAtom name;
25357|  2.94k|            op = s->token.val;
25358|  2.94k|            if (next_token(s))
25359|      6|                return -1;
25360|  2.93k|            if (js_parse_unary(s, 0))
25361|  1.00k|                return -1;
25362|  1.93k|            if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
25363|     25|                return -1;
25364|  1.90k|            emit_op(s, OP_dec + op - TOK_DEC);
25365|  1.90k|            put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP,
25366|  1.90k|                       FALSE);
25367|  1.90k|        }
25368|      0|        break;
25369|      0|    case TOK_TYPEOF:
25370|      0|        {
25371|      0|            JSFunctionDef *fd;
25372|      0|            if (next_token(s))
25373|      0|                return -1;
25374|      0|            if (js_parse_unary(s, PF_POW_FORBIDDEN))
25375|      0|                return -1;
25376|       |            /* reference access should not return an exception, so we
25377|       |               patch the get_var */
25378|      0|            fd = s->cur_func;
25379|      0|            if (get_prev_opcode(fd) == OP_scope_get_var) {
25380|      0|                fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_var_undef;
25381|      0|            }
25382|      0|            emit_op(s, OP_typeof);
25383|      0|            parse_flags = 0;
25384|      0|        }
25385|      0|        break;
25386|      0|    case TOK_DELETE:
25387|      0|        if (js_parse_delete(s))
25388|      0|            return -1;
25389|      0|        parse_flags = 0;
25390|      0|        break;
25391|      0|    case TOK_AWAIT:
25392|      0|        if (!(s->cur_func->func_kind & JS_FUNC_ASYNC))
25393|      0|            return js_parse_error(s, "unexpected 'await' keyword");
25394|      0|        if (!s->cur_func->in_function_body)
25395|      0|            return js_parse_error(s, "await in default expression");
25396|      0|        if (next_token(s))
25397|      0|            return -1;
25398|      0|        if (js_parse_unary(s, PF_POW_FORBIDDEN))
25399|      0|            return -1;
25400|      0|        s->cur_func->has_await = TRUE;
25401|      0|        emit_op(s, OP_await);
25402|      0|        parse_flags = 0;
25403|      0|        break;
25404|  1.24M|    default:
25405|  1.24M|        if (js_parse_postfix_expr(s, PF_POSTFIX_CALL))
25406|   136k|            return -1;
25407|  1.11M|        if (!s->got_lf &&
25408|  1.11M|            (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
25409|  76.7k|            int opcode, op, scope, label;
25410|  76.7k|            JSAtom name;
25411|  76.7k|            op = s->token.val;
25412|  76.7k|            if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
25413|     17|                return -1;
25414|  76.6k|            emit_op(s, OP_post_dec + op - TOK_DEC);
25415|  76.6k|            put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,
25416|  76.6k|                       FALSE);
25417|  76.6k|            if (next_token(s))
25418|      7|                return -1;
25419|  76.6k|        }
25420|  1.11M|        break;
25421|  1.32M|    }
25422|  1.18M|    if (parse_flags & (PF_POW_ALLOWED | PF_POW_FORBIDDEN)) {
25423|  1.11M|        if (s->token.val == TOK_POW) {
25424|       |            /* Strict ES7 exponentiation syntax rules: To solve
25425|       |               conficting semantics between different implementations
25426|       |               regarding the precedence of prefix operators and the
25427|       |               postifx exponential, ES7 specifies that -2**2 is a
25428|       |               syntax error. */
25429|  10.2k|            if (parse_flags & PF_POW_FORBIDDEN) {
25430|      4|                JS_ThrowSyntaxError(s->ctx, "unparenthesized unary expression can't appear on the left-hand side of '**'");
25431|      4|                return -1;
25432|      4|            }
25433|  10.2k|            if (next_token(s))
25434|      2|                return -1;
25435|  10.2k|            if (js_parse_unary(s, PF_POW_ALLOWED))
25436|     38|                return -1;
25437|  10.2k|            emit_op(s, OP_pow);
25438|  10.2k|        }
25439|  1.11M|    }
25440|  1.18M|    return 0;
25441|  1.18M|}
25442|       |
25443|       |/* allowed parse_flags: PF_IN_ACCEPTED */
25444|       |static __exception int js_parse_expr_binary(JSParseState *s, int level,
25445|       |                                            int parse_flags)
25446|  8.69M|{
25447|  8.69M|    int op, opcode;
25448|  8.69M|    const uint8_t *op_token_ptr;
25449|       |    
25450|  8.69M|    if (level == 0) {
25451|  1.23M|        return js_parse_unary(s, PF_POW_ALLOWED);
25452|  7.45M|    } else if (s->token.val == TOK_PRIVATE_NAME &&
25453|  7.45M|               (parse_flags & PF_IN_ACCEPTED) && level == 4 &&
25454|  7.45M|               peek_token(s, FALSE) == TOK_IN) {
25455|     79|        JSAtom atom;
25456|       |
25457|     79|        atom = JS_DupAtom(s->ctx, s->token.u.ident.atom);
25458|     79|        if (next_token(s))
25459|      0|            goto fail_private_in;
25460|     79|        if (s->token.val != TOK_IN)
25461|      1|            goto fail_private_in;
25462|     78|        if (next_token(s))
25463|      1|            goto fail_private_in;
25464|     77|        if (js_parse_expr_binary(s, level - 1, parse_flags)) {
25465|     63|        fail_private_in:
25466|     63|            JS_FreeAtom(s->ctx, atom);
25467|     63|            return -1;
25468|     61|        }
25469|     16|        emit_op(s, OP_scope_in_private_field);
25470|     16|        emit_atom(s, atom);
25471|     16|        emit_u16(s, s->cur_func->scope_level);
25472|     16|        JS_FreeAtom(s->ctx, atom);
25473|     16|        return 0;
25474|  7.45M|    } else {
25475|  7.45M|        if (js_parse_expr_binary(s, level - 1, parse_flags))
25476|  1.08M|            return -1;
25477|  7.45M|    }
25478|  6.74M|    for(;;) {
25479|  6.74M|        op = s->token.val;
25480|  6.74M|        op_token_ptr = s->token.ptr;
25481|  6.74M|        switch(level) {
25482|  1.10M|        case 1:
25483|  1.10M|            switch(op) {
25484|  58.7k|            case '*':
25485|  58.7k|                opcode = OP_mul;
25486|  58.7k|                break;
25487|  53.8k|            case '/':
25488|  53.8k|                opcode = OP_div;
25489|  53.8k|                break;
25490|  4.20k|            case '%':
25491|  4.20k|                opcode = OP_mod;
25492|  4.20k|                break;
25493|   986k|            default:
25494|   986k|                return 0;
25495|  1.10M|            }
25496|   116k|            break;
25497|   986k|        case 2:
25498|   986k|            switch(op) {
25499|   127k|            case '+':
25500|   127k|                opcode = OP_add;
25501|   127k|                break;
25502|  35.2k|            case '-':
25503|  35.2k|                opcode = OP_sub;
25504|  35.2k|                break;
25505|   823k|            default:
25506|   823k|                return 0;
25507|   986k|            }
25508|   162k|            break;
25509|   823k|        case 3:
25510|   823k|            switch(op) {
25511|    295|            case TOK_SHL:
25512|    295|                opcode = OP_shl;
25513|    295|                break;
25514|  5.64k|            case TOK_SAR:
25515|  5.64k|                opcode = OP_sar;
25516|  5.64k|                break;
25517|    383|            case TOK_SHR:
25518|    383|                opcode = OP_shr;
25519|    383|                break;
25520|   817k|            default:
25521|   817k|                return 0;
25522|   823k|            }
25523|  6.31k|            break;
25524|   817k|        case 4:
25525|   817k|            switch(op) {
25526|  9.70k|            case '<':
25527|  9.70k|                opcode = OP_lt;
25528|  9.70k|                break;
25529|  17.0k|            case '>':
25530|  17.0k|                opcode = OP_gt;
25531|  17.0k|                break;
25532|    358|            case TOK_LTE:
25533|    358|                opcode = OP_lte;
25534|    358|                break;
25535|  1.44k|            case TOK_GTE:
25536|  1.44k|                opcode = OP_gte;
25537|  1.44k|                break;
25538|      0|            case TOK_INSTANCEOF:
25539|      0|                opcode = OP_instanceof;
25540|      0|                break;
25541|    516|            case TOK_IN:
25542|    516|                if (parse_flags & PF_IN_ACCEPTED) {
25543|    383|                    opcode = OP_in;
25544|    383|                } else {
25545|    133|                    return 0;
25546|    133|                }
25547|    383|                break;
25548|   788k|            default:
25549|   788k|                return 0;
25550|   817k|            }
25551|  28.9k|            break;
25552|   788k|        case 5:
25553|   788k|            switch(op) {
25554|  11.5k|            case TOK_EQ:
25555|  11.5k|                opcode = OP_eq;
25556|  11.5k|                break;
25557|    197|            case TOK_NEQ:
25558|    197|                opcode = OP_neq;
25559|    197|                break;
25560|  4.43k|            case TOK_STRICT_EQ:
25561|  4.43k|                opcode = OP_strict_eq;
25562|  4.43k|                break;
25563|     43|            case TOK_STRICT_NEQ:
25564|     43|                opcode = OP_strict_neq;
25565|     43|                break;
25566|   772k|            default:
25567|   772k|                return 0;
25568|   788k|            }
25569|  16.2k|            break;
25570|   772k|        case 6:
25571|   772k|            switch(op) {
25572|  39.0k|            case '&':
25573|  39.0k|                opcode = OP_and;
25574|  39.0k|                break;
25575|   733k|            default:
25576|   733k|                return 0;
25577|   772k|            }
25578|  39.0k|            break;
25579|   733k|        case 7:
25580|   733k|            switch(op) {
25581|  7.44k|            case '^':
25582|  7.44k|                opcode = OP_xor;
25583|  7.44k|                break;
25584|   725k|            default:
25585|   725k|                return 0;
25586|   733k|            }
25587|  7.44k|            break;
25588|   725k|        case 8:
25589|   725k|            switch(op) {
25590|  8.74k|            case '|':
25591|  8.74k|                opcode = OP_or;
25592|  8.74k|                break;
25593|   716k|            default:
25594|   716k|                return 0;
25595|   725k|            }
25596|  8.74k|            break;
25597|  8.74k|        default:
25598|      0|            abort();
25599|  6.74M|        }
25600|   386k|        if (next_token(s))
25601|     97|            return -1;
25602|   386k|        if (js_parse_expr_binary(s, level - 1, parse_flags))
25603|  5.81k|            return -1;
25604|   380k|        emit_source_pos(s, op_token_ptr);
25605|   380k|        emit_op(s, opcode);
25606|   380k|    }
25607|      0|    return 0;
25608|  6.36M|}
25609|       |
25610|       |/* allowed parse_flags: PF_IN_ACCEPTED */
25611|       |static __exception int js_parse_logical_and_or(JSParseState *s, int op,
25612|       |                                               int parse_flags)
25613|  1.67M|{
25614|  1.67M|    int label1;
25615|       |
25616|  1.67M|    if (op == TOK_LAND) {
25617|   836k|        if (js_parse_expr_binary(s, 8, parse_flags))
25618|   136k|            return -1;
25619|   836k|    } else {
25620|   834k|        if (js_parse_logical_and_or(s, TOK_LAND, parse_flags))
25621|   136k|            return -1;
25622|   834k|    }
25623|  1.39M|    if (s->token.val == op) {
25624|  1.72k|        label1 = new_label(s);
25625|       |
25626|  6.92k|        for(;;) {
25627|  6.92k|            if (next_token(s))
25628|      2|                return -1;
25629|  6.92k|            emit_op(s, OP_dup);
25630|  6.92k|            emit_goto(s, op == TOK_LAND ? OP_if_false : OP_if_true, label1);
25631|  6.92k|            emit_op(s, OP_drop);
25632|       |
25633|  6.92k|            if (op == TOK_LAND) {
25634|  4.83k|                if (js_parse_expr_binary(s, 8, parse_flags))
25635|    132|                    return -1;
25636|  4.83k|            } else {
25637|  2.08k|                if (js_parse_logical_and_or(s, TOK_LAND,
25638|  2.08k|                                            parse_flags))
25639|     57|                    return -1;
25640|  2.08k|            }
25641|  6.73k|            if (s->token.val != op) {
25642|  1.53k|                if (s->token.val == TOK_DOUBLE_QUESTION_MARK)
25643|      1|                    return js_parse_error(s, "cannot mix ?? with && or ||");
25644|  1.53k|                break;
25645|  1.53k|            }
25646|  6.73k|        }
25647|       |
25648|  1.53k|        emit_label(s, label1);
25649|  1.53k|    }
25650|  1.39M|    return 0;
25651|  1.39M|}
25652|       |
25653|       |static __exception int js_parse_coalesce_expr(JSParseState *s, int parse_flags)
25654|   834k|{
25655|   834k|    int label1;
25656|       |
25657|   834k|    if (js_parse_logical_and_or(s, TOK_LOR, parse_flags))
25658|   136k|        return -1;
25659|   697k|    if (s->token.val == TOK_DOUBLE_QUESTION_MARK) {
25660|  5.21k|        label1 = new_label(s);
25661|  12.6k|        for(;;) {
25662|  12.6k|            if (next_token(s))
25663|      4|                return -1;
25664|       |
25665|  12.6k|            emit_op(s, OP_dup);
25666|  12.6k|            emit_op(s, OP_is_undefined_or_null);
25667|  12.6k|            emit_goto(s, OP_if_false, label1);
25668|  12.6k|            emit_op(s, OP_drop);
25669|       |
25670|  12.6k|            if (js_parse_expr_binary(s, 8, parse_flags))
25671|     40|                return -1;
25672|  12.5k|            if (s->token.val != TOK_DOUBLE_QUESTION_MARK)
25673|  5.16k|                break;
25674|  12.5k|        }
25675|  5.16k|        emit_label(s, label1);
25676|  5.16k|    }
25677|   697k|    return 0;
25678|   697k|}
25679|       |
25680|       |/* allowed parse_flags: PF_IN_ACCEPTED */
25681|       |static __exception int js_parse_cond_expr(JSParseState *s, int parse_flags)
25682|   834k|{
25683|   834k|    int label1, label2;
25684|       |
25685|   834k|    if (js_parse_coalesce_expr(s, parse_flags))
25686|   136k|        return -1;
25687|   697k|    if (s->token.val == '?') {
25688|  5.34k|        if (next_token(s))
25689|      4|            return -1;
25690|  5.34k|        label1 = emit_goto(s, OP_if_false, -1);
25691|       |
25692|  5.34k|        if (js_parse_assign_expr(s))
25693|  1.02k|            return -1;
25694|  4.31k|        if (js_parse_expect(s, ':'))
25695|     69|            return -1;
25696|       |
25697|  4.24k|        label2 = emit_goto(s, OP_goto, -1);
25698|       |
25699|  4.24k|        emit_label(s, label1);
25700|       |
25701|  4.24k|        if (js_parse_assign_expr2(s, parse_flags & PF_IN_ACCEPTED))
25702|    981|            return -1;
25703|       |
25704|  3.26k|        emit_label(s, label2);
25705|  3.26k|    }
25706|   695k|    return 0;
25707|   697k|}
25708|       |
25709|       |/* allowed parse_flags: PF_IN_ACCEPTED */
25710|       |static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)
25711|   980k|{
25712|   980k|    int opcode, op, scope, skip_bits;
25713|   980k|    JSAtom name0 = JS_ATOM_NULL;
25714|   980k|    JSAtom name;
25715|       |
25716|   980k|    if (s->token.val == TOK_YIELD) {
25717|      0|        BOOL is_star = FALSE, is_async;
25718|       |
25719|      0|        if (!(s->cur_func->func_kind & JS_FUNC_GENERATOR))
25720|      0|            return js_parse_error(s, "unexpected 'yield' keyword");
25721|      0|        if (!s->cur_func->in_function_body)
25722|      0|            return js_parse_error(s, "yield in default expression");
25723|      0|        if (next_token(s))
25724|      0|            return -1;
25725|       |        /* XXX: is there a better method to detect 'yield' without
25726|       |           parameters ? */
25727|      0|        if (s->token.val != ';' && s->token.val != ')' &&
25728|      0|            s->token.val != ']' && s->token.val != '}' &&
25729|      0|            s->token.val != ',' && s->token.val != ':' && !s->got_lf) {
25730|      0|            if (s->token.val == '*') {
25731|      0|                is_star = TRUE;
25732|      0|                if (next_token(s))
25733|      0|                    return -1;
25734|      0|            }
25735|      0|            if (js_parse_assign_expr2(s, parse_flags))
25736|      0|                return -1;
25737|      0|        } else {
25738|      0|            emit_op(s, OP_undefined);
25739|      0|        }
25740|      0|        is_async = (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR);
25741|       |
25742|      0|        if (is_star) {
25743|      0|            int label_loop, label_return, label_next;
25744|      0|            int label_return1, label_yield, label_throw, label_throw1;
25745|      0|            int label_throw2;
25746|       |
25747|      0|            label_loop = new_label(s);
25748|      0|            label_yield = new_label(s);
25749|       |
25750|      0|            emit_op(s, is_async ? OP_for_await_of_start : OP_for_of_start);
25751|       |
25752|       |            /* remove the catch offset (XXX: could avoid pushing back
25753|       |               undefined) */
25754|      0|            emit_op(s, OP_drop);
25755|      0|            emit_op(s, OP_undefined);
25756|       |
25757|      0|            emit_op(s, OP_undefined); /* initial value */
25758|       |
25759|      0|            emit_label(s, label_loop);
25760|      0|            emit_op(s, OP_iterator_next);
25761|      0|            if (is_async)
25762|      0|                emit_op(s, OP_await);
25763|      0|            emit_op(s, OP_iterator_check_object);
25764|      0|            emit_op(s, OP_get_field2);
25765|      0|            emit_atom(s, JS_ATOM_done);
25766|      0|            label_next = emit_goto(s, OP_if_true, -1); /* end of loop */
25767|      0|            emit_label(s, label_yield);
25768|      0|            if (is_async) {
25769|       |                /* OP_async_yield_star takes the value as parameter */
25770|      0|                emit_op(s, OP_get_field);
25771|      0|                emit_atom(s, JS_ATOM_value);
25772|      0|                emit_op(s, OP_async_yield_star);
25773|      0|            } else {
25774|       |                /* OP_yield_star takes (value, done) as parameter */
25775|      0|                emit_op(s, OP_yield_star);
25776|      0|            }
25777|      0|            emit_op(s, OP_dup);
25778|      0|            label_return = emit_goto(s, OP_if_true, -1);
25779|      0|            emit_op(s, OP_drop);
25780|      0|            emit_goto(s, OP_goto, label_loop);
25781|       |
25782|      0|            emit_label(s, label_return);
25783|      0|            emit_op(s, OP_push_i32);
25784|      0|            emit_u32(s, 2);
25785|      0|            emit_op(s, OP_strict_eq);
25786|      0|            label_throw = emit_goto(s, OP_if_true, -1);
25787|       |
25788|       |            /* return handling */
25789|      0|            if (is_async)
25790|      0|                emit_op(s, OP_await);
25791|      0|            emit_op(s, OP_iterator_call);
25792|      0|            emit_u8(s, 0);
25793|      0|            label_return1 = emit_goto(s, OP_if_true, -1);
25794|      0|            if (is_async)
25795|      0|                emit_op(s, OP_await);
25796|      0|            emit_op(s, OP_iterator_check_object);
25797|      0|            emit_op(s, OP_get_field2);
25798|      0|            emit_atom(s, JS_ATOM_done);
25799|      0|            emit_goto(s, OP_if_false, label_yield);
25800|       |
25801|      0|            emit_op(s, OP_get_field);
25802|      0|            emit_atom(s, JS_ATOM_value);
25803|       |
25804|      0|            emit_label(s, label_return1);
25805|      0|            emit_op(s, OP_nip);
25806|      0|            emit_op(s, OP_nip);
25807|      0|            emit_op(s, OP_nip);
25808|      0|            emit_return(s, TRUE);
25809|       |
25810|       |            /* throw handling */
25811|      0|            emit_label(s, label_throw);
25812|      0|            emit_op(s, OP_iterator_call);
25813|      0|            emit_u8(s, 1);
25814|      0|            label_throw1 = emit_goto(s, OP_if_true, -1);
25815|      0|            if (is_async)
25816|      0|                emit_op(s, OP_await);
25817|      0|            emit_op(s, OP_iterator_check_object);
25818|      0|            emit_op(s, OP_get_field2);
25819|      0|            emit_atom(s, JS_ATOM_done);
25820|      0|            emit_goto(s, OP_if_false, label_yield);
25821|      0|            emit_goto(s, OP_goto, label_next);
25822|       |            /* close the iterator and throw a type error exception */
25823|      0|            emit_label(s, label_throw1);
25824|      0|            emit_op(s, OP_iterator_call);
25825|      0|            emit_u8(s, 2);
25826|      0|            label_throw2 = emit_goto(s, OP_if_true, -1);
25827|      0|            if (is_async)
25828|      0|                emit_op(s, OP_await);
25829|      0|            emit_label(s, label_throw2);
25830|       |
25831|      0|            emit_op(s, OP_throw_error);
25832|      0|            emit_atom(s, JS_ATOM_NULL);
25833|      0|            emit_u8(s, JS_THROW_ERROR_ITERATOR_THROW);
25834|       |
25835|      0|            emit_label(s, label_next);
25836|      0|            emit_op(s, OP_get_field);
25837|      0|            emit_atom(s, JS_ATOM_value);
25838|      0|            emit_op(s, OP_nip); /* keep the value associated with
25839|       |                                   done = true */
25840|      0|            emit_op(s, OP_nip);
25841|      0|            emit_op(s, OP_nip);
25842|      0|        } else {
25843|      0|            int label_next;
25844|       |
25845|      0|            if (is_async)
25846|      0|                emit_op(s, OP_await);
25847|      0|            emit_op(s, OP_yield);
25848|      0|            label_next = emit_goto(s, OP_if_false, -1);
25849|      0|            emit_return(s, TRUE);
25850|      0|            emit_label(s, label_next);
25851|      0|        }
25852|      0|        return 0;
25853|   980k|    } else if (s->token.val == '(' &&
25854|   980k|               js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
25855|     10|        return js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
25856|     10|                                      JS_FUNC_NORMAL, JS_ATOM_NULL,
25857|     10|                                      s->token.ptr);
25858|   980k|    } else if (token_is_pseudo_keyword(s, JS_ATOM_async)) {
25859|      0|        const uint8_t *source_ptr;
25860|      0|        int tok;
25861|      0|        JSParsePos pos;
25862|       |
25863|       |        /* fast test */
25864|      0|        tok = peek_token(s, TRUE);
25865|      0|        if (tok == TOK_FUNCTION || tok == '\n')
25866|      0|            goto next;
25867|       |
25868|      0|        source_ptr = s->token.ptr;
25869|      0|        js_parse_get_pos(s, &pos);
25870|      0|        if (next_token(s))
25871|      0|            return -1;
25872|      0|        if ((s->token.val == '(' &&
25873|      0|             js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||
25874|      0|            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
25875|      0|             peek_token(s, TRUE) == TOK_ARROW)) {
25876|      0|            return js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
25877|      0|                                          JS_FUNC_ASYNC, JS_ATOM_NULL,
25878|      0|                                          source_ptr);
25879|      0|        } else {
25880|       |            /* undo the token parsing */
25881|      0|            if (js_parse_seek_token(s, &pos))
25882|      0|                return -1;
25883|      0|        }
25884|   980k|    } else if (s->token.val == TOK_IDENT &&
25885|   980k|               peek_token(s, TRUE) == TOK_ARROW) {
25886|   132k|        return js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
25887|   132k|                                      JS_FUNC_NORMAL, JS_ATOM_NULL,
25888|   132k|                                      s->token.ptr);
25889|   848k|    } else if ((s->token.val == '{' || s->token.val == '[') &&
25890|   848k|               js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
25891|  14.0k|        if (js_parse_destructuring_element(s, 0, 0, FALSE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE, FALSE) < 0)
25892|  1.41k|            return -1;
25893|  12.6k|        return 0;
25894|  14.0k|    }
25895|   834k| next:
25896|   834k|    if (s->token.val == TOK_IDENT) {
25897|       |        /* name0 is used to check for OP_set_name pattern, not duplicated */
25898|   531k|        name0 = s->token.u.ident.atom;
25899|   531k|    }
25900|   834k|    if (js_parse_cond_expr(s, parse_flags))
25901|   138k|        return -1;
25902|       |
25903|   695k|    op = s->token.val;
25904|   695k|    if (op == '=' || (op >= TOK_MUL_ASSIGN && op <= TOK_POW_ASSIGN)) {
25905|   286k|        int label;
25906|   286k|        if (next_token(s))
25907|     12|            return -1;
25908|   286k|        if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, (op != '='), op) < 0)
25909|     53|            return -1;
25910|       |
25911|   286k|        if (js_parse_assign_expr2(s, parse_flags)) {
25912|  5.79k|            JS_FreeAtom(s->ctx, name);
25913|  5.79k|            return -1;
25914|  5.79k|        }
25915|       |
25916|   280k|        if (op == '=') {
25917|   276k|            if (opcode == OP_get_ref_value && name == name0) {
25918|   272k|                set_object_name(s, name);
25919|   272k|            }
25920|   276k|        } else {
25921|  3.75k|            static const uint8_t assign_opcodes[] = {
25922|  3.75k|                OP_mul, OP_div, OP_mod, OP_add, OP_sub,
25923|  3.75k|                OP_shl, OP_sar, OP_shr, OP_and, OP_xor, OP_or,
25924|  3.75k|                OP_pow,
25925|  3.75k|            };
25926|  3.75k|            op = assign_opcodes[op - TOK_MUL_ASSIGN];
25927|  3.75k|            emit_op(s, op);
25928|  3.75k|        }
25929|   280k|        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
25930|   409k|    } else if (op >= TOK_LAND_ASSIGN && op <= TOK_DOUBLE_QUESTION_MARK_ASSIGN) {
25931|  7.22k|        int label, label1, depth_lvalue, label2;
25932|       |
25933|  7.22k|        if (next_token(s))
25934|      1|            return -1;
25935|  7.21k|        if (get_lvalue(s, &opcode, &scope, &name, &label,
25936|  7.21k|                       &depth_lvalue, TRUE, op) < 0)
25937|      8|            return -1;
25938|       |
25939|  7.21k|        emit_op(s, OP_dup);
25940|  7.21k|        if (op == TOK_DOUBLE_QUESTION_MARK_ASSIGN)
25941|  6.98k|            emit_op(s, OP_is_undefined_or_null);
25942|  7.21k|        label1 = emit_goto(s, op == TOK_LOR_ASSIGN ? OP_if_true : OP_if_false,
25943|  7.21k|                           -1);
25944|  7.21k|        emit_op(s, OP_drop);
25945|       |
25946|  7.21k|        if (js_parse_assign_expr2(s, parse_flags)) {
25947|    395|            JS_FreeAtom(s->ctx, name);
25948|    395|            return -1;
25949|    395|        }
25950|       |
25951|  6.81k|        if (opcode == OP_get_ref_value && name == name0) {
25952|  6.59k|            set_object_name(s, name);
25953|  6.59k|        }
25954|       |
25955|  6.81k|        switch(depth_lvalue) {
25956|    220|        case 1:
25957|    220|            emit_op(s, OP_insert2);
25958|    220|            break;
25959|  6.59k|        case 2:
25960|  6.59k|            emit_op(s, OP_insert3);
25961|  6.59k|            break;
25962|      0|        case 3:
25963|      0|            emit_op(s, OP_insert4);
25964|      0|            break;
25965|      0|        default:
25966|      0|            abort();
25967|  6.81k|        }
25968|       |
25969|       |        /* XXX: we disable the OP_put_ref_value optimization by not
25970|       |           using put_lvalue() otherwise depth_lvalue is not correct */
25971|  6.81k|        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_NOKEEP_DEPTH,
25972|  6.81k|                   FALSE);
25973|  6.81k|        label2 = emit_goto(s, OP_goto, -1);
25974|       |
25975|  6.81k|        emit_label(s, label1);
25976|       |
25977|       |        /* remove the lvalue stack entries */
25978|  20.2k|        while (depth_lvalue != 0) {
25979|  13.4k|            emit_op(s, OP_nip);
25980|  13.4k|            depth_lvalue--;
25981|  13.4k|        }
25982|       |
25983|  6.81k|        emit_label(s, label2);
25984|  6.81k|    }
25985|   689k|    return 0;
25986|   695k|}
25987|       |
25988|       |static __exception int js_parse_assign_expr(JSParseState *s)
25989|   320k|{
25990|   320k|    return js_parse_assign_expr2(s, PF_IN_ACCEPTED);
25991|   320k|}
25992|       |
25993|       |/* allowed parse_flags: PF_IN_ACCEPTED */
25994|       |static __exception int js_parse_expr2(JSParseState *s, int parse_flags)
25995|   314k|{
25996|   314k|    BOOL comma = FALSE;
25997|   346k|    for(;;) {
25998|   346k|        if (js_parse_assign_expr2(s, parse_flags))
25999|   101k|            return -1;
26000|   245k|        if (comma) {
26001|       |            /* prevent get_lvalue from using the last expression
26002|       |               as an lvalue. This also prevents the conversion of
26003|       |               of get_var to get_ref for method lookup in function
26004|       |               call inside `with` statement.
26005|       |             */
26006|  30.2k|            s->cur_func->last_opcode_pos = -1;
26007|  30.2k|        }
26008|   245k|        if (s->token.val != ',')
26009|   213k|            break;
26010|  31.6k|        comma = TRUE;
26011|  31.6k|        if (next_token(s))
26012|     13|            return -1;
26013|  31.6k|        emit_op(s, OP_drop);
26014|  31.6k|    }
26015|   213k|    return 0;
26016|   314k|}
26017|       |
26018|       |static __exception int js_parse_expr(JSParseState *s)
26019|   314k|{
26020|   314k|    return js_parse_expr2(s, PF_IN_ACCEPTED);
26021|   314k|}
26022|       |
26023|       |static void push_break_entry(JSFunctionDef *fd, BlockEnv *be,
26024|       |                             JSAtom label_name,
26025|       |                             int label_break, int label_cont,
26026|       |                             int drop_count)
26027|  46.4k|{
26028|  46.4k|    be->prev = fd->top_break;
26029|  46.4k|    fd->top_break = be;
26030|  46.4k|    be->label_name = label_name;
26031|  46.4k|    be->label_break = label_break;
26032|  46.4k|    be->label_cont = label_cont;
26033|  46.4k|    be->drop_count = drop_count;
26034|  46.4k|    be->label_finally = -1;
26035|  46.4k|    be->scope_level = fd->scope_level;
26036|  46.4k|    be->has_iterator = FALSE;
26037|  46.4k|    be->is_regular_stmt = FALSE;
26038|  46.4k|}
26039|       |
26040|       |static void pop_break_entry(JSFunctionDef *fd)
26041|  43.4k|{
26042|  43.4k|    BlockEnv *be;
26043|  43.4k|    be = fd->top_break;
26044|  43.4k|    fd->top_break = be->prev;
26045|  43.4k|}
26046|       |
26047|       |static __exception int emit_break(JSParseState *s, JSAtom name, int is_cont)
26048|      0|{
26049|      0|    BlockEnv *top;
26050|      0|    int i, scope_level;
26051|       |
26052|      0|    scope_level = s->cur_func->scope_level;
26053|      0|    top = s->cur_func->top_break;
26054|      0|    while (top != NULL) {
26055|      0|        close_scopes(s, scope_level, top->scope_level);
26056|      0|        scope_level = top->scope_level;
26057|      0|        if (is_cont &&
26058|      0|            top->label_cont != -1 &&
26059|      0|            (name == JS_ATOM_NULL || top->label_name == name)) {
26060|       |            /* continue stays inside the same block */
26061|      0|            emit_goto(s, OP_goto, top->label_cont);
26062|      0|            return 0;
26063|      0|        }
26064|      0|        if (!is_cont &&
26065|      0|            top->label_break != -1 &&
26066|      0|            ((name == JS_ATOM_NULL && !top->is_regular_stmt) ||
26067|      0|             top->label_name == name)) {
26068|      0|            emit_goto(s, OP_goto, top->label_break);
26069|      0|            return 0;
26070|      0|        }
26071|      0|        i = 0;
26072|      0|        if (top->has_iterator) {
26073|      0|            emit_op(s, OP_iterator_close);
26074|      0|            i += 3;
26075|      0|        }
26076|      0|        for(; i < top->drop_count; i++)
26077|      0|            emit_op(s, OP_drop);
26078|      0|        if (top->label_finally != -1) {
26079|       |            /* must push dummy value to keep same stack depth */
26080|      0|            emit_op(s, OP_undefined);
26081|      0|            emit_goto(s, OP_gosub, top->label_finally);
26082|      0|            emit_op(s, OP_drop);
26083|      0|        }
26084|      0|        top = top->prev;
26085|      0|    }
26086|      0|    if (name == JS_ATOM_NULL) {
26087|      0|        if (is_cont)
26088|      0|            return js_parse_error(s, "continue must be inside loop");
26089|      0|        else
26090|      0|            return js_parse_error(s, "break must be inside loop or switch");
26091|      0|    } else {
26092|      0|        return js_parse_error(s, "break/continue label not found");
26093|      0|    }
26094|      0|}
26095|       |
26096|       |/* execute the finally blocks before return */
26097|       |static void emit_return(JSParseState *s, BOOL hasval)
26098|  10.1k|{
26099|  10.1k|    BlockEnv *top;
26100|       |
26101|  10.1k|    if (s->cur_func->func_kind != JS_FUNC_NORMAL) {
26102|    505|        if (!hasval) {
26103|       |            /* no value: direct return in case of async generator */
26104|    505|            emit_op(s, OP_undefined);
26105|    505|            hasval = TRUE;
26106|    505|        } else if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
26107|       |            /* the await must be done before handling the "finally" in
26108|       |               case it raises an exception */
26109|      0|            emit_op(s, OP_await);
26110|      0|        }
26111|    505|    }
26112|       |
26113|  10.1k|    top = s->cur_func->top_break;
26114|  10.1k|    while (top != NULL) {
26115|      0|        if (top->has_iterator || top->label_finally != -1) {
26116|      0|            if (!hasval) {
26117|      0|                emit_op(s, OP_undefined);
26118|      0|                hasval = TRUE;
26119|      0|            }
26120|       |            /* Remove the stack elements up to and including the catch
26121|       |               offset. When 'yield' is used in an expression we have
26122|       |               no easy way to count them, so we use this specific
26123|       |               instruction instead. */
26124|      0|            emit_op(s, OP_nip_catch);
26125|       |            /* stack: iter_obj next ret_val */
26126|      0|            if (top->has_iterator) {
26127|      0|                if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
26128|      0|                    int label_next, label_next2;
26129|      0|                    emit_op(s, OP_nip); /* next */
26130|      0|                    emit_op(s, OP_swap);
26131|      0|                    emit_op(s, OP_get_field2);
26132|      0|                    emit_atom(s, JS_ATOM_return);
26133|       |                    /* stack: iter_obj return_func */
26134|      0|                    emit_op(s, OP_dup);
26135|      0|                    emit_op(s, OP_is_undefined_or_null);
26136|      0|                    label_next = emit_goto(s, OP_if_true, -1);
26137|      0|                    emit_op(s, OP_call_method);
26138|      0|                    emit_u16(s, 0);
26139|      0|                    emit_op(s, OP_iterator_check_object);
26140|      0|                    emit_op(s, OP_await);
26141|      0|                    label_next2 = emit_goto(s, OP_goto, -1);
26142|      0|                    emit_label(s, label_next);
26143|      0|                    emit_op(s, OP_drop);
26144|      0|                    emit_label(s, label_next2);
26145|      0|                    emit_op(s, OP_drop);
26146|      0|                } else {
26147|      0|                    emit_op(s, OP_rot3r);
26148|      0|                    emit_op(s, OP_undefined); /* dummy catch offset */
26149|      0|                    emit_op(s, OP_iterator_close);
26150|      0|                }
26151|      0|            } else {
26152|       |                /* execute the "finally" block */
26153|      0|                emit_goto(s, OP_gosub, top->label_finally);
26154|      0|            }
26155|      0|        }
26156|      0|        top = top->prev;
26157|      0|    }
26158|  10.1k|    if (s->cur_func->is_derived_class_constructor) {
26159|      0|        int label_return;
26160|       |
26161|       |        /* 'this' can be uninitialized, so it may be accessed only if
26162|       |           the derived class constructor does not return an object */
26163|      0|        if (hasval) {
26164|      0|            emit_op(s, OP_check_ctor_return);
26165|      0|            label_return = emit_goto(s, OP_if_false, -1);
26166|      0|            emit_op(s, OP_drop);
26167|      0|        } else {
26168|      0|            label_return = -1;
26169|      0|        }
26170|       |
26171|       |        /* The error should be raised in the caller context, so we use
26172|       |           a specific opcode */
26173|      0|        emit_op(s, OP_scope_get_var_checkthis);
26174|      0|        emit_atom(s, JS_ATOM_this);
26175|      0|        emit_u16(s, 0);
26176|       |
26177|      0|        emit_label(s, label_return);
26178|      0|        emit_op(s, OP_return);
26179|  10.1k|    } else if (s->cur_func->func_kind != JS_FUNC_NORMAL) {
26180|    505|        emit_op(s, OP_return_async);
26181|  9.61k|    } else {
26182|  9.61k|        emit_op(s, hasval ? OP_return : OP_return_undef);
26183|  9.61k|    }
26184|  10.1k|}
26185|       |
26186|   269k|#define DECL_MASK_FUNC  (1 << 0) /* allow normal function declaration */
26187|       |/* ored with DECL_MASK_FUNC if function declarations are allowed with a label */
26188|   271k|#define DECL_MASK_FUNC_WITH_LABEL (1 << 1)
26189|   286k|#define DECL_MASK_OTHER (1 << 2) /* all other declarations */
26190|   266k|#define DECL_MASK_ALL   (DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL | DECL_MASK_OTHER)
26191|       |
26192|       |static __exception int js_parse_statement_or_decl(JSParseState *s,
26193|       |                                                  int decl_mask);
26194|       |
26195|       |static __exception int js_parse_statement(JSParseState *s)
26196|  14.0k|{
26197|  14.0k|    return js_parse_statement_or_decl(s, 0);
26198|  14.0k|}
26199|       |
26200|       |static __exception int js_parse_block(JSParseState *s)
26201|  17.8k|{
26202|  17.8k|    if (js_parse_expect(s, '{'))
26203|      2|        return -1;
26204|  17.8k|    if (s->token.val != '}') {
26205|  17.7k|        push_scope(s);
26206|   152k|        for(;;) {
26207|   152k|            if (js_parse_statement_or_decl(s, DECL_MASK_ALL))
26208|  8.08k|                return -1;
26209|   144k|            if (s->token.val == '}')
26210|  9.62k|                break;
26211|   144k|        }
26212|  9.62k|        pop_scope(s);
26213|  9.62k|    }
26214|  9.74k|    if (next_token(s))
26215|      9|        return -1;
26216|  9.73k|    return 0;
26217|  9.74k|}
26218|       |
26219|       |/* allowed parse_flags: PF_IN_ACCEPTED */
26220|       |static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
26221|       |                                    BOOL export_flag)
26222|  11.4k|{
26223|  11.4k|    JSContext *ctx = s->ctx;
26224|  11.4k|    JSFunctionDef *fd = s->cur_func;
26225|  11.4k|    JSAtom name = JS_ATOM_NULL;
26226|       |
26227|  41.4k|    for (;;) {
26228|  41.4k|        if (s->token.val == TOK_IDENT) {
26229|  40.9k|            if (s->token.u.ident.is_reserved) {
26230|      1|                return js_parse_error_reserved_identifier(s);
26231|      1|            }
26232|  40.9k|            name = JS_DupAtom(ctx, s->token.u.ident.atom);
26233|  40.9k|            if (name == JS_ATOM_let && (tok == TOK_LET || tok == TOK_CONST)) {
26234|      5|                js_parse_error(s, "'let' is not a valid lexical identifier");
26235|      5|                goto var_error;
26236|      5|            }
26237|  40.9k|            if (next_token(s))
26238|     16|                goto var_error;
26239|  40.9k|            if (js_define_var(s, name, tok))
26240|     40|                goto var_error;
26241|  40.9k|            if (export_flag) {
26242|    711|                if (!add_export_entry(s, s->cur_func->module, name, name,
26243|    711|                                      JS_EXPORT_TYPE_LOCAL))
26244|      3|                    goto var_error;
26245|    711|            }
26246|       |
26247|  40.9k|            if (s->token.val == '=') {
26248|  15.7k|                if (next_token(s))
26249|      3|                    goto var_error;
26250|  15.7k|                if (need_var_reference(s, tok)) {
26251|       |                    /* Must make a reference for proper `with` semantics */
26252|  6.47k|                    int opcode, scope, label;
26253|  6.47k|                    JSAtom name1;
26254|       |
26255|  6.47k|                    emit_op(s, OP_scope_get_var);
26256|  6.47k|                    emit_atom(s, name);
26257|  6.47k|                    emit_u16(s, fd->scope_level);
26258|  6.47k|                    if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') < 0)
26259|      0|                        goto var_error;
26260|  6.47k|                    if (js_parse_assign_expr2(s, parse_flags)) {
26261|      8|                        JS_FreeAtom(ctx, name1);
26262|      8|                        goto var_error;
26263|      8|                    }
26264|  6.46k|                    set_object_name(s, name);
26265|  6.46k|                    put_lvalue(s, opcode, scope, name1, label,
26266|  6.46k|                               PUT_LVALUE_NOKEEP, FALSE);
26267|  9.26k|                } else {
26268|  9.26k|                    if (js_parse_assign_expr2(s, parse_flags))
26269|    160|                        goto var_error;
26270|  9.10k|                    set_object_name(s, name);
26271|  9.10k|                    emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ?
26272|  5.52k|                        OP_scope_put_var_init : OP_scope_put_var);
26273|  9.10k|                    emit_atom(s, name);
26274|  9.10k|                    emit_u16(s, fd->scope_level);
26275|  9.10k|                }
26276|  25.1k|            } else {
26277|  25.1k|                if (tok == TOK_CONST) {
26278|      5|                    js_parse_error(s, "missing initializer for const variable");
26279|      5|                    goto var_error;
26280|      5|                }
26281|  25.1k|                if (tok == TOK_LET) {
26282|       |                    /* initialize lexical variable upon entering its scope */
26283|  16.0k|                    emit_op(s, OP_undefined);
26284|  16.0k|                    emit_op(s, OP_scope_put_var_init);
26285|  16.0k|                    emit_atom(s, name);
26286|  16.0k|                    emit_u16(s, fd->scope_level);
26287|  16.0k|                }
26288|  25.1k|            }
26289|  40.7k|            JS_FreeAtom(ctx, name);
26290|  40.7k|        } else {
26291|    489|            int skip_bits;
26292|    489|            if ((s->token.val == '[' || s->token.val == '{')
26293|    489|            &&  js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
26294|    443|                emit_op(s, OP_undefined);
26295|    443|                if (js_parse_destructuring_element(s, tok, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE, export_flag) < 0)
26296|     60|                    return -1;
26297|    443|            } else {
26298|     46|                return js_parse_error(s, "variable name expected");
26299|     46|            }
26300|    489|        }
26301|  41.1k|        if (s->token.val != ',')
26302|  11.1k|            break;
26303|  29.9k|        if (next_token(s))
26304|      5|            return -1;
26305|  29.9k|    }
26306|  11.1k|    return 0;
26307|       |
26308|    240| var_error:
26309|    240|    JS_FreeAtom(ctx, name);
26310|    240|    return -1;
26311|  11.4k|}
26312|       |
26313|       |/* test if the current token is a label. Use simplistic look-ahead scanner */
26314|       |static BOOL is_label(JSParseState *s)
26315|   291k|{
26316|   291k|    return (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
26317|   291k|            peek_token(s, FALSE) == ':');
26318|   291k|}
26319|       |
26320|       |/* test if the current token is a let keyword. Use simplistic look-ahead scanner */
26321|       |static int is_let(JSParseState *s, int decl_mask)
26322|   189k|{
26323|   189k|    int res = FALSE;
26324|   189k|    const uint8_t *last_token_ptr;
26325|       |    
26326|   189k|    if (token_is_pseudo_keyword(s, JS_ATOM_let)) {
26327|  5.41k|        JSParsePos pos;
26328|  5.41k|        js_parse_get_pos(s, &pos);
26329|  5.41k|        for (;;) {
26330|  5.41k|            last_token_ptr = s->token.ptr;
26331|  5.41k|            if (next_token(s)) {
26332|      2|                res = -1;
26333|      2|                break;
26334|      2|            }
26335|  5.41k|            if (s->token.val == '[') {
26336|       |                /* let [ is a syntax restriction:
26337|       |                   it never introduces an ExpressionStatement */
26338|      5|                res = TRUE;
26339|      5|                break;
26340|      5|            }
26341|  5.40k|            if (s->token.val == '{' ||
26342|  5.40k|                (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved) ||
26343|  5.40k|                s->token.val == TOK_LET ||
26344|  5.40k|                s->token.val == TOK_YIELD ||
26345|  5.40k|                s->token.val == TOK_AWAIT) {
26346|       |                /* Check for possible ASI if not scanning for Declaration */
26347|       |                /* XXX: should also check that `{` introduces a BindingPattern,
26348|       |                   but Firefox does not and rejects eval("let=1;let\n{if(1)2;}") */
26349|  5.28k|                if (!has_lf_in_range(last_token_ptr, s->token.ptr) ||
26350|  5.28k|                    (decl_mask & DECL_MASK_OTHER)) {
26351|  5.28k|                    res = TRUE;
26352|  5.28k|                    break;
26353|  5.28k|                }
26354|      0|                break;
26355|  5.28k|            }
26356|    123|            break;
26357|  5.40k|        }
26358|  5.41k|        if (js_parse_seek_token(s, &pos)) {
26359|      0|            res = -1;
26360|      0|        }
26361|  5.41k|    }
26362|   189k|    return res;
26363|   189k|}
26364|       |
26365|       |/* XXX: handle IteratorClose when exiting the loop before the
26366|       |   enumeration is done */
26367|       |static __exception int js_parse_for_in_of(JSParseState *s, int label_name,
26368|       |                                          BOOL is_async)
26369|  10.8k|{
26370|  10.8k|    JSContext *ctx = s->ctx;
26371|  10.8k|    JSFunctionDef *fd = s->cur_func;
26372|  10.8k|    JSAtom var_name;
26373|  10.8k|    BOOL has_initializer, is_for_of, has_destructuring;
26374|  10.8k|    int tok, tok1, opcode, scope, block_scope_level;
26375|  10.8k|    int label_next, label_expr, label_cont, label_body, label_break;
26376|  10.8k|    int pos_next, pos_expr;
26377|  10.8k|    BlockEnv break_entry;
26378|       |
26379|  10.8k|    has_initializer = FALSE;
26380|  10.8k|    has_destructuring = FALSE;
26381|  10.8k|    is_for_of = FALSE;
26382|  10.8k|    block_scope_level = fd->scope_level;
26383|  10.8k|    label_cont = new_label(s);
26384|  10.8k|    label_body = new_label(s);
26385|  10.8k|    label_break = new_label(s);
26386|  10.8k|    label_next = new_label(s);
26387|       |
26388|       |    /* create scope for the lexical variables declared in the enumeration
26389|       |       expressions. XXX: Not completely correct because of weird capturing
26390|       |       semantics in `for (i of o) a.push(function(){return i})` */
26391|  10.8k|    push_scope(s);
26392|       |
26393|       |    /* local for_in scope starts here so individual elements
26394|       |       can be closed in statement. */
26395|  10.8k|    push_break_entry(s->cur_func, &break_entry,
26396|  10.8k|                     label_name, label_break, label_cont, 1);
26397|  10.8k|    break_entry.scope_level = block_scope_level;
26398|       |
26399|  10.8k|    label_expr = emit_goto(s, OP_goto, -1);
26400|       |
26401|  10.8k|    pos_next = s->cur_func->byte_code.size;
26402|  10.8k|    emit_label(s, label_next);
26403|       |
26404|  10.8k|    tok = s->token.val;
26405|  10.8k|    switch (is_let(s, DECL_MASK_OTHER)) {
26406|    417|    case TRUE:
26407|    417|        tok = TOK_LET;
26408|    417|        break;
26409|  10.4k|    case FALSE:
26410|  10.4k|        break;
26411|      1|    default:
26412|      1|        return -1;
26413|  10.8k|    }
26414|  10.8k|    if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
26415|    594|        if (next_token(s))
26416|      1|            return -1;
26417|       |
26418|    593|        if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
26419|     12|            if (s->token.val == '[' || s->token.val == '{') {
26420|      9|                if (js_parse_destructuring_element(s, tok, 0, TRUE, -1, FALSE, FALSE) < 0)
26421|      3|                    return -1;
26422|      6|                has_destructuring = TRUE;
26423|      6|            } else {
26424|      3|                return js_parse_error(s, "variable name expected");
26425|      3|            }
26426|      6|            var_name = JS_ATOM_NULL;
26427|    581|        } else {
26428|    581|            var_name = JS_DupAtom(ctx, s->token.u.ident.atom);
26429|    581|            if (next_token(s)) {
26430|      7|                JS_FreeAtom(s->ctx, var_name);
26431|      7|                return -1;
26432|      7|            }
26433|    574|            if (js_define_var(s, var_name, tok)) {
26434|      1|                JS_FreeAtom(s->ctx, var_name);
26435|      1|                return -1;
26436|      1|            }
26437|    573|            emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ?
26438|    443|                    OP_scope_put_var_init : OP_scope_put_var);
26439|    573|            emit_atom(s, var_name);
26440|    573|            emit_u16(s, fd->scope_level);
26441|    573|        }
26442|  10.2k|    } else if (!is_async && token_is_pseudo_keyword(s, JS_ATOM_async) &&
26443|  10.2k|               peek_token(s, FALSE) == TOK_OF) {
26444|      0|        return js_parse_error(s, "'for of' expression cannot start with 'async'");
26445|  10.2k|    } else {
26446|  10.2k|        int skip_bits;
26447|  10.2k|        if ((s->token.val == '[' || s->token.val == '{')
26448|  10.2k|        &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == TOK_IN || tok1 == TOK_OF)) {
26449|      5|            if (js_parse_destructuring_element(s, 0, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE, FALSE) < 0)
26450|      1|                return -1;
26451|  10.2k|        } else {
26452|  10.2k|            int lvalue_label;
26453|  10.2k|            if (js_parse_left_hand_side_expr(s))
26454|     10|                return -1;
26455|  10.2k|            if (get_lvalue(s, &opcode, &scope, &var_name, &lvalue_label,
26456|  10.2k|                           NULL, FALSE, TOK_FOR))
26457|      1|                return -1;
26458|  10.2k|            put_lvalue(s, opcode, scope, var_name, lvalue_label,
26459|  10.2k|                       PUT_LVALUE_NOKEEP_BOTTOM, FALSE);
26460|  10.2k|        }
26461|  10.2k|        var_name = JS_ATOM_NULL;
26462|  10.2k|    }
26463|  10.8k|    emit_goto(s, OP_goto, label_body);
26464|       |
26465|  10.8k|    pos_expr = s->cur_func->byte_code.size;
26466|  10.8k|    emit_label(s, label_expr);
26467|  10.8k|    if (s->token.val == '=') {
26468|       |        /* XXX: potential scoping issue if inside `with` statement */
26469|    136|        has_initializer = TRUE;
26470|       |        /* parse and evaluate initializer prior to evaluating the
26471|       |           object (only used with "for in" with a non lexical variable
26472|       |           in non strict mode */
26473|    136|        if (next_token(s) || js_parse_assign_expr2(s, 0)) {
26474|      3|            JS_FreeAtom(ctx, var_name);
26475|      3|            return -1;
26476|      3|        }
26477|    133|        if (var_name != JS_ATOM_NULL) {
26478|    131|            emit_op(s, OP_scope_put_var);
26479|    131|            emit_atom(s, var_name);
26480|    131|            emit_u16(s, fd->scope_level);
26481|    131|        }
26482|    133|    }
26483|  10.8k|    JS_FreeAtom(ctx, var_name);
26484|       |
26485|  10.8k|    if (token_is_pseudo_keyword(s, JS_ATOM_of)) {
26486|      6|        break_entry.has_iterator = is_for_of = TRUE;
26487|      6|        break_entry.drop_count += 2;
26488|      6|        if (has_initializer)
26489|      1|            goto initializer_error;
26490|  10.8k|    } else if (s->token.val == TOK_IN) {
26491|  10.8k|        if (is_async)
26492|      0|            return js_parse_error(s, "'for await' loop should be used with 'of'");
26493|  10.8k|        if (has_initializer &&
26494|  10.8k|            (tok != TOK_VAR || (fd->js_mode & JS_MODE_STRICT) ||
26495|    129|             has_destructuring)) {
26496|      2|        initializer_error:
26497|      2|            return js_parse_error(s, "a declaration in the head of a for-%s loop can't have an initializer",
26498|      2|                                  is_for_of ? "of" : "in");
26499|      1|        }
26500|  10.8k|    } else {
26501|     13|        return js_parse_error(s, "expected 'of' or 'in' in for control expression");
26502|     13|    }
26503|  10.8k|    if (next_token(s))
26504|     12|        return -1;
26505|  10.7k|    if (is_for_of) {
26506|      4|        if (js_parse_assign_expr(s))
26507|      2|            return -1;
26508|  10.7k|    } else {
26509|  10.7k|        if (js_parse_expr(s))
26510|     21|            return -1;
26511|  10.7k|    }
26512|       |    /* close the scope after having evaluated the expression so that
26513|       |       the TDZ values are in the closures */
26514|  10.7k|    close_scopes(s, s->cur_func->scope_level, block_scope_level);
26515|  10.7k|    if (is_for_of) {
26516|      2|        if (is_async)
26517|      0|            emit_op(s, OP_for_await_of_start);
26518|      2|        else
26519|      2|            emit_op(s, OP_for_of_start);
26520|       |        /* on stack: enum_rec */
26521|  10.7k|    } else {
26522|  10.7k|        emit_op(s, OP_for_in_start);
26523|       |        /* on stack: enum_obj */
26524|  10.7k|    }
26525|  10.7k|    emit_goto(s, OP_goto, label_cont);
26526|       |
26527|  10.7k|    if (js_parse_expect(s, ')'))
26528|     10|        return -1;
26529|       |
26530|  10.7k|    if (OPTIMIZE) {
26531|       |        /* move the `next` code here */
26532|  10.7k|        DynBuf *bc = &s->cur_func->byte_code;
26533|  10.7k|        int chunk_size = pos_expr - pos_next;
26534|  10.7k|        int offset = bc->size - pos_next;
26535|  10.7k|        int i;
26536|  10.7k|        dbuf_realloc(bc, bc->size + chunk_size);
26537|  10.7k|        dbuf_put(bc, bc->buf + pos_next, chunk_size);
26538|  10.7k|        memset(bc->buf + pos_next, OP_nop, chunk_size);
26539|       |        /* `next` part ends with a goto */
26540|  10.7k|        s->cur_func->last_opcode_pos = bc->size - 5;
26541|       |        /* relocate labels */
26542|  75.6k|        for (i = label_cont; i < s->cur_func->label_count; i++) {
26543|  64.8k|            LabelSlot *ls = &s->cur_func->label_slots[i];
26544|  64.8k|            if (ls->pos >= pos_next && ls->pos < pos_expr)
26545|  20.8k|                ls->pos += offset;
26546|  64.8k|        }
26547|  10.7k|    }
26548|       |
26549|  10.7k|    emit_label(s, label_body);
26550|  10.7k|    if (js_parse_statement(s))
26551|    931|        return -1;
26552|       |
26553|  9.83k|    close_scopes(s, s->cur_func->scope_level, block_scope_level);
26554|       |
26555|  9.83k|    emit_label(s, label_cont);
26556|  9.83k|    if (is_for_of) {
26557|      0|        if (is_async) {
26558|       |            /* stack: iter_obj next catch_offset */
26559|       |            /* call the next method */
26560|      0|            emit_op(s, OP_for_await_of_next); 
26561|       |            /* get the result of the promise */
26562|      0|            emit_op(s, OP_await);
26563|       |            /* unwrap the value and done values */
26564|      0|            emit_op(s, OP_iterator_get_value_done);
26565|      0|        } else {
26566|      0|            emit_op(s, OP_for_of_next);
26567|      0|            emit_u8(s, 0);
26568|      0|        }
26569|  9.83k|    } else {
26570|  9.83k|        emit_op(s, OP_for_in_next);
26571|  9.83k|    }
26572|       |    /* on stack: enum_rec / enum_obj value bool */
26573|  9.83k|    emit_goto(s, OP_if_false, label_next);
26574|       |    /* drop the undefined value from for_xx_next */
26575|  9.83k|    emit_op(s, OP_drop);
26576|       |
26577|  9.83k|    emit_label(s, label_break);
26578|  9.83k|    if (is_for_of) {
26579|       |        /* close and drop enum_rec */
26580|      0|        emit_op(s, OP_iterator_close);
26581|  9.83k|    } else {
26582|  9.83k|        emit_op(s, OP_drop);
26583|  9.83k|    }
26584|  9.83k|    pop_break_entry(s->cur_func);
26585|  9.83k|    pop_scope(s);
26586|  9.83k|    return 0;
26587|  10.7k|}
26588|       |
26589|       |static void set_eval_ret_undefined(JSParseState *s)
26590|  14.5k|{
26591|  14.5k|    if (s->cur_func->eval_ret_idx >= 0) {
26592|  9.73k|        emit_op(s, OP_undefined);
26593|  9.73k|        emit_op(s, OP_put_loc);
26594|  9.73k|        emit_u16(s, s->cur_func->eval_ret_idx);
26595|  9.73k|    }
26596|  14.5k|}
26597|       |
26598|       |static __exception int js_parse_statement_or_decl(JSParseState *s,
26599|       |                                                  int decl_mask)
26600|   291k|{
26601|   291k|    JSContext *ctx = s->ctx;
26602|   291k|    JSAtom label_name;
26603|   291k|    int tok;
26604|       |
26605|       |    /* specific label handling */
26606|       |    /* XXX: support multiple labels on loop statements */
26607|   291k|    label_name = JS_ATOM_NULL;
26608|   291k|    if (is_label(s)) {
26609|  11.3k|        BlockEnv *be;
26610|       |
26611|  11.3k|        label_name = JS_DupAtom(ctx, s->token.u.ident.atom);
26612|       |
26613|  17.3k|        for (be = s->cur_func->top_break; be; be = be->prev) {
26614|  5.94k|            if (be->label_name == label_name) {
26615|     21|                js_parse_error(s, "duplicate label name");
26616|     21|                goto fail;
26617|     21|            }
26618|  5.94k|        }
26619|       |
26620|  11.3k|        if (next_token(s))
26621|      0|            goto fail;
26622|  11.3k|        if (js_parse_expect(s, ':'))
26623|      2|            goto fail;
26624|  11.3k|        if (s->token.val != TOK_FOR
26625|  11.3k|        &&  s->token.val != TOK_DO
26626|  11.3k|        &&  s->token.val != TOK_WHILE) {
26627|       |            /* labelled regular statement */
26628|  11.3k|            int label_break, mask;
26629|  11.3k|            BlockEnv break_entry;
26630|       |
26631|  11.3k|            label_break = new_label(s);
26632|  11.3k|            push_break_entry(s->cur_func, &break_entry,
26633|  11.3k|                             label_name, label_break, -1, 0);
26634|  11.3k|            break_entry.is_regular_stmt = TRUE;
26635|  11.3k|            if (!(s->cur_func->js_mode & JS_MODE_STRICT) &&
26636|  11.3k|                (decl_mask & DECL_MASK_FUNC_WITH_LABEL)) {
26637|  2.77k|                mask = DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL;
26638|  8.58k|            } else {
26639|  8.58k|                mask = 0;
26640|  8.58k|            }
26641|  11.3k|            if (js_parse_statement_or_decl(s, mask))
26642|    127|                goto fail;
26643|  11.2k|            emit_label(s, label_break);
26644|  11.2k|            pop_break_entry(s->cur_func);
26645|  11.2k|            goto done;
26646|  11.3k|        }
26647|  11.3k|    }
26648|       |
26649|   280k|    switch(tok = s->token.val) {
26650|  17.8k|    case '{':
26651|  17.8k|        if (js_parse_block(s))
26652|  8.09k|            goto fail;
26653|  9.73k|        break;
26654|  9.73k|    case TOK_RETURN:
26655|      0|        {
26656|      0|            const uint8_t *op_token_ptr;
26657|      0|            if (s->cur_func->is_eval) {
26658|      0|                js_parse_error(s, "return not in a function");
26659|      0|                goto fail;
26660|      0|            }
26661|      0|            if (s->cur_func->func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT) {
26662|      0|                js_parse_error(s, "return in a static initializer block");
26663|      0|                goto fail;
26664|      0|            }
26665|      0|            op_token_ptr = s->token.ptr;
26666|      0|            if (next_token(s))
26667|      0|                goto fail;
26668|      0|            if (s->token.val != ';' && s->token.val != '}' && !s->got_lf) {
26669|      0|                if (js_parse_expr(s))
26670|      0|                    goto fail;
26671|      0|                emit_source_pos(s, op_token_ptr);
26672|      0|                emit_return(s, TRUE);
26673|      0|            } else {
26674|      0|                emit_source_pos(s, op_token_ptr);
26675|      0|                emit_return(s, FALSE);
26676|      0|            }
26677|      0|            if (js_parse_expect_semi(s))
26678|      0|                goto fail;
26679|      0|        }
26680|      0|        break;
26681|  1.49k|    case TOK_THROW:
26682|  1.49k|        {
26683|  1.49k|            const uint8_t *op_token_ptr;
26684|  1.49k|            op_token_ptr = s->token.ptr;
26685|  1.49k|            if (next_token(s))
26686|      1|                goto fail;
26687|  1.48k|            if (s->got_lf) {
26688|      1|                js_parse_error(s, "line terminator not allowed after throw");
26689|      1|                goto fail;
26690|      1|            }
26691|  1.48k|            if (js_parse_expr(s))
26692|     25|                goto fail;
26693|  1.46k|            emit_source_pos(s, op_token_ptr);
26694|  1.46k|            emit_op(s, OP_throw);
26695|  1.46k|            if (js_parse_expect_semi(s))
26696|     11|                goto fail;
26697|  1.46k|        }
26698|  1.45k|        break;
26699|  4.68k|    case TOK_LET:
26700|  5.00k|    case TOK_CONST:
26701|  9.86k|    haslet:
26702|  9.86k|        if (!(decl_mask & DECL_MASK_OTHER)) {
26703|      1|            js_parse_error(s, "lexical declarations can't appear in single-statement context");
26704|      1|            goto fail;
26705|      1|        }
26706|       |        /* fall thru */
26707|  10.9k|    case TOK_VAR:
26708|  10.9k|        if (next_token(s))
26709|      2|            goto fail;
26710|  10.9k|        if (js_parse_var(s, TRUE, tok, FALSE))
26711|    338|            goto fail;
26712|  10.5k|        if (js_parse_expect_semi(s))
26713|     87|            goto fail;
26714|  10.4k|        break;
26715|  10.4k|    case TOK_IF:
26716|    340|        {
26717|    340|            int label1, label2, mask;
26718|    340|            if (next_token(s))
26719|      1|                goto fail;
26720|       |            /* create a new scope for `let f;if(1) function f(){}` */
26721|    339|            push_scope(s);
26722|    339|            set_eval_ret_undefined(s);
26723|    339|            if (js_parse_expr_paren(s))
26724|    179|                goto fail;
26725|    160|            label1 = emit_goto(s, OP_if_false, -1);
26726|    160|            if (s->cur_func->js_mode & JS_MODE_STRICT)
26727|      0|                mask = 0;
26728|    160|            else
26729|    160|                mask = DECL_MASK_FUNC; /* Annex B.3.4 */
26730|       |
26731|    160|            if (js_parse_statement_or_decl(s, mask))
26732|     80|                goto fail;
26733|       |
26734|     80|            if (s->token.val == TOK_ELSE) {
26735|      0|                label2 = emit_goto(s, OP_goto, -1);
26736|      0|                if (next_token(s))
26737|      0|                    goto fail;
26738|       |
26739|      0|                emit_label(s, label1);
26740|      0|                if (js_parse_statement_or_decl(s, mask))
26741|      0|                    goto fail;
26742|       |
26743|      0|                label1 = label2;
26744|      0|            }
26745|     80|            emit_label(s, label1);
26746|     80|            pop_scope(s);
26747|     80|        }
26748|      0|        break;
26749|      0|    case TOK_WHILE:
26750|      0|        {
26751|      0|            int label_cont, label_break;
26752|      0|            BlockEnv break_entry;
26753|       |
26754|      0|            label_cont = new_label(s);
26755|      0|            label_break = new_label(s);
26756|       |
26757|      0|            push_break_entry(s->cur_func, &break_entry,
26758|      0|                             label_name, label_break, label_cont, 0);
26759|       |
26760|      0|            if (next_token(s))
26761|      0|                goto fail;
26762|       |
26763|      0|            set_eval_ret_undefined(s);
26764|       |
26765|      0|            emit_label(s, label_cont);
26766|      0|            if (js_parse_expr_paren(s))
26767|      0|                goto fail;
26768|      0|            emit_goto(s, OP_if_false, label_break);
26769|       |
26770|      0|            if (js_parse_statement(s))
26771|      0|                goto fail;
26772|      0|            emit_goto(s, OP_goto, label_cont);
26773|       |
26774|      0|            emit_label(s, label_break);
26775|       |
26776|      0|            pop_break_entry(s->cur_func);
26777|      0|        }
26778|      0|        break;
26779|    250|    case TOK_DO:
26780|    250|        {
26781|    250|            int label_cont, label_break, label1;
26782|    250|            BlockEnv break_entry;
26783|       |
26784|    250|            label_cont = new_label(s);
26785|    250|            label_break = new_label(s);
26786|    250|            label1 = new_label(s);
26787|       |
26788|    250|            push_break_entry(s->cur_func, &break_entry,
26789|    250|                             label_name, label_break, label_cont, 0);
26790|       |
26791|    250|            if (next_token(s))
26792|      6|                goto fail;
26793|       |
26794|    244|            emit_label(s, label1);
26795|       |
26796|    244|            set_eval_ret_undefined(s);
26797|       |
26798|    244|            if (js_parse_statement(s))
26799|    243|                goto fail;
26800|       |
26801|      1|            emit_label(s, label_cont);
26802|      1|            if (js_parse_expect(s, TOK_WHILE))
26803|      1|                goto fail;
26804|      0|            if (js_parse_expr_paren(s))
26805|      0|                goto fail;
26806|       |            /* Insert semicolon if missing */
26807|      0|            if (s->token.val == ';') {
26808|      0|                if (next_token(s))
26809|      0|                    goto fail;
26810|      0|            }
26811|      0|            emit_goto(s, OP_if_true, label1);
26812|       |
26813|      0|            emit_label(s, label_break);
26814|       |
26815|      0|            pop_break_entry(s->cur_func);
26816|      0|        }
26817|      0|        break;
26818|  13.9k|    case TOK_FOR:
26819|  13.9k|        {
26820|  13.9k|            int label_cont, label_break, label_body, label_test;
26821|  13.9k|            int pos_cont, pos_body, block_scope_level;
26822|  13.9k|            BlockEnv break_entry;
26823|  13.9k|            int tok, bits;
26824|  13.9k|            BOOL is_async;
26825|       |
26826|  13.9k|            if (next_token(s))
26827|      1|                goto fail;
26828|       |
26829|  13.9k|            set_eval_ret_undefined(s);
26830|  13.9k|            bits = 0;
26831|  13.9k|            is_async = FALSE;
26832|  13.9k|            if (s->token.val == '(') {
26833|  13.9k|                js_parse_skip_parens_token(s, &bits, FALSE);
26834|  13.9k|            } else if (s->token.val == TOK_AWAIT) {
26835|      0|                if (!(s->cur_func->func_kind & JS_FUNC_ASYNC)) {
26836|      0|                    js_parse_error(s, "for await is only valid in asynchronous functions");
26837|      0|                    goto fail;
26838|      0|                }
26839|      0|                is_async = TRUE;
26840|      0|                if (next_token(s))
26841|      0|                    goto fail;
26842|      0|                s->cur_func->has_await = TRUE;
26843|      0|            }
26844|  13.9k|            if (js_parse_expect(s, '('))
26845|      2|                goto fail;
26846|       |
26847|  13.9k|            if (!(bits & SKIP_HAS_SEMI)) {
26848|       |                /* parse for/in or for/of */
26849|  10.8k|                if (js_parse_for_in_of(s, label_name, is_async))
26850|  1.02k|                    goto fail;
26851|  9.83k|                break;
26852|  10.8k|            }
26853|  3.10k|            block_scope_level = s->cur_func->scope_level;
26854|       |
26855|       |            /* create scope for the lexical variables declared in the initial,
26856|       |               test and increment expressions */
26857|  3.10k|            push_scope(s);
26858|       |            /* initial expression */
26859|  3.10k|            tok = s->token.val;
26860|  3.10k|            if (tok != ';') {
26861|    131|                switch (is_let(s, DECL_MASK_OTHER)) {
26862|     10|                case TRUE:
26863|     10|                    tok = TOK_LET;
26864|     10|                    break;
26865|    121|                case FALSE:
26866|    121|                    break;
26867|      0|                default:
26868|      0|                    goto fail;
26869|    131|                }
26870|    131|                if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
26871|     14|                    if (next_token(s))
26872|      0|                        goto fail;
26873|     14|                    if (js_parse_var(s, FALSE, tok, FALSE))
26874|      1|                        goto fail;
26875|    117|                } else {
26876|    117|                    if (js_parse_expr2(s, FALSE))
26877|      3|                        goto fail;
26878|    114|                    emit_op(s, OP_drop);
26879|    114|                }
26880|       |
26881|       |                /* close the closures before the first iteration */
26882|    127|                close_scopes(s, s->cur_func->scope_level, block_scope_level);
26883|    127|            }
26884|  3.09k|            if (js_parse_expect(s, ';'))
26885|      7|                goto fail;
26886|       |
26887|  3.08k|            label_test = new_label(s);
26888|  3.08k|            label_cont = new_label(s);
26889|  3.08k|            label_body = new_label(s);
26890|  3.08k|            label_break = new_label(s);
26891|       |
26892|  3.08k|            push_break_entry(s->cur_func, &break_entry,
26893|  3.08k|                             label_name, label_break, label_cont, 0);
26894|       |
26895|       |            /* test expression */
26896|  3.08k|            if (s->token.val == ';') {
26897|       |                /* no test expression */
26898|  1.42k|                label_test = label_body;
26899|  1.66k|            } else {
26900|  1.66k|                emit_label(s, label_test);
26901|  1.66k|                if (js_parse_expr(s))
26902|     15|                    goto fail;
26903|  1.64k|                emit_goto(s, OP_if_false, label_break);
26904|  1.64k|            }
26905|  3.07k|            if (js_parse_expect(s, ';'))
26906|      4|                goto fail;
26907|       |
26908|  3.07k|            if (s->token.val == ')') {
26909|       |                /* no end expression */
26910|    852|                break_entry.label_cont = label_cont = label_test;
26911|    852|                pos_cont = 0; /* avoid warning */
26912|  2.21k|            } else {
26913|       |                /* skip the end expression */
26914|  2.21k|                emit_goto(s, OP_goto, label_body);
26915|       |
26916|  2.21k|                pos_cont = s->cur_func->byte_code.size;
26917|  2.21k|                emit_label(s, label_cont);
26918|  2.21k|                if (js_parse_expr(s))
26919|     21|                    goto fail;
26920|  2.19k|                emit_op(s, OP_drop);
26921|  2.19k|                if (label_test != label_body)
26922|  1.60k|                    emit_goto(s, OP_goto, label_test);
26923|  2.19k|            }
26924|  3.04k|            if (js_parse_expect(s, ')'))
26925|      2|                goto fail;
26926|       |
26927|  3.04k|            pos_body = s->cur_func->byte_code.size;
26928|  3.04k|            emit_label(s, label_body);
26929|  3.04k|            if (js_parse_statement(s))
26930|  1.03k|                goto fail;
26931|       |
26932|       |            /* close the closures before the next iteration */
26933|       |            /* XXX: check continue case */
26934|  2.01k|            close_scopes(s, s->cur_func->scope_level, block_scope_level);
26935|       |
26936|  2.01k|            if (OPTIMIZE && label_test != label_body && label_cont != label_test) {
26937|       |                /* move the increment code here */
26938|  1.08k|                DynBuf *bc = &s->cur_func->byte_code;
26939|  1.08k|                int chunk_size = pos_body - pos_cont;
26940|  1.08k|                int offset = bc->size - pos_cont;
26941|  1.08k|                int i;
26942|  1.08k|                dbuf_realloc(bc, bc->size + chunk_size);
26943|  1.08k|                dbuf_put(bc, bc->buf + pos_cont, chunk_size);
26944|  1.08k|                memset(bc->buf + pos_cont, OP_nop, chunk_size);
26945|       |                /* increment part ends with a goto */
26946|  1.08k|                s->cur_func->last_opcode_pos = bc->size - 5;
26947|       |                /* relocate labels */
26948|   467k|                for (i = label_cont; i < s->cur_func->label_count; i++) {
26949|   466k|                    LabelSlot *ls = &s->cur_func->label_slots[i];
26950|   466k|                    if (ls->pos >= pos_cont && ls->pos < pos_body)
26951|  2.10k|                        ls->pos += offset;
26952|   466k|                }
26953|  1.08k|            } else {
26954|    926|                emit_goto(s, OP_goto, label_cont);
26955|    926|            }
26956|       |
26957|  2.01k|            emit_label(s, label_break);
26958|       |
26959|  2.01k|            pop_break_entry(s->cur_func);
26960|  2.01k|            pop_scope(s);
26961|  2.01k|        }
26962|      0|        break;
26963|      0|    case TOK_BREAK:
26964|      0|    case TOK_CONTINUE:
26965|      0|        {
26966|      0|            int is_cont = s->token.val - TOK_BREAK;
26967|      0|            int label;
26968|       |
26969|      0|            if (next_token(s))
26970|      0|                goto fail;
26971|      0|            if (!s->got_lf && s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)
26972|      0|                label = s->token.u.ident.atom;
26973|      0|            else
26974|      0|                label = JS_ATOM_NULL;
26975|      0|            if (emit_break(s, label, is_cont))
26976|      0|                goto fail;
26977|      0|            if (label != JS_ATOM_NULL) {
26978|      0|                if (next_token(s))
26979|      0|                    goto fail;
26980|      0|            }
26981|      0|            if (js_parse_expect_semi(s))
26982|      0|                goto fail;
26983|      0|        }
26984|      0|        break;
26985|      0|    case TOK_SWITCH:
26986|      0|        {
26987|      0|            int label_case, label_break, label1;
26988|      0|            int default_label_pos;
26989|      0|            BlockEnv break_entry;
26990|       |
26991|      0|            if (next_token(s))
26992|      0|                goto fail;
26993|       |
26994|      0|            set_eval_ret_undefined(s);
26995|      0|            if (js_parse_expr_paren(s))
26996|      0|                goto fail;
26997|       |
26998|      0|            push_scope(s);
26999|      0|            label_break = new_label(s);
27000|      0|            push_break_entry(s->cur_func, &break_entry,
27001|      0|                             label_name, label_break, -1, 1);
27002|       |
27003|      0|            if (js_parse_expect(s, '{'))
27004|      0|                goto fail;
27005|       |
27006|      0|            default_label_pos = -1;
27007|      0|            label_case = -1;
27008|      0|            while (s->token.val != '}') {
27009|      0|                if (s->token.val == TOK_CASE) {
27010|      0|                    label1 = -1;
27011|      0|                    if (label_case >= 0) {
27012|       |                        /* skip the case if needed */
27013|      0|                        label1 = emit_goto(s, OP_goto, -1);
27014|      0|                    }
27015|      0|                    emit_label(s, label_case);
27016|      0|                    label_case = -1;
27017|      0|                    for (;;) {
27018|       |                        /* parse a sequence of case clauses */
27019|      0|                        if (next_token(s))
27020|      0|                            goto fail;
27021|      0|                        emit_op(s, OP_dup);
27022|      0|                        if (js_parse_expr(s))
27023|      0|                            goto fail;
27024|      0|                        if (js_parse_expect(s, ':'))
27025|      0|                            goto fail;
27026|      0|                        emit_op(s, OP_strict_eq);
27027|      0|                        if (s->token.val == TOK_CASE) {
27028|      0|                            label1 = emit_goto(s, OP_if_true, label1);
27029|      0|                        } else {
27030|      0|                            label_case = emit_goto(s, OP_if_false, -1);
27031|      0|                            emit_label(s, label1);
27032|      0|                            break;
27033|      0|                        }
27034|      0|                    }
27035|      0|                } else if (s->token.val == TOK_DEFAULT) {
27036|      0|                    if (next_token(s))
27037|      0|                        goto fail;
27038|      0|                    if (js_parse_expect(s, ':'))
27039|      0|                        goto fail;
27040|      0|                    if (default_label_pos >= 0) {
27041|      0|                        js_parse_error(s, "duplicate default");
27042|      0|                        goto fail;
27043|      0|                    }
27044|      0|                    if (label_case < 0) {
27045|       |                        /* falling thru direct from switch expression */
27046|      0|                        label_case = emit_goto(s, OP_goto, -1);
27047|      0|                    }
27048|       |                    /* Emit a dummy label opcode. Label will be patched after
27049|       |                       the end of the switch body. Do not use emit_label(s, 0)
27050|       |                       because it would clobber label 0 address, preventing
27051|       |                       proper optimizer operation.
27052|       |                     */
27053|      0|                    emit_op(s, OP_label);
27054|      0|                    emit_u32(s, 0);
27055|      0|                    default_label_pos = s->cur_func->byte_code.size - 4;
27056|      0|                } else {
27057|      0|                    if (label_case < 0) {
27058|       |                        /* falling thru direct from switch expression */
27059|      0|                        js_parse_error(s, "invalid switch statement");
27060|      0|                        goto fail;
27061|      0|                    }
27062|      0|                    if (js_parse_statement_or_decl(s, DECL_MASK_ALL))
27063|      0|                        goto fail;
27064|      0|                }
27065|      0|            }
27066|      0|            if (js_parse_expect(s, '}'))
27067|      0|                goto fail;
27068|      0|            if (default_label_pos >= 0) {
27069|       |                /* Ugly patch for the the `default` label, shameful and risky */
27070|      0|                put_u32(s->cur_func->byte_code.buf + default_label_pos,
27071|      0|                        label_case);
27072|      0|                s->cur_func->label_slots[label_case].pos = default_label_pos + 4;
27073|      0|            } else {
27074|      0|                emit_label(s, label_case);
27075|      0|            }
27076|      0|            emit_label(s, label_break);
27077|      0|            emit_op(s, OP_drop); /* drop the switch expression */
27078|       |
27079|      0|            pop_break_entry(s->cur_func);
27080|      0|            pop_scope(s);
27081|      0|        }
27082|      0|        break;
27083|      0|    case TOK_TRY:
27084|      0|        {
27085|      0|            int label_catch, label_catch2, label_finally, label_end;
27086|      0|            JSAtom name;
27087|      0|            BlockEnv block_env;
27088|       |
27089|      0|            set_eval_ret_undefined(s);
27090|      0|            if (next_token(s))
27091|      0|                goto fail;
27092|      0|            label_catch = new_label(s);
27093|      0|            label_catch2 = new_label(s);
27094|      0|            label_finally = new_label(s);
27095|      0|            label_end = new_label(s);
27096|       |
27097|      0|            emit_goto(s, OP_catch, label_catch);
27098|       |
27099|      0|            push_break_entry(s->cur_func, &block_env,
27100|      0|                             JS_ATOM_NULL, -1, -1, 1);
27101|      0|            block_env.label_finally = label_finally;
27102|       |
27103|      0|            if (js_parse_block(s))
27104|      0|                goto fail;
27105|       |
27106|      0|            pop_break_entry(s->cur_func);
27107|       |
27108|      0|            if (js_is_live_code(s)) {
27109|       |                /* drop the catch offset */
27110|      0|                emit_op(s, OP_drop);
27111|       |                /* must push dummy value to keep same stack size */
27112|      0|                emit_op(s, OP_undefined);
27113|      0|                emit_goto(s, OP_gosub, label_finally);
27114|      0|                emit_op(s, OP_drop);
27115|       |
27116|      0|                emit_goto(s, OP_goto, label_end);
27117|      0|            }
27118|       |
27119|      0|            if (s->token.val == TOK_CATCH) {
27120|      0|                if (next_token(s))
27121|      0|                    goto fail;
27122|       |
27123|      0|                push_scope(s);  /* catch variable */
27124|      0|                emit_label(s, label_catch);
27125|       |
27126|      0|                if (s->token.val == '{') {
27127|       |                    /* support optional-catch-binding feature */
27128|      0|                    emit_op(s, OP_drop);    /* pop the exception object */
27129|      0|                } else {
27130|      0|                    if (js_parse_expect(s, '('))
27131|      0|                        goto fail;
27132|      0|                    if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
27133|      0|                        if (s->token.val == '[' || s->token.val == '{') {
27134|       |                            /* XXX: TOK_LET is not completely correct */
27135|      0|                            if (js_parse_destructuring_element(s, TOK_LET, 0, TRUE, -1, TRUE, FALSE) < 0)
27136|      0|                                goto fail;
27137|      0|                        } else {
27138|      0|                            js_parse_error(s, "identifier expected");
27139|      0|                            goto fail;
27140|      0|                        }
27141|      0|                    } else {
27142|      0|                        name = JS_DupAtom(ctx, s->token.u.ident.atom);
27143|      0|                        if (next_token(s)
27144|      0|                        ||  js_define_var(s, name, TOK_CATCH) < 0) {
27145|      0|                            JS_FreeAtom(ctx, name);
27146|      0|                            goto fail;
27147|      0|                        }
27148|       |                        /* store the exception value in the catch variable */
27149|      0|                        emit_op(s, OP_scope_put_var);
27150|      0|                        emit_u32(s, name);
27151|      0|                        emit_u16(s, s->cur_func->scope_level);
27152|      0|                    }
27153|      0|                    if (js_parse_expect(s, ')'))
27154|      0|                        goto fail;
27155|      0|                }
27156|       |                /* XXX: should keep the address to nop it out if there is no finally block */
27157|      0|                emit_goto(s, OP_catch, label_catch2);
27158|       |
27159|      0|                push_scope(s);  /* catch block */
27160|      0|                push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,
27161|      0|                                 -1, -1, 1);
27162|      0|                block_env.label_finally = label_finally;
27163|       |
27164|      0|                if (js_parse_block(s))
27165|      0|                    goto fail;
27166|       |
27167|      0|                pop_break_entry(s->cur_func);
27168|      0|                pop_scope(s);  /* catch block */
27169|      0|                pop_scope(s);  /* catch variable */
27170|       |
27171|      0|                if (js_is_live_code(s)) {
27172|       |                    /* drop the catch2 offset */
27173|      0|                    emit_op(s, OP_drop);
27174|       |                    /* XXX: should keep the address to nop it out if there is no finally block */
27175|       |                    /* must push dummy value to keep same stack size */
27176|      0|                    emit_op(s, OP_undefined);
27177|      0|                    emit_goto(s, OP_gosub, label_finally);
27178|      0|                    emit_op(s, OP_drop);
27179|      0|                    emit_goto(s, OP_goto, label_end);
27180|      0|                }
27181|       |                /* catch exceptions thrown in the catch block to execute the
27182|       |                 * finally clause and rethrow the exception */
27183|      0|                emit_label(s, label_catch2);
27184|       |                /* catch value is at TOS, no need to push undefined */
27185|      0|                emit_goto(s, OP_gosub, label_finally);
27186|      0|                emit_op(s, OP_throw);
27187|       |
27188|      0|            } else if (s->token.val == TOK_FINALLY) {
27189|       |                /* finally without catch : execute the finally clause
27190|       |                 * and rethrow the exception */
27191|      0|                emit_label(s, label_catch);
27192|       |                /* catch value is at TOS, no need to push undefined */
27193|      0|                emit_goto(s, OP_gosub, label_finally);
27194|      0|                emit_op(s, OP_throw);
27195|      0|            } else {
27196|      0|                js_parse_error(s, "expecting catch or finally");
27197|      0|                goto fail;
27198|      0|            }
27199|      0|            emit_label(s, label_finally);
27200|      0|            if (s->token.val == TOK_FINALLY) {
27201|      0|                int saved_eval_ret_idx = 0; /* avoid warning */
27202|       |
27203|      0|                if (next_token(s))
27204|      0|                    goto fail;
27205|       |                /* on the stack: ret_value gosub_ret_value */
27206|      0|                push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,
27207|      0|                                 -1, -1, 2);
27208|       |
27209|      0|                if (s->cur_func->eval_ret_idx >= 0) {
27210|       |                    /* 'finally' updates eval_ret only if not a normal
27211|       |                       termination */
27212|      0|                    saved_eval_ret_idx =
27213|      0|                        add_var(s->ctx, s->cur_func, JS_ATOM__ret_);
27214|      0|                    if (saved_eval_ret_idx < 0)
27215|      0|                        goto fail;
27216|      0|                    emit_op(s, OP_get_loc);
27217|      0|                    emit_u16(s, s->cur_func->eval_ret_idx);
27218|      0|                    emit_op(s, OP_put_loc);
27219|      0|                    emit_u16(s, saved_eval_ret_idx);
27220|      0|                    set_eval_ret_undefined(s);
27221|      0|                }
27222|       |
27223|      0|                if (js_parse_block(s))
27224|      0|                    goto fail;
27225|       |
27226|      0|                if (s->cur_func->eval_ret_idx >= 0) {
27227|      0|                    emit_op(s, OP_get_loc);
27228|      0|                    emit_u16(s, saved_eval_ret_idx);
27229|      0|                    emit_op(s, OP_put_loc);
27230|      0|                    emit_u16(s, s->cur_func->eval_ret_idx);
27231|      0|                }
27232|      0|                pop_break_entry(s->cur_func);
27233|      0|            }
27234|      0|            emit_op(s, OP_ret);
27235|      0|            emit_label(s, label_end);
27236|      0|        }
27237|      0|        break;
27238|  42.2k|    case ';':
27239|       |        /* empty statement */
27240|  42.2k|        if (next_token(s))
27241|      3|            goto fail;
27242|  42.2k|        break;
27243|  42.2k|    case TOK_WITH:
27244|      0|        if (s->cur_func->js_mode & JS_MODE_STRICT) {
27245|      0|            js_parse_error(s, "invalid keyword: with");
27246|      0|            goto fail;
27247|      0|        } else {
27248|      0|            int with_idx;
27249|       |
27250|      0|            if (next_token(s))
27251|      0|                goto fail;
27252|       |
27253|      0|            if (js_parse_expr_paren(s))
27254|      0|                goto fail;
27255|       |
27256|      0|            push_scope(s);
27257|      0|            with_idx = define_var(s, s->cur_func, JS_ATOM__with_,
27258|      0|                                  JS_VAR_DEF_WITH);
27259|      0|            if (with_idx < 0)
27260|      0|                goto fail;
27261|      0|            emit_op(s, OP_to_object);
27262|      0|            emit_op(s, OP_put_loc);
27263|      0|            emit_u16(s, with_idx);
27264|       |
27265|      0|            set_eval_ret_undefined(s);
27266|      0|            if (js_parse_statement(s))
27267|      0|                goto fail;
27268|       |
27269|       |            /* Popping scope drops lexical context for the with object variable */
27270|      0|            pop_scope(s);
27271|      0|        }
27272|      0|        break;
27273|      0|    case TOK_FUNCTION:
27274|       |        /* ES6 Annex B.3.2 and B.3.3 semantics */
27275|      0|        if (!(decl_mask & DECL_MASK_FUNC))
27276|      0|            goto func_decl_error;
27277|      0|        if (!(decl_mask & DECL_MASK_OTHER) && peek_token(s, FALSE) == '*')
27278|      0|            goto func_decl_error;
27279|      0|        goto parse_func_var;
27280|   178k|    case TOK_IDENT:
27281|   178k|        if (s->token.u.ident.is_reserved) {
27282|      1|            js_parse_error_reserved_identifier(s);
27283|      1|            goto fail;
27284|      1|        }
27285|       |        /* Determine if `let` introduces a Declaration or an ExpressionStatement */
27286|   178k|        switch (is_let(s, decl_mask)) {
27287|  4.86k|        case TRUE:
27288|  4.86k|            tok = TOK_LET;
27289|  4.86k|            goto haslet;
27290|   173k|        case FALSE:
27291|   173k|            break;
27292|      1|        default:
27293|      1|            goto fail;
27294|   178k|        }
27295|   173k|        if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
27296|   173k|            peek_token(s, TRUE) == TOK_FUNCTION) {
27297|      0|            if (!(decl_mask & DECL_MASK_OTHER)) {
27298|      0|            func_decl_error:
27299|      0|                js_parse_error(s, "function declarations can't appear in single-statement context");
27300|      0|                goto fail;
27301|      0|            }
27302|      0|        parse_func_var:
27303|      0|            if (js_parse_function_decl(s, JS_PARSE_FUNC_VAR,
27304|      0|                                       JS_FUNC_NORMAL, JS_ATOM_NULL,
27305|      0|                                       s->token.ptr))
27306|      0|                goto fail;
27307|      0|            break;
27308|      0|        }
27309|   173k|        goto hasexpr;
27310|       |
27311|   173k|    case TOK_CLASS:
27312|      0|        if (!(decl_mask & DECL_MASK_OTHER)) {
27313|      0|            js_parse_error(s, "class declarations can't appear in single-statement context");
27314|      0|            goto fail;
27315|      0|        }
27316|      0|        if (js_parse_class(s, FALSE, JS_PARSE_EXPORT_NONE))
27317|      0|            return -1;
27318|      0|        break;
27319|       |
27320|      0|    case TOK_DEBUGGER:
27321|       |        /* currently no debugger, so just skip the keyword */
27322|      0|        if (next_token(s))
27323|      0|            goto fail;
27324|      0|        if (js_parse_expect_semi(s))
27325|      0|            goto fail;
27326|      0|        break;
27327|       |
27328|      0|    case TOK_ENUM:
27329|      2|    case TOK_EXPORT:
27330|      2|    case TOK_EXTENDS:
27331|      2|        js_unsupported_keyword(s, s->token.u.ident.atom);
27332|      2|        goto fail;
27333|       |
27334|  19.8k|    default:
27335|   193k|    hasexpr:
27336|   193k|        emit_source_pos(s, s->token.ptr);
27337|   193k|        if (js_parse_expr(s))
27338|  8.78k|            goto fail;
27339|   184k|        if (s->cur_func->eval_ret_idx >= 0) {
27340|       |            /* store the expression value so that it can be returned
27341|       |               by eval() */
27342|   126k|            emit_op(s, OP_put_loc);
27343|   126k|            emit_u16(s, s->cur_func->eval_ret_idx);
27344|   126k|        } else {
27345|  57.6k|            emit_op(s, OP_drop); /* drop the result */
27346|  57.6k|        }
27347|   184k|        if (js_parse_expect_semi(s))
27348|    556|            goto fail;
27349|   183k|        break;
27350|   280k|    }
27351|   271k|done:
27352|   271k|    JS_FreeAtom(ctx, label_name);
27353|   271k|    return 0;
27354|  20.6k|fail:
27355|  20.6k|    JS_FreeAtom(ctx, label_name);
27356|  20.6k|    return -1;
27357|   280k|}
27358|       |
27359|       |/* 'name' is freed */
27360|       |static JSModuleDef *js_new_module_def(JSContext *ctx, JSAtom name)
27361|  36.4k|{
27362|  36.4k|    JSModuleDef *m;
27363|  36.4k|    m = js_mallocz(ctx, sizeof(*m));
27364|  36.4k|    if (!m) {
27365|      0|        JS_FreeAtom(ctx, name);
27366|      0|        return NULL;
27367|      0|    }
27368|  36.4k|    m->header.ref_count = 1;
27369|  36.4k|    m->module_name = name;
27370|  36.4k|    m->module_ns = JS_UNDEFINED;
27371|  36.4k|    m->func_obj = JS_UNDEFINED;
27372|  36.4k|    m->eval_exception = JS_UNDEFINED;
27373|  36.4k|    m->meta_obj = JS_UNDEFINED;
27374|  36.4k|    m->promise = JS_UNDEFINED;
27375|  36.4k|    m->resolving_funcs[0] = JS_UNDEFINED;
27376|  36.4k|    m->resolving_funcs[1] = JS_UNDEFINED;
27377|  36.4k|    list_add_tail(&m->link, &ctx->loaded_modules);
27378|  36.4k|    return m;
27379|  36.4k|}
27380|       |
27381|       |static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
27382|       |                               JS_MarkFunc *mark_func)
27383|  73.7k|{
27384|  73.7k|    int i;
27385|       |
27386|  3.67M|    for(i = 0; i < m->export_entries_count; i++) {
27387|  3.60M|        JSExportEntry *me = &m->export_entries[i];
27388|  3.60M|        if (me->export_type == JS_EXPORT_TYPE_LOCAL &&
27389|  3.60M|            me->u.local.var_ref) {
27390|     74|            mark_func(rt, &me->u.local.var_ref->header);
27391|     74|        }
27392|  3.60M|    }
27393|       |
27394|  73.7k|    JS_MarkValue(rt, m->module_ns, mark_func);
27395|  73.7k|    JS_MarkValue(rt, m->func_obj, mark_func);
27396|  73.7k|    JS_MarkValue(rt, m->eval_exception, mark_func);
27397|  73.7k|    JS_MarkValue(rt, m->meta_obj, mark_func);
27398|  73.7k|    JS_MarkValue(rt, m->promise, mark_func);
27399|  73.7k|    JS_MarkValue(rt, m->resolving_funcs[0], mark_func);
27400|  73.7k|    JS_MarkValue(rt, m->resolving_funcs[1], mark_func);
27401|  73.7k|}
27402|       |
27403|       |static void js_free_module_def(JSContext *ctx, JSModuleDef *m)
27404|  35.3k|{
27405|  35.3k|    int i;
27406|       |
27407|  35.3k|    JS_FreeAtom(ctx, m->module_name);
27408|       |
27409|  35.8k|    for(i = 0; i < m->req_module_entries_count; i++) {
27410|    458|        JSReqModuleEntry *rme = &m->req_module_entries[i];
27411|    458|        JS_FreeAtom(ctx, rme->module_name);
27412|    458|    }
27413|  35.3k|    js_free(ctx, m->req_module_entries);
27414|       |
27415|  1.74M|    for(i = 0; i < m->export_entries_count; i++) {
27416|  1.70M|        JSExportEntry *me = &m->export_entries[i];
27417|  1.70M|        if (me->export_type == JS_EXPORT_TYPE_LOCAL)
27418|  1.70M|            free_var_ref(ctx->rt, me->u.local.var_ref);
27419|  1.70M|        JS_FreeAtom(ctx, me->export_name);
27420|  1.70M|        JS_FreeAtom(ctx, me->local_name);
27421|  1.70M|    }
27422|  35.3k|    js_free(ctx, m->export_entries);
27423|       |
27424|  35.3k|    js_free(ctx, m->star_export_entries);
27425|       |
27426|  35.4k|    for(i = 0; i < m->import_entries_count; i++) {
27427|     88|        JSImportEntry *mi = &m->import_entries[i];
27428|     88|        JS_FreeAtom(ctx, mi->import_name);
27429|     88|    }
27430|  35.3k|    js_free(ctx, m->import_entries);
27431|  35.3k|    js_free(ctx, m->async_parent_modules);
27432|       |
27433|  35.3k|    JS_FreeValue(ctx, m->module_ns);
27434|  35.3k|    JS_FreeValue(ctx, m->func_obj);
27435|  35.3k|    JS_FreeValue(ctx, m->eval_exception);
27436|  35.3k|    JS_FreeValue(ctx, m->meta_obj);
27437|  35.3k|    JS_FreeValue(ctx, m->promise);
27438|  35.3k|    JS_FreeValue(ctx, m->resolving_funcs[0]);
27439|  35.3k|    JS_FreeValue(ctx, m->resolving_funcs[1]);
27440|  35.3k|    list_del(&m->link);
27441|  35.3k|    js_free(ctx, m);
27442|  35.3k|}
27443|       |
27444|       |static int add_req_module_entry(JSContext *ctx, JSModuleDef *m,
27445|       |                                JSAtom module_name)
27446|    649|{
27447|    649|    JSReqModuleEntry *rme;
27448|    649|    int i;
27449|       |
27450|       |    /* no need to add the module request if it is already present */
27451|  2.40k|    for(i = 0; i < m->req_module_entries_count; i++) {
27452|  1.94k|        rme = &m->req_module_entries[i];
27453|  1.94k|        if (rme->module_name == module_name)
27454|    191|            return i;
27455|  1.94k|    }
27456|       |
27457|    458|    if (js_resize_array(ctx, (void **)&m->req_module_entries,
27458|    458|                        sizeof(JSReqModuleEntry),
27459|    458|                        &m->req_module_entries_size,
27460|    458|                        m->req_module_entries_count + 1))
27461|      0|        return -1;
27462|    458|    rme = &m->req_module_entries[m->req_module_entries_count++];
27463|    458|    rme->module_name = JS_DupAtom(ctx, module_name);
27464|    458|    rme->module = NULL;
27465|    458|    return i;
27466|    458|}
27467|       |
27468|       |static JSExportEntry *find_export_entry(JSContext *ctx, JSModuleDef *m,
27469|       |                                        JSAtom export_name)
27470|  1.74M|{
27471|  1.74M|    JSExportEntry *me;
27472|  1.74M|    int i;
27473|  52.9M|    for(i = 0; i < m->export_entries_count; i++) {
27474|  51.1M|        me = &m->export_entries[i];
27475|  51.1M|        if (me->export_name == export_name)
27476|      8|            return me;
27477|  51.1M|    }
27478|  1.74M|    return NULL;
27479|  1.74M|}
27480|       |
27481|       |static JSExportEntry *add_export_entry2(JSContext *ctx,
27482|       |                                        JSParseState *s, JSModuleDef *m,
27483|       |                                       JSAtom local_name, JSAtom export_name,
27484|       |                                       JSExportTypeEnum export_type)
27485|  1.74M|{
27486|  1.74M|    JSExportEntry *me;
27487|       |
27488|  1.74M|    if (find_export_entry(ctx, m, export_name)) {
27489|      8|        char buf1[ATOM_GET_STR_BUF_SIZE];
27490|      8|        if (s) {
27491|      8|            js_parse_error(s, "duplicate exported name '%s'",
27492|      8|                           JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name));
27493|      8|        } else {
27494|      0|            JS_ThrowSyntaxErrorAtom(ctx, "duplicate exported name '%s'", export_name);
27495|      0|        }
27496|      8|        return NULL;
27497|      8|    }
27498|       |
27499|  1.74M|    if (js_resize_array(ctx, (void **)&m->export_entries,
27500|  1.74M|                        sizeof(JSExportEntry),
27501|  1.74M|                        &m->export_entries_size,
27502|  1.74M|                        m->export_entries_count + 1))
27503|      0|        return NULL;
27504|  1.74M|    me = &m->export_entries[m->export_entries_count++];
27505|  1.74M|    memset(me, 0, sizeof(*me));
27506|  1.74M|    me->local_name = JS_DupAtom(ctx, local_name);
27507|  1.74M|    me->export_name = JS_DupAtom(ctx, export_name);
27508|  1.74M|    me->export_type = export_type;
27509|  1.74M|    return me;
27510|  1.74M|}
27511|       |
27512|       |static JSExportEntry *add_export_entry(JSParseState *s, JSModuleDef *m,
27513|       |                                       JSAtom local_name, JSAtom export_name,
27514|       |                                       JSExportTypeEnum export_type)
27515|    913|{
27516|    913|    return add_export_entry2(s->ctx, s, m, local_name, export_name,
27517|    913|                             export_type);
27518|    913|}
27519|       |
27520|       |static int add_star_export_entry(JSContext *ctx, JSModuleDef *m,
27521|       |                                 int req_module_idx)
27522|      0|{
27523|      0|    JSStarExportEntry *se;
27524|       |
27525|      0|    if (js_resize_array(ctx, (void **)&m->star_export_entries,
27526|      0|                        sizeof(JSStarExportEntry),
27527|      0|                        &m->star_export_entries_size,
27528|      0|                        m->star_export_entries_count + 1))
27529|      0|        return -1;
27530|      0|    se = &m->star_export_entries[m->star_export_entries_count++];
27531|      0|    se->req_module_idx = req_module_idx;
27532|      0|    return 0;
27533|      0|}
27534|       |
27535|       |/* create a C module */
27536|       |JSModuleDef *JS_NewCModule(JSContext *ctx, const char *name_str,
27537|       |                           JSModuleInitFunc *func)
27538|  35.5k|{
27539|  35.5k|    JSModuleDef *m;
27540|  35.5k|    JSAtom name;
27541|  35.5k|    name = JS_NewAtom(ctx, name_str);
27542|  35.5k|    if (name == JS_ATOM_NULL)
27543|      0|        return NULL;
27544|  35.5k|    m = js_new_module_def(ctx, name);
27545|  35.5k|    m->init_func = func;
27546|  35.5k|    return m;
27547|  35.5k|}
27548|       |
27549|       |int JS_AddModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name)
27550|  1.74M|{
27551|  1.74M|    JSExportEntry *me;
27552|  1.74M|    JSAtom name;
27553|  1.74M|    name = JS_NewAtom(ctx, export_name);
27554|  1.74M|    if (name == JS_ATOM_NULL)
27555|      0|        return -1;
27556|  1.74M|    me = add_export_entry2(ctx, NULL, m, JS_ATOM_NULL, name,
27557|  1.74M|                           JS_EXPORT_TYPE_LOCAL);
27558|  1.74M|    JS_FreeAtom(ctx, name);
27559|  1.74M|    if (!me)
27560|      0|        return -1;
27561|  1.74M|    else
27562|  1.74M|        return 0;
27563|  1.74M|}
27564|       |
27565|       |int JS_SetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name,
27566|       |                       JSValue val)
27567|      0|{
27568|      0|    JSExportEntry *me;
27569|      0|    JSAtom name;
27570|      0|    name = JS_NewAtom(ctx, export_name);
27571|      0|    if (name == JS_ATOM_NULL)
27572|      0|        goto fail;
27573|      0|    me = find_export_entry(ctx, m, name);
27574|      0|    JS_FreeAtom(ctx, name);
27575|      0|    if (!me)
27576|      0|        goto fail;
27577|      0|    set_value(ctx, me->u.local.var_ref->pvalue, val);
27578|      0|    return 0;
27579|      0| fail:
27580|      0|    JS_FreeValue(ctx, val);
27581|      0|    return -1;
27582|      0|}
27583|       |
27584|       |void JS_SetModuleLoaderFunc(JSRuntime *rt,
27585|       |                            JSModuleNormalizeFunc *module_normalize,
27586|       |                            JSModuleLoaderFunc *module_loader, void *opaque)
27587|  17.7k|{
27588|  17.7k|    rt->module_normalize_func = module_normalize;
27589|  17.7k|    rt->module_loader_func = module_loader;
27590|  17.7k|    rt->module_loader_opaque = opaque;
27591|  17.7k|}
27592|       |
27593|       |/* default module filename normalizer */
27594|       |static char *js_default_module_normalize_name(JSContext *ctx,
27595|       |                                              const char *base_name,
27596|       |                                              const char *name)
27597|    118|{
27598|    118|    char *filename, *p;
27599|    118|    const char *r;
27600|    118|    int cap;
27601|    118|    int len;
27602|       |
27603|    118|    if (name[0] != '.') {
27604|       |        /* if no initial dot, the module name is not modified */
27605|     90|        return js_strdup(ctx, name);
27606|     90|    }
27607|       |
27608|     28|    p = strrchr(base_name, '/');
27609|     28|    if (p)
27610|     28|        len = p - base_name;
27611|      0|    else
27612|      0|        len = 0;
27613|       |
27614|     28|    cap = len + strlen(name) + 1 + 1;
27615|     28|    filename = js_malloc(ctx, cap);
27616|     28|    if (!filename)
27617|      0|        return NULL;
27618|     28|    memcpy(filename, base_name, len);
27619|     28|    filename[len] = '\0';
27620|       |
27621|       |    /* we only normalize the leading '..' or '.' */
27622|     28|    r = name;
27623|     73|    for(;;) {
27624|     73|        if (r[0] == '.' && r[1] == '/') {
27625|     23|            r += 2;
27626|     50|        } else if (r[0] == '.' && r[1] == '.' && r[2] == '/') {
27627|       |            /* remove the last path element of filename, except if "."
27628|       |               or ".." */
27629|     25|            if (filename[0] == '\0')
27630|      3|                break;
27631|     22|            p = strrchr(filename, '/');
27632|     22|            if (!p)
27633|      4|                p = filename;
27634|     18|            else
27635|     18|                p++;
27636|     22|            if (!strcmp(p, ".") || !strcmp(p, ".."))
27637|      0|                break;
27638|     22|            if (p > filename)
27639|     18|                p--;
27640|     22|            *p = '\0';
27641|     22|            r += 3;
27642|     25|        } else {
27643|     25|            break;
27644|     25|        }
27645|     73|    }
27646|     28|    if (filename[0] != '\0')
27647|     24|        pstrcat(filename, cap, "/");
27648|     28|    pstrcat(filename, cap, r);
27649|       |    //    printf("normalize: %s %s -> %s\n", base_name, name, filename);
27650|     28|    return filename;
27651|     28|}
27652|       |
27653|       |static JSModuleDef *js_find_loaded_module(JSContext *ctx, JSAtom name)
27654|    118|{
27655|    118|    struct list_head *el;
27656|    118|    JSModuleDef *m;
27657|       |
27658|       |    /* first look at the loaded modules */
27659|    354|    list_for_each(el, &ctx->loaded_modules) {
27660|    354|        m = list_entry(el, JSModuleDef, link);
27661|    354|        if (m->module_name == name)
27662|      0|            return m;
27663|    354|    }
27664|    118|    return NULL;
27665|    118|}
27666|       |
27667|       |/* return NULL in case of exception (e.g. module could not be loaded) */
27668|       |static JSModuleDef *js_host_resolve_imported_module(JSContext *ctx,
27669|       |                                                    const char *base_cname,
27670|       |                                                    const char *cname1)
27671|    118|{
27672|    118|    JSRuntime *rt = ctx->rt;
27673|    118|    JSModuleDef *m;
27674|    118|    char *cname;
27675|    118|    JSAtom module_name;
27676|       |
27677|    118|    if (!rt->module_normalize_func) {
27678|    118|        cname = js_default_module_normalize_name(ctx, base_cname, cname1);
27679|    118|    } else {
27680|      0|        cname = rt->module_normalize_func(ctx, base_cname, cname1,
27681|      0|                                          rt->module_loader_opaque);
27682|      0|    }
27683|    118|    if (!cname)
27684|      0|        return NULL;
27685|       |
27686|    118|    module_name = JS_NewAtom(ctx, cname);
27687|    118|    if (module_name == JS_ATOM_NULL) {
27688|      0|        js_free(ctx, cname);
27689|      0|        return NULL;
27690|      0|    }
27691|       |
27692|       |    /* first look at the loaded modules */
27693|    118|    m = js_find_loaded_module(ctx, module_name);
27694|    118|    if (m) {
27695|      0|        js_free(ctx, cname);
27696|      0|        JS_FreeAtom(ctx, module_name);
27697|      0|        return m;
27698|      0|    }
27699|       |
27700|    118|    JS_FreeAtom(ctx, module_name);
27701|       |
27702|       |    /* load the module */
27703|    118|    if (!rt->module_loader_func) {
27704|       |        /* XXX: use a syntax error ? */
27705|      0|        JS_ThrowReferenceError(ctx, "could not load module '%s'",
27706|      0|                               cname);
27707|      0|        js_free(ctx, cname);
27708|      0|        return NULL;
27709|      0|    }
27710|       |
27711|    118|    m = rt->module_loader_func(ctx, cname, rt->module_loader_opaque);
27712|    118|    js_free(ctx, cname);
27713|    118|    return m;
27714|    118|}
27715|       |
27716|       |static JSModuleDef *js_host_resolve_imported_module_atom(JSContext *ctx,
27717|       |                                                    JSAtom base_module_name,
27718|       |                                                    JSAtom module_name1)
27719|    118|{
27720|    118|    const char *base_cname, *cname;
27721|    118|    JSModuleDef *m;
27722|       |
27723|    118|    base_cname = JS_AtomToCString(ctx, base_module_name);
27724|    118|    if (!base_cname)
27725|      0|        return NULL;
27726|    118|    cname = JS_AtomToCString(ctx, module_name1);
27727|    118|    if (!cname) {
27728|      0|        JS_FreeCString(ctx, base_cname);
27729|      0|        return NULL;
27730|      0|    }
27731|    118|    m = js_host_resolve_imported_module(ctx, base_cname, cname);
27732|    118|    JS_FreeCString(ctx, base_cname);
27733|    118|    JS_FreeCString(ctx, cname);
27734|    118|    return m;
27735|    118|}
27736|       |
27737|       |typedef struct JSResolveEntry {
27738|       |    JSModuleDef *module;
27739|       |    JSAtom name;
27740|       |} JSResolveEntry;
27741|       |
27742|       |typedef struct JSResolveState {
27743|       |    JSResolveEntry *array;
27744|       |    int size;
27745|       |    int count;
27746|       |} JSResolveState;
27747|       |
27748|       |static int find_resolve_entry(JSResolveState *s,
27749|       |                              JSModuleDef *m, JSAtom name)
27750|      0|{
27751|      0|    int i;
27752|      0|    for(i = 0; i < s->count; i++) {
27753|      0|        JSResolveEntry *re = &s->array[i];
27754|      0|        if (re->module == m && re->name == name)
27755|      0|            return i;
27756|      0|    }
27757|      0|    return -1;
27758|      0|}
27759|       |
27760|       |static int add_resolve_entry(JSContext *ctx, JSResolveState *s,
27761|       |                             JSModuleDef *m, JSAtom name)
27762|      0|{
27763|      0|    JSResolveEntry *re;
27764|       |
27765|      0|    if (js_resize_array(ctx, (void **)&s->array,
27766|      0|                        sizeof(JSResolveEntry),
27767|      0|                        &s->size, s->count + 1))
27768|      0|        return -1;
27769|      0|    re = &s->array[s->count++];
27770|      0|    re->module = m;
27771|      0|    re->name = JS_DupAtom(ctx, name);
27772|      0|    return 0;
27773|      0|}
27774|       |
27775|       |typedef enum JSResolveResultEnum {
27776|       |    JS_RESOLVE_RES_EXCEPTION = -1, /* memory alloc error */
27777|       |    JS_RESOLVE_RES_FOUND = 0,
27778|       |    JS_RESOLVE_RES_NOT_FOUND,
27779|       |    JS_RESOLVE_RES_CIRCULAR,
27780|       |    JS_RESOLVE_RES_AMBIGUOUS,
27781|       |} JSResolveResultEnum;
27782|       |
27783|       |static JSResolveResultEnum js_resolve_export1(JSContext *ctx,
27784|       |                                              JSModuleDef **pmodule,
27785|       |                                              JSExportEntry **pme,
27786|       |                                              JSModuleDef *m,
27787|       |                                              JSAtom export_name,
27788|       |                                              JSResolveState *s)
27789|      0|{
27790|      0|    JSExportEntry *me;
27791|       |
27792|      0|    *pmodule = NULL;
27793|      0|    *pme = NULL;
27794|      0|    if (find_resolve_entry(s, m, export_name) >= 0)
27795|      0|        return JS_RESOLVE_RES_CIRCULAR;
27796|      0|    if (add_resolve_entry(ctx, s, m, export_name) < 0)
27797|      0|        return JS_RESOLVE_RES_EXCEPTION;
27798|      0|    me = find_export_entry(ctx, m, export_name);
27799|      0|    if (me) {
27800|      0|        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
27801|       |            /* local export */
27802|      0|            *pmodule = m;
27803|      0|            *pme = me;
27804|      0|            return JS_RESOLVE_RES_FOUND;
27805|      0|        } else {
27806|       |            /* indirect export */
27807|      0|            JSModuleDef *m1;
27808|      0|            m1 = m->req_module_entries[me->u.req_module_idx].module;
27809|      0|            if (me->local_name == JS_ATOM__star_) {
27810|       |                /* export ns from */
27811|      0|                *pmodule = m;
27812|      0|                *pme = me;
27813|      0|                return JS_RESOLVE_RES_FOUND;
27814|      0|            } else {
27815|      0|                return js_resolve_export1(ctx, pmodule, pme, m1,
27816|      0|                                          me->local_name, s);
27817|      0|            }
27818|      0|        }
27819|      0|    } else {
27820|      0|        if (export_name != JS_ATOM_default) {
27821|       |            /* not found in direct or indirect exports: try star exports */
27822|      0|            int i;
27823|       |
27824|      0|            for(i = 0; i < m->star_export_entries_count; i++) {
27825|      0|                JSStarExportEntry *se = &m->star_export_entries[i];
27826|      0|                JSModuleDef *m1, *res_m;
27827|      0|                JSExportEntry *res_me;
27828|      0|                JSResolveResultEnum ret;
27829|       |
27830|      0|                m1 = m->req_module_entries[se->req_module_idx].module;
27831|      0|                ret = js_resolve_export1(ctx, &res_m, &res_me, m1,
27832|      0|                                         export_name, s);
27833|      0|                if (ret == JS_RESOLVE_RES_AMBIGUOUS ||
27834|      0|                    ret == JS_RESOLVE_RES_EXCEPTION) {
27835|      0|                    return ret;
27836|      0|                } else if (ret == JS_RESOLVE_RES_FOUND) {
27837|      0|                    if (*pme != NULL) {
27838|      0|                        if (*pmodule != res_m ||
27839|      0|                            res_me->local_name != (*pme)->local_name) {
27840|      0|                            *pmodule = NULL;
27841|      0|                            *pme = NULL;
27842|      0|                            return JS_RESOLVE_RES_AMBIGUOUS;
27843|      0|                        }
27844|      0|                    } else {
27845|      0|                        *pmodule = res_m;
27846|      0|                        *pme = res_me;
27847|      0|                    }
27848|      0|                }
27849|      0|            }
27850|      0|            if (*pme != NULL)
27851|      0|                return JS_RESOLVE_RES_FOUND;
27852|      0|        }
27853|      0|        return JS_RESOLVE_RES_NOT_FOUND;
27854|      0|    }
27855|      0|}
27856|       |
27857|       |/* If the return value is JS_RESOLVE_RES_FOUND, return the module
27858|       |  (*pmodule) and the corresponding local export entry
27859|       |  (*pme). Otherwise return (NULL, NULL) */
27860|       |static JSResolveResultEnum js_resolve_export(JSContext *ctx,
27861|       |                                             JSModuleDef **pmodule,
27862|       |                                             JSExportEntry **pme,
27863|       |                                             JSModuleDef *m,
27864|       |                                             JSAtom export_name)
27865|      0|{
27866|      0|    JSResolveState ss, *s = &ss;
27867|      0|    int i;
27868|      0|    JSResolveResultEnum ret;
27869|       |
27870|      0|    s->array = NULL;
27871|      0|    s->size = 0;
27872|      0|    s->count = 0;
27873|       |
27874|      0|    ret = js_resolve_export1(ctx, pmodule, pme, m, export_name, s);
27875|       |
27876|      0|    for(i = 0; i < s->count; i++)
27877|      0|        JS_FreeAtom(ctx, s->array[i].name);
27878|      0|    js_free(ctx, s->array);
27879|       |
27880|      0|    return ret;
27881|      0|}
27882|       |
27883|       |static void js_resolve_export_throw_error(JSContext *ctx,
27884|       |                                          JSResolveResultEnum res,
27885|       |                                          JSModuleDef *m, JSAtom export_name)
27886|      0|{
27887|      0|    char buf1[ATOM_GET_STR_BUF_SIZE];
27888|      0|    char buf2[ATOM_GET_STR_BUF_SIZE];
27889|      0|    switch(res) {
27890|      0|    case JS_RESOLVE_RES_EXCEPTION:
27891|      0|        break;
27892|      0|    default:
27893|      0|    case JS_RESOLVE_RES_NOT_FOUND:
27894|      0|        JS_ThrowSyntaxError(ctx, "Could not find export '%s' in module '%s'",
27895|      0|                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
27896|      0|                            JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
27897|      0|        break;
27898|      0|    case JS_RESOLVE_RES_CIRCULAR:
27899|      0|        JS_ThrowSyntaxError(ctx, "circular reference when looking for export '%s' in module '%s'",
27900|      0|                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
27901|      0|                            JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
27902|      0|        break;
27903|      0|    case JS_RESOLVE_RES_AMBIGUOUS:
27904|      0|        JS_ThrowSyntaxError(ctx, "export '%s' in module '%s' is ambiguous",
27905|      0|                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
27906|      0|                            JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
27907|      0|        break;
27908|      0|    }
27909|      0|}
27910|       |
27911|       |
27912|       |typedef enum {
27913|       |    EXPORTED_NAME_AMBIGUOUS,
27914|       |    EXPORTED_NAME_NORMAL,
27915|       |    EXPORTED_NAME_DELAYED,
27916|       |} ExportedNameEntryEnum;
27917|       |
27918|       |typedef struct ExportedNameEntry {
27919|       |    JSAtom export_name;
27920|       |    ExportedNameEntryEnum export_type;
27921|       |    union {
27922|       |        JSExportEntry *me; /* using when the list is built */
27923|       |        JSVarRef *var_ref; /* EXPORTED_NAME_NORMAL */
27924|       |    } u;
27925|       |} ExportedNameEntry;
27926|       |
27927|       |typedef struct GetExportNamesState {
27928|       |    JSModuleDef **modules;
27929|       |    int modules_size;
27930|       |    int modules_count;
27931|       |
27932|       |    ExportedNameEntry *exported_names;
27933|       |    int exported_names_size;
27934|       |    int exported_names_count;
27935|       |} GetExportNamesState;
27936|       |
27937|       |static int find_exported_name(GetExportNamesState *s, JSAtom name)
27938|      0|{
27939|      0|    int i;
27940|      0|    for(i = 0; i < s->exported_names_count; i++) {
27941|      0|        if (s->exported_names[i].export_name == name)
27942|      0|            return i;
27943|      0|    }
27944|      0|    return -1;
27945|      0|}
27946|       |
27947|       |static __exception int get_exported_names(JSContext *ctx,
27948|       |                                          GetExportNamesState *s,
27949|       |                                          JSModuleDef *m, BOOL from_star)
27950|      0|{
27951|      0|    ExportedNameEntry *en;
27952|      0|    int i, j;
27953|       |
27954|       |    /* check circular reference */
27955|      0|    for(i = 0; i < s->modules_count; i++) {
27956|      0|        if (s->modules[i] == m)
27957|      0|            return 0;
27958|      0|    }
27959|      0|    if (js_resize_array(ctx, (void **)&s->modules, sizeof(s->modules[0]),
27960|      0|                        &s->modules_size, s->modules_count + 1))
27961|      0|        return -1;
27962|      0|    s->modules[s->modules_count++] = m;
27963|       |
27964|      0|    for(i = 0; i < m->export_entries_count; i++) {
27965|      0|        JSExportEntry *me = &m->export_entries[i];
27966|      0|        if (from_star && me->export_name == JS_ATOM_default)
27967|      0|            continue;
27968|      0|        j = find_exported_name(s, me->export_name);
27969|      0|        if (j < 0) {
27970|      0|            if (js_resize_array(ctx, (void **)&s->exported_names, sizeof(s->exported_names[0]),
27971|      0|                                &s->exported_names_size,
27972|      0|                                s->exported_names_count + 1))
27973|      0|                return -1;
27974|      0|            en = &s->exported_names[s->exported_names_count++];
27975|      0|            en->export_name = me->export_name;
27976|       |            /* avoid a second lookup for simple module exports */
27977|      0|            if (from_star || me->export_type != JS_EXPORT_TYPE_LOCAL)
27978|      0|                en->u.me = NULL;
27979|      0|            else
27980|      0|                en->u.me = me;
27981|      0|        } else {
27982|      0|            en = &s->exported_names[j];
27983|      0|            en->u.me = NULL;
27984|      0|        }
27985|      0|    }
27986|      0|    for(i = 0; i < m->star_export_entries_count; i++) {
27987|      0|        JSStarExportEntry *se = &m->star_export_entries[i];
27988|      0|        JSModuleDef *m1;
27989|      0|        m1 = m->req_module_entries[se->req_module_idx].module;
27990|      0|        if (get_exported_names(ctx, s, m1, TRUE))
27991|      0|            return -1;
27992|      0|    }
27993|      0|    return 0;
27994|      0|}
27995|       |
27996|       |/* Unfortunately, the spec gives a different behavior from GetOwnProperty ! */
27997|       |static int js_module_ns_has(JSContext *ctx, JSValueConst obj, JSAtom atom)
27998|      0|{
27999|      0|    return (find_own_property1(JS_VALUE_GET_OBJ(obj), atom) != NULL);
28000|      0|}
28001|       |
28002|       |static const JSClassExoticMethods js_module_ns_exotic_methods = {
28003|       |    .has_property = js_module_ns_has,
28004|       |};
28005|       |
28006|       |static int exported_names_cmp(const void *p1, const void *p2, void *opaque)
28007|      0|{
28008|      0|    JSContext *ctx = opaque;
28009|      0|    const ExportedNameEntry *me1 = p1;
28010|      0|    const ExportedNameEntry *me2 = p2;
28011|      0|    JSValue str1, str2;
28012|      0|    int ret;
28013|       |
28014|       |    /* XXX: should avoid allocation memory in atom comparison */
28015|      0|    str1 = JS_AtomToString(ctx, me1->export_name);
28016|      0|    str2 = JS_AtomToString(ctx, me2->export_name);
28017|      0|    if (JS_IsException(str1) || JS_IsException(str2)) {
28018|       |        /* XXX: raise an error ? */
28019|      0|        ret = 0;
28020|      0|    } else {
28021|      0|        ret = js_string_compare(ctx, JS_VALUE_GET_STRING(str1),
28022|      0|                                JS_VALUE_GET_STRING(str2));
28023|      0|    }
28024|      0|    JS_FreeValue(ctx, str1);
28025|      0|    JS_FreeValue(ctx, str2);
28026|      0|    return ret;
28027|      0|}
28028|       |
28029|       |static JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
28030|       |                                     void *opaque)
28031|      0|{
28032|      0|    JSModuleDef *m = opaque;
28033|      0|    JSResolveResultEnum res;
28034|      0|    JSExportEntry *res_me;
28035|      0|    JSModuleDef *res_m;
28036|      0|    JSVarRef *var_ref;
28037|       |
28038|      0|    res = js_resolve_export(ctx, &res_m, &res_me, m, atom);
28039|      0|    if (res != JS_RESOLVE_RES_FOUND) {
28040|       |        /* fail safe: normally no error should happen here except for memory */
28041|      0|        js_resolve_export_throw_error(ctx, res, m, atom);
28042|      0|        return JS_EXCEPTION;
28043|      0|    }
28044|      0|    if (res_me->local_name == JS_ATOM__star_) {
28045|      0|        return JS_GetModuleNamespace(ctx, res_m->req_module_entries[res_me->u.req_module_idx].module);
28046|      0|    } else {
28047|      0|        if (res_me->u.local.var_ref) {
28048|      0|            var_ref = res_me->u.local.var_ref;
28049|      0|        } else {
28050|      0|            JSObject *p1 = JS_VALUE_GET_OBJ(res_m->func_obj);
28051|      0|            var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
28052|      0|        }
28053|       |        /* WARNING: a varref is returned as a string ! */
28054|      0|        return JS_MKPTR(JS_TAG_STRING, var_ref);
28055|      0|    }
28056|      0|}
28057|       |
28058|       |static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
28059|      0|{
28060|      0|    JSValue obj;
28061|      0|    JSObject *p;
28062|      0|    GetExportNamesState s_s, *s = &s_s;
28063|      0|    int i, ret;
28064|      0|    JSProperty *pr;
28065|       |
28066|      0|    obj = JS_NewObjectClass(ctx, JS_CLASS_MODULE_NS);
28067|      0|    if (JS_IsException(obj))
28068|      0|        return obj;
28069|      0|    p = JS_VALUE_GET_OBJ(obj);
28070|       |
28071|      0|    memset(s, 0, sizeof(*s));
28072|      0|    ret = get_exported_names(ctx, s, m, FALSE);
28073|      0|    js_free(ctx, s->modules);
28074|      0|    if (ret)
28075|      0|        goto fail;
28076|       |
28077|       |    /* Resolve the exported names. The ambiguous exports are removed */
28078|      0|    for(i = 0; i < s->exported_names_count; i++) {
28079|      0|        ExportedNameEntry *en = &s->exported_names[i];
28080|      0|        JSResolveResultEnum res;
28081|      0|        JSExportEntry *res_me;
28082|      0|        JSModuleDef *res_m;
28083|       |
28084|      0|        if (en->u.me) {
28085|      0|            res_me = en->u.me; /* fast case: no resolution needed */
28086|      0|            res_m = m;
28087|      0|            res = JS_RESOLVE_RES_FOUND;
28088|      0|        } else {
28089|      0|            res = js_resolve_export(ctx, &res_m, &res_me, m,
28090|      0|                                    en->export_name);
28091|      0|        }
28092|      0|        if (res != JS_RESOLVE_RES_FOUND) {
28093|      0|            if (res != JS_RESOLVE_RES_AMBIGUOUS) {
28094|      0|                js_resolve_export_throw_error(ctx, res, m, en->export_name);
28095|      0|                goto fail;
28096|      0|            }
28097|      0|            en->export_type = EXPORTED_NAME_AMBIGUOUS;
28098|      0|        } else {
28099|      0|            if (res_me->local_name == JS_ATOM__star_) {
28100|      0|                en->export_type = EXPORTED_NAME_DELAYED;
28101|      0|            } else {
28102|      0|                if (res_me->u.local.var_ref) {
28103|      0|                    en->u.var_ref = res_me->u.local.var_ref;
28104|      0|                } else {
28105|      0|                    JSObject *p1 = JS_VALUE_GET_OBJ(res_m->func_obj);
28106|      0|                    en->u.var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
28107|      0|                }
28108|      0|                if (en->u.var_ref == NULL)
28109|      0|                    en->export_type = EXPORTED_NAME_DELAYED;
28110|      0|                else
28111|      0|                    en->export_type = EXPORTED_NAME_NORMAL;
28112|      0|            }
28113|      0|        }
28114|      0|    }
28115|       |
28116|       |    /* sort the exported names */
28117|      0|    rqsort(s->exported_names, s->exported_names_count,
28118|      0|           sizeof(s->exported_names[0]), exported_names_cmp, ctx);
28119|       |
28120|      0|    for(i = 0; i < s->exported_names_count; i++) {
28121|      0|        ExportedNameEntry *en = &s->exported_names[i];
28122|      0|        switch(en->export_type) {
28123|      0|        case EXPORTED_NAME_NORMAL:
28124|      0|            {
28125|      0|                JSVarRef *var_ref = en->u.var_ref;
28126|      0|                pr = add_property(ctx, p, en->export_name,
28127|      0|                                  JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |
28128|      0|                                  JS_PROP_VARREF);
28129|      0|                if (!pr)
28130|      0|                    goto fail;
28131|      0|                var_ref->header.ref_count++;
28132|      0|                pr->u.var_ref = var_ref;
28133|      0|            }
28134|      0|            break;
28135|      0|        case EXPORTED_NAME_DELAYED:
28136|       |            /* the exported namespace or reference may depend on
28137|       |               circular references, so we resolve it lazily */
28138|      0|            if (JS_DefineAutoInitProperty(ctx, obj,
28139|      0|                                          en->export_name,
28140|      0|                                          JS_AUTOINIT_ID_MODULE_NS,
28141|      0|                                          m, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)
28142|      0|            break;
28143|      0|        default:
28144|      0|            break;
28145|      0|        }
28146|      0|    }
28147|       |
28148|      0|    js_free(ctx, s->exported_names);
28149|       |
28150|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_Symbol_toStringTag,
28151|      0|                           JS_AtomToString(ctx, JS_ATOM_Module),
28152|      0|                           0);
28153|       |
28154|      0|    p->extensible = FALSE;
28155|      0|    return obj;
28156|      0| fail:
28157|      0|    js_free(ctx, s->exported_names);
28158|      0|    JS_FreeValue(ctx, obj);
28159|      0|    return JS_EXCEPTION;
28160|      0|}
28161|       |
28162|       |JSValue JS_GetModuleNamespace(JSContext *ctx, JSModuleDef *m)
28163|      0|{
28164|      0|    if (JS_IsUndefined(m->module_ns)) {
28165|      0|        JSValue val;
28166|      0|        val = js_build_module_ns(ctx, m);
28167|      0|        if (JS_IsException(val))
28168|      0|            return JS_EXCEPTION;
28169|      0|        m->module_ns = val;
28170|      0|    }
28171|      0|    return JS_DupValue(ctx, m->module_ns);
28172|      0|}
28173|       |
28174|       |/* Load all the required modules for module 'm' */
28175|       |static int js_resolve_module(JSContext *ctx, JSModuleDef *m)
28176|    485|{
28177|    485|    int i;
28178|    485|    JSModuleDef *m1;
28179|       |
28180|    485|    if (m->resolved)
28181|      0|        return 0;
28182|       |#ifdef DUMP_MODULE_RESOLVE
28183|       |    {
28184|       |        char buf1[ATOM_GET_STR_BUF_SIZE];
28185|       |        printf("resolving module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
28186|       |    }
28187|       |#endif
28188|    485|    m->resolved = TRUE;
28189|       |    /* resolve each requested module */
28190|    485|    for(i = 0; i < m->req_module_entries_count; i++) {
28191|    118|        JSReqModuleEntry *rme = &m->req_module_entries[i];
28192|    118|        m1 = js_host_resolve_imported_module_atom(ctx, m->module_name,
28193|    118|                                                  rme->module_name);
28194|    118|        if (!m1)
28195|    118|            return -1;
28196|      0|        rme->module = m1;
28197|       |        /* already done in js_host_resolve_imported_module() except if
28198|       |           the module was loaded with JS_EvalBinary() */
28199|      0|        if (js_resolve_module(ctx, m1) < 0)
28200|      0|            return -1;
28201|      0|    }
28202|    367|    return 0;
28203|    485|}
28204|       |
28205|       |static JSVarRef *js_create_module_var(JSContext *ctx, BOOL is_lexical)
28206|  7.70k|{
28207|  7.70k|    JSVarRef *var_ref;
28208|  7.70k|    var_ref = js_malloc(ctx, sizeof(JSVarRef));
28209|  7.70k|    if (!var_ref)
28210|      0|        return NULL;
28211|  7.70k|    var_ref->header.ref_count = 1;
28212|  7.70k|    if (is_lexical)
28213|    916|        var_ref->value = JS_UNINITIALIZED;
28214|  6.78k|    else
28215|  6.78k|        var_ref->value = JS_UNDEFINED;
28216|  7.70k|    var_ref->pvalue = &var_ref->value;
28217|  7.70k|    var_ref->is_detached = TRUE;
28218|  7.70k|    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
28219|  7.70k|    return var_ref;
28220|  7.70k|}
28221|       |
28222|       |/* Create the <eval> function associated with the module */
28223|       |static int js_create_module_bytecode_function(JSContext *ctx, JSModuleDef *m)
28224|    367|{
28225|    367|    JSFunctionBytecode *b;
28226|    367|    int i;
28227|    367|    JSVarRef **var_refs;
28228|    367|    JSValue func_obj, bfunc;
28229|    367|    JSObject *p;
28230|       |
28231|    367|    bfunc = m->func_obj;
28232|    367|    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,
28233|    367|                                      JS_CLASS_BYTECODE_FUNCTION);
28234|       |
28235|    367|    if (JS_IsException(func_obj))
28236|      0|        return -1;
28237|    367|    b = JS_VALUE_GET_PTR(bfunc);
28238|       |
28239|    367|    p = JS_VALUE_GET_OBJ(func_obj);
28240|    367|    p->u.func.function_bytecode = b;
28241|    367|    b->header.ref_count++;
28242|    367|    p->u.func.home_object = NULL;
28243|    367|    p->u.func.var_refs = NULL;
28244|    367|    if (b->closure_var_count) {
28245|    366|        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);
28246|    366|        if (!var_refs)
28247|      0|            goto fail;
28248|    366|        p->u.func.var_refs = var_refs;
28249|       |
28250|       |        /* create the global variables. The other variables are
28251|       |           imported from other modules */
28252|  8.06k|        for(i = 0; i < b->closure_var_count; i++) {
28253|  7.70k|            JSClosureVar *cv = &b->closure_var[i];
28254|  7.70k|            JSVarRef *var_ref;
28255|  7.70k|            if (cv->is_local) {
28256|  7.70k|                var_ref = js_create_module_var(ctx, cv->is_lexical);
28257|  7.70k|                if (!var_ref)
28258|      0|                    goto fail;
28259|       |#ifdef DUMP_MODULE_RESOLVE
28260|       |                printf("local %d: %p\n", i, var_ref);
28261|       |#endif
28262|  7.70k|                var_refs[i] = var_ref;
28263|  7.70k|            }
28264|  7.70k|        }
28265|    366|    }
28266|    367|    m->func_obj = func_obj;
28267|    367|    JS_FreeValue(ctx, bfunc);
28268|    367|    return 0;
28269|      0| fail:
28270|      0|    JS_FreeValue(ctx, func_obj);
28271|      0|    return -1;
28272|    367|}
28273|       |
28274|       |/* must be done before js_link_module() because of cyclic references */
28275|       |static int js_create_module_function(JSContext *ctx, JSModuleDef *m)
28276|    367|{
28277|    367|    BOOL is_c_module;
28278|    367|    int i;
28279|    367|    JSVarRef *var_ref;
28280|       |
28281|    367|    if (m->func_created)
28282|      0|        return 0;
28283|       |
28284|    367|    is_c_module = (m->init_func != NULL);
28285|       |
28286|    367|    if (is_c_module) {
28287|       |        /* initialize the exported variables */
28288|      0|        for(i = 0; i < m->export_entries_count; i++) {
28289|      0|            JSExportEntry *me = &m->export_entries[i];
28290|      0|            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
28291|      0|                var_ref = js_create_module_var(ctx, FALSE);
28292|      0|                if (!var_ref)
28293|      0|                    return -1;
28294|      0|                me->u.local.var_ref = var_ref;
28295|      0|            }
28296|      0|        }
28297|    367|    } else {
28298|    367|        if (js_create_module_bytecode_function(ctx, m))
28299|      0|            return -1;
28300|    367|    }
28301|    367|    m->func_created = TRUE;
28302|       |
28303|       |    /* do it on the dependencies */
28304|       |
28305|    367|    for(i = 0; i < m->req_module_entries_count; i++) {
28306|      0|        JSReqModuleEntry *rme = &m->req_module_entries[i];
28307|      0|        if (js_create_module_function(ctx, rme->module) < 0)
28308|      0|            return -1;
28309|      0|    }
28310|       |
28311|    367|    return 0;
28312|    367|}
28313|       |
28314|       |
28315|       |/* Prepare a module to be executed by resolving all the imported
28316|       |   variables. */
28317|       |static int js_inner_module_linking(JSContext *ctx, JSModuleDef *m,
28318|       |                                   JSModuleDef **pstack_top, int index)
28319|    367|{
28320|    367|    int i;
28321|    367|    JSImportEntry *mi;
28322|    367|    JSModuleDef *m1;
28323|    367|    JSVarRef **var_refs, *var_ref;
28324|    367|    JSObject *p;
28325|    367|    BOOL is_c_module;
28326|    367|    JSValue ret_val;
28327|       |
28328|    367|    if (js_check_stack_overflow(ctx->rt, 0)) {
28329|      0|        JS_ThrowStackOverflow(ctx);
28330|      0|        return -1;
28331|      0|    }
28332|       |
28333|       |#ifdef DUMP_MODULE_RESOLVE
28334|       |    {
28335|       |        char buf1[ATOM_GET_STR_BUF_SIZE];
28336|       |        printf("js_inner_module_linking '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
28337|       |    }
28338|       |#endif
28339|       |
28340|    367|    if (m->status == JS_MODULE_STATUS_LINKING ||
28341|    367|        m->status == JS_MODULE_STATUS_LINKED ||
28342|    367|        m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
28343|    367|        m->status == JS_MODULE_STATUS_EVALUATED)
28344|      0|        return index;
28345|       |
28346|    367|    assert(m->status == JS_MODULE_STATUS_UNLINKED);
28347|    367|    m->status = JS_MODULE_STATUS_LINKING;
28348|    367|    m->dfs_index = index;
28349|    367|    m->dfs_ancestor_index = index;
28350|    367|    index++;
28351|       |    /* push 'm' on stack */
28352|    367|    m->stack_prev = *pstack_top;
28353|    367|    *pstack_top = m;
28354|       |
28355|    367|    for(i = 0; i < m->req_module_entries_count; i++) {
28356|      0|        JSReqModuleEntry *rme = &m->req_module_entries[i];
28357|      0|        m1 = rme->module;
28358|      0|        index = js_inner_module_linking(ctx, m1, pstack_top, index);
28359|      0|        if (index < 0)
28360|      0|            goto fail;
28361|      0|        assert(m1->status == JS_MODULE_STATUS_LINKING ||
28362|      0|               m1->status == JS_MODULE_STATUS_LINKED ||
28363|      0|               m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
28364|      0|               m1->status == JS_MODULE_STATUS_EVALUATED);
28365|      0|        if (m1->status == JS_MODULE_STATUS_LINKING) {
28366|      0|            m->dfs_ancestor_index = min_int(m->dfs_ancestor_index,
28367|      0|                                            m1->dfs_ancestor_index);
28368|      0|        }
28369|      0|    }
28370|       |
28371|       |#ifdef DUMP_MODULE_RESOLVE
28372|       |    {
28373|       |        char buf1[ATOM_GET_STR_BUF_SIZE];
28374|       |        printf("instantiating module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
28375|       |    }
28376|       |#endif
28377|       |    /* check the indirect exports */
28378|    827|    for(i = 0; i < m->export_entries_count; i++) {
28379|    460|        JSExportEntry *me = &m->export_entries[i];
28380|    460|        if (me->export_type == JS_EXPORT_TYPE_INDIRECT &&
28381|    460|            me->local_name != JS_ATOM__star_) {
28382|      0|            JSResolveResultEnum ret;
28383|      0|            JSExportEntry *res_me;
28384|      0|            JSModuleDef *res_m, *m1;
28385|      0|            m1 = m->req_module_entries[me->u.req_module_idx].module;
28386|      0|            ret = js_resolve_export(ctx, &res_m, &res_me, m1, me->local_name);
28387|      0|            if (ret != JS_RESOLVE_RES_FOUND) {
28388|      0|                js_resolve_export_throw_error(ctx, ret, m, me->export_name);
28389|      0|                goto fail;
28390|      0|            }
28391|      0|        }
28392|    460|    }
28393|       |
28394|       |#ifdef DUMP_MODULE_RESOLVE
28395|       |    {
28396|       |        printf("exported bindings:\n");
28397|       |        for(i = 0; i < m->export_entries_count; i++) {
28398|       |            JSExportEntry *me = &m->export_entries[i];
28399|       |            printf(" name="); print_atom(ctx, me->export_name);
28400|       |            printf(" local="); print_atom(ctx, me->local_name);
28401|       |            printf(" type=%d idx=%d\n", me->export_type, me->u.local.var_idx);
28402|       |        }
28403|       |    }
28404|       |#endif
28405|       |
28406|    367|    is_c_module = (m->init_func != NULL);
28407|       |
28408|    367|    if (!is_c_module) {
28409|    367|        p = JS_VALUE_GET_OBJ(m->func_obj);
28410|    367|        var_refs = p->u.func.var_refs;
28411|       |
28412|    367|        for(i = 0; i < m->import_entries_count; i++) {
28413|      0|            mi = &m->import_entries[i];
28414|       |#ifdef DUMP_MODULE_RESOLVE
28415|       |            printf("import var_idx=%d name=", mi->var_idx);
28416|       |            print_atom(ctx, mi->import_name);
28417|       |            printf(": ");
28418|       |#endif
28419|      0|            m1 = m->req_module_entries[mi->req_module_idx].module;
28420|      0|            if (mi->import_name == JS_ATOM__star_) {
28421|      0|                JSValue val;
28422|       |                /* name space import */
28423|      0|                val = JS_GetModuleNamespace(ctx, m1);
28424|      0|                if (JS_IsException(val))
28425|      0|                    goto fail;
28426|      0|                set_value(ctx, &var_refs[mi->var_idx]->value, val);
28427|       |#ifdef DUMP_MODULE_RESOLVE
28428|       |                printf("namespace\n");
28429|       |#endif
28430|      0|            } else {
28431|      0|                JSResolveResultEnum ret;
28432|      0|                JSExportEntry *res_me;
28433|      0|                JSModuleDef *res_m;
28434|      0|                JSObject *p1;
28435|       |
28436|      0|                ret = js_resolve_export(ctx, &res_m,
28437|      0|                                        &res_me, m1, mi->import_name);
28438|      0|                if (ret != JS_RESOLVE_RES_FOUND) {
28439|      0|                    js_resolve_export_throw_error(ctx, ret, m1, mi->import_name);
28440|      0|                    goto fail;
28441|      0|                }
28442|      0|                if (res_me->local_name == JS_ATOM__star_) {
28443|      0|                    JSValue val;
28444|      0|                    JSModuleDef *m2;
28445|       |                    /* name space import from */
28446|      0|                    m2 = res_m->req_module_entries[res_me->u.req_module_idx].module;
28447|      0|                    val = JS_GetModuleNamespace(ctx, m2);
28448|      0|                    if (JS_IsException(val))
28449|      0|                        goto fail;
28450|      0|                    var_ref = js_create_module_var(ctx, TRUE);
28451|      0|                    if (!var_ref) {
28452|      0|                        JS_FreeValue(ctx, val);
28453|      0|                        goto fail;
28454|      0|                    }
28455|      0|                    set_value(ctx, &var_ref->value, val);
28456|      0|                    var_refs[mi->var_idx] = var_ref;
28457|       |#ifdef DUMP_MODULE_RESOLVE
28458|       |                    printf("namespace from\n");
28459|       |#endif
28460|      0|                } else {
28461|      0|                    var_ref = res_me->u.local.var_ref;
28462|      0|                    if (!var_ref) {
28463|      0|                        p1 = JS_VALUE_GET_OBJ(res_m->func_obj);
28464|      0|                        var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
28465|      0|                    }
28466|      0|                    var_ref->header.ref_count++;
28467|      0|                    var_refs[mi->var_idx] = var_ref;
28468|       |#ifdef DUMP_MODULE_RESOLVE
28469|       |                    printf("local export (var_ref=%p)\n", var_ref);
28470|       |#endif
28471|      0|                }
28472|      0|            }
28473|      0|        }
28474|       |
28475|       |        /* keep the exported variables in the module export entries (they
28476|       |           are used when the eval function is deleted and cannot be
28477|       |           initialized before in case imports are exported) */
28478|    827|        for(i = 0; i < m->export_entries_count; i++) {
28479|    460|            JSExportEntry *me = &m->export_entries[i];
28480|    460|            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
28481|    460|                var_ref = var_refs[me->u.local.var_idx];
28482|    460|                var_ref->header.ref_count++;
28483|    460|                me->u.local.var_ref = var_ref;
28484|    460|            }
28485|    460|        }
28486|       |
28487|       |        /* initialize the global variables */
28488|    367|        ret_val = JS_Call(ctx, m->func_obj, JS_TRUE, 0, NULL);
28489|    367|        if (JS_IsException(ret_val))
28490|      0|            goto fail;
28491|    367|        JS_FreeValue(ctx, ret_val);
28492|    367|    }
28493|       |
28494|    367|    assert(m->dfs_ancestor_index <= m->dfs_index);
28495|    367|    if (m->dfs_index == m->dfs_ancestor_index) {
28496|    367|        for(;;) {
28497|       |            /* pop m1 from stack */
28498|    367|            m1 = *pstack_top;
28499|    367|            *pstack_top = m1->stack_prev;
28500|    367|            m1->status = JS_MODULE_STATUS_LINKED;
28501|    367|            if (m1 == m)
28502|    367|                break;
28503|    367|        }
28504|    367|    }
28505|       |
28506|       |#ifdef DUMP_MODULE_RESOLVE
28507|       |    printf("js_inner_module_linking done\n");
28508|       |#endif
28509|    367|    return index;
28510|      0| fail:
28511|      0|    return -1;
28512|    367|}
28513|       |
28514|       |/* Prepare a module to be executed by resolving all the imported
28515|       |   variables. */
28516|       |static int js_link_module(JSContext *ctx, JSModuleDef *m)
28517|    367|{
28518|    367|    JSModuleDef *stack_top, *m1;
28519|       |
28520|       |#ifdef DUMP_MODULE_RESOLVE
28521|       |    {
28522|       |        char buf1[ATOM_GET_STR_BUF_SIZE];
28523|       |        printf("js_link_module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
28524|       |    }
28525|       |#endif
28526|    367|    assert(m->status == JS_MODULE_STATUS_UNLINKED ||
28527|    367|           m->status == JS_MODULE_STATUS_LINKED ||
28528|    367|           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
28529|    367|           m->status == JS_MODULE_STATUS_EVALUATED);
28530|    367|    stack_top = NULL;
28531|    367|    if (js_inner_module_linking(ctx, m, &stack_top, 0) < 0) {
28532|      0|        while (stack_top != NULL) {
28533|      0|            m1 = stack_top;
28534|      0|            assert(m1->status == JS_MODULE_STATUS_LINKING);
28535|      0|            m1->status = JS_MODULE_STATUS_UNLINKED;
28536|      0|            stack_top = m1->stack_prev;
28537|      0|        }
28538|      0|        return -1;
28539|      0|    }
28540|    367|    assert(stack_top == NULL);
28541|    367|    assert(m->status == JS_MODULE_STATUS_LINKED ||
28542|    367|           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
28543|    367|           m->status == JS_MODULE_STATUS_EVALUATED);
28544|    367|    return 0;
28545|    367|}
28546|       |
28547|       |/* return JS_ATOM_NULL if the name cannot be found. Only works with
28548|       |   not striped bytecode functions. */
28549|       |JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels)
28550|      0|{
28551|      0|    JSStackFrame *sf;
28552|      0|    JSFunctionBytecode *b;
28553|      0|    JSObject *p;
28554|       |    /* XXX: currently we just use the filename of the englobing
28555|       |       function from the debug info. May need to add a ScriptOrModule
28556|       |       info in JSFunctionBytecode. */
28557|      0|    sf = ctx->rt->current_stack_frame;
28558|      0|    if (!sf)
28559|      0|        return JS_ATOM_NULL;
28560|      0|    while (n_stack_levels-- > 0) {
28561|      0|        sf = sf->prev_frame;
28562|      0|        if (!sf)
28563|      0|            return JS_ATOM_NULL;
28564|      0|    }
28565|      0|    for(;;) {
28566|      0|        if (JS_VALUE_GET_TAG(sf->cur_func) != JS_TAG_OBJECT)
28567|      0|            return JS_ATOM_NULL;
28568|      0|        p = JS_VALUE_GET_OBJ(sf->cur_func);
28569|      0|        if (!js_class_has_bytecode(p->class_id))
28570|      0|            return JS_ATOM_NULL;
28571|      0|        b = p->u.func.function_bytecode;
28572|      0|        if (!b->is_direct_or_indirect_eval) {
28573|      0|            if (!b->has_debug)
28574|      0|                return JS_ATOM_NULL;
28575|      0|            return JS_DupAtom(ctx, b->debug.filename);
28576|      0|        } else {
28577|      0|            sf = sf->prev_frame;
28578|      0|            if (!sf)
28579|      0|                return JS_ATOM_NULL;
28580|      0|        }
28581|      0|    }
28582|      0|}
28583|       |
28584|       |JSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m)
28585|    367|{
28586|    367|    return JS_DupAtom(ctx, m->module_name);
28587|    367|}
28588|       |
28589|       |JSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m)
28590|    367|{
28591|    367|    JSValue obj;
28592|       |    /* allocate meta_obj only if requested to save memory */
28593|    367|    obj = m->meta_obj;
28594|    367|    if (JS_IsUndefined(obj)) {
28595|    367|        obj = JS_NewObjectProto(ctx, JS_NULL);
28596|    367|        if (JS_IsException(obj))
28597|      0|            return JS_EXCEPTION;
28598|    367|        m->meta_obj = obj;
28599|    367|    }
28600|    367|    return JS_DupValue(ctx, obj);
28601|    367|}
28602|       |
28603|       |static JSValue js_import_meta(JSContext *ctx)
28604|      0|{
28605|      0|    JSAtom filename;
28606|      0|    JSModuleDef *m;
28607|       |
28608|      0|    filename = JS_GetScriptOrModuleName(ctx, 0);
28609|      0|    if (filename == JS_ATOM_NULL)
28610|      0|        goto fail;
28611|       |
28612|       |    /* XXX: inefficient, need to add a module or script pointer in
28613|       |       JSFunctionBytecode */
28614|      0|    m = js_find_loaded_module(ctx, filename);
28615|      0|    JS_FreeAtom(ctx, filename);
28616|      0|    if (!m) {
28617|      0|    fail:
28618|      0|        JS_ThrowTypeError(ctx, "import.meta not supported in this context");
28619|      0|        return JS_EXCEPTION;
28620|      0|    }
28621|      0|    return JS_GetImportMeta(ctx, m);
28622|      0|}
28623|       |
28624|       |static JSValue JS_NewModuleValue(JSContext *ctx, JSModuleDef *m)
28625|    367|{
28626|    367|    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
28627|    367|}
28628|       |
28629|       |static JSValue js_load_module_rejected(JSContext *ctx, JSValueConst this_val,
28630|       |                                       int argc, JSValueConst *argv, int magic, JSValue *func_data)
28631|      0|{
28632|      0|    JSValueConst *resolving_funcs = (JSValueConst *)func_data;
28633|      0|    JSValueConst error;
28634|      0|    JSValue ret;
28635|       |
28636|       |    /* XXX: check if the test is necessary */
28637|      0|    if (argc >= 1)
28638|      0|        error = argv[0];
28639|      0|    else
28640|      0|        error = JS_UNDEFINED;
28641|      0|    ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
28642|      0|                  1, &error);
28643|      0|    JS_FreeValue(ctx, ret);
28644|      0|    return JS_UNDEFINED;
28645|      0|}
28646|       |
28647|       |static JSValue js_load_module_fulfilled(JSContext *ctx, JSValueConst this_val,
28648|       |                                        int argc, JSValueConst *argv, int magic, JSValue *func_data)
28649|      0|{
28650|      0|    JSValueConst *resolving_funcs = (JSValueConst *)func_data;
28651|      0|    JSModuleDef *m = JS_VALUE_GET_PTR(func_data[2]);
28652|      0|    JSValue ret, ns;
28653|       |
28654|       |    /* return the module namespace */
28655|      0|    ns = JS_GetModuleNamespace(ctx, m);
28656|      0|    if (JS_IsException(ns)) {
28657|      0|        JSValue err = JS_GetException(ctx);
28658|      0|        js_load_module_rejected(ctx, JS_UNDEFINED, 1, (JSValueConst *)&err, 0, func_data);
28659|      0|        return JS_UNDEFINED;
28660|      0|    }
28661|      0|    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
28662|      0|                   1, (JSValueConst *)&ns);
28663|      0|    JS_FreeValue(ctx, ret);
28664|      0|    JS_FreeValue(ctx, ns);
28665|      0|    return JS_UNDEFINED;
28666|      0|}
28667|       |
28668|       |static void JS_LoadModuleInternal(JSContext *ctx, const char *basename,
28669|       |                                  const char *filename,
28670|       |                                  JSValueConst *resolving_funcs)
28671|      0|{
28672|      0|    JSValue evaluate_promise;
28673|      0|    JSModuleDef *m;
28674|      0|    JSValue ret, err, func_obj, evaluate_resolving_funcs[2];
28675|      0|    JSValueConst func_data[3];
28676|       |
28677|      0|    m = js_host_resolve_imported_module(ctx, basename, filename);
28678|      0|    if (!m)
28679|      0|        goto fail;
28680|       |
28681|      0|    if (js_resolve_module(ctx, m) < 0) {
28682|      0|        js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
28683|      0|        goto fail;
28684|      0|    }
28685|       |
28686|       |    /* Evaluate the module code */
28687|      0|    func_obj = JS_NewModuleValue(ctx, m);
28688|      0|    evaluate_promise = JS_EvalFunction(ctx, func_obj);
28689|      0|    if (JS_IsException(evaluate_promise)) {
28690|      0|    fail:
28691|      0|        err = JS_GetException(ctx);
28692|      0|        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
28693|      0|                      1, (JSValueConst *)&err);
28694|      0|        JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
28695|      0|        JS_FreeValue(ctx, err);
28696|      0|        return;
28697|      0|    }
28698|       |
28699|      0|    func_obj = JS_NewModuleValue(ctx, m);
28700|      0|    func_data[0] = resolving_funcs[0];
28701|      0|    func_data[1] = resolving_funcs[1];
28702|      0|    func_data[2] = func_obj;
28703|      0|    evaluate_resolving_funcs[0] = JS_NewCFunctionData(ctx, js_load_module_fulfilled, 0, 0, 3, func_data);
28704|      0|    evaluate_resolving_funcs[1] = JS_NewCFunctionData(ctx, js_load_module_rejected, 0, 0, 3, func_data);
28705|      0|    JS_FreeValue(ctx, func_obj);
28706|      0|    ret = js_promise_then(ctx, evaluate_promise, 2, (JSValueConst *)evaluate_resolving_funcs);
28707|      0|    JS_FreeValue(ctx, ret);
28708|      0|    JS_FreeValue(ctx, evaluate_resolving_funcs[0]);
28709|      0|    JS_FreeValue(ctx, evaluate_resolving_funcs[1]);
28710|      0|    JS_FreeValue(ctx, evaluate_promise);
28711|      0|}
28712|       |
28713|       |/* Return a promise or an exception in case of memory error. Used by
28714|       |   os.Worker() */
28715|       |JSValue JS_LoadModule(JSContext *ctx, const char *basename,
28716|       |                      const char *filename)
28717|      0|{
28718|      0|    JSValue promise, resolving_funcs[2];
28719|       |
28720|      0|    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
28721|      0|    if (JS_IsException(promise))
28722|      0|        return JS_EXCEPTION;
28723|      0|    JS_LoadModuleInternal(ctx, basename, filename,
28724|      0|                          (JSValueConst *)resolving_funcs);
28725|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
28726|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
28727|      0|    return promise;
28728|      0|}
28729|       |
28730|       |static JSValue js_dynamic_import_job(JSContext *ctx,
28731|       |                                     int argc, JSValueConst *argv)
28732|      0|{
28733|      0|    JSValueConst *resolving_funcs = argv;
28734|      0|    JSValueConst basename_val = argv[2];
28735|      0|    JSValueConst specifier = argv[3];
28736|      0|    const char *basename = NULL, *filename;
28737|      0|    JSValue ret, err;
28738|       |
28739|      0|    if (!JS_IsString(basename_val)) {
28740|      0|        JS_ThrowTypeError(ctx, "no function filename for import()");
28741|      0|        goto exception;
28742|      0|    }
28743|      0|    basename = JS_ToCString(ctx, basename_val);
28744|      0|    if (!basename)
28745|      0|        goto exception;
28746|       |
28747|      0|    filename = JS_ToCString(ctx, specifier);
28748|      0|    if (!filename)
28749|      0|        goto exception;
28750|       |
28751|      0|    JS_LoadModuleInternal(ctx, basename, filename,
28752|      0|                          resolving_funcs);
28753|      0|    JS_FreeCString(ctx, filename);
28754|      0|    JS_FreeCString(ctx, basename);
28755|      0|    return JS_UNDEFINED;
28756|      0| exception:
28757|      0|    err = JS_GetException(ctx);
28758|      0|    ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
28759|      0|                   1, (JSValueConst *)&err);
28760|      0|    JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
28761|      0|    JS_FreeValue(ctx, err);
28762|      0|    JS_FreeCString(ctx, basename);
28763|      0|    return JS_UNDEFINED;
28764|      0|}
28765|       |
28766|       |static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
28767|      0|{
28768|      0|    JSAtom basename;
28769|      0|    JSValue promise, resolving_funcs[2], basename_val;
28770|      0|    JSValueConst args[4];
28771|       |
28772|      0|    basename = JS_GetScriptOrModuleName(ctx, 0);
28773|      0|    if (basename == JS_ATOM_NULL)
28774|      0|        basename_val = JS_NULL;
28775|      0|    else
28776|      0|        basename_val = JS_AtomToValue(ctx, basename);
28777|      0|    JS_FreeAtom(ctx, basename);
28778|      0|    if (JS_IsException(basename_val))
28779|      0|        return basename_val;
28780|       |
28781|      0|    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
28782|      0|    if (JS_IsException(promise)) {
28783|      0|        JS_FreeValue(ctx, basename_val);
28784|      0|        return promise;
28785|      0|    }
28786|       |
28787|      0|    args[0] = resolving_funcs[0];
28788|      0|    args[1] = resolving_funcs[1];
28789|      0|    args[2] = basename_val;
28790|      0|    args[3] = specifier;
28791|       |
28792|       |    /* cannot run JS_LoadModuleInternal synchronously because it would
28793|       |       cause an unexpected recursion in js_evaluate_module() */
28794|      0|    JS_EnqueueJob(ctx, js_dynamic_import_job, 4, args);
28795|       |
28796|      0|    JS_FreeValue(ctx, basename_val);
28797|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
28798|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
28799|      0|    return promise;
28800|      0|}
28801|       |
28802|       |static void js_set_module_evaluated(JSContext *ctx, JSModuleDef *m)
28803|      0|{
28804|      0|    m->status = JS_MODULE_STATUS_EVALUATED;
28805|      0|    if (!JS_IsUndefined(m->promise)) {
28806|      0|        JSValue value, ret_val;
28807|      0|        assert(m->cycle_root == m);
28808|      0|        value = JS_UNDEFINED;
28809|      0|        ret_val = JS_Call(ctx, m->resolving_funcs[0], JS_UNDEFINED,
28810|      0|                          1, (JSValueConst *)&value);
28811|      0|        JS_FreeValue(ctx, ret_val);
28812|      0|    }
28813|      0|}
28814|       |
28815|       |typedef struct {
28816|       |    JSModuleDef **tab;
28817|       |    int count;
28818|       |    int size;
28819|       |} ExecModuleList;
28820|       |
28821|       |/* XXX: slow. Could use a linked list instead of ExecModuleList */
28822|       |static BOOL find_in_exec_module_list(ExecModuleList *exec_list, JSModuleDef *m)
28823|      0|{
28824|      0|    int i;
28825|      0|    for(i = 0; i < exec_list->count; i++) {
28826|      0|        if (exec_list->tab[i] == m)
28827|      0|            return TRUE;
28828|      0|    }
28829|      0|    return FALSE;
28830|      0|}
28831|       |
28832|       |static int gather_available_ancestors(JSContext *ctx, JSModuleDef *module,
28833|       |                                      ExecModuleList *exec_list)
28834|      0|{
28835|      0|    int i;
28836|       |
28837|      0|    if (js_check_stack_overflow(ctx->rt, 0)) {
28838|      0|        JS_ThrowStackOverflow(ctx);
28839|      0|        return -1;
28840|      0|    }
28841|      0|    for(i = 0; i < module->async_parent_modules_count; i++) {
28842|      0|        JSModuleDef *m = module->async_parent_modules[i];
28843|      0|        if (!find_in_exec_module_list(exec_list, m) &&
28844|      0|            !m->cycle_root->eval_has_exception) {
28845|      0|            assert(m->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
28846|      0|            assert(!m->eval_has_exception);
28847|      0|            assert(m->async_evaluation);
28848|      0|            assert(m->pending_async_dependencies > 0);
28849|      0|            m->pending_async_dependencies--;
28850|      0|            if (m->pending_async_dependencies == 0) {
28851|      0|                if (js_resize_array(ctx, (void **)&exec_list->tab, sizeof(exec_list->tab[0]), &exec_list->size, exec_list->count + 1)) {
28852|      0|                    return -1;
28853|      0|                }
28854|      0|                exec_list->tab[exec_list->count++] = m;
28855|      0|                if (!m->has_tla) {
28856|      0|                    if (gather_available_ancestors(ctx, m, exec_list))
28857|      0|                        return -1;
28858|      0|                }
28859|      0|            }
28860|      0|        }
28861|      0|    }
28862|      0|    return 0;
28863|      0|}
28864|       |
28865|       |static int exec_module_list_cmp(const void *p1, const void *p2, void *opaque)
28866|      0|{
28867|      0|    JSModuleDef *m1 = *(JSModuleDef **)p1;
28868|      0|    JSModuleDef *m2 = *(JSModuleDef **)p2;
28869|      0|    return (m1->async_evaluation_timestamp > m2->async_evaluation_timestamp) -
28870|      0|        (m1->async_evaluation_timestamp < m2->async_evaluation_timestamp);
28871|      0|}
28872|       |
28873|       |static int js_execute_async_module(JSContext *ctx, JSModuleDef *m);
28874|       |static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
28875|       |                                  JSValue *pvalue);
28876|       |
28877|       |static JSValue js_async_module_execution_rejected(JSContext *ctx, JSValueConst this_val,
28878|       |                                                  int argc, JSValueConst *argv, int magic, JSValue *func_data)
28879|      0|{
28880|      0|    JSModuleDef *module = JS_VALUE_GET_PTR(func_data[0]);
28881|      0|    JSValueConst error = argv[0];
28882|      0|    int i;
28883|       |
28884|      0|    if (js_check_stack_overflow(ctx->rt, 0))
28885|      0|        return JS_ThrowStackOverflow(ctx);
28886|       |
28887|      0|    if (module->status == JS_MODULE_STATUS_EVALUATED) {
28888|      0|        assert(module->eval_has_exception);
28889|      0|        return JS_UNDEFINED;
28890|      0|    }
28891|       |
28892|      0|    assert(module->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
28893|      0|    assert(!module->eval_has_exception);
28894|      0|    assert(module->async_evaluation);
28895|       |
28896|      0|    module->eval_has_exception = TRUE;
28897|      0|    module->eval_exception = JS_DupValue(ctx, error);
28898|      0|    module->status = JS_MODULE_STATUS_EVALUATED;
28899|       |
28900|      0|    for(i = 0; i < module->async_parent_modules_count; i++) {
28901|      0|        JSModuleDef *m = module->async_parent_modules[i];
28902|      0|        JSValue m_obj = JS_NewModuleValue(ctx, m);
28903|      0|        js_async_module_execution_rejected(ctx, JS_UNDEFINED, 1, &error, 0,
28904|      0|                                           &m_obj);
28905|      0|        JS_FreeValue(ctx, m_obj);
28906|      0|    }
28907|       |
28908|      0|    if (!JS_IsUndefined(module->promise)) {
28909|      0|        JSValue ret_val;
28910|      0|        assert(module->cycle_root == module);
28911|      0|        ret_val = JS_Call(ctx, module->resolving_funcs[1], JS_UNDEFINED,
28912|      0|                          1, &error);
28913|      0|        JS_FreeValue(ctx, ret_val);
28914|      0|    }
28915|      0|    return JS_UNDEFINED;
28916|      0|}
28917|       |
28918|       |static JSValue js_async_module_execution_fulfilled(JSContext *ctx, JSValueConst this_val,
28919|       |                                                   int argc, JSValueConst *argv, int magic, JSValue *func_data)
28920|      0|{
28921|      0|    JSModuleDef *module = JS_VALUE_GET_PTR(func_data[0]);
28922|      0|    ExecModuleList exec_list_s, *exec_list = &exec_list_s;
28923|      0|    int i;
28924|       |
28925|      0|    if (module->status == JS_MODULE_STATUS_EVALUATED) {
28926|      0|        assert(module->eval_has_exception);
28927|      0|        return JS_UNDEFINED;
28928|      0|    }
28929|      0|    assert(module->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
28930|      0|    assert(!module->eval_has_exception);
28931|      0|    assert(module->async_evaluation);
28932|      0|    module->async_evaluation = FALSE;
28933|      0|    js_set_module_evaluated(ctx, module);
28934|       |
28935|      0|    exec_list->tab = NULL;
28936|      0|    exec_list->count = 0;
28937|      0|    exec_list->size = 0;
28938|       |
28939|      0|    if (gather_available_ancestors(ctx, module, exec_list) < 0) {
28940|      0|        js_free(ctx, exec_list->tab);
28941|      0|        return JS_EXCEPTION;
28942|      0|    }
28943|       |
28944|       |    /* sort by increasing async_evaluation timestamp */
28945|      0|    rqsort(exec_list->tab, exec_list->count, sizeof(exec_list->tab[0]),
28946|      0|           exec_module_list_cmp, NULL);
28947|       |
28948|      0|    for(i = 0; i < exec_list->count; i++) {
28949|      0|        JSModuleDef *m = exec_list->tab[i];
28950|      0|        if (m->status == JS_MODULE_STATUS_EVALUATED) {
28951|      0|            assert(m->eval_has_exception);
28952|      0|        } else if (m->has_tla) {
28953|      0|            js_execute_async_module(ctx, m);
28954|      0|        } else {
28955|      0|            JSValue error;
28956|      0|            if (js_execute_sync_module(ctx, m, &error) < 0) {
28957|      0|                JSValue m_obj = JS_NewModuleValue(ctx, m);
28958|      0|                js_async_module_execution_rejected(ctx, JS_UNDEFINED,
28959|      0|                                                   1, (JSValueConst *)&error, 0,
28960|      0|                                                   &m_obj);
28961|      0|                JS_FreeValue(ctx, m_obj);
28962|      0|                JS_FreeValue(ctx, error);
28963|      0|            } else {
28964|      0|                js_set_module_evaluated(ctx, m);
28965|      0|            }
28966|      0|        }
28967|      0|    }
28968|      0|    js_free(ctx, exec_list->tab);
28969|      0|    return JS_UNDEFINED;
28970|      0|}
28971|       |
28972|       |static int js_execute_async_module(JSContext *ctx, JSModuleDef *m)
28973|      0|{
28974|      0|    JSValue promise, m_obj;
28975|      0|    JSValue resolve_funcs[2], ret_val;
28976|      0|    promise = js_async_function_call(ctx, m->func_obj, JS_UNDEFINED, 0, NULL, 0);
28977|      0|    if (JS_IsException(promise))
28978|      0|        return -1;
28979|      0|    m_obj = JS_NewModuleValue(ctx, m);
28980|      0|    resolve_funcs[0] = JS_NewCFunctionData(ctx, js_async_module_execution_fulfilled, 0, 0, 1, (JSValueConst *)&m_obj);
28981|      0|    resolve_funcs[1] = JS_NewCFunctionData(ctx, js_async_module_execution_rejected, 0, 0, 1, (JSValueConst *)&m_obj);
28982|      0|    ret_val = js_promise_then(ctx, promise, 2, (JSValueConst *)resolve_funcs);
28983|      0|    JS_FreeValue(ctx, ret_val);
28984|      0|    JS_FreeValue(ctx, m_obj);
28985|      0|    JS_FreeValue(ctx, resolve_funcs[0]);
28986|      0|    JS_FreeValue(ctx, resolve_funcs[1]);
28987|      0|    JS_FreeValue(ctx, promise);
28988|      0|    return 0;
28989|      0|}
28990|       |
28991|       |/* return < 0 in case of exception. *pvalue contains the exception. */
28992|       |static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
28993|       |                                  JSValue *pvalue)
28994|    367|{
28995|    367|    if (m->init_func) {
28996|       |        /* C module init : no asynchronous execution */
28997|      0|        if (m->init_func(ctx, m) < 0)
28998|      0|            goto fail;
28999|    367|    } else {
29000|    367|        JSValue promise;
29001|    367|        JSPromiseStateEnum state;
29002|       |
29003|    367|        promise = js_async_function_call(ctx, m->func_obj, JS_UNDEFINED, 0, NULL, 0);
29004|    367|        if (JS_IsException(promise))
29005|      0|            goto fail;
29006|    367|        state = JS_PromiseState(ctx, promise);
29007|    367|        if (state == JS_PROMISE_FULFILLED) {
29008|     15|            JS_FreeValue(ctx, promise);
29009|    352|        } else if (state == JS_PROMISE_REJECTED) {
29010|      0|            *pvalue = JS_PromiseResult(ctx, promise);
29011|      0|            JS_FreeValue(ctx, promise);
29012|      0|            return -1;
29013|    352|        } else {
29014|    352|            JS_FreeValue(ctx, promise);
29015|    352|            JS_ThrowTypeError(ctx, "promise is pending");
29016|    352|        fail:
29017|      0|            *pvalue = JS_GetException(ctx);
29018|      0|            return -1;
29019|    352|        }
29020|    367|    }
29021|     15|    *pvalue = JS_UNDEFINED;
29022|     15|    return 0;
29023|    367|}
29024|       |
29025|       |/* spec: InnerModuleEvaluation. Return (index, JS_UNDEFINED) or (-1,
29026|       |   exception) */
29027|       |static int js_inner_module_evaluation(JSContext *ctx, JSModuleDef *m,
29028|       |                                      int index, JSModuleDef **pstack_top,
29029|       |                                      JSValue *pvalue)
29030|    367|{
29031|    367|    JSModuleDef *m1;
29032|    367|    int i;
29033|       |
29034|    367|    if (js_check_stack_overflow(ctx->rt, 0)) {
29035|      0|        JS_ThrowStackOverflow(ctx);
29036|      0|        *pvalue = JS_GetException(ctx);
29037|      0|        return -1;
29038|      0|    }
29039|       |
29040|       |#ifdef DUMP_MODULE_RESOLVE
29041|       |    {
29042|       |        char buf1[ATOM_GET_STR_BUF_SIZE];
29043|       |        printf("js_inner_module_evaluation '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
29044|       |    }
29045|       |#endif
29046|       |
29047|    367|    if (m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
29048|    367|        m->status == JS_MODULE_STATUS_EVALUATED) {
29049|      0|        if (m->eval_has_exception) {
29050|      0|            *pvalue = JS_DupValue(ctx, m->eval_exception);
29051|      0|            return -1;
29052|      0|        } else {
29053|      0|            *pvalue = JS_UNDEFINED;
29054|      0|            return index;
29055|      0|        }
29056|      0|    }
29057|    367|    if (m->status == JS_MODULE_STATUS_EVALUATING) {
29058|      0|        *pvalue = JS_UNDEFINED;
29059|      0|        return index;
29060|      0|    }
29061|    367|    assert(m->status == JS_MODULE_STATUS_LINKED);
29062|       |
29063|    367|    m->status = JS_MODULE_STATUS_EVALUATING;
29064|    367|    m->dfs_index = index;
29065|    367|    m->dfs_ancestor_index = index;
29066|    367|    m->pending_async_dependencies = 0;
29067|    367|    index++;
29068|       |    /* push 'm' on stack */
29069|    367|    m->stack_prev = *pstack_top;
29070|    367|    *pstack_top = m;
29071|       |
29072|    367|    for(i = 0; i < m->req_module_entries_count; i++) {
29073|      0|        JSReqModuleEntry *rme = &m->req_module_entries[i];
29074|      0|        m1 = rme->module;
29075|      0|        index = js_inner_module_evaluation(ctx, m1, index, pstack_top, pvalue);
29076|      0|        if (index < 0)
29077|      0|            return -1;
29078|      0|        assert(m1->status == JS_MODULE_STATUS_EVALUATING ||
29079|      0|               m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
29080|      0|               m1->status == JS_MODULE_STATUS_EVALUATED);
29081|      0|        if (m1->status == JS_MODULE_STATUS_EVALUATING) {
29082|      0|            m->dfs_ancestor_index = min_int(m->dfs_ancestor_index,
29083|      0|                                            m1->dfs_ancestor_index);
29084|      0|        } else {
29085|      0|            m1 = m1->cycle_root;
29086|      0|            assert(m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
29087|      0|                   m1->status == JS_MODULE_STATUS_EVALUATED);
29088|      0|            if (m1->eval_has_exception) {
29089|      0|                *pvalue = JS_DupValue(ctx, m1->eval_exception);
29090|      0|                return -1;
29091|      0|            }
29092|      0|        }
29093|      0|        if (m1->async_evaluation) {
29094|      0|            m->pending_async_dependencies++;
29095|      0|            if (js_resize_array(ctx, (void **)&m1->async_parent_modules, sizeof(m1->async_parent_modules[0]), &m1->async_parent_modules_size, m1->async_parent_modules_count + 1)) {
29096|      0|                *pvalue = JS_GetException(ctx);
29097|      0|                return -1;
29098|      0|            }
29099|      0|            m1->async_parent_modules[m1->async_parent_modules_count++] = m;
29100|      0|        }
29101|      0|    }
29102|       |
29103|    367|    if (m->pending_async_dependencies > 0) {
29104|      0|        assert(!m->async_evaluation);
29105|      0|        m->async_evaluation = TRUE;
29106|      0|        m->async_evaluation_timestamp =
29107|      0|            ctx->rt->module_async_evaluation_next_timestamp++;
29108|    367|    } else if (m->has_tla) {
29109|      0|        assert(!m->async_evaluation);
29110|      0|        m->async_evaluation = TRUE;
29111|      0|        m->async_evaluation_timestamp =
29112|      0|            ctx->rt->module_async_evaluation_next_timestamp++;
29113|      0|        js_execute_async_module(ctx, m);
29114|    367|    } else {
29115|    367|        if (js_execute_sync_module(ctx, m, pvalue) < 0)
29116|      0|            return -1;
29117|    367|    }
29118|       |
29119|    367|    assert(m->dfs_ancestor_index <= m->dfs_index);
29120|     15|    if (m->dfs_index == m->dfs_ancestor_index) {
29121|     15|        for(;;) {
29122|       |            /* pop m1 from stack */
29123|     15|            m1 = *pstack_top;
29124|     15|            *pstack_top = m1->stack_prev;
29125|     15|            if (!m1->async_evaluation) {
29126|     15|                m1->status = JS_MODULE_STATUS_EVALUATED;
29127|     15|            } else {
29128|      0|                m1->status = JS_MODULE_STATUS_EVALUATING_ASYNC;
29129|      0|            }
29130|       |            /* spec bug: cycle_root must be assigned before the test */
29131|     15|            m1->cycle_root = m;
29132|     15|            if (m1 == m)
29133|     15|                break;
29134|     15|        }
29135|     15|    }
29136|     15|    *pvalue = JS_UNDEFINED;
29137|     15|    return index;
29138|    367|}
29139|       |
29140|       |/* Run the <eval> function of the module and of all its requested
29141|       |   modules. Return a promise or an exception. */
29142|       |static JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)
29143|    367|{
29144|    367|    JSModuleDef *m1, *stack_top;
29145|    367|    JSValue ret_val, result;
29146|       |
29147|    367|    assert(m->status == JS_MODULE_STATUS_LINKED ||
29148|    367|           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
29149|    367|           m->status == JS_MODULE_STATUS_EVALUATED);
29150|    367|    if (m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
29151|    367|        m->status == JS_MODULE_STATUS_EVALUATED) {
29152|      0|        m = m->cycle_root;
29153|      0|    }
29154|       |    /* a promise may be created only on the cycle_root of a cycle */
29155|    367|    if (!JS_IsUndefined(m->promise))
29156|      0|        return JS_DupValue(ctx, m->promise);
29157|    367|    m->promise = JS_NewPromiseCapability(ctx, m->resolving_funcs);
29158|    367|    if (JS_IsException(m->promise))
29159|      0|        return JS_EXCEPTION;
29160|       |
29161|    367|    stack_top = NULL;
29162|    367|    if (js_inner_module_evaluation(ctx, m, 0, &stack_top, &result) < 0) {
29163|      0|        while (stack_top != NULL) {
29164|      0|            m1 = stack_top;
29165|      0|            assert(m1->status == JS_MODULE_STATUS_EVALUATING);
29166|      0|            m1->status = JS_MODULE_STATUS_EVALUATED;
29167|      0|            m1->eval_has_exception = TRUE;
29168|      0|            m1->eval_exception = JS_DupValue(ctx, result);
29169|      0|            m1->cycle_root = m; /* spec bug: should be present */
29170|      0|            stack_top = m1->stack_prev;
29171|      0|        }
29172|      0|        JS_FreeValue(ctx, result);
29173|      0|        assert(m->status == JS_MODULE_STATUS_EVALUATED);
29174|      0|        assert(m->eval_has_exception);
29175|      0|        ret_val = JS_Call(ctx, m->resolving_funcs[1], JS_UNDEFINED,
29176|      0|                          1, (JSValueConst *)&m->eval_exception);
29177|      0|        JS_FreeValue(ctx, ret_val);
29178|    367|    } else {
29179|    367|        assert(m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
29180|    367|               m->status == JS_MODULE_STATUS_EVALUATED);
29181|     15|        assert(!m->eval_has_exception);
29182|     15|        if (!m->async_evaluation) {
29183|     15|            JSValue value;
29184|     15|            assert(m->status == JS_MODULE_STATUS_EVALUATED);
29185|     15|            value = JS_UNDEFINED;
29186|     15|            ret_val = JS_Call(ctx, m->resolving_funcs[0], JS_UNDEFINED,
29187|     15|                              1, (JSValueConst *)&value);
29188|     15|            JS_FreeValue(ctx, ret_val);
29189|     15|        }
29190|     15|        assert(stack_top == NULL);
29191|     15|    }
29192|     15|    return JS_DupValue(ctx, m->promise);
29193|    367|}
29194|       |
29195|       |static __exception JSAtom js_parse_from_clause(JSParseState *s)
29196|     16|{
29197|     16|    JSAtom module_name;
29198|     16|    if (!token_is_pseudo_keyword(s, JS_ATOM_from)) {
29199|     16|        js_parse_error(s, "from clause expected");
29200|     16|        return JS_ATOM_NULL;
29201|     16|    }
29202|      0|    if (next_token(s))
29203|      0|        return JS_ATOM_NULL;
29204|      0|    if (s->token.val != TOK_STRING) {
29205|      0|        js_parse_error(s, "string expected");
29206|      0|        return JS_ATOM_NULL;
29207|      0|    }
29208|      0|    module_name = JS_ValueToAtom(s->ctx, s->token.u.str.str);
29209|      0|    if (module_name == JS_ATOM_NULL)
29210|      0|        return JS_ATOM_NULL;
29211|      0|    if (next_token(s)) {
29212|      0|        JS_FreeAtom(s->ctx, module_name);
29213|      0|        return JS_ATOM_NULL;
29214|      0|    }
29215|      0|    return module_name;
29216|      0|}
29217|       |
29218|       |static __exception int js_parse_export(JSParseState *s)
29219|    592|{
29220|    592|    JSContext *ctx = s->ctx;
29221|    592|    JSModuleDef *m = s->cur_func->module;
29222|    592|    JSAtom local_name, export_name;
29223|    592|    int first_export, idx, i, tok;
29224|    592|    JSAtom module_name;
29225|    592|    JSExportEntry *me;
29226|       |
29227|    592|    if (next_token(s))
29228|      1|        return -1;
29229|       |
29230|    591|    tok = s->token.val;
29231|    591|    if (tok == TOK_CLASS) {
29232|      0|        return js_parse_class(s, FALSE, JS_PARSE_EXPORT_NAMED);
29233|    591|    } else if (tok == TOK_FUNCTION ||
29234|    591|               (token_is_pseudo_keyword(s, JS_ATOM_async) &&
29235|    591|                peek_token(s, TRUE) == TOK_FUNCTION)) {
29236|      0|        return js_parse_function_decl2(s, JS_PARSE_FUNC_STATEMENT,
29237|      0|                                       JS_FUNC_NORMAL, JS_ATOM_NULL,
29238|      0|                                       s->token.ptr,
29239|      0|                                       JS_PARSE_EXPORT_NAMED, NULL);
29240|      0|    }
29241|       |
29242|    591|    if (next_token(s))
29243|      1|        return -1;
29244|       |
29245|    590|    switch(tok) {
29246|     42|    case '{':
29247|     42|        first_export = m->export_entries_count;
29248|    187|        while (s->token.val != '}') {
29249|    185|            if (!token_is_ident(s->token.val)) {
29250|      2|                js_parse_error(s, "identifier expected");
29251|      2|                return -1;
29252|      2|            }
29253|    183|            local_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29254|    183|            export_name = JS_ATOM_NULL;
29255|    183|            if (next_token(s))
29256|      1|                goto fail;
29257|    182|            if (token_is_pseudo_keyword(s, JS_ATOM_as)) {
29258|     14|                if (next_token(s))
29259|      1|                    goto fail;
29260|     13|                if (!token_is_ident(s->token.val)) {
29261|      1|                    js_parse_error(s, "identifier expected");
29262|      1|                    goto fail;
29263|      1|                }
29264|     12|                export_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29265|     12|                if (next_token(s)) {
29266|      4|                fail:
29267|      4|                    JS_FreeAtom(ctx, local_name);
29268|      7|                fail1:
29269|      7|                    JS_FreeAtom(ctx, export_name);
29270|      7|                    return -1;
29271|      4|                }
29272|    168|            } else {
29273|    168|                export_name = JS_DupAtom(ctx, local_name);
29274|    168|            }
29275|    179|            me = add_export_entry(s, m, local_name, export_name,
29276|    179|                                  JS_EXPORT_TYPE_LOCAL);
29277|    179|            JS_FreeAtom(ctx, local_name);
29278|    179|            JS_FreeAtom(ctx, export_name);
29279|    179|            if (!me)
29280|      5|                return -1;
29281|    174|            if (s->token.val != ',')
29282|     28|                break;
29283|    146|            if (next_token(s))
29284|      1|                return -1;
29285|    146|        }
29286|     30|        if (js_parse_expect(s, '}'))
29287|     21|            return -1;
29288|      9|        if (token_is_pseudo_keyword(s, JS_ATOM_from)) {
29289|      0|            module_name = js_parse_from_clause(s);
29290|      0|            if (module_name == JS_ATOM_NULL)
29291|      0|                return -1;
29292|      0|            idx = add_req_module_entry(ctx, m, module_name);
29293|      0|            JS_FreeAtom(ctx, module_name);
29294|      0|            if (idx < 0)
29295|      0|                return -1;
29296|      0|            for(i = first_export; i < m->export_entries_count; i++) {
29297|      0|                me = &m->export_entries[i];
29298|      0|                me->export_type = JS_EXPORT_TYPE_INDIRECT;
29299|      0|                me->u.req_module_idx = idx;
29300|      0|            }
29301|      0|        }
29302|      9|        break;
29303|      9|    case '*':
29304|      7|        if (token_is_pseudo_keyword(s, JS_ATOM_as)) {
29305|       |            /* export ns from */
29306|      5|            if (next_token(s))
29307|      1|                return -1;
29308|      4|            if (!token_is_ident(s->token.val)) {
29309|      1|                js_parse_error(s, "identifier expected");
29310|      1|                return -1;
29311|      1|            }
29312|      3|            export_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29313|      3|            if (next_token(s))
29314|      1|                goto fail1;
29315|      2|            module_name = js_parse_from_clause(s);
29316|      2|            if (module_name == JS_ATOM_NULL)
29317|      2|                goto fail1;
29318|      0|            idx = add_req_module_entry(ctx, m, module_name);
29319|      0|            JS_FreeAtom(ctx, module_name);
29320|      0|            if (idx < 0)
29321|      0|                goto fail1;
29322|      0|            me = add_export_entry(s, m, JS_ATOM__star_, export_name,
29323|      0|                                  JS_EXPORT_TYPE_INDIRECT);
29324|      0|            JS_FreeAtom(ctx, export_name);
29325|      0|            if (!me)
29326|      0|                return -1;
29327|      0|            me->u.req_module_idx = idx;
29328|      2|        } else {
29329|      2|            module_name = js_parse_from_clause(s);
29330|      2|            if (module_name == JS_ATOM_NULL)
29331|      2|                return -1;
29332|      0|            idx = add_req_module_entry(ctx, m, module_name);
29333|      0|            JS_FreeAtom(ctx, module_name);
29334|      0|            if (idx < 0)
29335|      0|                return -1;
29336|      0|            if (add_star_export_entry(ctx, m, idx) < 0)
29337|      0|                return -1;
29338|      0|        }
29339|      0|        break;
29340|      0|    case TOK_DEFAULT:
29341|      0|        if (s->token.val == TOK_CLASS) {
29342|      0|            return js_parse_class(s, FALSE, JS_PARSE_EXPORT_DEFAULT);
29343|      0|        } else if (s->token.val == TOK_FUNCTION ||
29344|      0|                   (token_is_pseudo_keyword(s, JS_ATOM_async) &&
29345|      0|                    peek_token(s, TRUE) == TOK_FUNCTION)) {
29346|      0|            return js_parse_function_decl2(s, JS_PARSE_FUNC_STATEMENT,
29347|      0|                                           JS_FUNC_NORMAL, JS_ATOM_NULL,
29348|      0|                                           s->token.ptr,
29349|      0|                                           JS_PARSE_EXPORT_DEFAULT, NULL);
29350|      0|        } else {
29351|      0|            if (js_parse_assign_expr(s))
29352|      0|                return -1;
29353|      0|        }
29354|       |        /* set the name of anonymous functions */
29355|      0|        set_object_name(s, JS_ATOM_default);
29356|       |
29357|       |        /* store the value in the _default_ global variable and export
29358|       |           it */
29359|      0|        local_name = JS_ATOM__default_;
29360|      0|        if (define_var(s, s->cur_func, local_name, JS_VAR_DEF_LET) < 0)
29361|      0|            return -1;
29362|      0|        emit_op(s, OP_scope_put_var_init);
29363|      0|        emit_atom(s, local_name);
29364|      0|        emit_u16(s, 0);
29365|       |
29366|      0|        if (!add_export_entry(s, m, local_name, JS_ATOM_default,
29367|      0|                              JS_EXPORT_TYPE_LOCAL))
29368|      0|            return -1;
29369|      0|        break;
29370|     13|    case TOK_VAR:
29371|    539|    case TOK_LET:
29372|    539|    case TOK_CONST:
29373|    539|        return js_parse_var(s, TRUE, tok, TRUE);
29374|      2|    default:
29375|      2|        return js_parse_error(s, "invalid export syntax");
29376|    590|    }
29377|      9|    return js_parse_expect_semi(s);
29378|    590|}
29379|       |
29380|       |static int add_closure_var(JSContext *ctx, JSFunctionDef *s,
29381|       |                           BOOL is_local, BOOL is_arg,
29382|       |                           int var_idx, JSAtom var_name,
29383|       |                           BOOL is_const, BOOL is_lexical,
29384|       |                           JSVarKindEnum var_kind);
29385|       |
29386|       |static int add_import(JSParseState *s, JSModuleDef *m,
29387|       |                      JSAtom local_name, JSAtom import_name)
29388|     93|{
29389|     93|    JSContext *ctx = s->ctx;
29390|     93|    int i, var_idx;
29391|     93|    JSImportEntry *mi;
29392|     93|    BOOL is_local;
29393|       |
29394|     93|    if (local_name == JS_ATOM_arguments || local_name == JS_ATOM_eval)
29395|      0|        return js_parse_error(s, "invalid import binding");
29396|       |
29397|     93|    if (local_name != JS_ATOM_default) {
29398|    271|        for (i = 0; i < s->cur_func->closure_var_count; i++) {
29399|    183|            if (s->cur_func->closure_var[i].var_name == local_name)
29400|      5|                return js_parse_error(s, "duplicate import binding");
29401|    183|        }
29402|     93|    }
29403|       |
29404|     88|    is_local = (import_name == JS_ATOM__star_);
29405|     88|    var_idx = add_closure_var(ctx, s->cur_func, is_local, FALSE,
29406|     88|                              m->import_entries_count,
29407|     88|                              local_name, TRUE, TRUE, FALSE);
29408|     88|    if (var_idx < 0)
29409|      0|        return -1;
29410|     88|    if (js_resize_array(ctx, (void **)&m->import_entries,
29411|     88|                        sizeof(JSImportEntry),
29412|     88|                        &m->import_entries_size,
29413|     88|                        m->import_entries_count + 1))
29414|      0|        return -1;
29415|     88|    mi = &m->import_entries[m->import_entries_count++];
29416|     88|    mi->import_name = JS_DupAtom(ctx, import_name);
29417|     88|    mi->var_idx = var_idx;
29418|     88|    return 0;
29419|     88|}
29420|       |
29421|       |static __exception int js_parse_import(JSParseState *s)
29422|    710|{
29423|    710|    JSContext *ctx = s->ctx;
29424|    710|    JSModuleDef *m = s->cur_func->module;
29425|    710|    JSAtom local_name, import_name, module_name;
29426|    710|    int first_import, i, idx;
29427|       |
29428|    710|    if (next_token(s))
29429|      7|        return -1;
29430|       |
29431|    703|    first_import = m->import_entries_count;
29432|    703|    if (s->token.val == TOK_STRING) {
29433|    653|        module_name = JS_ValueToAtom(ctx, s->token.u.str.str);
29434|    653|        if (module_name == JS_ATOM_NULL)
29435|      0|            return -1;
29436|    653|        if (next_token(s)) {
29437|      4|            JS_FreeAtom(ctx, module_name);
29438|      4|            return -1;
29439|      4|        }
29440|    653|    } else {
29441|     50|        if (s->token.val == TOK_IDENT) {
29442|      8|            if (s->token.u.ident.is_reserved) {
29443|      1|                return js_parse_error_reserved_identifier(s);
29444|      1|            }
29445|       |            /* "default" import */
29446|      7|            local_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29447|      7|            import_name = JS_ATOM_default;
29448|      7|            if (next_token(s))
29449|      2|                goto fail;
29450|      5|            if (add_import(s, m, local_name, import_name))
29451|      0|                goto fail;
29452|      5|            JS_FreeAtom(ctx, local_name);
29453|       |
29454|      5|            if (s->token.val != ',')
29455|      3|                goto end_import_clause;
29456|      2|            if (next_token(s))
29457|      1|                return -1;
29458|      2|        }
29459|       |
29460|     43|        if (s->token.val == '*') {
29461|       |            /* name space import */
29462|      8|            if (next_token(s))
29463|      1|                return -1;
29464|      7|            if (!token_is_pseudo_keyword(s, JS_ATOM_as))
29465|      2|                return js_parse_error(s, "expecting 'as'");
29466|      5|            if (next_token(s))
29467|      1|                return -1;
29468|      4|            if (!token_is_ident(s->token.val)) {
29469|      1|                js_parse_error(s, "identifier expected");
29470|      1|                return -1;
29471|      1|            }
29472|      3|            local_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29473|      3|            import_name = JS_ATOM__star_;
29474|      3|            if (next_token(s))
29475|      1|                goto fail;
29476|      2|            if (add_import(s, m, local_name, import_name))
29477|      0|                goto fail;
29478|      2|            JS_FreeAtom(ctx, local_name);
29479|     35|        } else if (s->token.val == '{') {
29480|     30|            if (next_token(s))
29481|      1|                return -1;
29482|       |
29483|     95|            while (s->token.val != '}') {
29484|     94|                if (!token_is_ident(s->token.val)) {
29485|      2|                    js_parse_error(s, "identifier expected");
29486|      2|                    return -1;
29487|      2|                }
29488|     92|                import_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29489|     92|                local_name = JS_ATOM_NULL;
29490|     92|                if (next_token(s))
29491|      3|                    goto fail;
29492|     89|                if (token_is_pseudo_keyword(s, JS_ATOM_as)) {
29493|      5|                    if (next_token(s))
29494|      1|                        goto fail;
29495|      4|                    if (!token_is_ident(s->token.val)) {
29496|      1|                        js_parse_error(s, "identifier expected");
29497|      1|                        goto fail;
29498|      1|                    }
29499|      3|                    local_name = JS_DupAtom(ctx, s->token.u.ident.atom);
29500|      3|                    if (next_token(s)) {
29501|     14|                    fail:
29502|     14|                        JS_FreeAtom(ctx, local_name);
29503|     14|                        JS_FreeAtom(ctx, import_name);
29504|     14|                        return -1;
29505|      1|                    }
29506|     84|                } else {
29507|     84|                    local_name = JS_DupAtom(ctx, import_name);
29508|     84|                }
29509|     86|                if (add_import(s, m, local_name, import_name))
29510|      5|                    goto fail;
29511|     81|                JS_FreeAtom(ctx, local_name);
29512|     81|                JS_FreeAtom(ctx, import_name);
29513|     81|                if (s->token.val != ',')
29514|     14|                    break;
29515|     67|                if (next_token(s))
29516|      1|                    return -1;
29517|     67|            }
29518|     15|            if (js_parse_expect(s, '}'))
29519|     13|                return -1;
29520|     15|        }
29521|     12|    end_import_clause:
29522|     12|        module_name = js_parse_from_clause(s);
29523|     12|        if (module_name == JS_ATOM_NULL)
29524|     12|            return -1;
29525|     12|    }
29526|    649|    idx = add_req_module_entry(ctx, m, module_name);
29527|    649|    JS_FreeAtom(ctx, module_name);
29528|    649|    if (idx < 0)
29529|      0|        return -1;
29530|    649|    for(i = first_import; i < m->import_entries_count; i++)
29531|      0|        m->import_entries[i].req_module_idx = idx;
29532|       |
29533|    649|    return js_parse_expect_semi(s);
29534|    649|}
29535|       |
29536|       |static __exception int js_parse_source_element(JSParseState *s)
29537|   115k|{
29538|   115k|    JSFunctionDef *fd = s->cur_func;
29539|   115k|    int tok;
29540|       |
29541|   115k|    if (s->token.val == TOK_FUNCTION ||
29542|   115k|        (token_is_pseudo_keyword(s, JS_ATOM_async) &&
29543|   115k|         peek_token(s, TRUE) == TOK_FUNCTION)) {
29544|      0|        if (js_parse_function_decl(s, JS_PARSE_FUNC_STATEMENT,
29545|      0|                                   JS_FUNC_NORMAL, JS_ATOM_NULL,
29546|      0|                                   s->token.ptr))
29547|      0|            return -1;
29548|   115k|    } else if (s->token.val == TOK_EXPORT && fd->module) {
29549|    592|        if (js_parse_export(s))
29550|     58|            return -1;
29551|   114k|    } else if (s->token.val == TOK_IMPORT && fd->module &&
29552|   114k|               ((tok = peek_token(s, FALSE)) != '(' && tok != '.'))  {
29553|       |        /* the peek_token is needed to avoid confusion with ImportCall
29554|       |           (dynamic import) or import.meta */
29555|    710|        if (js_parse_import(s))
29556|     69|            return -1;
29557|   113k|    } else {
29558|   113k|        if (js_parse_statement_or_decl(s, DECL_MASK_ALL))
29559|  10.1k|            return -1;
29560|   113k|    }
29561|   104k|    return 0;
29562|   115k|}
29563|       |
29564|       |static JSFunctionDef *js_new_function_def(JSContext *ctx,
29565|       |                                          JSFunctionDef *parent,
29566|       |                                          BOOL is_eval,
29567|       |                                          BOOL is_func_expr,
29568|       |                                          const char *filename,
29569|       |                                          const uint8_t *source_ptr,
29570|       |                                          GetLineColCache *get_line_col_cache)
29571|   154k|{
29572|   154k|    JSFunctionDef *fd;
29573|       |
29574|   154k|    fd = js_mallocz(ctx, sizeof(*fd));
29575|   154k|    if (!fd)
29576|      0|        return NULL;
29577|       |
29578|   154k|    fd->ctx = ctx;
29579|   154k|    init_list_head(&fd->child_list);
29580|       |
29581|       |    /* insert in parent list */
29582|   154k|    fd->parent = parent;
29583|   154k|    fd->parent_cpool_idx = -1;
29584|   154k|    if (parent) {
29585|   136k|        list_add_tail(&fd->link, &parent->child_list);
29586|   136k|        fd->js_mode = parent->js_mode;
29587|   136k|        fd->parent_scope_level = parent->scope_level;
29588|   136k|    }
29589|   154k|    fd->strip_debug = ((ctx->rt->strip_flags & JS_STRIP_DEBUG) != 0);
29590|   154k|    fd->strip_source = ((ctx->rt->strip_flags & (JS_STRIP_DEBUG | JS_STRIP_SOURCE)) != 0);
29591|       |
29592|   154k|    fd->is_eval = is_eval;
29593|   154k|    fd->is_func_expr = is_func_expr;
29594|   154k|    js_dbuf_init(ctx, &fd->byte_code);
29595|   154k|    fd->last_opcode_pos = -1;
29596|   154k|    fd->func_name = JS_ATOM_NULL;
29597|   154k|    fd->var_object_idx = -1;
29598|   154k|    fd->arg_var_object_idx = -1;
29599|   154k|    fd->arguments_var_idx = -1;
29600|   154k|    fd->arguments_arg_idx = -1;
29601|   154k|    fd->func_var_idx = -1;
29602|   154k|    fd->eval_ret_idx = -1;
29603|   154k|    fd->this_var_idx = -1;
29604|   154k|    fd->new_target_var_idx = -1;
29605|   154k|    fd->this_active_func_var_idx = -1;
29606|   154k|    fd->home_object_var_idx = -1;
29607|       |
29608|       |    /* XXX: should distinguish arg, var and var object and body scopes */
29609|   154k|    fd->scopes = fd->def_scope_array;
29610|   154k|    fd->scope_size = countof(fd->def_scope_array);
29611|   154k|    fd->scope_count = 1;
29612|   154k|    fd->scopes[0].first = -1;
29613|   154k|    fd->scopes[0].parent = -1;
29614|   154k|    fd->scope_level = 0;  /* 0: var/arg scope */
29615|   154k|    fd->scope_first = -1;
29616|   154k|    fd->body_scope = -1;
29617|       |
29618|   154k|    fd->filename = JS_NewAtom(ctx, filename);
29619|   154k|    fd->source_pos = source_ptr - get_line_col_cache->buf_start;
29620|   154k|    fd->get_line_col_cache = get_line_col_cache;
29621|       |    
29622|   154k|    js_dbuf_init(ctx, &fd->pc2line);
29623|       |    //fd->pc2line_last_line_num = line_num;
29624|       |    //fd->pc2line_last_pc = 0;
29625|   154k|    fd->last_opcode_source_ptr = source_ptr;
29626|   154k|    return fd;
29627|   154k|}
29628|       |
29629|       |static void free_bytecode_atoms(JSRuntime *rt,
29630|       |                                const uint8_t *bc_buf, int bc_len,
29631|       |                                BOOL use_short_opcodes)
29632|   134k|{
29633|   134k|    int pos, len, op;
29634|   134k|    JSAtom atom;
29635|   134k|    const JSOpCode *oi;
29636|       |
29637|   134k|    pos = 0;
29638|  5.59M|    while (pos < bc_len) {
29639|  5.46M|        op = bc_buf[pos];
29640|  5.46M|        if (use_short_opcodes)
29641|  3.11M|            oi = &short_opcode_info(op);
29642|  2.34M|        else
29643|  2.34M|            oi = &opcode_info[op];
29644|       |
29645|  5.46M|        len = oi->size;
29646|  5.46M|        switch(oi->fmt) {
29647|   538k|        case OP_FMT_atom:
29648|   543k|        case OP_FMT_atom_u8:
29649|   644k|        case OP_FMT_atom_u16:
29650|   644k|        case OP_FMT_atom_label_u8:
29651|   705k|        case OP_FMT_atom_label_u16:
29652|   705k|            atom = get_u32(bc_buf + pos + 1);
29653|   705k|            JS_FreeAtomRT(rt, atom);
29654|   705k|            break;
29655|  4.75M|        default:
29656|  4.75M|            break;
29657|  5.46M|        }
29658|  5.46M|        pos += len;
29659|  5.46M|    }
29660|   134k|}
29661|       |
29662|       |static void js_free_function_def(JSContext *ctx, JSFunctionDef *fd)
29663|  32.8k|{
29664|  32.8k|    int i;
29665|  32.8k|    struct list_head *el, *el1;
29666|       |
29667|       |    /* free the child functions */
29668|  32.8k|    list_for_each_safe(el, el1, &fd->child_list) {
29669|  13.9k|        JSFunctionDef *fd1;
29670|  13.9k|        fd1 = list_entry(el, JSFunctionDef, link);
29671|  13.9k|        js_free_function_def(ctx, fd1);
29672|  13.9k|    }
29673|       |
29674|  32.8k|    free_bytecode_atoms(ctx->rt, fd->byte_code.buf, fd->byte_code.size,
29675|  32.8k|                        fd->use_short_opcodes);
29676|  32.8k|    dbuf_free(&fd->byte_code);
29677|  32.8k|    js_free(ctx, fd->jump_slots);
29678|  32.8k|    js_free(ctx, fd->label_slots);
29679|  32.8k|    js_free(ctx, fd->line_number_slots);
29680|       |
29681|   470k|    for(i = 0; i < fd->cpool_count; i++) {
29682|   438k|        JS_FreeValue(ctx, fd->cpool[i]);
29683|   438k|    }
29684|  32.8k|    js_free(ctx, fd->cpool);
29685|       |
29686|  32.8k|    JS_FreeAtom(ctx, fd->func_name);
29687|       |
29688|  62.4k|    for(i = 0; i < fd->var_count; i++) {
29689|  29.6k|        JS_FreeAtom(ctx, fd->vars[i].var_name);
29690|  29.6k|    }
29691|  32.8k|    js_free(ctx, fd->vars);
29692|  58.3k|    for(i = 0; i < fd->arg_count; i++) {
29693|  25.5k|        JS_FreeAtom(ctx, fd->args[i].var_name);
29694|  25.5k|    }
29695|  32.8k|    js_free(ctx, fd->args);
29696|       |
29697|  41.1k|    for(i = 0; i < fd->global_var_count; i++) {
29698|  8.28k|        JS_FreeAtom(ctx, fd->global_vars[i].var_name);
29699|  8.28k|    }
29700|  32.8k|    js_free(ctx, fd->global_vars);
29701|       |
29702|  34.2k|    for(i = 0; i < fd->closure_var_count; i++) {
29703|  1.45k|        JSClosureVar *cv = &fd->closure_var[i];
29704|  1.45k|        JS_FreeAtom(ctx, cv->var_name);
29705|  1.45k|    }
29706|  32.8k|    js_free(ctx, fd->closure_var);
29707|       |
29708|  32.8k|    if (fd->scopes != fd->def_scope_array)
29709|    623|        js_free(ctx, fd->scopes);
29710|       |
29711|  32.8k|    JS_FreeAtom(ctx, fd->filename);
29712|  32.8k|    dbuf_free(&fd->pc2line);
29713|       |
29714|  32.8k|    js_free(ctx, fd->source);
29715|       |
29716|  32.8k|    if (fd->parent) {
29717|       |        /* remove in parent list */
29718|  24.4k|        list_del(&fd->link);
29719|  24.4k|    }
29720|  32.8k|    js_free(ctx, fd);
29721|  32.8k|}
29722|       |
29723|       |#ifdef DUMP_BYTECODE
29724|       |static const char *skip_lines(const char *p, int n) {
29725|       |    while (n-- > 0 && *p) {
29726|       |        while (*p && *p++ != '\n')
29727|       |            continue;
29728|       |    }
29729|       |    return p;
29730|       |}
29731|       |
29732|       |static void print_lines(const char *source, int line, int line1) {
29733|       |    const char *s = source;
29734|       |    const char *p = skip_lines(s, line);
29735|       |    if (*p) {
29736|       |        while (line++ < line1) {
29737|       |            p = skip_lines(s = p, 1);
29738|       |            printf(";; %.*s", (int)(p - s), s);
29739|       |            if (!*p) {
29740|       |                if (p[-1] != '\n')
29741|       |                    printf("\n");
29742|       |                break;
29743|       |            }
29744|       |        }
29745|       |    }
29746|       |}
29747|       |
29748|       |static void dump_byte_code(JSContext *ctx, int pass,
29749|       |                           const uint8_t *tab, int len,
29750|       |                           const JSVarDef *args, int arg_count,
29751|       |                           const JSVarDef *vars, int var_count,
29752|       |                           const JSClosureVar *closure_var, int closure_var_count,
29753|       |                           const JSValue *cpool, uint32_t cpool_count,
29754|       |                           const char *source,
29755|       |                           const LabelSlot *label_slots, JSFunctionBytecode *b)
29756|       |{
29757|       |    const JSOpCode *oi;
29758|       |    int pos, pos_next, op, size, idx, addr, line, line1, in_source, line_num;
29759|       |    uint8_t *bits = js_mallocz(ctx, len * sizeof(*bits));
29760|       |    BOOL use_short_opcodes = (b != NULL);
29761|       |
29762|       |    if (b) {
29763|       |        int col_num;
29764|       |        line_num = find_line_num(ctx, b, -1, &col_num);
29765|       |    }
29766|       |    
29767|       |    /* scan for jump targets */
29768|       |    for (pos = 0; pos < len; pos = pos_next) {
29769|       |        op = tab[pos];
29770|       |        if (use_short_opcodes)
29771|       |            oi = &short_opcode_info(op);
29772|       |        else
29773|       |            oi = &opcode_info[op];
29774|       |        pos_next = pos + oi->size;
29775|       |        if (op < OP_COUNT) {
29776|       |            switch (oi->fmt) {
29777|       |#if SHORT_OPCODES
29778|       |            case OP_FMT_label8:
29779|       |                pos++;
29780|       |                addr = (int8_t)tab[pos];
29781|       |                goto has_addr;
29782|       |            case OP_FMT_label16:
29783|       |                pos++;
29784|       |                addr = (int16_t)get_u16(tab + pos);
29785|       |                goto has_addr;
29786|       |#endif
29787|       |            case OP_FMT_atom_label_u8:
29788|       |            case OP_FMT_atom_label_u16:
29789|       |                pos += 4;
29790|       |                /* fall thru */
29791|       |            case OP_FMT_label:
29792|       |            case OP_FMT_label_u16:
29793|       |                pos++;
29794|       |                addr = get_u32(tab + pos);
29795|       |                goto has_addr;
29796|       |            has_addr:
29797|       |                if (pass == 1)
29798|       |                    addr = label_slots[addr].pos;
29799|       |                if (pass == 2)
29800|       |                    addr = label_slots[addr].pos2;
29801|       |                if (pass == 3)
29802|       |                    addr += pos;
29803|       |                if (addr >= 0 && addr < len)
29804|       |                    bits[addr] |= 1;
29805|       |                break;
29806|       |            }
29807|       |        }
29808|       |    }
29809|       |    in_source = 0;
29810|       |    if (source) {
29811|       |        /* Always print first line: needed if single line */
29812|       |        print_lines(source, 0, 1);
29813|       |        in_source = 1;
29814|       |    }
29815|       |    line1 = line = 1;
29816|       |    pos = 0;
29817|       |    while (pos < len) {
29818|       |        op = tab[pos];
29819|       |        if (source && b) {
29820|       |            int col_num;
29821|       |            if (b) {
29822|       |                line1 = find_line_num(ctx, b, pos, &col_num) - line_num + 1;
29823|       |            } else if (op == OP_line_num) {
29824|       |                /* XXX: no longer works */
29825|       |                line1 = get_u32(tab + pos + 1) - line_num + 1;
29826|       |            }
29827|       |            if (line1 > line) {
29828|       |                if (!in_source)
29829|       |                    printf("\n");
29830|       |                in_source = 1;
29831|       |                print_lines(source, line, line1);
29832|       |                line = line1;
29833|       |                //bits[pos] |= 2;
29834|       |            }
29835|       |        }
29836|       |        if (in_source)
29837|       |            printf("\n");
29838|       |        in_source = 0;
29839|       |        if (op >= OP_COUNT) {
29840|       |            printf("invalid opcode (0x%02x)\n", op);
29841|       |            pos++;
29842|       |            continue;
29843|       |        }
29844|       |        if (use_short_opcodes)
29845|       |            oi = &short_opcode_info(op);
29846|       |        else
29847|       |            oi = &opcode_info[op];
29848|       |        size = oi->size;
29849|       |        if (pos + size > len) {
29850|       |            printf("truncated opcode (0x%02x)\n", op);
29851|       |            break;
29852|       |        }
29853|       |#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 16)
29854|       |        {
29855|       |            int i, x, x0;
29856|       |            x = x0 = printf("%5d ", pos);
29857|       |            for (i = 0; i < size; i++) {
29858|       |                if (i == 6) {
29859|       |                    printf("\n%*s", x = x0, "");
29860|       |                }
29861|       |                x += printf(" %02X", tab[pos + i]);
29862|       |            }
29863|       |            printf("%*s", x0 + 20 - x, "");
29864|       |        }
29865|       |#endif
29866|       |        if (bits[pos]) {
29867|       |            printf("%5d:  ", pos);
29868|       |        } else {
29869|       |            printf("        ");
29870|       |        }
29871|       |        printf("%s", oi->name);
29872|       |        pos++;
29873|       |        switch(oi->fmt) {
29874|       |        case OP_FMT_none_int:
29875|       |            printf(" %d", op - OP_push_0);
29876|       |            break;
29877|       |        case OP_FMT_npopx:
29878|       |            printf(" %d", op - OP_call0);
29879|       |            break;
29880|       |        case OP_FMT_u8:
29881|       |            printf(" %u", get_u8(tab + pos));
29882|       |            break;
29883|       |        case OP_FMT_i8:
29884|       |            printf(" %d", get_i8(tab + pos));
29885|       |            break;
29886|       |        case OP_FMT_u16:
29887|       |        case OP_FMT_npop:
29888|       |            printf(" %u", get_u16(tab + pos));
29889|       |            break;
29890|       |        case OP_FMT_npop_u16:
29891|       |            printf(" %u,%u", get_u16(tab + pos), get_u16(tab + pos + 2));
29892|       |            break;
29893|       |        case OP_FMT_i16:
29894|       |            printf(" %d", get_i16(tab + pos));
29895|       |            break;
29896|       |        case OP_FMT_i32:
29897|       |            printf(" %d", get_i32(tab + pos));
29898|       |            break;
29899|       |        case OP_FMT_u32:
29900|       |            printf(" %u", get_u32(tab + pos));
29901|       |            break;
29902|       |#if SHORT_OPCODES
29903|       |        case OP_FMT_label8:
29904|       |            addr = get_i8(tab + pos);
29905|       |            goto has_addr1;
29906|       |        case OP_FMT_label16:
29907|       |            addr = get_i16(tab + pos);
29908|       |            goto has_addr1;
29909|       |#endif
29910|       |        case OP_FMT_label:
29911|       |            addr = get_u32(tab + pos);
29912|       |            goto has_addr1;
29913|       |        has_addr1:
29914|       |            if (pass == 1)
29915|       |                printf(" %u:%u", addr, label_slots[addr].pos);
29916|       |            if (pass == 2)
29917|       |                printf(" %u:%u", addr, label_slots[addr].pos2);
29918|       |            if (pass == 3)
29919|       |                printf(" %u", addr + pos);
29920|       |            break;
29921|       |        case OP_FMT_label_u16:
29922|       |            addr = get_u32(tab + pos);
29923|       |            if (pass == 1)
29924|       |                printf(" %u:%u", addr, label_slots[addr].pos);
29925|       |            if (pass == 2)
29926|       |                printf(" %u:%u", addr, label_slots[addr].pos2);
29927|       |            if (pass == 3)
29928|       |                printf(" %u", addr + pos);
29929|       |            printf(",%u", get_u16(tab + pos + 4));
29930|       |            break;
29931|       |#if SHORT_OPCODES
29932|       |        case OP_FMT_const8:
29933|       |            idx = get_u8(tab + pos);
29934|       |            goto has_pool_idx;
29935|       |#endif
29936|       |        case OP_FMT_const:
29937|       |            idx = get_u32(tab + pos);
29938|       |            goto has_pool_idx;
29939|       |        has_pool_idx:
29940|       |            printf(" %u: ", idx);
29941|       |            if (idx < cpool_count) {
29942|       |                JS_DumpValue(ctx, cpool[idx]);
29943|       |            }
29944|       |            break;
29945|       |        case OP_FMT_atom:
29946|       |            printf(" ");
29947|       |            print_atom(ctx, get_u32(tab + pos));
29948|       |            break;
29949|       |        case OP_FMT_atom_u8:
29950|       |            printf(" ");
29951|       |            print_atom(ctx, get_u32(tab + pos));
29952|       |            printf(",%d", get_u8(tab + pos + 4));
29953|       |            break;
29954|       |        case OP_FMT_atom_u16:
29955|       |            printf(" ");
29956|       |            print_atom(ctx, get_u32(tab + pos));
29957|       |            printf(",%d", get_u16(tab + pos + 4));
29958|       |            break;
29959|       |        case OP_FMT_atom_label_u8:
29960|       |        case OP_FMT_atom_label_u16:
29961|       |            printf(" ");
29962|       |            print_atom(ctx, get_u32(tab + pos));
29963|       |            addr = get_u32(tab + pos + 4);
29964|       |            if (pass == 1)
29965|       |                printf(",%u:%u", addr, label_slots[addr].pos);
29966|       |            if (pass == 2)
29967|       |                printf(",%u:%u", addr, label_slots[addr].pos2);
29968|       |            if (pass == 3)
29969|       |                printf(",%u", addr + pos + 4);
29970|       |            if (oi->fmt == OP_FMT_atom_label_u8)
29971|       |                printf(",%u", get_u8(tab + pos + 8));
29972|       |            else
29973|       |                printf(",%u", get_u16(tab + pos + 8));
29974|       |            break;
29975|       |        case OP_FMT_none_loc:
29976|       |            idx = (op - OP_get_loc0) % 4;
29977|       |            goto has_loc;
29978|       |        case OP_FMT_loc8:
29979|       |            idx = get_u8(tab + pos);
29980|       |            goto has_loc;
29981|       |        case OP_FMT_loc:
29982|       |            idx = get_u16(tab + pos);
29983|       |        has_loc:
29984|       |            printf(" %d: ", idx);
29985|       |            if (idx < var_count) {
29986|       |                print_atom(ctx, vars[idx].var_name);
29987|       |            }
29988|       |            break;
29989|       |        case OP_FMT_none_arg:
29990|       |            idx = (op - OP_get_arg0) % 4;
29991|       |            goto has_arg;
29992|       |        case OP_FMT_arg:
29993|       |            idx = get_u16(tab + pos);
29994|       |        has_arg:
29995|       |            printf(" %d: ", idx);
29996|       |            if (idx < arg_count) {
29997|       |                print_atom(ctx, args[idx].var_name);
29998|       |            }
29999|       |            break;
30000|       |        case OP_FMT_none_var_ref:
30001|       |            idx = (op - OP_get_var_ref0) % 4;
30002|       |            goto has_var_ref;
30003|       |        case OP_FMT_var_ref:
30004|       |            idx = get_u16(tab + pos);
30005|       |        has_var_ref:
30006|       |            printf(" %d: ", idx);
30007|       |            if (idx < closure_var_count) {
30008|       |                print_atom(ctx, closure_var[idx].var_name);
30009|       |            }
30010|       |            break;
30011|       |        default:
30012|       |            break;
30013|       |        }
30014|       |        printf("\n");
30015|       |        pos += oi->size - 1;
30016|       |    }
30017|       |    if (source) {
30018|       |        if (!in_source)
30019|       |            printf("\n");
30020|       |        print_lines(source, line, INT32_MAX);
30021|       |    }
30022|       |    js_free(ctx, bits);
30023|       |}
30024|       |
30025|       |static __maybe_unused void dump_pc2line(JSContext *ctx, const uint8_t *buf, int len)
30026|       |{
30027|       |    const uint8_t *p_end, *p;
30028|       |    int pc, v, line_num, col_num, ret;
30029|       |    unsigned int op;
30030|       |    uint32_t val;
30031|       |    
30032|       |    if (len <= 0)
30033|       |        return;
30034|       |
30035|       |    printf("%5s %5s %5s\n", "PC", "LINE", "COL");
30036|       |
30037|       |    p = buf;
30038|       |    p_end = buf + len;
30039|       |    
30040|       |    /* get the function line and column numbers */
30041|       |    ret = get_leb128(&val, p, p_end);
30042|       |    if (ret < 0)
30043|       |        goto fail;
30044|       |    p += ret;
30045|       |    line_num = val + 1;
30046|       |
30047|       |    ret = get_leb128(&val, p, p_end);
30048|       |    if (ret < 0)
30049|       |        goto fail;
30050|       |    p += ret;
30051|       |    col_num = val + 1;
30052|       |
30053|       |    printf("%5s %5d %5d\n", "-", line_num, col_num);
30054|       |    
30055|       |    pc = 0;
30056|       |    while (p < p_end) {
30057|       |        op = *p++;
30058|       |        if (op == 0) {
30059|       |            ret = get_leb128(&val, p, p_end);
30060|       |            if (ret < 0)
30061|       |                goto fail;
30062|       |            pc += val;
30063|       |            p += ret;
30064|       |            ret = get_sleb128(&v, p, p_end);
30065|       |            if (ret < 0)
30066|       |                goto fail;
30067|       |            p += ret;
30068|       |            line_num += v;
30069|       |        } else {
30070|       |            op -= PC2LINE_OP_FIRST;
30071|       |            pc += (op / PC2LINE_RANGE);
30072|       |            line_num += (op % PC2LINE_RANGE) + PC2LINE_BASE;
30073|       |        }
30074|       |        ret = get_sleb128(&v, p, p_end);
30075|       |        if (ret < 0)
30076|       |            goto fail;
30077|       |        p += ret;
30078|       |        col_num += v;
30079|       |        
30080|       |        printf("%5d %5d %5d\n", pc, line_num, col_num);
30081|       |    }
30082|       | fail: ;
30083|       |}
30084|       |
30085|       |static __maybe_unused void js_dump_function_bytecode(JSContext *ctx, JSFunctionBytecode *b)
30086|       |{
30087|       |    int i;
30088|       |    char atom_buf[ATOM_GET_STR_BUF_SIZE];
30089|       |    const char *str;
30090|       |
30091|       |    if (b->has_debug && b->debug.filename != JS_ATOM_NULL) {
30092|       |        int line_num, col_num;
30093|       |        str = JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->debug.filename);
30094|       |        line_num = find_line_num(ctx, b, -1, &col_num);
30095|       |        printf("%s:%d:%d: ", str, line_num, col_num);
30096|       |    }
30097|       |
30098|       |    str = JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->func_name);
30099|       |    printf("function: %s%s\n", &"*"[b->func_kind != JS_FUNC_GENERATOR], str);
30100|       |    if (b->js_mode) {
30101|       |        printf("  mode:");
30102|       |        if (b->js_mode & JS_MODE_STRICT)
30103|       |            printf(" strict");
30104|       |        printf("\n");
30105|       |    }
30106|       |    if (b->arg_count && b->vardefs) {
30107|       |        printf("  args:");
30108|       |        for(i = 0; i < b->arg_count; i++) {
30109|       |            printf(" %s", JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf),
30110|       |                                        b->vardefs[i].var_name));
30111|       |        }
30112|       |        printf("\n");
30113|       |    }
30114|       |    if (b->var_count && b->vardefs) {
30115|       |        printf("  locals:\n");
30116|       |        for(i = 0; i < b->var_count; i++) {
30117|       |            JSVarDef *vd = &b->vardefs[b->arg_count + i];
30118|       |            printf("%5d: %s %s", i,
30119|       |                   vd->var_kind == JS_VAR_CATCH ? "catch" :
30120|       |                   (vd->var_kind == JS_VAR_FUNCTION_DECL ||
30121|       |                    vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) ? "function" :
30122|       |                   vd->is_const ? "const" :
30123|       |                   vd->is_lexical ? "let" : "var",
30124|       |                   JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), vd->var_name));
30125|       |            if (vd->scope_level)
30126|       |                printf(" [level:%d next:%d]", vd->scope_level, vd->scope_next);
30127|       |            printf("\n");
30128|       |        }
30129|       |    }
30130|       |    if (b->closure_var_count) {
30131|       |        printf("  closure vars:\n");
30132|       |        for(i = 0; i < b->closure_var_count; i++) {
30133|       |            JSClosureVar *cv = &b->closure_var[i];
30134|       |            printf("%5d: %s %s:%s%d %s\n", i,
30135|       |                   JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), cv->var_name),
30136|       |                   cv->is_local ? "local" : "parent",
30137|       |                   cv->is_arg ? "arg" : "loc", cv->var_idx,
30138|       |                   cv->is_const ? "const" :
30139|       |                   cv->is_lexical ? "let" : "var");
30140|       |        }
30141|       |    }
30142|       |    printf("  stack_size: %d\n", b->stack_size);
30143|       |    printf("  opcodes:\n");
30144|       |    dump_byte_code(ctx, 3, b->byte_code_buf, b->byte_code_len,
30145|       |                   b->vardefs, b->arg_count,
30146|       |                   b->vardefs ? b->vardefs + b->arg_count : NULL, b->var_count,
30147|       |                   b->closure_var, b->closure_var_count,
30148|       |                   b->cpool, b->cpool_count,
30149|       |                   b->has_debug ? b->debug.source : NULL,
30150|       |                   NULL, b);
30151|       |#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 32)
30152|       |    if (b->has_debug)
30153|       |        dump_pc2line(ctx, b->debug.pc2line_buf, b->debug.pc2line_len);
30154|       |#endif
30155|       |    printf("\n");
30156|       |}
30157|       |#endif
30158|       |
30159|       |static int add_closure_var(JSContext *ctx, JSFunctionDef *s,
30160|       |                           BOOL is_local, BOOL is_arg,
30161|       |                           int var_idx, JSAtom var_name,
30162|       |                           BOOL is_const, BOOL is_lexical,
30163|       |                           JSVarKindEnum var_kind)
30164|   119k|{
30165|   119k|    JSClosureVar *cv;
30166|       |
30167|       |    /* the closure variable indexes are currently stored on 16 bits */
30168|   119k|    if (s->closure_var_count >= JS_MAX_LOCAL_VARS) {
30169|      0|        JS_ThrowInternalError(ctx, "too many closure variables");
30170|      0|        return -1;
30171|      0|    }
30172|       |
30173|   119k|    if (js_resize_array(ctx, (void **)&s->closure_var,
30174|   119k|                        sizeof(s->closure_var[0]),
30175|   119k|                        &s->closure_var_size, s->closure_var_count + 1))
30176|      0|        return -1;
30177|   119k|    cv = &s->closure_var[s->closure_var_count++];
30178|   119k|    cv->is_local = is_local;
30179|   119k|    cv->is_arg = is_arg;
30180|   119k|    cv->is_const = is_const;
30181|   119k|    cv->is_lexical = is_lexical;
30182|   119k|    cv->var_kind = var_kind;
30183|   119k|    cv->var_idx = var_idx;
30184|   119k|    cv->var_name = JS_DupAtom(ctx, var_name);
30185|   119k|    return s->closure_var_count - 1;
30186|   119k|}
30187|       |
30188|       |static int find_closure_var(JSContext *ctx, JSFunctionDef *s,
30189|       |                            JSAtom var_name)
30190|    492|{
30191|    492|    int i;
30192|    917|    for(i = 0; i < s->closure_var_count; i++) {
30193|    914|        JSClosureVar *cv = &s->closure_var[i];
30194|    914|        if (cv->var_name == var_name)
30195|    489|            return i;
30196|    914|    }
30197|      3|    return -1;
30198|    492|}
30199|       |
30200|       |/* 'fd' must be a parent of 's'. Create in 's' a closure referencing a
30201|       |   local variable (is_local = TRUE) or a closure (is_local = FALSE) in
30202|       |   'fd' */
30203|       |static int get_closure_var2(JSContext *ctx, JSFunctionDef *s,
30204|       |                            JSFunctionDef *fd, BOOL is_local,
30205|       |                            BOOL is_arg, int var_idx, JSAtom var_name,
30206|       |                            BOOL is_const, BOOL is_lexical,
30207|       |                            JSVarKindEnum var_kind)
30208|   158k|{
30209|   158k|    int i;
30210|       |
30211|   158k|    if (fd != s->parent) {
30212|  85.4k|        var_idx = get_closure_var2(ctx, s->parent, fd, is_local,
30213|  85.4k|                                   is_arg, var_idx, var_name,
30214|  85.4k|                                   is_const, is_lexical, var_kind);
30215|  85.4k|        if (var_idx < 0)
30216|      0|            return -1;
30217|  85.4k|        is_local = FALSE;
30218|  85.4k|    }
30219|   246k|    for(i = 0; i < s->closure_var_count; i++) {
30220|   135k|        JSClosureVar *cv = &s->closure_var[i];
30221|   135k|        if (cv->var_idx == var_idx && cv->is_arg == is_arg &&
30222|   135k|            cv->is_local == is_local)
30223|  47.0k|            return i;
30224|   135k|    }
30225|   111k|    return add_closure_var(ctx, s, is_local, is_arg, var_idx, var_name,
30226|   111k|                           is_const, is_lexical, var_kind);
30227|   158k|}
30228|       |
30229|       |static int get_closure_var(JSContext *ctx, JSFunctionDef *s,
30230|       |                           JSFunctionDef *fd, BOOL is_arg,
30231|       |                           int var_idx, JSAtom var_name,
30232|       |                           BOOL is_const, BOOL is_lexical,
30233|       |                           JSVarKindEnum var_kind)
30234|  68.1k|{
30235|  68.1k|    return get_closure_var2(ctx, s, fd, TRUE, is_arg,
30236|  68.1k|                            var_idx, var_name, is_const, is_lexical,
30237|  68.1k|                            var_kind);
30238|  68.1k|}
30239|       |
30240|       |static int get_with_scope_opcode(int op)
30241|      0|{
30242|      0|    if (op == OP_scope_get_var_undef)
30243|      0|        return OP_with_get_var;
30244|      0|    else
30245|      0|        return OP_with_get_var + (op - OP_scope_get_var);
30246|      0|}
30247|       |
30248|       |static BOOL can_opt_put_ref_value(const uint8_t *bc_buf, int pos)
30249|   125k|{
30250|   125k|    int opcode = bc_buf[pos];
30251|   125k|    return (bc_buf[pos + 1] == OP_put_ref_value &&
30252|   125k|            (opcode == OP_insert3 ||
30253|   124k|             opcode == OP_perm4 ||
30254|   124k|             opcode == OP_nop ||
30255|   124k|             opcode == OP_rot3l));
30256|   125k|}
30257|       |
30258|       |static BOOL can_opt_put_global_ref_value(const uint8_t *bc_buf, int pos)
30259|   208k|{
30260|   208k|    int opcode = bc_buf[pos];
30261|   208k|    return (bc_buf[pos + 1] == OP_put_ref_value &&
30262|   208k|            (opcode == OP_insert3 ||
30263|   193k|             opcode == OP_perm4 ||
30264|   193k|             opcode == OP_nop ||
30265|   193k|             opcode == OP_rot3l));
30266|   208k|}
30267|       |
30268|       |static int optimize_scope_make_ref(JSContext *ctx, JSFunctionDef *s,
30269|       |                                   DynBuf *bc, uint8_t *bc_buf,
30270|       |                                   LabelSlot *ls, int pos_next,
30271|       |                                   int get_op, int var_idx)
30272|   124k|{
30273|   124k|    int label_pos, end_pos, pos;
30274|       |
30275|       |    /* XXX: should optimize `loc(a) += expr` as `expr add_loc(a)`
30276|       |       but only if expr does not modify `a`.
30277|       |       should scan the code between pos_next and label_pos
30278|       |       for operations that can potentially change `a`:
30279|       |       OP_scope_make_ref(a), function calls, jumps and gosub.
30280|       |     */
30281|       |    /* replace the reference get/put with normal variable
30282|       |       accesses */
30283|   124k|    if (bc_buf[pos_next] == OP_get_ref_value) {
30284|  43.6k|        dbuf_putc(bc, get_op);
30285|  43.6k|        dbuf_put_u16(bc, var_idx);
30286|  43.6k|        pos_next++;
30287|  43.6k|    }
30288|       |    /* remove the OP_label to make room for replacement */
30289|       |    /* label should have a refcount of 0 anyway */
30290|       |    /* XXX: should avoid this patch by inserting nops in phase 1 */
30291|   124k|    label_pos = ls->pos;
30292|   124k|    pos = label_pos - 5;
30293|   124k|    assert(bc_buf[pos] == OP_label);
30294|       |    /* label points to an instruction pair:
30295|       |       - insert3 / put_ref_value
30296|       |       - perm4 / put_ref_value
30297|       |       - rot3l / put_ref_value
30298|       |       - nop / put_ref_value
30299|       |     */
30300|   124k|    end_pos = label_pos + 2;
30301|   124k|    if (bc_buf[label_pos] == OP_insert3)
30302|  80.8k|        bc_buf[pos++] = OP_dup;
30303|   124k|    bc_buf[pos] = get_op + 1;
30304|   124k|    put_u16(bc_buf + pos + 1, var_idx);
30305|   124k|    pos += 3;
30306|       |    /* pad with OP_nop */
30307|   541k|    while (pos < end_pos)
30308|   417k|        bc_buf[pos++] = OP_nop;
30309|   124k|    return pos_next;
30310|   124k|}
30311|       |
30312|       |static int optimize_scope_make_global_ref(JSContext *ctx, JSFunctionDef *s,
30313|       |                                          DynBuf *bc, uint8_t *bc_buf,
30314|       |                                          LabelSlot *ls, int pos_next,
30315|       |                                          JSAtom var_name)
30316|   193k|{
30317|   193k|    int label_pos, end_pos, pos, op;
30318|   193k|    BOOL is_strict;
30319|   193k|    is_strict = ((s->js_mode & JS_MODE_STRICT) != 0);
30320|       |
30321|       |    /* replace the reference get/put with normal variable
30322|       |       accesses */
30323|   193k|    if (is_strict) {
30324|       |        /* need to check if the variable exists before evaluating the right
30325|       |           expression */
30326|       |        /* XXX: need an extra OP_true if destructuring an array */
30327|  53.0k|        dbuf_putc(bc, OP_check_var);
30328|  53.0k|        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30329|   140k|    } else {
30330|       |        /* XXX: need 2 extra OP_true if destructuring an array */
30331|   140k|    }
30332|   193k|    if (bc_buf[pos_next] == OP_get_ref_value) {
30333|  21.7k|        dbuf_putc(bc, OP_get_var);
30334|  21.7k|        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30335|  21.7k|        pos_next++;
30336|  21.7k|    }
30337|       |    /* remove the OP_label to make room for replacement */
30338|       |    /* label should have a refcount of 0 anyway */
30339|       |    /* XXX: should have emitted several OP_nop to avoid this kludge */
30340|   193k|    label_pos = ls->pos;
30341|   193k|    pos = label_pos - 5;
30342|   193k|    assert(bc_buf[pos] == OP_label);
30343|   193k|    end_pos = label_pos + 2;
30344|   193k|    op = bc_buf[label_pos];
30345|   193k|    if (is_strict) {
30346|  53.0k|        if (op != OP_nop) {
30347|  53.0k|            switch(op) {
30348|  43.1k|            case OP_insert3:
30349|  43.1k|                op = OP_insert2;
30350|  43.1k|                break;
30351|  5.67k|            case OP_perm4:
30352|  5.67k|                op = OP_perm3;
30353|  5.67k|                break;
30354|  4.23k|            case OP_rot3l:
30355|  4.23k|                op = OP_swap;
30356|  4.23k|                break;
30357|      0|            default:
30358|      0|                abort();
30359|  53.0k|            }
30360|  53.0k|            bc_buf[pos++] = op;
30361|  53.0k|        }
30362|   140k|    } else {
30363|   140k|        if (op == OP_insert3)
30364|   119k|            bc_buf[pos++] = OP_dup;
30365|   140k|    }
30366|   193k|    if (is_strict) {
30367|  53.0k|        bc_buf[pos] = OP_put_var_strict;
30368|       |        /* XXX: need 1 extra OP_drop if destructuring an array */
30369|   140k|    } else {
30370|   140k|        bc_buf[pos] = OP_put_var;
30371|       |        /* XXX: need 2 extra OP_drop if destructuring an array */
30372|   140k|    }
30373|   193k|    put_u32(bc_buf + pos + 1, JS_DupAtom(ctx, var_name));
30374|   193k|    pos += 5;
30375|       |    /* pad with OP_nop */
30376|   407k|    while (pos < end_pos)
30377|   214k|        bc_buf[pos++] = OP_nop;
30378|   193k|    return pos_next;
30379|   193k|}
30380|       |
30381|       |static int add_var_this(JSContext *ctx, JSFunctionDef *fd)
30382|      0|{
30383|      0|    int idx;
30384|      0|    idx = add_var(ctx, fd, JS_ATOM_this);
30385|      0|    if (idx >= 0 && fd->is_derived_class_constructor) {
30386|      0|        JSVarDef *vd = &fd->vars[idx];
30387|       |        /* XXX: should have is_this flag or var type */
30388|      0|        vd->is_lexical = 1; /* used to trigger 'uninitialized' checks
30389|       |                               in a derived class constructor */
30390|      0|    }
30391|      0|    return idx;
30392|      0|}
30393|       |
30394|       |static int resolve_pseudo_var(JSContext *ctx, JSFunctionDef *s,
30395|       |                               JSAtom var_name)
30396|      0|{
30397|      0|    int var_idx;
30398|       |
30399|      0|    if (!s->has_this_binding)
30400|      0|        return -1;
30401|      0|    switch(var_name) {
30402|      0|    case JS_ATOM_home_object:
30403|       |        /* 'home_object' pseudo variable */
30404|      0|        if (s->home_object_var_idx < 0)
30405|      0|            s->home_object_var_idx = add_var(ctx, s, var_name);
30406|      0|        var_idx = s->home_object_var_idx;
30407|      0|        break;
30408|      0|    case JS_ATOM_this_active_func:
30409|       |        /* 'this.active_func' pseudo variable */
30410|      0|        if (s->this_active_func_var_idx < 0)
30411|      0|            s->this_active_func_var_idx = add_var(ctx, s, var_name);
30412|      0|        var_idx = s->this_active_func_var_idx;
30413|      0|        break;
30414|      0|    case JS_ATOM_new_target:
30415|       |        /* 'new.target' pseudo variable */
30416|      0|        if (s->new_target_var_idx < 0)
30417|      0|            s->new_target_var_idx = add_var(ctx, s, var_name);
30418|      0|        var_idx = s->new_target_var_idx;
30419|      0|        break;
30420|      0|    case JS_ATOM_this:
30421|       |        /* 'this' pseudo variable */
30422|      0|        if (s->this_var_idx < 0)
30423|      0|            s->this_var_idx = add_var_this(ctx, s);
30424|      0|        var_idx = s->this_var_idx;
30425|      0|        break;
30426|      0|    default:
30427|      0|        var_idx = -1;
30428|      0|        break;
30429|      0|    }
30430|      0|    return var_idx;
30431|      0|}
30432|       |
30433|       |/* test if 'var_name' is in the variable object on the stack. If is it
30434|       |   the case, handle it and jump to 'label_done' */
30435|       |static void var_object_test(JSContext *ctx, JSFunctionDef *s,
30436|       |                            JSAtom var_name, int op, DynBuf *bc,
30437|       |                            int *plabel_done, BOOL is_with)
30438|      0|{
30439|      0|    dbuf_putc(bc, get_with_scope_opcode(op));
30440|      0|    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30441|      0|    *plabel_done = new_label_fd(s, *plabel_done);
30442|      0|    dbuf_put_u32(bc, *plabel_done);
30443|      0|    dbuf_putc(bc, is_with);
30444|      0|    update_label(s, *plabel_done, 1);
30445|      0|    s->jump_size++;
30446|      0|}
30447|       |
30448|       |/* return the position of the next opcode */
30449|       |static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
30450|       |                             JSAtom var_name, int scope_level, int op,
30451|       |                             DynBuf *bc, uint8_t *bc_buf,
30452|       |                             LabelSlot *ls, int pos_next)
30453|   472k|{
30454|   472k|    int idx, var_idx, is_put;
30455|   472k|    int label_done;
30456|   472k|    JSFunctionDef *fd;
30457|   472k|    JSVarDef *vd;
30458|   472k|    BOOL is_pseudo_var, is_arg_scope;
30459|       |
30460|   472k|    label_done = -1;
30461|       |
30462|       |    /* XXX: could be simpler to use a specific function to
30463|       |       resolve the pseudo variables */
30464|   472k|    is_pseudo_var = (var_name == JS_ATOM_home_object ||
30465|   472k|                     var_name == JS_ATOM_this_active_func ||
30466|   472k|                     var_name == JS_ATOM_new_target ||
30467|   472k|                     var_name == JS_ATOM_this);
30468|       |
30469|       |    /* resolve local scoped variables */
30470|   472k|    var_idx = -1;
30471|   664k|    for (idx = s->scopes[scope_level].first; idx >= 0;) {
30472|   257k|        vd = &s->vars[idx];
30473|   257k|        if (vd->var_name == var_name) {
30474|  65.6k|            if (op == OP_scope_put_var || op == OP_scope_make_ref) {
30475|  31.3k|                if (vd->is_const) {
30476|  1.96k|                    dbuf_putc(bc, OP_throw_error);
30477|  1.96k|                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30478|  1.96k|                    dbuf_putc(bc, JS_THROW_VAR_RO);
30479|  1.96k|                    goto done;
30480|  1.96k|                }
30481|  31.3k|            }
30482|  63.7k|            var_idx = idx;
30483|  63.7k|            break;
30484|  65.6k|        } else
30485|   191k|        if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {
30486|      0|            dbuf_putc(bc, OP_get_loc);
30487|      0|            dbuf_put_u16(bc, idx);
30488|      0|            var_object_test(ctx, s, var_name, op, bc, &label_done, 1);
30489|      0|        }
30490|   191k|        idx = vd->scope_next;
30491|   191k|    }
30492|   470k|    is_arg_scope = (idx == ARG_SCOPE_END);
30493|   470k|    if (var_idx < 0) {
30494|       |        /* argument scope: variables are not visible but pseudo
30495|       |           variables are visible */
30496|   406k|        if (!is_arg_scope) {
30497|   406k|            var_idx = find_var(ctx, s, var_name);
30498|   406k|        }
30499|       |
30500|   406k|        if (var_idx < 0 && is_pseudo_var)
30501|      0|            var_idx = resolve_pseudo_var(ctx, s, var_name);
30502|       |
30503|   406k|        if (var_idx < 0 && var_name == JS_ATOM_arguments &&
30504|   406k|            s->has_arguments_binding) {
30505|       |            /* 'arguments' pseudo variable */
30506|      0|            var_idx = add_arguments_var(ctx, s);
30507|      0|        }
30508|   406k|        if (var_idx < 0 && s->is_func_expr && var_name == s->func_name) {
30509|       |            /* add a new variable with the function name */
30510|      0|            var_idx = add_func_var(ctx, s, var_name);
30511|      0|        }
30512|   406k|    }
30513|   470k|    if (var_idx >= 0) {
30514|  98.0k|        if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
30515|  98.0k|            !(var_idx & ARGUMENT_VAR_OFFSET) &&
30516|  98.0k|            s->vars[var_idx].is_const) {
30517|       |            /* only happens when assigning a function expression name
30518|       |               in strict mode */
30519|      0|            dbuf_putc(bc, OP_throw_error);
30520|      0|            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30521|      0|            dbuf_putc(bc, JS_THROW_VAR_RO);
30522|      0|            goto done;
30523|      0|        }
30524|       |        /* OP_scope_put_var_init is only used to initialize a
30525|       |           lexical variable, so it is never used in a with or var object. It
30526|       |           can be used with a closure (module global variable case). */
30527|  98.0k|        switch (op) {
30528|  61.0k|        case OP_scope_make_ref:
30529|  61.0k|            if (!(var_idx & ARGUMENT_VAR_OFFSET) &&
30530|  61.0k|                s->vars[var_idx].var_kind == JS_VAR_FUNCTION_NAME) {
30531|       |                /* Create a dummy object reference for the func_var */
30532|      0|                dbuf_putc(bc, OP_object);
30533|      0|                dbuf_putc(bc, OP_get_loc);
30534|      0|                dbuf_put_u16(bc, var_idx);
30535|      0|                dbuf_putc(bc, OP_define_field);
30536|      0|                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30537|      0|                dbuf_putc(bc, OP_push_atom_value);
30538|      0|                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30539|      0|            } else
30540|  61.0k|            if (label_done == -1 && can_opt_put_ref_value(bc_buf, ls->pos)) {
30541|  60.0k|                int get_op;
30542|  60.0k|                if (var_idx & ARGUMENT_VAR_OFFSET) {
30543|  27.6k|                    get_op = OP_get_arg;
30544|  27.6k|                    var_idx -= ARGUMENT_VAR_OFFSET;
30545|  32.3k|                } else {
30546|  32.3k|                    if (s->vars[var_idx].is_lexical)
30547|  29.2k|                        get_op = OP_get_loc_check;
30548|  3.12k|                    else
30549|  3.12k|                        get_op = OP_get_loc;
30550|  32.3k|                }
30551|  60.0k|                pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls,
30552|  60.0k|                                                   pos_next, get_op, var_idx);
30553|  60.0k|            } else {
30554|       |                /* Create a dummy object with a named slot that is
30555|       |                   a reference to the local variable */
30556|    916|                if (var_idx & ARGUMENT_VAR_OFFSET) {
30557|    652|                    dbuf_putc(bc, OP_make_arg_ref);
30558|    652|                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30559|    652|                    dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
30560|    652|                } else {
30561|    264|                    dbuf_putc(bc, OP_make_loc_ref);
30562|    264|                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30563|    264|                    dbuf_put_u16(bc, var_idx);
30564|    264|                }
30565|    916|            }
30566|  61.0k|            break;
30567|      0|        case OP_scope_get_ref:
30568|      0|            dbuf_putc(bc, OP_undefined);
30569|       |            /* fall thru */
30570|      0|        case OP_scope_get_var_checkthis:
30571|      0|        case OP_scope_get_var_undef:
30572|  24.9k|        case OP_scope_get_var:
30573|  25.1k|        case OP_scope_put_var:
30574|  37.0k|        case OP_scope_put_var_init:
30575|  37.0k|            is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);
30576|  37.0k|            if (var_idx & ARGUMENT_VAR_OFFSET) {
30577|    395|                dbuf_putc(bc, OP_get_arg + is_put);
30578|    395|                dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
30579|  36.6k|            } else {
30580|  36.6k|                if (is_put) {
30581|  12.1k|                    if (s->vars[var_idx].is_lexical) {
30582|  11.8k|                        if (op == OP_scope_put_var_init) {
30583|       |                            /* 'this' can only be initialized once */
30584|  11.8k|                            if (var_name == JS_ATOM_this)
30585|      0|                                dbuf_putc(bc, OP_put_loc_check_init);
30586|  11.8k|                            else
30587|  11.8k|                                dbuf_putc(bc, OP_put_loc);
30588|  11.8k|                        } else {
30589|      0|                            dbuf_putc(bc, OP_put_loc_check);
30590|      0|                        }
30591|  11.8k|                    } else {
30592|    216|                        dbuf_putc(bc, OP_put_loc);
30593|    216|                    }
30594|  24.5k|                } else {
30595|  24.5k|                    if (s->vars[var_idx].is_lexical) {
30596|  22.4k|                        if (op == OP_scope_get_var_checkthis) {
30597|       |                            /* only used for 'this' return in derived class constructors */
30598|      0|                            dbuf_putc(bc, OP_get_loc_checkthis);
30599|  22.4k|                        } else {
30600|  22.4k|                            dbuf_putc(bc, OP_get_loc_check);
30601|  22.4k|                        }
30602|  22.4k|                    } else {
30603|  2.13k|                        dbuf_putc(bc, OP_get_loc);
30604|  2.13k|                    }
30605|  24.5k|                }
30606|  36.6k|                dbuf_put_u16(bc, var_idx);
30607|  36.6k|            }
30608|  37.0k|            break;
30609|      0|        case OP_scope_delete_var:
30610|      0|            dbuf_putc(bc, OP_push_false);
30611|      0|            break;
30612|  98.0k|        }
30613|  98.0k|        goto done;
30614|  98.0k|    }
30615|       |    /* check eval object */
30616|   372k|    if (!is_arg_scope && s->var_object_idx >= 0 && !is_pseudo_var) {
30617|      0|        dbuf_putc(bc, OP_get_loc);
30618|      0|        dbuf_put_u16(bc, s->var_object_idx);
30619|      0|        var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
30620|      0|    }
30621|       |    /* check eval object in argument scope */
30622|   372k|    if (s->arg_var_object_idx >= 0 && !is_pseudo_var) {
30623|      0|        dbuf_putc(bc, OP_get_loc);
30624|      0|        dbuf_put_u16(bc, s->arg_var_object_idx);
30625|      0|        var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
30626|      0|    }
30627|       |
30628|       |    /* check parent scopes */
30629|  1.09M|    for (fd = s; fd->parent;) {
30630|   962k|        scope_level = fd->parent_scope_level;
30631|   962k|        fd = fd->parent;
30632|  1.29M|        for (idx = fd->scopes[scope_level].first; idx >= 0;) {
30633|   385k|            vd = &fd->vars[idx];
30634|   385k|            if (vd->var_name == var_name) {
30635|  48.4k|                if (op == OP_scope_put_var || op == OP_scope_make_ref) {
30636|  37.1k|                    if (vd->is_const) {
30637|    405|                        dbuf_putc(bc, OP_throw_error);
30638|    405|                        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30639|    405|                        dbuf_putc(bc, JS_THROW_VAR_RO);
30640|    405|                        goto done;
30641|    405|                    }
30642|  37.1k|                }
30643|  48.0k|                var_idx = idx;
30644|  48.0k|                break;
30645|   336k|            } else if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {
30646|      0|                vd->is_captured = 1;
30647|      0|                idx = get_closure_var(ctx, s, fd, FALSE, idx, vd->var_name, FALSE, FALSE, JS_VAR_NORMAL);
30648|      0|                if (idx >= 0) {
30649|      0|                    dbuf_putc(bc, OP_get_var_ref);
30650|      0|                    dbuf_put_u16(bc, idx);
30651|      0|                    var_object_test(ctx, s, var_name, op, bc, &label_done, 1);
30652|      0|                }
30653|      0|            }
30654|   336k|            idx = vd->scope_next;
30655|   336k|        }
30656|   961k|        is_arg_scope = (idx == ARG_SCOPE_END);
30657|   961k|        if (var_idx >= 0)
30658|  48.0k|            break;
30659|       |
30660|   913k|        if (!is_arg_scope) {
30661|   913k|            var_idx = find_var(ctx, fd, var_name);
30662|   913k|            if (var_idx >= 0)
30663|  20.0k|                break;
30664|   913k|        }
30665|   893k|        if (is_pseudo_var) {
30666|      0|            var_idx = resolve_pseudo_var(ctx, fd, var_name);
30667|      0|            if (var_idx >= 0)
30668|      0|                break;
30669|      0|        }
30670|   893k|        if (var_name == JS_ATOM_arguments && fd->has_arguments_binding) {
30671|      0|            var_idx = add_arguments_var(ctx, fd);
30672|      0|            break;
30673|      0|        }
30674|   893k|        if (fd->is_func_expr && fd->func_name == var_name) {
30675|       |            /* add a new variable with the function name */
30676|      0|            var_idx = add_func_var(ctx, fd, var_name);
30677|      0|            break;
30678|      0|        }
30679|       |
30680|       |        /* check eval object */
30681|   893k|        if (!is_arg_scope && fd->var_object_idx >= 0 && !is_pseudo_var) {
30682|      0|            vd = &fd->vars[fd->var_object_idx];
30683|      0|            vd->is_captured = 1;
30684|      0|            idx = get_closure_var(ctx, s, fd, FALSE,
30685|      0|                                  fd->var_object_idx, vd->var_name,
30686|      0|                                  FALSE, FALSE, JS_VAR_NORMAL);
30687|      0|            dbuf_putc(bc, OP_get_var_ref);
30688|      0|            dbuf_put_u16(bc, idx);
30689|      0|            var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
30690|      0|        }
30691|       |
30692|       |        /* check eval object in argument scope */
30693|   893k|        if (fd->arg_var_object_idx >= 0 && !is_pseudo_var) {
30694|      0|            vd = &fd->vars[fd->arg_var_object_idx];
30695|      0|            vd->is_captured = 1;
30696|      0|            idx = get_closure_var(ctx, s, fd, FALSE,
30697|      0|                                  fd->arg_var_object_idx, vd->var_name,
30698|      0|                                  FALSE, FALSE, JS_VAR_NORMAL);
30699|      0|            dbuf_putc(bc, OP_get_var_ref);
30700|      0|            dbuf_put_u16(bc, idx);
30701|      0|            var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
30702|      0|        }
30703|       |
30704|   893k|        if (fd->is_eval)
30705|   171k|            break; /* it it necessarily the top level function */
30706|   893k|    }
30707|       |
30708|       |    /* check direct eval scope (in the closure of the eval function
30709|       |       which is necessarily at the top level) */
30710|   371k|    if (!fd)
30711|      0|        fd = s;
30712|   371k|    if (var_idx < 0 && fd->is_eval) {
30713|   303k|        int idx1;
30714|  1.07M|        for (idx1 = 0; idx1 < fd->closure_var_count; idx1++) {
30715|   796k|            JSClosureVar *cv = &fd->closure_var[idx1];
30716|   796k|            if (var_name == cv->var_name) {
30717|  24.1k|                if (fd != s) {
30718|  4.74k|                    idx = get_closure_var2(ctx, s, fd,
30719|  4.74k|                                           FALSE,
30720|  4.74k|                                           cv->is_arg, idx1,
30721|  4.74k|                                           cv->var_name, cv->is_const,
30722|  4.74k|                                           cv->is_lexical, cv->var_kind);
30723|  19.4k|                } else {
30724|  19.4k|                    idx = idx1;
30725|  19.4k|                }
30726|  24.1k|                goto has_idx;
30727|   772k|            } else if ((cv->var_name == JS_ATOM__var_ ||
30728|   772k|                        cv->var_name == JS_ATOM__arg_var_ ||
30729|   772k|                        cv->var_name == JS_ATOM__with_) && !is_pseudo_var) {
30730|      0|                int is_with = (cv->var_name == JS_ATOM__with_);
30731|      0|                if (fd != s) {
30732|      0|                    idx = get_closure_var2(ctx, s, fd,
30733|      0|                                           FALSE,
30734|      0|                                           cv->is_arg, idx1,
30735|      0|                                           cv->var_name, FALSE, FALSE,
30736|      0|                                           JS_VAR_NORMAL);
30737|      0|                } else {
30738|      0|                    idx = idx1;
30739|      0|                }
30740|      0|                dbuf_putc(bc, OP_get_var_ref);
30741|      0|                dbuf_put_u16(bc, idx);
30742|      0|                var_object_test(ctx, s, var_name, op, bc, &label_done, is_with);
30743|      0|            }
30744|   796k|        }
30745|   303k|    }
30746|       |
30747|   347k|    if (var_idx >= 0) {
30748|       |        /* find the corresponding closure variable */
30749|  68.1k|        if (var_idx & ARGUMENT_VAR_OFFSET) {
30750|  19.6k|            fd->args[var_idx - ARGUMENT_VAR_OFFSET].is_captured = 1;
30751|  19.6k|            idx = get_closure_var(ctx, s, fd,
30752|  19.6k|                                  TRUE, var_idx - ARGUMENT_VAR_OFFSET,
30753|  19.6k|                                  var_name, FALSE, FALSE, JS_VAR_NORMAL);
30754|  48.4k|        } else {
30755|  48.4k|            fd->vars[var_idx].is_captured = 1;
30756|  48.4k|            idx = get_closure_var(ctx, s, fd,
30757|  48.4k|                                  FALSE, var_idx,
30758|  48.4k|                                  var_name,
30759|  48.4k|                                  fd->vars[var_idx].is_const,
30760|  48.4k|                                  fd->vars[var_idx].is_lexical,
30761|  48.4k|                                  fd->vars[var_idx].var_kind);
30762|  48.4k|        }
30763|  68.1k|        if (idx >= 0) {
30764|  92.3k|        has_idx:
30765|  92.3k|            if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
30766|  92.3k|                s->closure_var[idx].is_const) {
30767|    119|                dbuf_putc(bc, OP_throw_error);
30768|    119|                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30769|    119|                dbuf_putc(bc, JS_THROW_VAR_RO);
30770|    119|                goto done;
30771|    119|            }
30772|  92.1k|            switch (op) {
30773|  64.6k|            case OP_scope_make_ref:
30774|  64.6k|                if (s->closure_var[idx].var_kind == JS_VAR_FUNCTION_NAME) {
30775|       |                    /* Create a dummy object reference for the func_var */
30776|      0|                    dbuf_putc(bc, OP_object);
30777|      0|                    dbuf_putc(bc, OP_get_var_ref);
30778|      0|                    dbuf_put_u16(bc, idx);
30779|      0|                    dbuf_putc(bc, OP_define_field);
30780|      0|                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30781|      0|                    dbuf_putc(bc, OP_push_atom_value);
30782|      0|                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30783|      0|                } else
30784|  64.6k|                if (label_done == -1 &&
30785|  64.6k|                    can_opt_put_ref_value(bc_buf, ls->pos)) {
30786|  64.4k|                    int get_op;
30787|  64.4k|                    if (s->closure_var[idx].is_lexical)
30788|  44.5k|                        get_op = OP_get_var_ref_check;
30789|  19.8k|                    else
30790|  19.8k|                        get_op = OP_get_var_ref;
30791|  64.4k|                    pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls,
30792|  64.4k|                                                       pos_next,
30793|  64.4k|                                                       get_op, idx);
30794|  64.4k|                } else {
30795|       |                    /* Create a dummy object with a named slot that is
30796|       |                       a reference to the closure variable */
30797|    213|                    dbuf_putc(bc, OP_make_var_ref_ref);
30798|    213|                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30799|    213|                    dbuf_put_u16(bc, idx);
30800|    213|                }
30801|  64.6k|                break;
30802|      0|            case OP_scope_get_ref:
30803|       |                /* XXX: should create a dummy object with a named slot that is
30804|       |                   a reference to the closure variable */
30805|      0|                dbuf_putc(bc, OP_undefined);
30806|       |                /* fall thru */
30807|      0|            case OP_scope_get_var_undef:
30808|  22.8k|            case OP_scope_get_var:
30809|  26.5k|            case OP_scope_put_var:
30810|  27.5k|            case OP_scope_put_var_init:
30811|  27.5k|                is_put = (op == OP_scope_put_var ||
30812|  27.5k|                          op == OP_scope_put_var_init);
30813|  27.5k|                if (is_put) {
30814|  4.68k|                    if (s->closure_var[idx].is_lexical) {
30815|    961|                        if (op == OP_scope_put_var_init) {
30816|       |                            /* 'this' can only be initialized once */
30817|    961|                            if (var_name == JS_ATOM_this)
30818|      0|                                dbuf_putc(bc, OP_put_var_ref_check_init);
30819|    961|                            else
30820|    961|                                dbuf_putc(bc, OP_put_var_ref);
30821|    961|                        } else {
30822|      0|                            dbuf_putc(bc, OP_put_var_ref_check);
30823|      0|                        }
30824|  3.72k|                    } else {
30825|  3.72k|                        dbuf_putc(bc, OP_put_var_ref);
30826|  3.72k|                    }
30827|  22.8k|                } else {
30828|  22.8k|                    if (s->closure_var[idx].is_lexical) {
30829|  11.7k|                        dbuf_putc(bc, OP_get_var_ref_check);
30830|  11.7k|                    } else {
30831|  11.1k|                        dbuf_putc(bc, OP_get_var_ref);
30832|  11.1k|                    }
30833|  22.8k|                }
30834|  27.5k|                dbuf_put_u16(bc, idx);
30835|  27.5k|                break;
30836|      0|            case OP_scope_delete_var:
30837|      0|                dbuf_putc(bc, OP_push_false);
30838|      0|                break;
30839|  92.1k|            }
30840|  92.1k|            goto done;
30841|  92.1k|        }
30842|  68.1k|    }
30843|       |
30844|       |    /* global variable access */
30845|       |
30846|   279k|    switch (op) {
30847|   208k|    case OP_scope_make_ref:
30848|   208k|        if (label_done == -1 && can_opt_put_global_ref_value(bc_buf, ls->pos)) {
30849|   193k|            pos_next = optimize_scope_make_global_ref(ctx, s, bc, bc_buf, ls,
30850|   193k|                                                      pos_next, var_name);
30851|   193k|        } else {
30852|  14.8k|            dbuf_putc(bc, OP_make_var_ref);
30853|  14.8k|            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30854|  14.8k|        }
30855|   208k|        break;
30856|      0|    case OP_scope_get_ref:
30857|       |        /* XXX: should create a dummy object with a named slot that is
30858|       |           a reference to the global variable */
30859|      0|        dbuf_putc(bc, OP_undefined);
30860|      0|        dbuf_putc(bc, OP_get_var);
30861|      0|        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30862|      0|        break;
30863|      0|    case OP_scope_get_var_undef:
30864|  70.2k|    case OP_scope_get_var:
30865|  70.2k|    case OP_scope_put_var:
30866|  70.2k|        dbuf_putc(bc, OP_get_var_undef + (op - OP_scope_get_var_undef));
30867|  70.2k|        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30868|  70.2k|        break;
30869|    926|    case OP_scope_put_var_init:
30870|    926|        dbuf_putc(bc, OP_put_var_init);
30871|    926|        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30872|    926|        break;
30873|      0|    case OP_scope_delete_var:
30874|      0|        dbuf_putc(bc, OP_delete_var);
30875|      0|        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
30876|      0|        break;
30877|   279k|    }
30878|   472k|done:
30879|   472k|    if (label_done >= 0) {
30880|      0|        dbuf_putc(bc, OP_label);
30881|      0|        dbuf_put_u32(bc, label_done);
30882|      0|        s->label_slots[label_done].pos2 = bc->size;
30883|      0|    }
30884|   472k|    return pos_next;
30885|   279k|}
30886|       |
30887|       |/* search in all scopes */
30888|       |static int find_private_class_field_all(JSContext *ctx, JSFunctionDef *fd,
30889|       |                                        JSAtom name, int scope_level)
30890|  1.13k|{
30891|  1.13k|    int idx;
30892|       |
30893|  1.13k|    idx = fd->scopes[scope_level].first;
30894|  1.17k|    while (idx >= 0) {
30895|     44|        if (fd->vars[idx].var_name == name)
30896|      0|            return idx;
30897|     44|        idx = fd->vars[idx].scope_next;
30898|     44|    }
30899|  1.13k|    return -1;
30900|  1.13k|}
30901|       |
30902|       |static void get_loc_or_ref(DynBuf *bc, BOOL is_ref, int idx)
30903|      0|{
30904|       |    /* if the field is not initialized, the error is catched when
30905|       |       accessing it */
30906|      0|    if (is_ref)
30907|      0|        dbuf_putc(bc, OP_get_var_ref);
30908|      0|    else
30909|      0|        dbuf_putc(bc, OP_get_loc);
30910|      0|    dbuf_put_u16(bc, idx);
30911|      0|}
30912|       |
30913|       |static int resolve_scope_private_field1(JSContext *ctx,
30914|       |                                        BOOL *pis_ref, int *pvar_kind,
30915|       |                                        JSFunctionDef *s,
30916|       |                                        JSAtom var_name, int scope_level)
30917|     68|{
30918|     68|    int idx, var_kind;
30919|     68|    JSFunctionDef *fd;
30920|     68|    BOOL is_ref;
30921|       |
30922|     68|    fd = s;
30923|     68|    is_ref = FALSE;
30924|  1.13k|    for(;;) {
30925|  1.13k|        idx = find_private_class_field_all(ctx, fd, var_name, scope_level);
30926|  1.13k|        if (idx >= 0) {
30927|      0|            var_kind = fd->vars[idx].var_kind;
30928|      0|            if (is_ref) {
30929|      0|                idx = get_closure_var(ctx, s, fd, FALSE, idx, var_name,
30930|      0|                                      TRUE, TRUE, JS_VAR_NORMAL);
30931|      0|                if (idx < 0)
30932|      0|                    return -1;
30933|      0|            }
30934|      0|            break;
30935|      0|        }
30936|  1.13k|        scope_level = fd->parent_scope_level;
30937|  1.13k|        if (!fd->parent) {
30938|     68|            if (fd->is_eval) {
30939|       |                /* closure of the eval function (top level) */
30940|    844|                for (idx = 0; idx < fd->closure_var_count; idx++) {
30941|    776|                    JSClosureVar *cv = &fd->closure_var[idx];
30942|    776|                    if (cv->var_name == var_name) {
30943|      0|                        var_kind = cv->var_kind;
30944|      0|                        is_ref = TRUE;
30945|      0|                        if (fd != s) {
30946|      0|                            idx = get_closure_var2(ctx, s, fd,
30947|      0|                                                   FALSE,
30948|      0|                                                   cv->is_arg, idx,
30949|      0|                                                   cv->var_name, cv->is_const,
30950|      0|                                                   cv->is_lexical,
30951|      0|                                                   cv->var_kind);
30952|      0|                            if (idx < 0)
30953|      0|                                return -1;
30954|      0|                        }
30955|      0|                        goto done;
30956|      0|                    }
30957|    776|                }
30958|     68|            }
30959|       |            /* XXX: no line number info */
30960|     68|            JS_ThrowSyntaxErrorAtom(ctx, "undefined private field '%s'",
30961|     68|                                    var_name);
30962|     68|            return -1;
30963|  1.06k|        } else {
30964|  1.06k|            fd = fd->parent;
30965|  1.06k|        }
30966|  1.06k|        is_ref = TRUE;
30967|  1.06k|    }
30968|      0| done:
30969|      0|    *pis_ref = is_ref;
30970|      0|    *pvar_kind = var_kind;
30971|      0|    return idx;
30972|     68|}
30973|       |
30974|       |/* return 0 if OK or -1 if the private field could not be resolved */
30975|       |static int resolve_scope_private_field(JSContext *ctx, JSFunctionDef *s,
30976|       |                                       JSAtom var_name, int scope_level, int op,
30977|       |                                       DynBuf *bc)
30978|     68|{
30979|     68|    int idx, var_kind;
30980|     68|    BOOL is_ref;
30981|       |
30982|     68|    idx = resolve_scope_private_field1(ctx, &is_ref, &var_kind, s,
30983|     68|                                       var_name, scope_level);
30984|     68|    if (idx < 0)
30985|     68|        return -1;
30986|      0|    assert(var_kind != JS_VAR_NORMAL);
30987|      0|    switch (op) {
30988|      0|    case OP_scope_get_private_field:
30989|      0|    case OP_scope_get_private_field2:
30990|      0|        switch(var_kind) {
30991|      0|        case JS_VAR_PRIVATE_FIELD:
30992|      0|            if (op == OP_scope_get_private_field2)
30993|      0|                dbuf_putc(bc, OP_dup);
30994|      0|            get_loc_or_ref(bc, is_ref, idx);
30995|      0|            dbuf_putc(bc, OP_get_private_field);
30996|      0|            break;
30997|      0|        case JS_VAR_PRIVATE_METHOD:
30998|      0|            get_loc_or_ref(bc, is_ref, idx);
30999|      0|            dbuf_putc(bc, OP_check_brand);
31000|      0|            if (op != OP_scope_get_private_field2)
31001|      0|                dbuf_putc(bc, OP_nip);
31002|      0|            break;
31003|      0|        case JS_VAR_PRIVATE_GETTER:
31004|      0|        case JS_VAR_PRIVATE_GETTER_SETTER:
31005|      0|            if (op == OP_scope_get_private_field2)
31006|      0|                dbuf_putc(bc, OP_dup);
31007|      0|            get_loc_or_ref(bc, is_ref, idx);
31008|      0|            dbuf_putc(bc, OP_check_brand);
31009|      0|            dbuf_putc(bc, OP_call_method);
31010|      0|            dbuf_put_u16(bc, 0);
31011|      0|            break;
31012|      0|        case JS_VAR_PRIVATE_SETTER:
31013|       |            /* XXX: add clearer error message */
31014|      0|            dbuf_putc(bc, OP_throw_error);
31015|      0|            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
31016|      0|            dbuf_putc(bc, JS_THROW_VAR_RO);
31017|      0|            break;
31018|      0|        default:
31019|      0|            abort();
31020|      0|        }
31021|      0|        break;
31022|      0|    case OP_scope_put_private_field:
31023|      0|        switch(var_kind) {
31024|      0|        case JS_VAR_PRIVATE_FIELD:
31025|      0|            get_loc_or_ref(bc, is_ref, idx);
31026|      0|            dbuf_putc(bc, OP_put_private_field);
31027|      0|            break;
31028|      0|        case JS_VAR_PRIVATE_METHOD:
31029|      0|        case JS_VAR_PRIVATE_GETTER:
31030|       |            /* XXX: add clearer error message */
31031|      0|            dbuf_putc(bc, OP_throw_error);
31032|      0|            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
31033|      0|            dbuf_putc(bc, JS_THROW_VAR_RO);
31034|      0|            break;
31035|      0|        case JS_VAR_PRIVATE_SETTER:
31036|      0|        case JS_VAR_PRIVATE_GETTER_SETTER:
31037|      0|            {
31038|      0|                JSAtom setter_name = get_private_setter_name(ctx, var_name);
31039|      0|                if (setter_name == JS_ATOM_NULL)
31040|      0|                    return -1;
31041|      0|                idx = resolve_scope_private_field1(ctx, &is_ref,
31042|      0|                                                   &var_kind, s,
31043|      0|                                                   setter_name, scope_level);
31044|      0|                JS_FreeAtom(ctx, setter_name);
31045|      0|                if (idx < 0)
31046|      0|                    return -1;
31047|      0|                assert(var_kind == JS_VAR_PRIVATE_SETTER);
31048|      0|                get_loc_or_ref(bc, is_ref, idx);
31049|      0|                dbuf_putc(bc, OP_swap);
31050|       |                /* obj func value */
31051|      0|                dbuf_putc(bc, OP_rot3r);
31052|       |                /* value obj func */
31053|      0|                dbuf_putc(bc, OP_check_brand);
31054|      0|                dbuf_putc(bc, OP_rot3l);
31055|       |                /* obj func value */
31056|      0|                dbuf_putc(bc, OP_call_method);
31057|      0|                dbuf_put_u16(bc, 1);
31058|      0|                dbuf_putc(bc, OP_drop);
31059|      0|            }
31060|      0|            break;
31061|      0|        default:
31062|      0|            abort();
31063|      0|        }
31064|      0|        break;
31065|      0|    case OP_scope_in_private_field:
31066|      0|        get_loc_or_ref(bc, is_ref, idx);
31067|      0|        dbuf_putc(bc, OP_private_in);
31068|      0|        break;
31069|      0|    default:
31070|      0|        abort();
31071|      0|    }
31072|      0|    return 0;
31073|      0|}
31074|       |
31075|       |static void mark_eval_captured_variables(JSContext *ctx, JSFunctionDef *s,
31076|       |                                         int scope_level)
31077|      0|{
31078|      0|    int idx;
31079|      0|    JSVarDef *vd;
31080|       |
31081|      0|    for (idx = s->scopes[scope_level].first; idx >= 0;) {
31082|      0|        vd = &s->vars[idx];
31083|      0|        vd->is_captured = 1;
31084|      0|        idx = vd->scope_next;
31085|      0|    }
31086|      0|}
31087|       |
31088|       |/* XXX: should handle the argument scope generically */
31089|       |static BOOL is_var_in_arg_scope(const JSVarDef *vd)
31090|      0|{
31091|      0|    return (vd->var_name == JS_ATOM_home_object ||
31092|      0|            vd->var_name == JS_ATOM_this_active_func ||
31093|      0|            vd->var_name == JS_ATOM_new_target ||
31094|      0|            vd->var_name == JS_ATOM_this ||
31095|      0|            vd->var_name == JS_ATOM__arg_var_ ||
31096|      0|            vd->var_kind == JS_VAR_FUNCTION_NAME);
31097|      0|}
31098|       |
31099|       |static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
31100|      0|{
31101|      0|    JSFunctionDef *fd;
31102|      0|    JSVarDef *vd;
31103|      0|    int i, scope_level, scope_idx;
31104|      0|    BOOL has_arguments_binding, has_this_binding, is_arg_scope;
31105|       |
31106|       |    /* in non strict mode, variables are created in the caller's
31107|       |       environment object */
31108|      0|    if (!s->is_eval && !(s->js_mode & JS_MODE_STRICT)) {
31109|      0|        s->var_object_idx = add_var(ctx, s, JS_ATOM__var_);
31110|      0|        if (s->has_parameter_expressions) {
31111|       |            /* an additional variable object is needed for the
31112|       |               argument scope */
31113|      0|            s->arg_var_object_idx = add_var(ctx, s, JS_ATOM__arg_var_);
31114|      0|        }
31115|      0|    }
31116|       |
31117|       |    /* eval can potentially use 'arguments' so we must define it */
31118|      0|    has_this_binding = s->has_this_binding;
31119|      0|    if (has_this_binding) {
31120|      0|        if (s->this_var_idx < 0)
31121|      0|            s->this_var_idx = add_var_this(ctx, s);
31122|      0|        if (s->new_target_var_idx < 0)
31123|      0|            s->new_target_var_idx = add_var(ctx, s, JS_ATOM_new_target);
31124|      0|        if (s->is_derived_class_constructor && s->this_active_func_var_idx < 0)
31125|      0|            s->this_active_func_var_idx = add_var(ctx, s, JS_ATOM_this_active_func);
31126|      0|        if (s->has_home_object && s->home_object_var_idx < 0)
31127|      0|            s->home_object_var_idx = add_var(ctx, s, JS_ATOM_home_object);
31128|      0|    }
31129|      0|    has_arguments_binding = s->has_arguments_binding;
31130|      0|    if (has_arguments_binding) {
31131|      0|        add_arguments_var(ctx, s);
31132|       |        /* also add an arguments binding in the argument scope to
31133|       |           raise an error if a direct eval in the argument scope tries
31134|       |           to redefine it */
31135|      0|        if (s->has_parameter_expressions && !(s->js_mode & JS_MODE_STRICT))
31136|      0|            add_arguments_arg(ctx, s);
31137|      0|    }
31138|      0|    if (s->is_func_expr && s->func_name != JS_ATOM_NULL)
31139|      0|        add_func_var(ctx, s, s->func_name);
31140|       |
31141|       |    /* eval can use all the variables of the enclosing functions, so
31142|       |       they must be all put in the closure. The closure variables are
31143|       |       ordered by scope. It works only because no closure are created
31144|       |       before. */
31145|      0|    assert(s->is_eval || s->closure_var_count == 0);
31146|       |
31147|       |    /* XXX: inefficient, but eval performance is less critical */
31148|      0|    fd = s;
31149|      0|    for(;;) {
31150|      0|        scope_level = fd->parent_scope_level;
31151|      0|        fd = fd->parent;
31152|      0|        if (!fd)
31153|      0|            break;
31154|       |        /* add 'this' if it was not previously added */
31155|      0|        if (!has_this_binding && fd->has_this_binding) {
31156|      0|            if (fd->this_var_idx < 0)
31157|      0|                fd->this_var_idx = add_var_this(ctx, fd);
31158|      0|            if (fd->new_target_var_idx < 0)
31159|      0|                fd->new_target_var_idx = add_var(ctx, fd, JS_ATOM_new_target);
31160|      0|            if (fd->is_derived_class_constructor && fd->this_active_func_var_idx < 0)
31161|      0|                fd->this_active_func_var_idx = add_var(ctx, fd, JS_ATOM_this_active_func);
31162|      0|            if (fd->has_home_object && fd->home_object_var_idx < 0)
31163|      0|                fd->home_object_var_idx = add_var(ctx, fd, JS_ATOM_home_object);
31164|      0|            has_this_binding = TRUE;
31165|      0|        }
31166|       |        /* add 'arguments' if it was not previously added */
31167|      0|        if (!has_arguments_binding && fd->has_arguments_binding) {
31168|      0|            add_arguments_var(ctx, fd);
31169|      0|            has_arguments_binding = TRUE;
31170|      0|        }
31171|       |        /* add function name */
31172|      0|        if (fd->is_func_expr && fd->func_name != JS_ATOM_NULL)
31173|      0|            add_func_var(ctx, fd, fd->func_name);
31174|       |
31175|       |        /* add lexical variables */
31176|      0|        scope_idx = fd->scopes[scope_level].first;
31177|      0|        while (scope_idx >= 0) {
31178|      0|            vd = &fd->vars[scope_idx];
31179|      0|            vd->is_captured = 1;
31180|      0|            get_closure_var(ctx, s, fd, FALSE, scope_idx,
31181|      0|                            vd->var_name, vd->is_const, vd->is_lexical, vd->var_kind);
31182|      0|            scope_idx = vd->scope_next;
31183|      0|        }
31184|      0|        is_arg_scope = (scope_idx == ARG_SCOPE_END);
31185|      0|        if (!is_arg_scope) {
31186|       |            /* add unscoped variables */
31187|       |            /* XXX: propagate is_const and var_kind too ? */
31188|      0|            for(i = 0; i < fd->arg_count; i++) {
31189|      0|                vd = &fd->args[i];
31190|      0|                if (vd->var_name != JS_ATOM_NULL) {
31191|      0|                    get_closure_var(ctx, s, fd,
31192|      0|                                    TRUE, i, vd->var_name, FALSE,
31193|      0|                                    vd->is_lexical, JS_VAR_NORMAL);
31194|      0|                }
31195|      0|            }
31196|      0|            for(i = 0; i < fd->var_count; i++) {
31197|      0|                vd = &fd->vars[i];
31198|       |                /* do not close top level last result */
31199|      0|                if (vd->scope_level == 0 &&
31200|      0|                    vd->var_name != JS_ATOM__ret_ &&
31201|      0|                    vd->var_name != JS_ATOM_NULL) {
31202|      0|                    get_closure_var(ctx, s, fd,
31203|      0|                                    FALSE, i, vd->var_name, FALSE,
31204|      0|                                    vd->is_lexical, JS_VAR_NORMAL);
31205|      0|                }
31206|      0|            }
31207|      0|        } else {
31208|      0|            for(i = 0; i < fd->var_count; i++) {
31209|      0|                vd = &fd->vars[i];
31210|       |                /* do not close top level last result */
31211|      0|                if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {
31212|      0|                    get_closure_var(ctx, s, fd,
31213|      0|                                    FALSE, i, vd->var_name, FALSE,
31214|      0|                                    vd->is_lexical, JS_VAR_NORMAL);
31215|      0|                }
31216|      0|            }
31217|      0|        }
31218|      0|        if (fd->is_eval) {
31219|      0|            int idx;
31220|       |            /* add direct eval variables (we are necessarily at the
31221|       |               top level) */
31222|      0|            for (idx = 0; idx < fd->closure_var_count; idx++) {
31223|      0|                JSClosureVar *cv = &fd->closure_var[idx];
31224|      0|                get_closure_var2(ctx, s, fd,
31225|      0|                                 FALSE, cv->is_arg,
31226|      0|                                 idx, cv->var_name, cv->is_const,
31227|      0|                                 cv->is_lexical, cv->var_kind);
31228|      0|            }
31229|      0|        }
31230|      0|    }
31231|      0|}
31232|       |
31233|       |static void set_closure_from_var(JSContext *ctx, JSClosureVar *cv,
31234|       |                                 JSVarDef *vd, int var_idx)
31235|      0|{
31236|      0|    cv->is_local = TRUE;
31237|      0|    cv->is_arg = FALSE;
31238|      0|    cv->is_const = vd->is_const;
31239|      0|    cv->is_lexical = vd->is_lexical;
31240|      0|    cv->var_kind = vd->var_kind;
31241|      0|    cv->var_idx = var_idx;
31242|      0|    cv->var_name = JS_DupAtom(ctx, vd->var_name);
31243|      0|}
31244|       |
31245|       |/* for direct eval compilation: add references to the variables of the
31246|       |   calling function */
31247|       |static __exception int add_closure_variables(JSContext *ctx, JSFunctionDef *s,
31248|       |                                             JSFunctionBytecode *b, int scope_idx)
31249|      0|{
31250|      0|    int i, count;
31251|      0|    JSVarDef *vd;
31252|      0|    BOOL is_arg_scope;
31253|       |
31254|      0|    count = b->arg_count + b->var_count + b->closure_var_count;
31255|      0|    s->closure_var = NULL;
31256|      0|    s->closure_var_count = 0;
31257|      0|    s->closure_var_size = count;
31258|      0|    if (count == 0)
31259|      0|        return 0;
31260|      0|    s->closure_var = js_malloc(ctx, sizeof(s->closure_var[0]) * count);
31261|      0|    if (!s->closure_var)
31262|      0|        return -1;
31263|       |    /* Add lexical variables in scope at the point of evaluation */
31264|      0|    for (i = scope_idx; i >= 0;) {
31265|      0|        vd = &b->vardefs[b->arg_count + i];
31266|      0|        if (vd->scope_level > 0) {
31267|      0|            JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
31268|      0|            set_closure_from_var(ctx, cv, vd, i);
31269|      0|        }
31270|      0|        i = vd->scope_next;
31271|      0|    }
31272|      0|    is_arg_scope = (i == ARG_SCOPE_END);
31273|      0|    if (!is_arg_scope) {
31274|       |        /* Add argument variables */
31275|      0|        for(i = 0; i < b->arg_count; i++) {
31276|      0|            JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
31277|      0|            vd = &b->vardefs[i];
31278|      0|            cv->is_local = TRUE;
31279|      0|            cv->is_arg = TRUE;
31280|      0|            cv->is_const = FALSE;
31281|      0|            cv->is_lexical = FALSE;
31282|      0|            cv->var_kind = JS_VAR_NORMAL;
31283|      0|            cv->var_idx = i;
31284|      0|            cv->var_name = JS_DupAtom(ctx, vd->var_name);
31285|      0|        }
31286|       |        /* Add local non lexical variables */
31287|      0|        for(i = 0; i < b->var_count; i++) {
31288|      0|            vd = &b->vardefs[b->arg_count + i];
31289|      0|            if (vd->scope_level == 0 && vd->var_name != JS_ATOM__ret_) {
31290|      0|                JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
31291|      0|                set_closure_from_var(ctx, cv, vd, i);
31292|      0|            }
31293|      0|        }
31294|      0|    } else {
31295|       |        /* only add pseudo variables */
31296|      0|        for(i = 0; i < b->var_count; i++) {
31297|      0|            vd = &b->vardefs[b->arg_count + i];
31298|      0|            if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {
31299|      0|                JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
31300|      0|                set_closure_from_var(ctx, cv, vd, i);
31301|      0|            }
31302|      0|        }
31303|      0|    }
31304|      0|    for(i = 0; i < b->closure_var_count; i++) {
31305|      0|        JSClosureVar *cv0 = &b->closure_var[i];
31306|      0|        JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
31307|      0|        cv->is_local = FALSE;
31308|      0|        cv->is_arg = cv0->is_arg;
31309|      0|        cv->is_const = cv0->is_const;
31310|      0|        cv->is_lexical = cv0->is_lexical;
31311|      0|        cv->var_kind = cv0->var_kind;
31312|      0|        cv->var_idx = i;
31313|      0|        cv->var_name = JS_DupAtom(ctx, cv0->var_name);
31314|      0|    }
31315|      0|    return 0;
31316|      0|}
31317|       |
31318|       |typedef struct CodeContext {
31319|       |    const uint8_t *bc_buf; /* code buffer */
31320|       |    int bc_len;   /* length of the code buffer */
31321|       |    int pos;      /* position past the matched code pattern */
31322|       |    int line_num; /* last visited OP_line_num parameter or -1 */
31323|       |    int op;
31324|       |    int idx;
31325|       |    int label;
31326|       |    int val;
31327|       |    JSAtom atom;
31328|       |} CodeContext;
31329|       |
31330|   520k|#define M2(op1, op2)            ((op1) | ((op2) << 8))
31331|   298k|#define M3(op1, op2, op3)       ((op1) | ((op2) << 8) | ((op3) << 16))
31332|    338|#define M4(op1, op2, op3, op4)  ((op1) | ((op2) << 8) | ((op3) << 16) | ((op4) << 24))
31333|       |
31334|       |static BOOL code_match(CodeContext *s, int pos, ...)
31335|  2.31M|{
31336|  2.31M|    const uint8_t *tab = s->bc_buf;
31337|  2.31M|    int op, len, op1, line_num, pos_next;
31338|  2.31M|    va_list ap;
31339|  2.31M|    BOOL ret = FALSE;
31340|       |
31341|  2.31M|    line_num = -1;
31342|  2.31M|    va_start(ap, pos);
31343|       |
31344|  2.51M|    for(;;) {
31345|  2.51M|        op1 = va_arg(ap, int);
31346|  2.51M|        if (op1 == -1) {
31347|   126k|            s->pos = pos;
31348|   126k|            s->line_num = line_num;
31349|   126k|            ret = TRUE;
31350|   126k|            break;
31351|   126k|        }
31352|  2.80M|        for (;;) {
31353|  2.80M|            if (pos >= s->bc_len)
31354|      0|                goto done;
31355|  2.80M|            op = tab[pos];
31356|  2.80M|            len = opcode_info[op].size;
31357|  2.80M|            pos_next = pos + len;
31358|  2.80M|            if (pos_next > s->bc_len)
31359|      0|                goto done;
31360|  2.80M|            if (op == OP_line_num) {
31361|   413k|                line_num = get_u32(tab + pos + 1);
31362|   413k|                pos = pos_next;
31363|  2.39M|            } else {
31364|  2.39M|                break;
31365|  2.39M|            }
31366|  2.80M|        }
31367|  2.39M|        if (op != op1) {
31368|  2.29M|            if (op1 == (uint8_t)op1 || !op)
31369|  1.55M|                break;
31370|   746k|            if (op != (uint8_t)op1
31371|   746k|            &&  op != (uint8_t)(op1 >> 8)
31372|   746k|            &&  op != (uint8_t)(op1 >> 16)
31373|   746k|            &&  op != (uint8_t)(op1 >> 24)) {
31374|   633k|                break;
31375|   633k|            }
31376|   112k|            s->op = op;
31377|   112k|        }
31378|       |
31379|   208k|        pos++;
31380|   208k|        switch(opcode_info[op].fmt) {
31381|      0|        case OP_FMT_loc8:
31382|      0|        case OP_FMT_u8:
31383|      0|            {
31384|      0|                int idx = tab[pos];
31385|      0|                int arg = va_arg(ap, int);
31386|      0|                if (arg == -1) {
31387|      0|                    s->idx = idx;
31388|      0|                } else {
31389|      0|                    if (arg != idx)
31390|      0|                        goto done;
31391|      0|                }
31392|      0|                break;
31393|      0|            }
31394|      0|        case OP_FMT_u16:
31395|      0|        case OP_FMT_npop:
31396|  10.9k|        case OP_FMT_loc:
31397|  38.7k|        case OP_FMT_arg:
31398|  61.8k|        case OP_FMT_var_ref:
31399|  61.8k|            {
31400|  61.8k|                int idx = get_u16(tab + pos);
31401|  61.8k|                int arg = va_arg(ap, int);
31402|  61.8k|                if (arg == -1) {
31403|  48.5k|                    s->idx = idx;
31404|  48.5k|                } else {
31405|  13.3k|                    if (arg != idx)
31406|  3.85k|                        goto done;
31407|  13.3k|                }
31408|  57.9k|                break;
31409|  61.8k|            }
31410|  57.9k|        case OP_FMT_i32:
31411|     76|        case OP_FMT_u32:
31412|  5.35k|        case OP_FMT_label:
31413|  5.35k|        case OP_FMT_const:
31414|  5.35k|            {
31415|  5.35k|                s->label = get_u32(tab + pos);
31416|  5.35k|                break;
31417|  5.35k|            }
31418|      0|        case OP_FMT_label_u16:
31419|      0|            {
31420|      0|                s->label = get_u32(tab + pos);
31421|      0|                s->val = get_u16(tab + pos + 4);
31422|      0|                break;
31423|  5.35k|            }
31424|  55.0k|        case OP_FMT_atom:
31425|  55.0k|            {
31426|  55.0k|                s->atom = get_u32(tab + pos);
31427|  55.0k|                break;
31428|  5.35k|            }
31429|      0|        case OP_FMT_atom_u8:
31430|      0|            {
31431|      0|                s->atom = get_u32(tab + pos);
31432|      0|                s->val = get_u8(tab + pos + 4);
31433|      0|                break;
31434|  5.35k|            }
31435|      0|        case OP_FMT_atom_u16:
31436|      0|            {
31437|      0|                s->atom = get_u32(tab + pos);
31438|      0|                s->val = get_u16(tab + pos + 4);
31439|      0|                break;
31440|  5.35k|            }
31441|      0|        case OP_FMT_atom_label_u8:
31442|      0|            {
31443|      0|                s->atom = get_u32(tab + pos);
31444|      0|                s->label = get_u32(tab + pos + 4);
31445|      0|                s->val = get_u8(tab + pos + 8);
31446|      0|                break;
31447|  5.35k|            }
31448|  86.4k|        default:
31449|  86.4k|            break;
31450|   208k|        }
31451|   204k|        pos = pos_next;
31452|   204k|    }
31453|  2.31M| done:
31454|  2.31M|    va_end(ap);
31455|  2.31M|    return ret;
31456|  2.31M|}
31457|       |
31458|       |static void instantiate_hoisted_definitions(JSContext *ctx, JSFunctionDef *s, DynBuf *bc)
31459|   121k|{
31460|   121k|    int i, idx, label_next = -1;
31461|       |
31462|       |    /* add the hoisted functions in arguments and local variables */
31463|   233k|    for(i = 0; i < s->arg_count; i++) {
31464|   112k|        JSVarDef *vd = &s->args[i];
31465|   112k|        if (vd->func_pool_idx >= 0) {
31466|      0|            dbuf_putc(bc, OP_fclosure);
31467|      0|            dbuf_put_u32(bc, vd->func_pool_idx);
31468|      0|            dbuf_putc(bc, OP_put_arg);
31469|      0|            dbuf_put_u16(bc, i);
31470|      0|        }
31471|   112k|    }
31472|   143k|    for(i = 0; i < s->var_count; i++) {
31473|  21.6k|        JSVarDef *vd = &s->vars[i];
31474|  21.6k|        if (vd->scope_level == 0 && vd->func_pool_idx >= 0) {
31475|      0|            dbuf_putc(bc, OP_fclosure);
31476|      0|            dbuf_put_u32(bc, vd->func_pool_idx);
31477|      0|            dbuf_putc(bc, OP_put_loc);
31478|      0|            dbuf_put_u16(bc, i);
31479|      0|        }
31480|  21.6k|    }
31481|       |
31482|       |    /* the module global variables must be initialized before
31483|       |       evaluating the module so that the exported functions are
31484|       |       visible if there are cyclic module references */
31485|   121k|    if (s->module) {
31486|    489|        label_next = new_label_fd(s, -1);
31487|       |
31488|       |        /* if 'this' is true, initialize the global variables and return */
31489|    489|        dbuf_putc(bc, OP_push_this);
31490|    489|        dbuf_putc(bc, OP_if_false);
31491|    489|        dbuf_put_u32(bc, label_next);
31492|    489|        update_label(s, label_next, 1);
31493|    489|        s->jump_size++;
31494|    489|    }
31495|       |
31496|       |    /* add the global variables (only happens if s->is_global_var is
31497|       |       true) */
31498|   132k|    for(i = 0; i < s->global_var_count; i++) {
31499|  10.5k|        JSGlobalVar *hf = &s->global_vars[i];
31500|  10.5k|        int has_closure = 0;
31501|  10.5k|        BOOL force_init = hf->force_init;
31502|       |        /* we are in an eval, so the closure contains all the
31503|       |           enclosing variables */
31504|       |        /* If the outer function has a variable environment,
31505|       |           create a property for the variable there */
31506|   136k|        for(idx = 0; idx < s->closure_var_count; idx++) {
31507|   133k|            JSClosureVar *cv = &s->closure_var[idx];
31508|   133k|            if (cv->var_name == hf->var_name) {
31509|  7.82k|                has_closure = 2;
31510|  7.82k|                force_init = FALSE;
31511|  7.82k|                break;
31512|  7.82k|            }
31513|   125k|            if (cv->var_name == JS_ATOM__var_ ||
31514|   125k|                cv->var_name == JS_ATOM__arg_var_) {
31515|      0|                dbuf_putc(bc, OP_get_var_ref);
31516|      0|                dbuf_put_u16(bc, idx);
31517|      0|                has_closure = 1;
31518|      0|                force_init = TRUE;
31519|      0|                break;
31520|      0|            }
31521|   125k|        }
31522|  10.5k|        if (!has_closure) {
31523|  2.75k|            int flags;
31524|       |
31525|  2.75k|            flags = 0;
31526|  2.75k|            if (s->eval_type != JS_EVAL_TYPE_GLOBAL)
31527|      0|                flags |= JS_PROP_CONFIGURABLE;
31528|  2.75k|            if (hf->cpool_idx >= 0 && !hf->is_lexical) {
31529|       |                /* global function definitions need a specific handling */
31530|      0|                dbuf_putc(bc, OP_fclosure);
31531|      0|                dbuf_put_u32(bc, hf->cpool_idx);
31532|       |
31533|      0|                dbuf_putc(bc, OP_define_func);
31534|      0|                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
31535|      0|                dbuf_putc(bc, flags);
31536|       |
31537|      0|                goto done_global_var;
31538|  2.75k|            } else {
31539|  2.75k|                if (hf->is_lexical) {
31540|    926|                    flags |= DEFINE_GLOBAL_LEX_VAR;
31541|    926|                    if (!hf->is_const)
31542|    870|                        flags |= JS_PROP_WRITABLE;
31543|    926|                }
31544|  2.75k|                dbuf_putc(bc, OP_define_var);
31545|  2.75k|                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
31546|  2.75k|                dbuf_putc(bc, flags);
31547|  2.75k|            }
31548|  2.75k|        }
31549|  10.5k|        if (hf->cpool_idx >= 0 || force_init) {
31550|      0|            if (hf->cpool_idx >= 0) {
31551|      0|                dbuf_putc(bc, OP_fclosure);
31552|      0|                dbuf_put_u32(bc, hf->cpool_idx);
31553|      0|                if (hf->var_name == JS_ATOM__default_) {
31554|       |                    /* set default export function name */
31555|      0|                    dbuf_putc(bc, OP_set_name);
31556|      0|                    dbuf_put_u32(bc, JS_DupAtom(ctx, JS_ATOM_default));
31557|      0|                }
31558|      0|            } else {
31559|      0|                dbuf_putc(bc, OP_undefined);
31560|      0|            }
31561|      0|            if (has_closure == 2) {
31562|      0|                dbuf_putc(bc, OP_put_var_ref);
31563|      0|                dbuf_put_u16(bc, idx);
31564|      0|            } else if (has_closure == 1) {
31565|      0|                dbuf_putc(bc, OP_define_field);
31566|      0|                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
31567|      0|                dbuf_putc(bc, OP_drop);
31568|      0|            } else {
31569|       |                /* XXX: Check if variable is writable and enumerable */
31570|      0|                dbuf_putc(bc, OP_put_var);
31571|      0|                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
31572|      0|            }
31573|      0|        }
31574|  10.5k|    done_global_var:
31575|  10.5k|        JS_FreeAtom(ctx, hf->var_name);
31576|  10.5k|    }
31577|       |
31578|   121k|    if (s->module) {
31579|    489|        dbuf_putc(bc, OP_return_undef);
31580|       |
31581|    489|        dbuf_putc(bc, OP_label);
31582|    489|        dbuf_put_u32(bc, label_next);
31583|    489|        s->label_slots[label_next].pos2 = bc->size;
31584|    489|    }
31585|       |
31586|   121k|    js_free(ctx, s->global_vars);
31587|   121k|    s->global_vars = NULL;
31588|   121k|    s->global_var_count = 0;
31589|   121k|    s->global_var_size = 0;
31590|   121k|}
31591|       |
31592|       |static int skip_dead_code(JSFunctionDef *s, const uint8_t *bc_buf, int bc_len,
31593|       |                          int pos, int *linep)
31594|   349k|{
31595|   349k|    int op, len, label;
31596|       |
31597|   797k|    for (; pos < bc_len; pos += len) {
31598|   554k|        op = bc_buf[pos];
31599|   554k|        len = opcode_info[op].size;
31600|   554k|        if (op == OP_line_num) {
31601|  23.2k|            *linep = get_u32(bc_buf + pos + 1);
31602|  23.2k|        } else
31603|   531k|        if (op == OP_label) {
31604|   123k|            label = get_u32(bc_buf + pos + 1);
31605|   123k|            if (update_label(s, label, 0) > 0)
31606|   107k|                break;
31607|       |#if 0
31608|       |            if (s->label_slots[label].first_reloc) {
31609|       |                printf("line %d: unreferenced label %d:%d has relocations\n",
31610|       |                       *linep, label, s->label_slots[label].pos2);
31611|       |            }
31612|       |#endif
31613|  15.7k|            assert(s->label_slots[label].first_reloc == NULL);
31614|   408k|        } else {
31615|       |            /* XXX: output a warning for unreachable code? */
31616|   408k|            JSAtom atom;
31617|   408k|            switch(opcode_info[op].fmt) {
31618|  13.1k|            case OP_FMT_label:
31619|  13.1k|            case OP_FMT_label_u16:
31620|  13.1k|                label = get_u32(bc_buf + pos + 1);
31621|  13.1k|                update_label(s, label, -1);
31622|  13.1k|                break;
31623|      0|            case OP_FMT_atom_label_u8:
31624|  1.04k|            case OP_FMT_atom_label_u16:
31625|  1.04k|                label = get_u32(bc_buf + pos + 5);
31626|  1.04k|                update_label(s, label, -1);
31627|       |                /* fall thru */
31628|  11.8k|            case OP_FMT_atom:
31629|  13.7k|            case OP_FMT_atom_u8:
31630|  19.6k|            case OP_FMT_atom_u16:
31631|  19.6k|                atom = get_u32(bc_buf + pos + 1);
31632|  19.6k|                JS_FreeAtom(s->ctx, atom);
31633|  19.6k|                break;
31634|   375k|            default:
31635|   375k|                break;
31636|   408k|            }
31637|   408k|        }
31638|   554k|    }
31639|   349k|    return pos;
31640|   349k|}
31641|       |
31642|       |static int get_label_pos(JSFunctionDef *s, int label)
31643|  4.42k|{
31644|  4.42k|    int i, pos;
31645|  5.95k|    for (i = 0; i < 20; i++) {
31646|  5.95k|        pos = s->label_slots[label].pos;
31647|  8.04k|        for (;;) {
31648|  8.04k|            switch (s->byte_code.buf[pos]) {
31649|     91|            case OP_line_num:
31650|  2.08k|            case OP_label:
31651|  2.08k|                pos += 5;
31652|  2.08k|                continue;
31653|  1.53k|            case OP_goto:
31654|  1.53k|                label = get_u32(s->byte_code.buf + pos + 1);
31655|  1.53k|                break;
31656|  4.42k|            default:
31657|  4.42k|                return pos;
31658|  8.04k|            }
31659|  1.53k|            break;
31660|  8.04k|        }
31661|  5.95k|    }
31662|      0|    return pos;
31663|  4.42k|}
31664|       |
31665|       |/* convert global variable accesses to local variables or closure
31666|       |   variables when necessary */
31667|       |static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
31668|   121k|{
31669|   121k|    int pos, pos_next, bc_len, op, len, i, idx, line_num;
31670|   121k|    uint8_t *bc_buf;
31671|   121k|    JSAtom var_name;
31672|   121k|    DynBuf bc_out;
31673|   121k|    CodeContext cc;
31674|   121k|    int scope;
31675|       |
31676|   121k|    cc.bc_buf = bc_buf = s->byte_code.buf;
31677|   121k|    cc.bc_len = bc_len = s->byte_code.size;
31678|   121k|    js_dbuf_init(ctx, &bc_out);
31679|       |
31680|       |    /* first pass for runtime checks (must be done before the
31681|       |       variables are created) */
31682|   132k|    for(i = 0; i < s->global_var_count; i++) {
31683|  10.5k|        JSGlobalVar *hf = &s->global_vars[i];
31684|  10.5k|        int flags;
31685|       |
31686|       |        /* check if global variable (XXX: simplify) */
31687|   136k|        for(idx = 0; idx < s->closure_var_count; idx++) {
31688|   133k|            JSClosureVar *cv = &s->closure_var[idx];
31689|   133k|            if (cv->var_name == hf->var_name) {
31690|  7.82k|                if (s->eval_type == JS_EVAL_TYPE_DIRECT &&
31691|  7.82k|                    cv->is_lexical) {
31692|       |                    /* Check if a lexical variable is
31693|       |                       redefined as 'var'. XXX: Could abort
31694|       |                       compilation here, but for consistency
31695|       |                       with the other checks, we delay the
31696|       |                       error generation. */
31697|      0|                    dbuf_putc(&bc_out, OP_throw_error);
31698|      0|                    dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
31699|      0|                    dbuf_putc(&bc_out, JS_THROW_VAR_REDECL);
31700|      0|                }
31701|  7.82k|                goto next;
31702|  7.82k|            }
31703|   125k|            if (cv->var_name == JS_ATOM__var_ ||
31704|   125k|                cv->var_name == JS_ATOM__arg_var_)
31705|      0|                goto next;
31706|   125k|        }
31707|       |
31708|  2.75k|        dbuf_putc(&bc_out, OP_check_define_var);
31709|  2.75k|        dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
31710|  2.75k|        flags = 0;
31711|  2.75k|        if (hf->is_lexical)
31712|    926|            flags |= DEFINE_GLOBAL_LEX_VAR;
31713|  2.75k|        if (hf->cpool_idx >= 0)
31714|      0|            flags |= DEFINE_GLOBAL_FUNC_VAR;
31715|  2.75k|        dbuf_putc(&bc_out, flags);
31716|  10.5k|    next: ;
31717|  10.5k|    }
31718|       |
31719|   121k|    line_num = 0; /* avoid warning */
31720|  5.69M|    for (pos = 0; pos < bc_len; pos = pos_next) {
31721|  5.57M|        op = bc_buf[pos];
31722|  5.57M|        len = opcode_info[op].size;
31723|  5.57M|        pos_next = pos + len;
31724|  5.57M|        switch(op) {
31725|   671k|        case OP_line_num:
31726|   671k|            line_num = get_u32(bc_buf + pos + 1);
31727|   671k|            s->line_number_size++;
31728|   671k|            goto no_change;
31729|       |
31730|      0|        case OP_eval: /* convert scope index to adjusted variable index */
31731|      0|            {
31732|      0|                int call_argc = get_u16(bc_buf + pos + 1);
31733|      0|                scope = get_u16(bc_buf + pos + 1 + 2);
31734|      0|                mark_eval_captured_variables(ctx, s, scope);
31735|      0|                dbuf_putc(&bc_out, op);
31736|      0|                dbuf_put_u16(&bc_out, call_argc);
31737|      0|                dbuf_put_u16(&bc_out, s->scopes[scope].first - ARG_SCOPE_END);
31738|      0|            }
31739|      0|            break;
31740|      0|        case OP_apply_eval: /* convert scope index to adjusted variable index */
31741|      0|            scope = get_u16(bc_buf + pos + 1);
31742|      0|            mark_eval_captured_variables(ctx, s, scope);
31743|      0|            dbuf_putc(&bc_out, op);
31744|      0|            dbuf_put_u16(&bc_out, s->scopes[scope].first - ARG_SCOPE_END);
31745|      0|            break;
31746|      0|        case OP_scope_get_var_checkthis:
31747|      0|        case OP_scope_get_var_undef:
31748|   118k|        case OP_scope_get_var:
31749|   122k|        case OP_scope_put_var:
31750|   122k|        case OP_scope_delete_var:
31751|   122k|        case OP_scope_get_ref:
31752|   135k|        case OP_scope_put_var_init:
31753|   135k|            var_name = get_u32(bc_buf + pos + 1);
31754|   135k|            scope = get_u16(bc_buf + pos + 5);
31755|   135k|            pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,
31756|   135k|                                         NULL, NULL, pos_next);
31757|   135k|            JS_FreeAtom(ctx, var_name);
31758|   135k|            break;
31759|   336k|        case OP_scope_make_ref:
31760|   336k|            {
31761|   336k|                int label;
31762|   336k|                LabelSlot *ls;
31763|   336k|                var_name = get_u32(bc_buf + pos + 1);
31764|   336k|                label = get_u32(bc_buf + pos + 5);
31765|   336k|                scope = get_u16(bc_buf + pos + 9);
31766|   336k|                ls = &s->label_slots[label];
31767|   336k|                ls->ref_count--;  /* always remove label reference */
31768|   336k|                pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,
31769|   336k|                                             bc_buf, ls, pos_next);
31770|   336k|                JS_FreeAtom(ctx, var_name);
31771|   336k|            }
31772|   336k|            break;
31773|      5|        case OP_scope_get_private_field:
31774|     29|        case OP_scope_get_private_field2:
31775|     63|        case OP_scope_put_private_field:
31776|     68|        case OP_scope_in_private_field:
31777|     68|            {
31778|     68|                int ret;
31779|     68|                var_name = get_u32(bc_buf + pos + 1);
31780|     68|                scope = get_u16(bc_buf + pos + 5);
31781|     68|                ret = resolve_scope_private_field(ctx, s, var_name, scope, op, &bc_out);
31782|     68|                if (ret < 0)
31783|     68|                    goto fail;
31784|      0|                JS_FreeAtom(ctx, var_name);
31785|      0|            }
31786|      0|            break;
31787|      0|        case OP_gosub:
31788|      0|            s->jump_size++;
31789|      0|            if (OPTIMIZE) {
31790|       |                /* remove calls to empty finalizers  */
31791|      0|                int label;
31792|      0|                LabelSlot *ls;
31793|       |
31794|      0|                label = get_u32(bc_buf + pos + 1);
31795|      0|                assert(label >= 0 && label < s->label_count);
31796|      0|                ls = &s->label_slots[label];
31797|      0|                if (code_match(&cc, ls->pos, OP_ret, -1)) {
31798|      0|                    ls->ref_count--;
31799|      0|                    break;
31800|      0|                }
31801|      0|            }
31802|      0|            goto no_change;
31803|   501k|        case OP_drop:
31804|   501k|            if (0) {
31805|       |                /* remove drops before return_undef */
31806|       |                /* do not perform this optimization in pass2 because
31807|       |                   it breaks patterns recognised in resolve_labels */
31808|      0|                int pos1 = pos_next;
31809|      0|                int line1 = line_num;
31810|      0|                while (code_match(&cc, pos1, OP_drop, -1)) {
31811|      0|                    if (cc.line_num >= 0) line1 = cc.line_num;
31812|      0|                    pos1 = cc.pos;
31813|      0|                }
31814|      0|                if (code_match(&cc, pos1, OP_return_undef, -1)) {
31815|      0|                    pos_next = pos1;
31816|      0|                    if (line1 != -1 && line1 != line_num) {
31817|      0|                        line_num = line1;
31818|      0|                        s->line_number_size++;
31819|      0|                        dbuf_putc(&bc_out, OP_line_num);
31820|      0|                        dbuf_put_u32(&bc_out, line_num);
31821|      0|                    }
31822|      0|                    break;
31823|      0|                }
31824|      0|            }
31825|   501k|            goto no_change;
31826|   501k|        case OP_insert3:
31827|  9.62k|            if (OPTIMIZE) {
31828|       |                /* Transformation: insert3 put_array_el|put_ref_value drop -> put_array_el|put_ref_value */
31829|  9.62k|                if (code_match(&cc, pos_next, M2(OP_put_array_el, OP_put_ref_value), OP_drop, -1)) {
31830|  1.07k|                    dbuf_putc(&bc_out, cc.op);
31831|  1.07k|                    pos_next = cc.pos;
31832|  1.07k|                    if (cc.line_num != -1 && cc.line_num != line_num) {
31833|      0|                        line_num = cc.line_num;
31834|      0|                        s->line_number_size++;
31835|      0|                        dbuf_putc(&bc_out, OP_line_num);
31836|      0|                        dbuf_put_u32(&bc_out, line_num);
31837|      0|                    }
31838|  1.07k|                    break;
31839|  1.07k|                }
31840|  9.62k|            }
31841|  8.54k|            goto no_change;
31842|       |
31843|  65.1k|        case OP_goto:
31844|  65.1k|            s->jump_size++;
31845|       |            /* fall thru */
31846|  65.1k|        case OP_tail_call:
31847|  65.1k|        case OP_tail_call_method:
31848|   185k|        case OP_return:
31849|   186k|        case OP_return_undef:
31850|   187k|        case OP_throw:
31851|   187k|        case OP_throw_error:
31852|   187k|        case OP_ret:
31853|   187k|            if (OPTIMIZE) {
31854|       |                /* remove dead code */
31855|   187k|                int line = -1;
31856|   187k|                dbuf_put(&bc_out, bc_buf + pos, len);
31857|   187k|                pos = skip_dead_code(s, bc_buf, bc_len, pos + len, &line);
31858|   187k|                pos_next = pos;
31859|   187k|                if (pos < bc_len && line >= 0 && line_num != line) {
31860|  1.07k|                    line_num = line;
31861|  1.07k|                    s->line_number_size++;
31862|  1.07k|                    dbuf_putc(&bc_out, OP_line_num);
31863|  1.07k|                    dbuf_put_u32(&bc_out, line_num);
31864|  1.07k|                }
31865|   187k|                break;
31866|   187k|            }
31867|      0|            goto no_change;
31868|       |
31869|   125k|        case OP_label:
31870|   125k|            {
31871|   125k|                int label;
31872|   125k|                LabelSlot *ls;
31873|       |
31874|   125k|                label = get_u32(bc_buf + pos + 1);
31875|   125k|                assert(label >= 0 && label < s->label_count);
31876|   125k|                ls = &s->label_slots[label];
31877|   125k|                ls->pos2 = bc_out.size + opcode_info[op].size;
31878|   125k|            }
31879|      0|            goto no_change;
31880|       |
31881|   139k|        case OP_enter_scope:
31882|   139k|            {
31883|   139k|                int scope_idx, scope = get_u16(bc_buf + pos + 1);
31884|       |
31885|   139k|                if (scope == s->body_scope) {
31886|   121k|                    instantiate_hoisted_definitions(ctx, s, &bc_out);
31887|   121k|                }
31888|       |
31889|   151k|                for(scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
31890|  15.6k|                    JSVarDef *vd = &s->vars[scope_idx];
31891|  15.6k|                    if (vd->scope_level == scope) {
31892|  11.8k|                        if (scope_idx != s->arguments_arg_idx) {
31893|  11.8k|                            if (vd->var_kind == JS_VAR_FUNCTION_DECL ||
31894|  11.8k|                                vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) {
31895|       |                                /* Initialize lexical variable upon entering scope */
31896|      0|                                dbuf_putc(&bc_out, OP_fclosure);
31897|      0|                                dbuf_put_u32(&bc_out, vd->func_pool_idx);
31898|      0|                                dbuf_putc(&bc_out, OP_put_loc);
31899|      0|                                dbuf_put_u16(&bc_out, scope_idx);
31900|  11.8k|                            } else {
31901|       |                                /* XXX: should check if variable can be used
31902|       |                                   before initialization */
31903|  11.8k|                                dbuf_putc(&bc_out, OP_set_loc_uninitialized);
31904|  11.8k|                                dbuf_put_u16(&bc_out, scope_idx);
31905|  11.8k|                            }
31906|  11.8k|                        }
31907|  11.8k|                        scope_idx = vd->scope_next;
31908|  11.8k|                    } else {
31909|  3.75k|                        break;
31910|  3.75k|                    }
31911|  15.6k|                }
31912|   139k|            }
31913|   139k|            break;
31914|       |
31915|  36.6k|        case OP_leave_scope:
31916|  36.6k|            {
31917|  36.6k|                int scope_idx, scope = get_u16(bc_buf + pos + 1);
31918|       |
31919|  48.9k|                for(scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
31920|  19.2k|                    JSVarDef *vd = &s->vars[scope_idx];
31921|  19.2k|                    if (vd->scope_level == scope) {
31922|  12.2k|                        if (vd->is_captured) {
31923|  2.63k|                            dbuf_putc(&bc_out, OP_close_loc);
31924|  2.63k|                            dbuf_put_u16(&bc_out, scope_idx);
31925|  2.63k|                        }
31926|  12.2k|                        scope_idx = vd->scope_next;
31927|  12.2k|                    } else {
31928|  6.94k|                        break;
31929|  6.94k|                    }
31930|  19.2k|                }
31931|  36.6k|            }
31932|  36.6k|            break;
31933|       |
31934|   110k|        case OP_set_name:
31935|   110k|            {
31936|       |                /* remove dummy set_name opcodes */
31937|   110k|                JSAtom name = get_u32(bc_buf + pos + 1);
31938|   110k|                if (name == JS_ATOM_NULL)
31939|  57.0k|                    break;
31940|   110k|            }
31941|  53.7k|            goto no_change;
31942|       |
31943|  53.7k|        case OP_if_false:
31944|  31.3k|        case OP_if_true:
31945|  31.3k|        case OP_catch:
31946|  31.3k|            s->jump_size++;
31947|  31.3k|            goto no_change;
31948|       |
31949|   233k|        case OP_dup:
31950|   233k|            if (OPTIMIZE) {
31951|       |                /* Transformation: dup if_false(l1) drop, l1: if_false(l2) -> if_false(l2) */
31952|       |                /* Transformation: dup if_true(l1) drop, l1: if_true(l2) -> if_true(l2) */
31953|   233k|                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), OP_drop, -1)) {
31954|  4.42k|                    int lab0, lab1, op1, pos1, line1, pos2;
31955|  4.42k|                    lab0 = lab1 = cc.label;
31956|  4.42k|                    assert(lab1 >= 0 && lab1 < s->label_count);
31957|  4.42k|                    op1 = cc.op;
31958|  4.42k|                    pos1 = cc.pos;
31959|  4.42k|                    line1 = cc.line_num;
31960|  4.42k|                    while (code_match(&cc, (pos2 = get_label_pos(s, lab1)), OP_dup, op1, OP_drop, -1)) {
31961|      0|                        lab1 = cc.label;
31962|      0|                    }
31963|  4.42k|                    if (code_match(&cc, pos2, op1, -1)) {
31964|    162|                        s->jump_size++;
31965|    162|                        update_label(s, lab0, -1);
31966|    162|                        update_label(s, cc.label, +1);
31967|    162|                        dbuf_putc(&bc_out, op1);
31968|    162|                        dbuf_put_u32(&bc_out, cc.label);
31969|    162|                        pos_next = pos1;
31970|    162|                        if (line1 != -1 && line1 != line_num) {
31971|      0|                            line_num = line1;
31972|      0|                            s->line_number_size++;
31973|      0|                            dbuf_putc(&bc_out, OP_line_num);
31974|      0|                            dbuf_put_u32(&bc_out, line_num);
31975|      0|                        }
31976|    162|                        break;
31977|    162|                    }
31978|  4.42k|                }
31979|   233k|            }
31980|   233k|            goto no_change;
31981|       |
31982|   662k|        case OP_nop:
31983|       |            /* remove erased code */
31984|   662k|            break;
31985|      0|        case OP_set_class_name:
31986|       |            /* only used during parsing */
31987|      0|            break;
31988|       |
31989|     38|        case OP_get_field_opt_chain: /* equivalent to OP_get_field */
31990|     38|            {
31991|     38|                JSAtom name = get_u32(bc_buf + pos + 1);
31992|     38|                dbuf_putc(&bc_out, OP_get_field);
31993|     38|                dbuf_put_u32(&bc_out, name);
31994|     38|            }
31995|     38|            break;
31996|      0|        case OP_get_array_el_opt_chain: /* equivalent to OP_get_array_el */
31997|      0|            dbuf_putc(&bc_out, OP_get_array_el);
31998|      0|            break;
31999|       |
32000|  2.39M|        default:
32001|  4.02M|        no_change:
32002|  4.02M|            dbuf_put(&bc_out, bc_buf + pos, len);
32003|  4.02M|            break;
32004|  5.57M|        }
32005|  5.57M|    }
32006|       |
32007|       |    /* set the new byte code */
32008|   121k|    dbuf_free(&s->byte_code);
32009|   121k|    s->byte_code = bc_out;
32010|   121k|    if (dbuf_error(&s->byte_code)) {
32011|      0|        JS_ThrowOutOfMemory(ctx);
32012|      0|        return -1;
32013|      0|    }
32014|   121k|    return 0;
32015|     68| fail:
32016|       |    /* continue the copy to keep the atom refcounts consistent */
32017|       |    /* XXX: find a better solution ? */
32018|    748|    for (; pos < bc_len; pos = pos_next) {
32019|    680|        op = bc_buf[pos];
32020|    680|        len = opcode_info[op].size;
32021|    680|        pos_next = pos + len;
32022|    680|        dbuf_put(&bc_out, bc_buf + pos, len);
32023|    680|    }
32024|     68|    dbuf_free(&s->byte_code);
32025|     68|    s->byte_code = bc_out;
32026|     68|    return -1;
32027|   121k|}
32028|       |
32029|       |/* the pc2line table gives a source position for each PC value */
32030|       |static void add_pc2line_info(JSFunctionDef *s, uint32_t pc, uint32_t source_pos)
32031|  3.45M|{
32032|  3.45M|    if (s->line_number_slots != NULL
32033|  3.45M|    &&  s->line_number_count < s->line_number_size
32034|  3.45M|    &&  pc >= s->line_number_last_pc
32035|  3.45M|    &&  source_pos != s->line_number_last) {
32036|   657k|        s->line_number_slots[s->line_number_count].pc = pc;
32037|   657k|        s->line_number_slots[s->line_number_count].source_pos = source_pos;
32038|   657k|        s->line_number_count++;
32039|   657k|        s->line_number_last_pc = pc;
32040|   657k|        s->line_number_last = source_pos;
32041|   657k|    }
32042|  3.45M|}
32043|       |
32044|       |/* XXX: could use a more compact storage */
32045|       |/* XXX: get_line_col_cached() is slow. For more predictable
32046|       |   performance, line/cols could be stored every N source
32047|       |   bytes. Alternatively, get_line_col_cached() could be issued in
32048|       |   emit_source_pos() so that the deltas are more likely to be
32049|       |   small. */
32050|       |static void compute_pc2line_info(JSFunctionDef *s)
32051|   121k|{
32052|   121k|    if (!s->strip_debug) {
32053|   121k|        int last_line_num, last_col_num;
32054|   121k|        uint32_t last_pc = 0;
32055|   121k|        int i, line_num, col_num;
32056|   121k|        const uint8_t *buf_start = s->get_line_col_cache->buf_start;
32057|   121k|        js_dbuf_init(s->ctx, &s->pc2line);
32058|       |
32059|   121k|        last_line_num = get_line_col_cached(s->get_line_col_cache,
32060|   121k|                                            &last_col_num,
32061|   121k|                                            buf_start + s->source_pos);
32062|   121k|        dbuf_put_leb128(&s->pc2line, last_line_num); /* line number minus 1 */
32063|   121k|        dbuf_put_leb128(&s->pc2line, last_col_num); /* column number minus 1 */
32064|       |
32065|   779k|        for (i = 0; i < s->line_number_count; i++) {
32066|   657k|            uint32_t pc = s->line_number_slots[i].pc;
32067|   657k|            uint32_t source_pos = s->line_number_slots[i].source_pos;
32068|   657k|            int diff_pc, diff_line, diff_col;
32069|       |
32070|   657k|            if (source_pos == -1)
32071|      0|                continue;
32072|   657k|            diff_pc = pc - last_pc;
32073|   657k|            if (diff_pc < 0)
32074|      0|                continue;
32075|       |
32076|   657k|            line_num = get_line_col_cached(s->get_line_col_cache, &col_num,
32077|   657k|                                           buf_start + source_pos);
32078|   657k|            diff_line = line_num - last_line_num;
32079|   657k|            diff_col = col_num - last_col_num;
32080|   657k|            if (diff_line == 0 && diff_col == 0)
32081|      0|                continue;
32082|       |
32083|   657k|            if (diff_line >= PC2LINE_BASE &&
32084|   657k|                diff_line < PC2LINE_BASE + PC2LINE_RANGE &&
32085|   657k|                diff_pc <= PC2LINE_DIFF_PC_MAX) {
32086|   649k|                dbuf_putc(&s->pc2line, (diff_line - PC2LINE_BASE) +
32087|   649k|                          diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);
32088|   649k|            } else {
32089|       |                /* longer encoding */
32090|  8.15k|                dbuf_putc(&s->pc2line, 0);
32091|  8.15k|                dbuf_put_leb128(&s->pc2line, diff_pc);
32092|  8.15k|                dbuf_put_sleb128(&s->pc2line, diff_line);
32093|  8.15k|            }
32094|   657k|            dbuf_put_sleb128(&s->pc2line, diff_col);
32095|       |                
32096|   657k|            last_pc = pc;
32097|   657k|            last_line_num = line_num;
32098|   657k|            last_col_num = col_num;
32099|   657k|        }
32100|   121k|    }
32101|   121k|}
32102|       |
32103|       |static RelocEntry *add_reloc(JSContext *ctx, LabelSlot *ls, uint32_t addr, int size)
32104|  45.5k|{
32105|  45.5k|    RelocEntry *re;
32106|  45.5k|    re = js_malloc(ctx, sizeof(*re));
32107|  45.5k|    if (!re)
32108|      0|        return NULL;
32109|  45.5k|    re->addr = addr;
32110|  45.5k|    re->size = size;
32111|  45.5k|    re->next = ls->first_reloc;
32112|  45.5k|    ls->first_reloc = re;
32113|  45.5k|    return re;
32114|  45.5k|}
32115|       |
32116|       |static BOOL code_has_label(CodeContext *s, int pos, int label)
32117|  86.3k|{
32118|   132k|    while (pos < s->bc_len) {
32119|   132k|        int op = s->bc_buf[pos];
32120|   132k|        if (op == OP_line_num) {
32121|    193|            pos += 5;
32122|    193|            continue;
32123|    193|        }
32124|   132k|        if (op == OP_label) {
32125|  61.8k|            int lab = get_u32(s->bc_buf + pos + 1);
32126|  61.8k|            if (lab == label)
32127|  16.1k|                return TRUE;
32128|  45.7k|            pos += 5;
32129|  45.7k|            continue;
32130|  61.8k|        }
32131|  70.2k|        if (op == OP_goto) {
32132|  5.34k|            int lab = get_u32(s->bc_buf + pos + 1);
32133|  5.34k|            if (lab == label)
32134|  3.19k|                return TRUE;
32135|  5.34k|        }
32136|  67.0k|        break;
32137|  70.2k|    }
32138|  67.0k|    return FALSE;
32139|  86.3k|}
32140|       |
32141|       |/* return the target label, following the OP_goto jumps
32142|       |   the first opcode at destination is stored in *pop
32143|       | */
32144|       |static int find_jump_target(JSFunctionDef *s, int label0, int *pop, int *pline)
32145|  86.2k|{
32146|  86.2k|    int i, pos, op, label;
32147|       |
32148|  86.2k|    label = label0;
32149|  86.2k|    update_label(s, label, -1);
32150|  94.9k|    for (i = 0; i < 10; i++) {
32151|  94.9k|        assert(label >= 0 && label < s->label_count);
32152|  94.9k|        pos = s->label_slots[label].pos2;
32153|   105k|        for (;;) {
32154|   105k|            switch(op = s->byte_code.buf[pos]) {
32155|  2.18k|            case OP_line_num:
32156|  2.18k|                if (pline)
32157|  1.92k|                    *pline = get_u32(s->byte_code.buf + pos + 1);
32158|       |                /* fall thru */
32159|  10.8k|            case OP_label:
32160|  10.8k|                pos += opcode_info[op].size;
32161|  10.8k|                continue;
32162|  8.71k|            case OP_goto:
32163|  8.71k|                label = get_u32(s->byte_code.buf + pos + 1);
32164|  8.71k|                break;
32165|  3.05k|            case OP_drop:
32166|       |                /* ignore drop opcodes if followed by OP_return_undef */
32167|  3.06k|                while (s->byte_code.buf[++pos] == OP_drop)
32168|     10|                    continue;
32169|  3.05k|                if (s->byte_code.buf[pos] == OP_return_undef)
32170|      6|                    op = OP_return_undef;
32171|       |                /* fall thru */
32172|  86.1k|            default:
32173|  86.1k|                goto done;
32174|   105k|            }
32175|  8.71k|            break;
32176|   105k|        }
32177|  94.9k|    }
32178|       |    /* cycle detected, could issue a warning */
32179|       |    /* XXX: the combination of find_jump_target() and skip_dead_code()
32180|       |       seems incorrect with cyclic labels. See for exemple:
32181|       |
32182|       |       for (;;) {
32183|       |       l:break l;
32184|       |       l:break l;
32185|       |       l:break l;
32186|       |       l:break l;
32187|       |       }
32188|       |
32189|       |       Avoiding changing the target is just a workaround and might not
32190|       |       suffice to completely fix the problem. */
32191|     16|    label = label0;
32192|  86.2k| done:
32193|  86.2k|    *pop = op;
32194|  86.2k|    update_label(s, label, +1);
32195|  86.2k|    return label;
32196|     16|}
32197|       |
32198|       |static void push_short_int(DynBuf *bc_out, int val)
32199|   127k|{
32200|   127k|#if SHORT_OPCODES
32201|   127k|    if (val >= -1 && val <= 7) {
32202|  30.8k|        dbuf_putc(bc_out, OP_push_0 + val);
32203|  30.8k|        return;
32204|  30.8k|    }
32205|  96.6k|    if (val == (int8_t)val) {
32206|  51.8k|        dbuf_putc(bc_out, OP_push_i8);
32207|  51.8k|        dbuf_putc(bc_out, val);
32208|  51.8k|        return;
32209|  51.8k|    }
32210|  44.8k|    if (val == (int16_t)val) {
32211|  19.7k|        dbuf_putc(bc_out, OP_push_i16);
32212|  19.7k|        dbuf_put_u16(bc_out, val);
32213|  19.7k|        return;
32214|  19.7k|    }
32215|  25.0k|#endif
32216|  25.0k|    dbuf_putc(bc_out, OP_push_i32);
32217|  25.0k|    dbuf_put_u32(bc_out, val);
32218|  25.0k|}
32219|       |
32220|       |static void put_short_code(DynBuf *bc_out, int op, int idx)
32221|   351k|{
32222|   351k|#if SHORT_OPCODES
32223|   351k|    if (idx < 4) {
32224|   328k|        switch (op) {
32225|  1.86k|        case OP_get_loc:
32226|  1.86k|            dbuf_putc(bc_out, OP_get_loc0 + idx);
32227|  1.86k|            return;
32228|   107k|        case OP_put_loc:
32229|   107k|            dbuf_putc(bc_out, OP_put_loc0 + idx);
32230|   107k|            return;
32231|  8.20k|        case OP_set_loc:
32232|  8.20k|            dbuf_putc(bc_out, OP_set_loc0 + idx);
32233|  8.20k|            return;
32234|    699|        case OP_get_arg:
32235|    699|            dbuf_putc(bc_out, OP_get_arg0 + idx);
32236|    699|            return;
32237|    481|        case OP_put_arg:
32238|    481|            dbuf_putc(bc_out, OP_put_arg0 + idx);
32239|    481|            return;
32240|  27.2k|        case OP_set_arg:
32241|  27.2k|            dbuf_putc(bc_out, OP_set_arg0 + idx);
32242|  27.2k|            return;
32243|  8.31k|        case OP_get_var_ref:
32244|  8.31k|            dbuf_putc(bc_out, OP_get_var_ref0 + idx);
32245|  8.31k|            return;
32246|  3.41k|        case OP_put_var_ref:
32247|  3.41k|            dbuf_putc(bc_out, OP_put_var_ref0 + idx);
32248|  3.41k|            return;
32249|  13.5k|        case OP_set_var_ref:
32250|  13.5k|            dbuf_putc(bc_out, OP_set_var_ref0 + idx);
32251|  13.5k|            return;
32252|   155k|        case OP_call:
32253|   155k|            dbuf_putc(bc_out, OP_call0 + idx);
32254|   155k|            return;
32255|   328k|        }
32256|   328k|    }
32257|  24.5k|    if (idx < 256) {
32258|  23.7k|        switch (op) {
32259|    909|        case OP_get_loc:
32260|    909|            dbuf_putc(bc_out, OP_get_loc8);
32261|    909|            dbuf_putc(bc_out, idx);
32262|    909|            return;
32263|  9.13k|        case OP_put_loc:
32264|  9.13k|            dbuf_putc(bc_out, OP_put_loc8);
32265|  9.13k|            dbuf_putc(bc_out, idx);
32266|  9.13k|            return;
32267|    604|        case OP_set_loc:
32268|    604|            dbuf_putc(bc_out, OP_set_loc8);
32269|    604|            dbuf_putc(bc_out, idx);
32270|    604|            return;
32271|  23.7k|        }
32272|  23.7k|    }
32273|  13.9k|#endif
32274|  13.9k|    dbuf_putc(bc_out, op);
32275|  13.9k|    dbuf_put_u16(bc_out, idx);
32276|  13.9k|}
32277|       |
32278|       |/* peephole optimizations and resolve goto/labels */
32279|       |static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
32280|   121k|{
32281|   121k|    int pos, pos_next, bc_len, op, op1, len, i, line_num;
32282|   121k|    const uint8_t *bc_buf;
32283|   121k|    DynBuf bc_out;
32284|   121k|    LabelSlot *label_slots, *ls;
32285|   121k|    RelocEntry *re, *re_next;
32286|   121k|    CodeContext cc;
32287|   121k|    int label;
32288|   121k|#if SHORT_OPCODES
32289|   121k|    JumpSlot *jp;
32290|   121k|#endif
32291|       |
32292|   121k|    label_slots = s->label_slots;
32293|       |
32294|   121k|    line_num = s->source_pos;
32295|       |
32296|   121k|    cc.bc_buf = bc_buf = s->byte_code.buf;
32297|   121k|    cc.bc_len = bc_len = s->byte_code.size;
32298|   121k|    js_dbuf_init(ctx, &bc_out);
32299|       |
32300|   121k|#if SHORT_OPCODES
32301|   121k|    if (s->jump_size) {
32302|  5.02k|        s->jump_slots = js_mallocz(s->ctx, sizeof(*s->jump_slots) * s->jump_size);
32303|  5.02k|        if (s->jump_slots == NULL)
32304|      0|            return -1;
32305|  5.02k|    }
32306|   121k|#endif
32307|       |    /* XXX: Should skip this phase if not generating SHORT_OPCODES */
32308|   121k|    if (s->line_number_size && !s->strip_debug) {
32309|  26.3k|        s->line_number_slots = js_mallocz(s->ctx, sizeof(*s->line_number_slots) * s->line_number_size);
32310|  26.3k|        if (s->line_number_slots == NULL)
32311|      0|            return -1;
32312|  26.3k|        s->line_number_last = s->source_pos;
32313|  26.3k|        s->line_number_last_pc = 0;
32314|  26.3k|    }
32315|       |
32316|       |    /* initialize the 'home_object' variable if needed */
32317|   121k|    if (s->home_object_var_idx >= 0) {
32318|      0|        dbuf_putc(&bc_out, OP_special_object);
32319|      0|        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_HOME_OBJECT);
32320|      0|        put_short_code(&bc_out, OP_put_loc, s->home_object_var_idx);
32321|      0|    }
32322|       |    /* initialize the 'this.active_func' variable if needed */
32323|   121k|    if (s->this_active_func_var_idx >= 0) {
32324|      0|        dbuf_putc(&bc_out, OP_special_object);
32325|      0|        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);
32326|      0|        put_short_code(&bc_out, OP_put_loc, s->this_active_func_var_idx);
32327|      0|    }
32328|       |    /* initialize the 'new.target' variable if needed */
32329|   121k|    if (s->new_target_var_idx >= 0) {
32330|      0|        dbuf_putc(&bc_out, OP_special_object);
32331|      0|        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_NEW_TARGET);
32332|      0|        put_short_code(&bc_out, OP_put_loc, s->new_target_var_idx);
32333|      0|    }
32334|       |    /* initialize the 'this' variable if needed. In a derived class
32335|       |       constructor, this is initially uninitialized. */
32336|   121k|    if (s->this_var_idx >= 0) {
32337|      0|        if (s->is_derived_class_constructor) {
32338|      0|            dbuf_putc(&bc_out, OP_set_loc_uninitialized);
32339|      0|            dbuf_put_u16(&bc_out, s->this_var_idx);
32340|      0|        } else {
32341|      0|            dbuf_putc(&bc_out, OP_push_this);
32342|      0|            put_short_code(&bc_out, OP_put_loc, s->this_var_idx);
32343|      0|        }
32344|      0|    }
32345|       |    /* initialize the 'arguments' variable if needed */
32346|   121k|    if (s->arguments_var_idx >= 0) {
32347|      0|        if ((s->js_mode & JS_MODE_STRICT) || !s->has_simple_parameter_list) {
32348|      0|            dbuf_putc(&bc_out, OP_special_object);
32349|      0|            dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_ARGUMENTS);
32350|      0|        } else {
32351|      0|            dbuf_putc(&bc_out, OP_special_object);
32352|      0|            dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS);
32353|      0|        }
32354|      0|        if (s->arguments_arg_idx >= 0)
32355|      0|            put_short_code(&bc_out, OP_set_loc, s->arguments_arg_idx);
32356|      0|        put_short_code(&bc_out, OP_put_loc, s->arguments_var_idx);
32357|      0|    }
32358|       |    /* initialize a reference to the current function if needed */
32359|   121k|    if (s->func_var_idx >= 0) {
32360|      0|        dbuf_putc(&bc_out, OP_special_object);
32361|      0|        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);
32362|      0|        put_short_code(&bc_out, OP_put_loc, s->func_var_idx);
32363|      0|    }
32364|       |    /* initialize the variable environment object if needed */
32365|   121k|    if (s->var_object_idx >= 0) {
32366|      0|        dbuf_putc(&bc_out, OP_special_object);
32367|      0|        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
32368|      0|        put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
32369|      0|    }
32370|   121k|    if (s->arg_var_object_idx >= 0) {
32371|      0|        dbuf_putc(&bc_out, OP_special_object);
32372|      0|        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
32373|      0|        put_short_code(&bc_out, OP_put_loc, s->arg_var_object_idx);
32374|      0|    }
32375|       |
32376|  4.37M|    for (pos = 0; pos < bc_len; pos = pos_next) {
32377|  4.24M|        int val;
32378|  4.24M|        op = bc_buf[pos];
32379|  4.24M|        len = opcode_info[op].size;
32380|  4.24M|        pos_next = pos + len;
32381|  4.24M|        switch(op) {
32382|   656k|        case OP_line_num:
32383|       |            /* line number info (for debug). We put it in a separate
32384|       |               compressed table to reduce memory usage and get better
32385|       |               performance */
32386|   656k|            line_num = get_u32(bc_buf + pos + 1);
32387|   656k|            break;
32388|       |
32389|   112k|        case OP_label:
32390|   112k|            {
32391|   112k|                label = get_u32(bc_buf + pos + 1);
32392|   112k|                assert(label >= 0 && label < s->label_count);
32393|   112k|                ls = &label_slots[label];
32394|   112k|                assert(ls->addr == -1);
32395|   112k|                ls->addr = bc_out.size;
32396|       |                /* resolve the relocation entries */
32397|   158k|                for(re = ls->first_reloc; re != NULL; re = re_next) {
32398|  45.5k|                    int diff = ls->addr - re->addr;
32399|  45.5k|                    re_next = re->next;
32400|  45.5k|                    switch (re->size) {
32401|  7.00k|                    case 4:
32402|  7.00k|                        put_u32(bc_out.buf + re->addr, diff);
32403|  7.00k|                        break;
32404|  6.80k|                    case 2:
32405|  6.80k|                        assert(diff == (int16_t)diff);
32406|  6.80k|                        put_u16(bc_out.buf + re->addr, diff);
32407|  6.80k|                        break;
32408|  31.7k|                    case 1:
32409|  31.7k|                        assert(diff == (int8_t)diff);
32410|  31.7k|                        put_u8(bc_out.buf + re->addr, diff);
32411|  31.7k|                        break;
32412|  45.5k|                    }
32413|  45.5k|                    js_free(ctx, re);
32414|  45.5k|                }
32415|   112k|                ls->first_reloc = NULL;
32416|   112k|            }
32417|      0|            break;
32418|       |
32419|   155k|        case OP_call:
32420|   157k|        case OP_call_method:
32421|   157k|            {
32422|       |                /* detect and transform tail calls */
32423|   157k|                int argc;
32424|   157k|                argc = get_u16(bc_buf + pos + 1);
32425|   157k|                if (code_match(&cc, pos_next, OP_return, -1)) {
32426|    426|                    if (cc.line_num >= 0) line_num = cc.line_num;
32427|    426|                    add_pc2line_info(s, bc_out.size, line_num);
32428|    426|                    put_short_code(&bc_out, op + 1, argc);
32429|    426|                    pos_next = skip_dead_code(s, bc_buf, bc_len, cc.pos, &line_num);
32430|    426|                    break;
32431|    426|                }
32432|   156k|                add_pc2line_info(s, bc_out.size, line_num);
32433|   156k|                put_short_code(&bc_out, op, argc);
32434|   156k|                break;
32435|   157k|            }
32436|      0|            goto no_change;
32437|       |
32438|   119k|        case OP_return:
32439|   120k|        case OP_return_undef:
32440|   121k|        case OP_return_async:
32441|   121k|        case OP_throw:
32442|   121k|        case OP_throw_error:
32443|   121k|            pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
32444|   121k|            goto no_change;
32445|       |
32446|  60.0k|        case OP_goto:
32447|  60.0k|            label = get_u32(bc_buf + pos + 1);
32448|  60.0k|        has_goto:
32449|  60.0k|            if (OPTIMIZE) {
32450|  60.0k|                int line1 = -1;
32451|       |                /* Use custom matcher because multiple labels can follow */
32452|  60.0k|                label = find_jump_target(s, label, &op1, &line1);
32453|  60.0k|                if (code_has_label(&cc, pos_next, label)) {
32454|       |                    /* jump to next instruction: remove jump */
32455|  19.2k|                    update_label(s, label, -1);
32456|  19.2k|                    break;
32457|  19.2k|                }
32458|  40.7k|                if (op1 == OP_return || op1 == OP_return_undef || op1 == OP_throw) {
32459|       |                    /* jump to return/throw: remove jump, append return/throw */
32460|       |                    /* updating the line number obfuscates assembly listing */
32461|       |                    //if (line1 != -1) line_num = line1;
32462|  1.16k|                    update_label(s, label, -1);
32463|  1.16k|                    add_pc2line_info(s, bc_out.size, line_num);
32464|  1.16k|                    dbuf_putc(&bc_out, op1);
32465|  1.16k|                    pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
32466|  1.16k|                    break;
32467|  1.16k|                }
32468|       |                /* XXX: should duplicate single instructions followed by goto or return */
32469|       |                /* For example, can match one of these followed by return:
32470|       |                   push_i32 / push_const / push_atom_value / get_var /
32471|       |                   undefined / null / push_false / push_true / get_ref_value /
32472|       |                   get_loc / get_arg / get_var_ref
32473|       |                 */
32474|  40.7k|            }
32475|  39.6k|            goto has_label;
32476|       |
32477|  39.6k|        case OP_gosub:
32478|      0|            label = get_u32(bc_buf + pos + 1);
32479|      0|            if (0 && OPTIMIZE) {
32480|      0|                label = find_jump_target(s, label, &op1, NULL);
32481|      0|                if (op1 == OP_ret) {
32482|      0|                    update_label(s, label, -1);
32483|       |                    /* empty finally clause: remove gosub */
32484|      0|                    break;
32485|      0|                }
32486|      0|            }
32487|      0|            goto has_label;
32488|       |
32489|      0|        case OP_catch:
32490|      0|            label = get_u32(bc_buf + pos + 1);
32491|      0|            goto has_label;
32492|       |
32493|  3.37k|        case OP_if_true:
32494|  26.1k|        case OP_if_false:
32495|  26.1k|            label = get_u32(bc_buf + pos + 1);
32496|  26.1k|            if (OPTIMIZE) {
32497|  26.1k|                label = find_jump_target(s, label, &op1, NULL);
32498|       |                /* transform if_false/if_true(l1) label(l1) -> drop label(l1) */
32499|  26.1k|                if (code_has_label(&cc, pos_next, label)) {
32500|     13|                    update_label(s, label, -1);
32501|     13|                    dbuf_putc(&bc_out, OP_drop);
32502|     13|                    break;
32503|     13|                }
32504|       |                /* transform if_false(l1) goto(l2) label(l1) -> if_false(l2) label(l1) */
32505|  26.1k|                if (code_match(&cc, pos_next, OP_goto, -1)) {
32506|    115|                    int pos1 = cc.pos;
32507|    115|                    int line1 = cc.line_num;
32508|    115|                    if (code_has_label(&cc, pos1, label)) {
32509|      0|                        if (line1 != -1) line_num = line1;
32510|      0|                        pos_next = pos1;
32511|      0|                        update_label(s, label, -1);
32512|      0|                        label = cc.label;
32513|      0|                        op ^= OP_if_true ^ OP_if_false;
32514|      0|                    }
32515|    115|                }
32516|  26.1k|            }
32517|  65.7k|        has_label:
32518|  65.7k|            add_pc2line_info(s, bc_out.size, line_num);
32519|  65.7k|            if (op == OP_goto) {
32520|  39.6k|                pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
32521|  39.6k|            }
32522|  65.7k|            assert(label >= 0 && label < s->label_count);
32523|  65.7k|            ls = &label_slots[label];
32524|  65.7k|#if SHORT_OPCODES
32525|  65.7k|            jp = &s->jump_slots[s->jump_count++];
32526|  65.7k|            jp->op = op;
32527|  65.7k|            jp->size = 4;
32528|  65.7k|            jp->pos = bc_out.size + 1;
32529|  65.7k|            jp->label = label;
32530|       |
32531|  65.7k|            if (ls->addr == -1) {
32532|  45.5k|                int diff = ls->pos2 - pos - 1;
32533|  45.5k|                if (diff < 128 && (op == OP_if_false || op == OP_if_true || op == OP_goto)) {
32534|  31.7k|                    jp->size = 1;
32535|  31.7k|                    jp->op = OP_if_false8 + (op - OP_if_false);
32536|  31.7k|                    dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));
32537|  31.7k|                    dbuf_putc(&bc_out, 0);
32538|  31.7k|                    if (!add_reloc(ctx, ls, bc_out.size - 1, 1))
32539|      0|                        goto fail;
32540|  31.7k|                    break;
32541|  31.7k|                }
32542|  13.8k|                if (diff < 32768 && op == OP_goto) {
32543|  6.80k|                    jp->size = 2;
32544|  6.80k|                    jp->op = OP_goto16;
32545|  6.80k|                    dbuf_putc(&bc_out, OP_goto16);
32546|  6.80k|                    dbuf_put_u16(&bc_out, 0);
32547|  6.80k|                    if (!add_reloc(ctx, ls, bc_out.size - 2, 2))
32548|      0|                        goto fail;
32549|  6.80k|                    break;
32550|  6.80k|                }
32551|  20.2k|            } else {
32552|  20.2k|                int diff = ls->addr - bc_out.size - 1;
32553|  20.2k|                if (diff == (int8_t)diff && (op == OP_if_false || op == OP_if_true || op == OP_goto)) {
32554|  18.0k|                    jp->size = 1;
32555|  18.0k|                    jp->op = OP_if_false8 + (op - OP_if_false);
32556|  18.0k|                    dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));
32557|  18.0k|                    dbuf_putc(&bc_out, diff);
32558|  18.0k|                    break;
32559|  18.0k|                }
32560|  2.20k|                if (diff == (int16_t)diff && op == OP_goto) {
32561|  1.05k|                    jp->size = 2;
32562|  1.05k|                    jp->op = OP_goto16;
32563|  1.05k|                    dbuf_putc(&bc_out, OP_goto16);
32564|  1.05k|                    dbuf_put_u16(&bc_out, diff);
32565|  1.05k|                    break;
32566|  1.05k|                }
32567|  2.20k|            }
32568|  8.15k|#endif
32569|  8.15k|            dbuf_putc(&bc_out, op);
32570|  8.15k|            dbuf_put_u32(&bc_out, ls->addr - bc_out.size);
32571|  8.15k|            if (ls->addr == -1) {
32572|       |                /* unresolved yet: create a new relocation entry */
32573|  7.00k|                if (!add_reloc(ctx, ls, bc_out.size - 4, 4))
32574|      0|                    goto fail;
32575|  7.00k|            }
32576|  8.15k|            break;
32577|  8.15k|        case OP_with_get_var:
32578|      0|        case OP_with_put_var:
32579|      0|        case OP_with_delete_var:
32580|      0|        case OP_with_make_ref:
32581|      0|        case OP_with_get_ref:
32582|      0|            {
32583|      0|                JSAtom atom;
32584|      0|                int is_with;
32585|       |
32586|      0|                atom = get_u32(bc_buf + pos + 1);
32587|      0|                label = get_u32(bc_buf + pos + 5);
32588|      0|                is_with = bc_buf[pos + 9];
32589|      0|                if (OPTIMIZE) {
32590|      0|                    label = find_jump_target(s, label, &op1, NULL);
32591|      0|                }
32592|      0|                assert(label >= 0 && label < s->label_count);
32593|      0|                ls = &label_slots[label];
32594|      0|                add_pc2line_info(s, bc_out.size, line_num);
32595|      0|#if SHORT_OPCODES
32596|      0|                jp = &s->jump_slots[s->jump_count++];
32597|      0|                jp->op = op;
32598|      0|                jp->size = 4;
32599|      0|                jp->pos = bc_out.size + 5;
32600|      0|                jp->label = label;
32601|      0|#endif
32602|      0|                dbuf_putc(&bc_out, op);
32603|      0|                dbuf_put_u32(&bc_out, atom);
32604|      0|                dbuf_put_u32(&bc_out, ls->addr - bc_out.size);
32605|      0|                if (ls->addr == -1) {
32606|       |                    /* unresolved yet: create a new relocation entry */
32607|      0|                    if (!add_reloc(ctx, ls, bc_out.size - 4, 4))
32608|      0|                        goto fail;
32609|      0|                }
32610|      0|                dbuf_putc(&bc_out, is_with);
32611|      0|            }
32612|      0|            break;
32613|       |
32614|   463k|        case OP_drop:
32615|   463k|            if (OPTIMIZE) {
32616|       |                /* remove useless drops before return */
32617|   463k|                if (code_match(&cc, pos_next, OP_return_undef, -1)) {
32618|    395|                    if (cc.line_num >= 0) line_num = cc.line_num;
32619|    395|                    break;
32620|    395|                }
32621|   463k|            }
32622|   463k|            goto no_change;
32623|       |
32624|   463k|        case OP_null:
32625|      8|#if SHORT_OPCODES
32626|      8|            if (OPTIMIZE) {
32627|       |                /* transform null strict_eq into is_null */
32628|      8|                if (code_match(&cc, pos_next, OP_strict_eq, -1)) {
32629|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32630|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32631|      0|                    dbuf_putc(&bc_out, OP_is_null);
32632|      0|                    pos_next = cc.pos;
32633|      0|                    break;
32634|      0|                }
32635|       |                /* transform null strict_neq if_false/if_true -> is_null if_true/if_false */
32636|      8|                if (code_match(&cc, pos_next, OP_strict_neq, M2(OP_if_false, OP_if_true), -1)) {
32637|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32638|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32639|      0|                    dbuf_putc(&bc_out, OP_is_null);
32640|      0|                    pos_next = cc.pos;
32641|      0|                    label = cc.label;
32642|      0|                    op = cc.op ^ OP_if_false ^ OP_if_true;
32643|      0|                    goto has_label;
32644|      0|                }
32645|      8|            }
32646|      8|#endif
32647|       |            /* fall thru */
32648|      8|        case OP_push_false:
32649|      8|        case OP_push_true:
32650|      8|            if (OPTIMIZE) {
32651|      8|                val = (op == OP_push_true);
32652|      8|                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
32653|    576|                has_constant_test:
32654|    576|                    if (cc.line_num >= 0) line_num = cc.line_num;
32655|    576|                    if (val == cc.op - OP_if_false) {
32656|       |                        /* transform null if_false(l1) -> goto l1 */
32657|       |                        /* transform false if_false(l1) -> goto l1 */
32658|       |                        /* transform true if_true(l1) -> goto l1 */
32659|     34|                        pos_next = cc.pos;
32660|     34|                        op = OP_goto;
32661|     34|                        label = cc.label;
32662|     34|                        goto has_goto;
32663|    542|                    } else {
32664|       |                        /* transform null if_true(l1) -> nop */
32665|       |                        /* transform false if_true(l1) -> nop */
32666|       |                        /* transform true if_false(l1) -> nop */
32667|    542|                        pos_next = cc.pos;
32668|    542|                        update_label(s, cc.label, -1);
32669|    542|                        break;
32670|    542|                    }
32671|    576|                }
32672|      8|            }
32673|      8|            goto no_change;
32674|       |
32675|   128k|        case OP_push_i32:
32676|   128k|            if (OPTIMIZE) {
32677|       |                /* transform i32(val) neg -> i32(-val) */
32678|   128k|                val = get_i32(bc_buf + pos + 1);
32679|   128k|                if ((val != INT32_MIN && val != 0)
32680|   128k|                &&  code_match(&cc, pos_next, OP_neg, -1)) {
32681|  4.58k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32682|  4.58k|                    if (code_match(&cc, cc.pos, OP_drop, -1)) {
32683|     34|                        if (cc.line_num >= 0) line_num = cc.line_num;
32684|  4.54k|                    } else {
32685|  4.54k|                        add_pc2line_info(s, bc_out.size, line_num);
32686|  4.54k|                        push_short_int(&bc_out, -val);
32687|  4.54k|                    }
32688|  4.58k|                    pos_next = cc.pos;
32689|  4.58k|                    break;
32690|  4.58k|                }
32691|       |                /* remove push/drop pairs generated by the parser */
32692|   124k|                if (code_match(&cc, pos_next, OP_drop, -1)) {
32693|    637|                    if (cc.line_num >= 0) line_num = cc.line_num;
32694|    637|                    pos_next = cc.pos;
32695|    637|                    break;
32696|    637|                }
32697|       |                /* Optimize constant tests: `if (0)`, `if (1)`, `if (!0)`... */
32698|   123k|                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
32699|    576|                    val = (val != 0);
32700|    576|                    goto has_constant_test;
32701|    576|                }
32702|   122k|                add_pc2line_info(s, bc_out.size, line_num);
32703|   122k|                push_short_int(&bc_out, val);
32704|   122k|                break;
32705|   123k|            }
32706|      0|            goto no_change;
32707|       |
32708|  63.5k|        case OP_push_bigint_i32:
32709|  63.5k|            if (OPTIMIZE) {
32710|       |                /* transform i32(val) neg -> i32(-val) */
32711|  63.5k|                val = get_i32(bc_buf + pos + 1);
32712|  63.5k|                if (val != INT32_MIN
32713|  63.5k|                &&  code_match(&cc, pos_next, OP_neg, -1)) {
32714|  27.4k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32715|  27.4k|                    if (code_match(&cc, cc.pos, OP_drop, -1)) {
32716|  3.56k|                        if (cc.line_num >= 0) line_num = cc.line_num;
32717|  23.8k|                    } else {
32718|  23.8k|                        add_pc2line_info(s, bc_out.size, line_num);
32719|  23.8k|                        dbuf_putc(&bc_out, OP_push_bigint_i32);
32720|  23.8k|                        dbuf_put_u32(&bc_out, -val);
32721|  23.8k|                    }
32722|  27.4k|                    pos_next = cc.pos;
32723|  27.4k|                    break;
32724|  27.4k|                }
32725|  63.5k|            }
32726|  36.0k|            goto no_change;
32727|       |
32728|  36.0k|#if SHORT_OPCODES
32729|   266k|        case OP_push_const:
32730|   373k|        case OP_fclosure:
32731|   373k|            if (OPTIMIZE) {
32732|   373k|                int idx = get_u32(bc_buf + pos + 1);
32733|   373k|                if (idx < 256) {
32734|   218k|                    add_pc2line_info(s, bc_out.size, line_num);
32735|   218k|                    dbuf_putc(&bc_out, OP_push_const8 + op - OP_push_const);
32736|   218k|                    dbuf_putc(&bc_out, idx);
32737|   218k|                    break;
32738|   218k|                }
32739|   373k|            }
32740|   154k|            goto no_change;
32741|       |
32742|   154k|        case OP_get_field:
32743|  3.64k|            if (OPTIMIZE) {
32744|  3.64k|                JSAtom atom = get_u32(bc_buf + pos + 1);
32745|  3.64k|                if (atom == JS_ATOM_length) {
32746|      0|                    JS_FreeAtom(ctx, atom);
32747|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32748|      0|                    dbuf_putc(&bc_out, OP_get_length);
32749|      0|                    break;
32750|      0|                }
32751|  3.64k|            }
32752|  3.64k|            goto no_change;
32753|  3.64k|#endif
32754|   187k|        case OP_push_atom_value:
32755|   187k|            if (OPTIMIZE) {
32756|   187k|                JSAtom atom = get_u32(bc_buf + pos + 1);
32757|       |                /* remove push/drop pairs generated by the parser */
32758|   187k|                if (code_match(&cc, pos_next, OP_drop, -1)) {
32759|  1.10k|                    JS_FreeAtom(ctx, atom);
32760|  1.10k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32761|  1.10k|                    pos_next = cc.pos;
32762|  1.10k|                    break;
32763|  1.10k|                }
32764|   186k|#if SHORT_OPCODES
32765|   186k|                if (atom == JS_ATOM_empty_string) {
32766|  50.9k|                    JS_FreeAtom(ctx, atom);
32767|  50.9k|                    add_pc2line_info(s, bc_out.size, line_num);
32768|  50.9k|                    dbuf_putc(&bc_out, OP_push_empty_string);
32769|  50.9k|                    break;
32770|  50.9k|                }
32771|   186k|#endif
32772|   186k|            }
32773|   135k|            goto no_change;
32774|       |
32775|   135k|        case OP_to_propkey:
32776|    338|        case OP_to_propkey2:
32777|    338|            if (OPTIMIZE) {
32778|       |                /* remove redundant to_propkey/to_propkey2 opcodes when storing simple data */
32779|    338|                if (code_match(&cc, pos_next, M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1, OP_put_array_el, -1)
32780|    338|                ||  code_match(&cc, pos_next, M3(OP_push_i32, OP_push_const, OP_push_atom_value), OP_put_array_el, -1)
32781|    338|                ||  code_match(&cc, pos_next, M4(OP_undefined, OP_null, OP_push_true, OP_push_false), OP_put_array_el, -1)) {
32782|      0|                    break;
32783|      0|                }
32784|    338|            }
32785|    338|            goto no_change;
32786|       |
32787|  19.7k|        case OP_undefined:
32788|  19.7k|            if (OPTIMIZE) {
32789|       |                /* remove push/drop pairs generated by the parser */
32790|  19.7k|                if (code_match(&cc, pos_next, OP_drop, -1)) {
32791|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32792|      0|                    pos_next = cc.pos;
32793|      0|                    break;
32794|      0|                }
32795|       |                /* transform undefined return -> return_undefined */
32796|  19.7k|                if (code_match(&cc, pos_next, OP_return, -1)) {
32797|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32798|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32799|      0|                    dbuf_putc(&bc_out, OP_return_undef);
32800|      0|                    pos_next = cc.pos;
32801|      0|                    break;
32802|      0|                }
32803|       |                /* transform undefined if_true(l1)/if_false(l1) -> nop/goto(l1) */
32804|  19.7k|                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
32805|      0|                    val = 0;
32806|      0|                    goto has_constant_test;
32807|      0|                }
32808|  19.7k|#if SHORT_OPCODES
32809|       |                /* transform undefined strict_eq -> is_undefined */
32810|  19.7k|                if (code_match(&cc, pos_next, OP_strict_eq, -1)) {
32811|  1.75k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32812|  1.75k|                    add_pc2line_info(s, bc_out.size, line_num);
32813|  1.75k|                    dbuf_putc(&bc_out, OP_is_undefined);
32814|  1.75k|                    pos_next = cc.pos;
32815|  1.75k|                    break;
32816|  1.75k|                }
32817|       |                /* transform undefined strict_neq if_false/if_true -> is_undefined if_true/if_false */
32818|  18.0k|                if (code_match(&cc, pos_next, OP_strict_neq, M2(OP_if_false, OP_if_true), -1)) {
32819|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32820|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32821|      0|                    dbuf_putc(&bc_out, OP_is_undefined);
32822|      0|                    pos_next = cc.pos;
32823|      0|                    label = cc.label;
32824|      0|                    op = cc.op ^ OP_if_false ^ OP_if_true;
32825|      0|                    goto has_label;
32826|      0|                }
32827|  18.0k|#endif
32828|  18.0k|            }
32829|  18.0k|            goto no_change;
32830|       |
32831|  42.6k|        case OP_insert2:
32832|  42.6k|            if (OPTIMIZE) {
32833|       |                /* Transformation:
32834|       |                   insert2 put_field(a) drop -> put_field(a)
32835|       |                   insert2 put_var_strict(a) drop -> put_var_strict(a)
32836|       |                */
32837|  42.6k|                if (code_match(&cc, pos_next, M2(OP_put_field, OP_put_var_strict), OP_drop, -1)) {
32838|  13.3k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32839|  13.3k|                    add_pc2line_info(s, bc_out.size, line_num);
32840|  13.3k|                    dbuf_putc(&bc_out, cc.op);
32841|  13.3k|                    dbuf_put_u32(&bc_out, cc.atom);
32842|  13.3k|                    pos_next = cc.pos;
32843|  13.3k|                    break;
32844|  13.3k|                }
32845|  42.6k|            }
32846|  29.2k|            goto no_change;
32847|       |
32848|   227k|        case OP_dup:
32849|   227k|            if (OPTIMIZE) {
32850|       |                /* Transformation: dup put_x(n) drop -> put_x(n) */
32851|   227k|                int op1, line2 = -1;
32852|       |                /* Transformation: dup put_x(n) -> set_x(n) */
32853|   227k|                if (code_match(&cc, pos_next, M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1, -1)) {
32854|  47.6k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32855|  47.6k|                    op1 = cc.op + 1;  /* put_x -> set_x */
32856|  47.6k|                    pos_next = cc.pos;
32857|  47.6k|                    if (code_match(&cc, cc.pos, OP_drop, -1)) {
32858|  3.25k|                        if (cc.line_num >= 0) line_num = cc.line_num;
32859|  3.25k|                        op1 -= 1; /* set_x drop -> put_x */
32860|  3.25k|                        pos_next = cc.pos;
32861|  3.25k|                        if (code_match(&cc, cc.pos, op1 - 1, cc.idx, -1)) {
32862|    711|                            line2 = cc.line_num; /* delay line number update */
32863|    711|                            op1 += 1;   /* put_x(n) get_x(n) -> set_x(n) */
32864|    711|                            pos_next = cc.pos;
32865|    711|                        }
32866|  3.25k|                    }
32867|  47.6k|                    add_pc2line_info(s, bc_out.size, line_num);
32868|  47.6k|                    put_short_code(&bc_out, op1, cc.idx);
32869|  47.6k|                    if (line2 >= 0) line_num = line2;
32870|  47.6k|                    break;
32871|  47.6k|                }
32872|   227k|            }
32873|   179k|            goto no_change;
32874|       |
32875|   179k|        case OP_get_loc:
32876|  2.92k|            if (OPTIMIZE) {
32877|       |                /* transformation:
32878|       |                   get_loc(n) post_dec put_loc(n) drop -> dec_loc(n)
32879|       |                   get_loc(n) post_inc put_loc(n) drop -> inc_loc(n)
32880|       |                   get_loc(n) dec dup put_loc(n) drop -> dec_loc(n)
32881|       |                   get_loc(n) inc dup put_loc(n) drop -> inc_loc(n)
32882|       |                 */
32883|  2.92k|                int idx;
32884|  2.92k|                idx = get_u16(bc_buf + pos + 1);
32885|  2.92k|                if (idx >= 256)
32886|      0|                    goto no_change;
32887|  2.92k|                if (code_match(&cc, pos_next, M2(OP_post_dec, OP_post_inc), OP_put_loc, idx, OP_drop, -1) ||
32888|  2.92k|                    code_match(&cc, pos_next, M2(OP_dec, OP_inc), OP_dup, OP_put_loc, idx, OP_drop, -1)) {
32889|    141|                    if (cc.line_num >= 0) line_num = cc.line_num;
32890|    141|                    add_pc2line_info(s, bc_out.size, line_num);
32891|    141|                    dbuf_putc(&bc_out, (cc.op == OP_inc || cc.op == OP_post_inc) ? OP_inc_loc : OP_dec_loc);
32892|    141|                    dbuf_putc(&bc_out, idx);
32893|    141|                    pos_next = cc.pos;
32894|    141|                    break;
32895|    141|                }
32896|       |                /* transformation:
32897|       |                   get_loc(n) push_atom_value(x) add dup put_loc(n) drop -> push_atom_value(x) add_loc(n)
32898|       |                 */
32899|  2.77k|                if (code_match(&cc, pos_next, OP_push_atom_value, OP_add, OP_dup, OP_put_loc, idx, OP_drop, -1)) {
32900|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32901|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32902|      0|#if SHORT_OPCODES
32903|      0|                    if (cc.atom == JS_ATOM_empty_string) {
32904|      0|                        JS_FreeAtom(ctx, cc.atom);
32905|      0|                        dbuf_putc(&bc_out, OP_push_empty_string);
32906|      0|                    } else
32907|      0|#endif
32908|      0|                    {
32909|      0|                        dbuf_putc(&bc_out, OP_push_atom_value);
32910|      0|                        dbuf_put_u32(&bc_out, cc.atom);
32911|      0|                    }
32912|      0|                    dbuf_putc(&bc_out, OP_add_loc);
32913|      0|                    dbuf_putc(&bc_out, idx);
32914|      0|                    pos_next = cc.pos;
32915|      0|                    break;
32916|      0|                }
32917|       |                /* transformation:
32918|       |                   get_loc(n) push_i32(x) add dup put_loc(n) drop -> push_i32(x) add_loc(n)
32919|       |                 */
32920|  2.77k|                if (code_match(&cc, pos_next, OP_push_i32, OP_add, OP_dup, OP_put_loc, idx, OP_drop, -1)) {
32921|      1|                    if (cc.line_num >= 0) line_num = cc.line_num;
32922|      1|                    add_pc2line_info(s, bc_out.size, line_num);
32923|      1|                    push_short_int(&bc_out, cc.label);
32924|      1|                    dbuf_putc(&bc_out, OP_add_loc);
32925|      1|                    dbuf_putc(&bc_out, idx);
32926|      1|                    pos_next = cc.pos;
32927|      1|                    break;
32928|      1|                }
32929|       |                /* transformation: XXX: also do these:
32930|       |                   get_loc(n) get_loc(x) add dup put_loc(n) drop -> get_loc(x) add_loc(n)
32931|       |                   get_loc(n) get_arg(x) add dup put_loc(n) drop -> get_arg(x) add_loc(n)
32932|       |                   get_loc(n) get_var_ref(x) add dup put_loc(n) drop -> get_var_ref(x) add_loc(n)
32933|       |                 */
32934|  2.77k|                if (code_match(&cc, pos_next, M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1, OP_add, OP_dup, OP_put_loc, idx, OP_drop, -1)) {
32935|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
32936|      0|                    add_pc2line_info(s, bc_out.size, line_num);
32937|      0|                    put_short_code(&bc_out, cc.op, cc.idx);
32938|      0|                    dbuf_putc(&bc_out, OP_add_loc);
32939|      0|                    dbuf_putc(&bc_out, idx);
32940|      0|                    pos_next = cc.pos;
32941|      0|                    break;
32942|      0|                }
32943|  2.77k|                add_pc2line_info(s, bc_out.size, line_num);
32944|  2.77k|                put_short_code(&bc_out, op, idx);
32945|  2.77k|                break;
32946|  2.77k|            }
32947|      0|            goto no_change;
32948|      0|#if SHORT_OPCODES
32949|    699|        case OP_get_arg:
32950|  13.1k|        case OP_get_var_ref:
32951|  13.1k|            if (OPTIMIZE) {
32952|  13.1k|                int idx;
32953|  13.1k|                idx = get_u16(bc_buf + pos + 1);
32954|  13.1k|                add_pc2line_info(s, bc_out.size, line_num);
32955|  13.1k|                put_short_code(&bc_out, op, idx);
32956|  13.1k|                break;
32957|  13.1k|            }
32958|      0|            goto no_change;
32959|      0|#endif
32960|   125k|        case OP_put_loc:
32961|   125k|        case OP_put_arg:
32962|   130k|        case OP_put_var_ref:
32963|   130k|            if (OPTIMIZE) {
32964|       |                /* transformation: put_x(n) get_x(n) -> set_x(n) */
32965|   130k|                int idx;
32966|   130k|                idx = get_u16(bc_buf + pos + 1);
32967|   130k|                if (code_match(&cc, pos_next, op - 1, idx, -1)) {
32968|  8.57k|                    if (cc.line_num >= 0) line_num = cc.line_num;
32969|  8.57k|                    add_pc2line_info(s, bc_out.size, line_num);
32970|  8.57k|                    put_short_code(&bc_out, op + 1, idx);
32971|  8.57k|                    pos_next = cc.pos;
32972|  8.57k|                    break;
32973|  8.57k|                }
32974|   121k|                add_pc2line_info(s, bc_out.size, line_num);
32975|   121k|                put_short_code(&bc_out, op, idx);
32976|   121k|                break;
32977|   130k|            }
32978|      0|            goto no_change;
32979|       |
32980|  67.9k|        case OP_post_inc:
32981|  68.0k|        case OP_post_dec:
32982|  68.0k|            if (OPTIMIZE) {
32983|       |                /* transformation:
32984|       |                   post_inc put_x drop -> inc put_x
32985|       |                   post_inc perm3 put_field drop -> inc put_field
32986|       |                   post_inc perm3 put_var_strict drop -> inc put_var_strict
32987|       |                   post_inc perm4 put_array_el drop -> inc put_array_el
32988|       |                 */
32989|  68.0k|                int op1, idx;
32990|  68.0k|                if (code_match(&cc, pos_next, M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1, OP_drop, -1)) {
32991|    729|                    if (cc.line_num >= 0) line_num = cc.line_num;
32992|    729|                    op1 = cc.op;
32993|    729|                    idx = cc.idx;
32994|    729|                    pos_next = cc.pos;
32995|    729|                    if (code_match(&cc, cc.pos, op1 - 1, idx, -1)) {
32996|     36|                        if (cc.line_num >= 0) line_num = cc.line_num;
32997|     36|                        op1 += 1;   /* put_x(n) get_x(n) -> set_x(n) */
32998|     36|                        pos_next = cc.pos;
32999|     36|                    }
33000|    729|                    add_pc2line_info(s, bc_out.size, line_num);
33001|    729|                    dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
33002|    729|                    put_short_code(&bc_out, op1, idx);
33003|    729|                    break;
33004|    729|                }
33005|  67.3k|                if (code_match(&cc, pos_next, OP_perm3, M2(OP_put_field, OP_put_var_strict), OP_drop, -1)) {
33006|  5.28k|                    if (cc.line_num >= 0) line_num = cc.line_num;
33007|  5.28k|                    add_pc2line_info(s, bc_out.size, line_num);
33008|  5.28k|                    dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
33009|  5.28k|                    dbuf_putc(&bc_out, cc.op);
33010|  5.28k|                    dbuf_put_u32(&bc_out, cc.atom);
33011|  5.28k|                    pos_next = cc.pos;
33012|  5.28k|                    break;
33013|  5.28k|                }
33014|  62.0k|                if (code_match(&cc, pos_next, OP_perm4, OP_put_array_el, OP_drop, -1)) {
33015|      4|                    if (cc.line_num >= 0) line_num = cc.line_num;
33016|      4|                    add_pc2line_info(s, bc_out.size, line_num);
33017|      4|                    dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
33018|      4|                    dbuf_putc(&bc_out, OP_put_array_el);
33019|      4|                    pos_next = cc.pos;
33020|      4|                    break;
33021|      4|                }
33022|  62.0k|            }
33023|  62.0k|            goto no_change;
33024|       |
33025|  62.0k|#if SHORT_OPCODES
33026|  62.0k|        case OP_typeof:
33027|      0|            if (OPTIMIZE) {
33028|       |                /* simplify typeof tests */
33029|      0|                if (code_match(&cc, pos_next, OP_push_atom_value, M4(OP_strict_eq, OP_strict_neq, OP_eq, OP_neq), -1)) {
33030|      0|                    if (cc.line_num >= 0) line_num = cc.line_num;
33031|      0|                    int op1 = (cc.op == OP_strict_eq || cc.op == OP_eq) ? OP_strict_eq : OP_strict_neq;
33032|      0|                    int op2 = -1;
33033|      0|                    switch (cc.atom) {
33034|      0|                    case JS_ATOM_undefined:
33035|      0|                        op2 = OP_typeof_is_undefined;
33036|      0|                        break;
33037|      0|                    case JS_ATOM_function:
33038|      0|                        op2 = OP_typeof_is_function;
33039|      0|                        break;
33040|      0|                    }
33041|      0|                    if (op2 >= 0) {
33042|       |                        /* transform typeof(s) == "<type>" into is_<type> */
33043|      0|                        if (op1 == OP_strict_eq) {
33044|      0|                            add_pc2line_info(s, bc_out.size, line_num);
33045|      0|                            dbuf_putc(&bc_out, op2);
33046|      0|                            JS_FreeAtom(ctx, cc.atom);
33047|      0|                            pos_next = cc.pos;
33048|      0|                            break;
33049|      0|                        }
33050|      0|                        if (op1 == OP_strict_neq && code_match(&cc, cc.pos, OP_if_false, -1)) {
33051|       |                            /* transform typeof(s) != "<type>" if_false into is_<type> if_true */
33052|      0|                            if (cc.line_num >= 0) line_num = cc.line_num;
33053|      0|                            add_pc2line_info(s, bc_out.size, line_num);
33054|      0|                            dbuf_putc(&bc_out, op2);
33055|      0|                            JS_FreeAtom(ctx, cc.atom);
33056|      0|                            pos_next = cc.pos;
33057|      0|                            label = cc.label;
33058|      0|                            op = OP_if_true;
33059|      0|                            goto has_label;
33060|      0|                        }
33061|      0|                    }
33062|      0|                }
33063|      0|            }
33064|      0|            goto no_change;
33065|      0|#endif
33066|       |
33067|  1.38M|        default:
33068|  2.59M|        no_change:
33069|  2.59M|            add_pc2line_info(s, bc_out.size, line_num);
33070|  2.59M|            dbuf_put(&bc_out, bc_buf + pos, len);
33071|  2.59M|            break;
33072|  4.24M|        }
33073|  4.24M|    }
33074|       |
33075|       |    /* check that there were no missing labels */
33076|   573k|    for(i = 0; i < s->label_count; i++) {
33077|   452k|        assert(label_slots[i].first_reloc == NULL);
33078|   452k|    }
33079|   121k|#if SHORT_OPCODES
33080|   121k|    if (OPTIMIZE) {
33081|       |        /* more jump optimizations */
33082|   121k|        int patch_offsets = 0;
33083|   187k|        for (i = 0, jp = s->jump_slots; i < s->jump_count; i++, jp++) {
33084|  65.7k|            LabelSlot *ls;
33085|  65.7k|            JumpSlot *jp1;
33086|  65.7k|            int j, pos, diff, delta;
33087|       |
33088|  65.7k|            delta = 3;
33089|  65.7k|            switch (op = jp->op) {
33090|  7.86k|            case OP_goto16:
33091|  7.86k|                delta = 1;
33092|       |                /* fall thru */
33093|  15.2k|            case OP_if_false:
33094|  15.9k|            case OP_if_true:
33095|  16.0k|            case OP_goto:
33096|  16.0k|                pos = jp->pos;
33097|  16.0k|                diff = s->label_slots[jp->label].addr - pos;
33098|  16.0k|                if (diff >= -128 && diff <= 127 + delta) {
33099|       |                    //put_u8(bc_out.buf + pos, diff);
33100|  7.07k|                    jp->size = 1;
33101|  7.07k|                    if (op == OP_goto16) {
33102|  4.62k|                        bc_out.buf[pos - 1] = jp->op = OP_goto8;
33103|  4.62k|                    } else {
33104|  2.45k|                        bc_out.buf[pos - 1] = jp->op = OP_if_false8 + (op - OP_if_false);
33105|  2.45k|                    }
33106|  7.07k|                    goto shrink;
33107|  7.07k|                } else
33108|  8.93k|                if (diff == (int16_t)diff && op == OP_goto) {
33109|       |                    //put_u16(bc_out.buf + pos, diff);
33110|     12|                    jp->size = 2;
33111|     12|                    delta = 2;
33112|     12|                    bc_out.buf[pos - 1] = jp->op = OP_goto16;
33113|  7.08k|                shrink:
33114|       |                    /* XXX: should reduce complexity, using 2 finger copy scheme */
33115|  7.08k|                    memmove(bc_out.buf + pos + jp->size, bc_out.buf + pos + jp->size + delta,
33116|  7.08k|                            bc_out.size - pos - jp->size - delta);
33117|  7.08k|                    bc_out.size -= delta;
33118|  7.08k|                    patch_offsets++;
33119|  7.59M|                    for (j = 0, ls = s->label_slots; j < s->label_count; j++, ls++) {
33120|  7.58M|                        if (ls->addr > pos)
33121|  2.09M|                            ls->addr -= delta;
33122|  7.58M|                    }
33123|   848k|                    for (j = i + 1, jp1 = jp + 1; j < s->jump_count; j++, jp1++) {
33124|   840k|                        if (jp1->pos > pos)
33125|   840k|                            jp1->pos -= delta;
33126|   840k|                    }
33127|  2.89M|                    for (j = 0; j < s->line_number_count; j++) {
33128|  2.88M|                        if (s->line_number_slots[j].pc > pos)
33129|  1.49M|                            s->line_number_slots[j].pc -= delta;
33130|  2.88M|                    }
33131|  7.08k|                    continue;
33132|     12|                }
33133|  8.92k|                break;
33134|  65.7k|            }
33135|  65.7k|        }
33136|   121k|        if (patch_offsets) {
33137|  2.38k|            JumpSlot *jp1;
33138|  2.38k|            int j;
33139|  50.9k|            for (j = 0, jp1 = s->jump_slots; j < s->jump_count; j++, jp1++) {
33140|  48.5k|                int diff1 = s->label_slots[jp1->label].addr - jp1->pos;
33141|  48.5k|                switch (jp1->size) {
33142|  40.6k|                case 1:
33143|  40.6k|                    put_u8(bc_out.buf + jp1->pos, diff1);
33144|  40.6k|                    break;
33145|  2.75k|                case 2:
33146|  2.75k|                    put_u16(bc_out.buf + jp1->pos, diff1);
33147|  2.75k|                    break;
33148|  5.19k|                case 4:
33149|  5.19k|                    put_u32(bc_out.buf + jp1->pos, diff1);
33150|  5.19k|                    break;
33151|  48.5k|                }
33152|  48.5k|            }
33153|  2.38k|        }
33154|   121k|    }
33155|   121k|    js_free(ctx, s->jump_slots);
33156|   121k|    s->jump_slots = NULL;
33157|   121k|#endif
33158|   121k|    js_free(ctx, s->label_slots);
33159|   121k|    s->label_slots = NULL;
33160|       |    /* XXX: should delay until copying to runtime bytecode function */
33161|   121k|    compute_pc2line_info(s);
33162|   121k|    js_free(ctx, s->line_number_slots);
33163|   121k|    s->line_number_slots = NULL;
33164|       |    /* set the new byte code */
33165|   121k|    dbuf_free(&s->byte_code);
33166|   121k|    s->byte_code = bc_out;
33167|   121k|    s->use_short_opcodes = TRUE;
33168|   121k|    if (dbuf_error(&s->byte_code)) {
33169|      0|        JS_ThrowOutOfMemory(ctx);
33170|      0|        return -1;
33171|      0|    }
33172|   121k|    return 0;
33173|      0| fail:
33174|       |    /* XXX: not safe */
33175|      0|    dbuf_free(&bc_out);
33176|      0|    return -1;
33177|   121k|}
33178|       |
33179|       |/* compute the maximum stack size needed by the function */
33180|       |
33181|       |typedef struct StackSizeState {
33182|       |    int bc_len;
33183|       |    int stack_len_max;
33184|       |    uint16_t *stack_level_tab;
33185|       |    int32_t *catch_pos_tab;
33186|       |    int *pc_stack;
33187|       |    int pc_stack_len;
33188|       |    int pc_stack_size;
33189|       |} StackSizeState;
33190|       |
33191|       |/* 'op' is only used for error indication */
33192|       |static __exception int ss_check(JSContext *ctx, StackSizeState *s,
33193|       |                                int pos, int op, int stack_len, int catch_pos)
33194|  3.48M|{
33195|  3.48M|    if ((unsigned)pos >= s->bc_len) {
33196|      0|        JS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)", op, pos);
33197|      0|        return -1;
33198|      0|    }
33199|  3.48M|    if (stack_len > s->stack_len_max) {
33200|      0|        s->stack_len_max = stack_len;
33201|      0|        if (s->stack_len_max > JS_STACK_SIZE_MAX) {
33202|      0|            JS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
33203|      0|            return -1;
33204|      0|        }
33205|      0|    }
33206|  3.48M|    if (s->stack_level_tab[pos] != 0xffff) {
33207|       |        /* already explored: check that the stack size is consistent */
33208|  24.4k|        if (s->stack_level_tab[pos] != stack_len) {
33209|      0|            JS_ThrowInternalError(ctx, "inconsistent stack size: %d %d (pc=%d)",
33210|      0|                                  s->stack_level_tab[pos], stack_len, pos);
33211|      0|            return -1;
33212|  24.4k|        } else if (s->catch_pos_tab[pos] != catch_pos) {
33213|      0|            JS_ThrowInternalError(ctx, "inconsistent catch position: %d %d (pc=%d)",
33214|      0|                                  s->catch_pos_tab[pos], catch_pos, pos);
33215|      0|            return -1;
33216|  24.4k|        } else {
33217|  24.4k|            return 0;
33218|  24.4k|        }
33219|  24.4k|    }
33220|       |
33221|       |    /* mark as explored and store the stack size */
33222|  3.45M|    s->stack_level_tab[pos] = stack_len;
33223|  3.45M|    s->catch_pos_tab[pos] = catch_pos;
33224|       |
33225|       |    /* queue the new PC to explore */
33226|  3.45M|    if (js_resize_array(ctx, (void **)&s->pc_stack, sizeof(s->pc_stack[0]),
33227|  3.45M|                        &s->pc_stack_size, s->pc_stack_len + 1))
33228|      0|        return -1;
33229|  3.45M|    s->pc_stack[s->pc_stack_len++] = pos;
33230|  3.45M|    return 0;
33231|  3.45M|}
33232|       |
33233|       |static __exception int compute_stack_size(JSContext *ctx,
33234|       |                                          JSFunctionDef *fd,
33235|       |                                          int *pstack_size)
33236|   121k|{
33237|   121k|    StackSizeState s_s, *s = &s_s;
33238|   121k|    int i, diff, n_pop, pos_next, stack_len, pos, op, catch_pos, catch_level;
33239|   121k|    const JSOpCode *oi;
33240|   121k|    const uint8_t *bc_buf;
33241|       |
33242|   121k|    bc_buf = fd->byte_code.buf;
33243|   121k|    s->bc_len = fd->byte_code.size;
33244|       |    /* bc_len > 0 */
33245|   121k|    s->stack_level_tab = js_malloc(ctx, sizeof(s->stack_level_tab[0]) *
33246|   121k|                                   s->bc_len);
33247|   121k|    if (!s->stack_level_tab)
33248|      0|        return -1;
33249|  8.07M|    for(i = 0; i < s->bc_len; i++)
33250|  7.95M|        s->stack_level_tab[i] = 0xffff;
33251|   121k|    s->pc_stack = NULL;
33252|   121k|    s->catch_pos_tab = js_malloc(ctx, sizeof(s->catch_pos_tab[0]) *
33253|   121k|                                   s->bc_len);
33254|   121k|    if (!s->catch_pos_tab)
33255|      0|        goto fail;
33256|       |
33257|   121k|    s->stack_len_max = 0;
33258|   121k|    s->pc_stack_len = 0;
33259|   121k|    s->pc_stack_size = 0;
33260|       |
33261|       |    /* breadth-first graph exploration */
33262|   121k|    if (ss_check(ctx, s, 0, OP_invalid, 0, -1))
33263|      0|        goto fail;
33264|       |
33265|  3.57M|    while (s->pc_stack_len > 0) {
33266|  3.45M|        pos = s->pc_stack[--s->pc_stack_len];
33267|  3.45M|        stack_len = s->stack_level_tab[pos];
33268|  3.45M|        catch_pos = s->catch_pos_tab[pos];
33269|  3.45M|        op = bc_buf[pos];
33270|  3.45M|        if (op == 0 || op >= OP_COUNT) {
33271|      0|            JS_ThrowInternalError(ctx, "invalid opcode (op=%d, pc=%d)", op, pos);
33272|      0|            goto fail;
33273|      0|        }
33274|  3.45M|        oi = &short_opcode_info(op);
33275|       |#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 64)
33276|       |        printf("%5d: %10s %5d %5d\n", pos, oi->name, stack_len, catch_pos);
33277|       |#endif
33278|  3.45M|        pos_next = pos + oi->size;
33279|  3.45M|        if (pos_next > s->bc_len) {
33280|      0|            JS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)", op, pos);
33281|      0|            goto fail;
33282|      0|        }
33283|  3.45M|        n_pop = oi->n_pop;
33284|       |        /* call pops a variable number of arguments */
33285|  3.45M|        if (oi->fmt == OP_FMT_npop || oi->fmt == OP_FMT_npop_u16) {
33286|  9.78k|            n_pop += get_u16(bc_buf + pos + 1);
33287|  3.44M|        } else {
33288|  3.44M|#if SHORT_OPCODES
33289|  3.44M|            if (oi->fmt == OP_FMT_npopx) {
33290|   155k|                n_pop += op - OP_call0;
33291|   155k|            }
33292|  3.44M|#endif
33293|  3.44M|        }
33294|       |
33295|  3.45M|        if (stack_len < n_pop) {
33296|      0|            JS_ThrowInternalError(ctx, "stack underflow (op=%d, pc=%d)", op, pos);
33297|      0|            goto fail;
33298|      0|        }
33299|  3.45M|        stack_len += oi->n_push - n_pop;
33300|  3.45M|        if (stack_len > s->stack_len_max) {
33301|   313k|            s->stack_len_max = stack_len;
33302|   313k|            if (s->stack_len_max > JS_STACK_SIZE_MAX) {
33303|      0|                JS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
33304|      0|                goto fail;
33305|      0|            }
33306|   313k|        }
33307|  3.45M|        switch(op) {
33308|    239|        case OP_tail_call:
33309|    426|        case OP_tail_call_method:
33310|   121k|        case OP_return:
33311|   122k|        case OP_return_undef:
33312|   122k|        case OP_return_async:
33313|   122k|        case OP_throw:
33314|   123k|        case OP_throw_error:
33315|   123k|        case OP_ret:
33316|   123k|            goto done_insn;
33317|     69|        case OP_goto:
33318|     69|            diff = get_u32(bc_buf + pos + 1);
33319|     69|            pos_next = pos + 1 + diff;
33320|     69|            break;
33321|      0|#if SHORT_OPCODES
33322|  3.25k|        case OP_goto16:
33323|  3.25k|            diff = (int16_t)get_u16(bc_buf + pos + 1);
33324|  3.25k|            pos_next = pos + 1 + diff;
33325|  3.25k|            break;
33326|  36.0k|        case OP_goto8:
33327|  36.0k|            diff = (int8_t)bc_buf[pos + 1];
33328|  36.0k|            pos_next = pos + 1 + diff;
33329|  36.0k|            break;
33330|  2.86k|        case OP_if_true8:
33331|  20.4k|        case OP_if_false8:
33332|  20.4k|            diff = (int8_t)bc_buf[pos + 1];
33333|  20.4k|            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len, catch_pos))
33334|      0|                goto fail;
33335|  20.4k|            break;
33336|  20.4k|#endif
33337|  20.4k|        case OP_if_true:
33338|  5.61k|        case OP_if_false:
33339|  5.61k|            diff = get_u32(bc_buf + pos + 1);
33340|  5.61k|            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len, catch_pos))
33341|      0|                goto fail;
33342|  5.61k|            break;
33343|  5.61k|        case OP_gosub:
33344|      0|            diff = get_u32(bc_buf + pos + 1);
33345|      0|            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len + 1, catch_pos))
33346|      0|                goto fail;
33347|      0|            break;
33348|      0|        case OP_with_get_var:
33349|      0|        case OP_with_delete_var:
33350|      0|            diff = get_u32(bc_buf + pos + 5);
33351|      0|            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 1, catch_pos))
33352|      0|                goto fail;
33353|      0|            break;
33354|      0|        case OP_with_make_ref:
33355|      0|        case OP_with_get_ref:
33356|      0|            diff = get_u32(bc_buf + pos + 5);
33357|      0|            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 2, catch_pos))
33358|      0|                goto fail;
33359|      0|            break;
33360|      0|        case OP_with_put_var:
33361|      0|            diff = get_u32(bc_buf + pos + 5);
33362|      0|            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len - 1, catch_pos))
33363|      0|                goto fail;
33364|      0|            break;
33365|      0|        case OP_catch:
33366|      0|            diff = get_u32(bc_buf + pos + 1);
33367|      0|            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len, catch_pos))
33368|      0|                goto fail;
33369|      0|            catch_pos = pos;
33370|      0|            break;
33371|  8.06k|        case OP_for_of_start:
33372|  8.06k|        case OP_for_await_of_start:
33373|  8.06k|            catch_pos = pos;
33374|  8.06k|            break;
33375|       |            /* we assume the catch offset entry is only removed with
33376|       |               some op codes */
33377|   463k|        case OP_drop:
33378|   463k|            catch_level = stack_len;
33379|   463k|            goto check_catch;
33380|  11.7k|        case OP_nip:
33381|  11.7k|            catch_level = stack_len - 1;
33382|  11.7k|            goto check_catch;
33383|      0|        case OP_nip1:
33384|      0|            catch_level = stack_len - 1;
33385|      0|            goto check_catch;
33386|  8.06k|        case OP_iterator_close:
33387|  8.06k|            catch_level = stack_len + 2;
33388|   482k|        check_catch:
33389|       |            /* Note: for for_of_start/for_await_of_start we consider
33390|       |               the catch offset is on the first stack entry instead of
33391|       |               the thirst */
33392|   482k|            if (catch_pos >= 0) {
33393|   406k|                int level;
33394|   406k|                level = s->stack_level_tab[catch_pos];
33395|   406k|                if (bc_buf[catch_pos] != OP_catch)
33396|   406k|                    level++; /* for_of_start, for_wait_of_start */
33397|       |                /* catch_level = stack_level before op_catch is executed ? */
33398|   406k|                if (catch_level == level) {
33399|  8.06k|                    catch_pos = s->catch_pos_tab[catch_pos];
33400|  8.06k|                }
33401|   406k|            }
33402|   482k|            break;
33403|      0|        case OP_nip_catch:
33404|      0|            if (catch_pos < 0) {
33405|      0|                JS_ThrowInternalError(ctx, "nip_catch: no catch op (pc=%d)", pos);
33406|      0|                goto fail;
33407|      0|            }
33408|      0|            stack_len = s->stack_level_tab[catch_pos];
33409|      0|            if (bc_buf[catch_pos] != OP_catch)
33410|      0|                stack_len++; /* for_of_start, for_wait_of_start */
33411|      0|            stack_len++; /* no stack overflow is possible by construction */
33412|      0|            catch_pos = s->catch_pos_tab[catch_pos];
33413|      0|            break;
33414|  2.77M|        default:
33415|  2.77M|            break;
33416|  3.45M|        }
33417|  3.33M|        if (ss_check(ctx, s, pos_next, op, stack_len, catch_pos))
33418|      0|            goto fail;
33419|  3.45M|    done_insn: ;
33420|  3.45M|    }
33421|   121k|    js_free(ctx, s->pc_stack);
33422|   121k|    js_free(ctx, s->catch_pos_tab);
33423|   121k|    js_free(ctx, s->stack_level_tab);
33424|   121k|    *pstack_size = s->stack_len_max;
33425|   121k|    return 0;
33426|      0| fail:
33427|      0|    js_free(ctx, s->pc_stack);
33428|      0|    js_free(ctx, s->catch_pos_tab);
33429|      0|    js_free(ctx, s->stack_level_tab);
33430|      0|    *pstack_size = 0;
33431|      0|    return -1;
33432|   121k|}
33433|       |
33434|       |static int add_module_variables(JSContext *ctx, JSFunctionDef *fd)
33435|    505|{
33436|    505|    int i, idx;
33437|    505|    JSModuleDef *m = fd->module;
33438|    505|    JSExportEntry *me;
33439|    505|    JSGlobalVar *hf;
33440|       |
33441|       |    /* The imported global variables were added as closure variables
33442|       |       in js_parse_import(). We add here the module global
33443|       |       variables. */
33444|       |
33445|  9.10k|    for(i = 0; i < fd->global_var_count; i++) {
33446|  8.60k|        hf = &fd->global_vars[i];
33447|  8.60k|        if (add_closure_var(ctx, fd, TRUE, FALSE, i, hf->var_name, hf->is_const,
33448|  8.60k|                            hf->is_lexical, FALSE) < 0)
33449|      0|            return -1;
33450|  8.60k|    }
33451|       |
33452|       |    /* resolve the variable names of the local exports */
33453|    994|    for(i = 0; i < m->export_entries_count; i++) {
33454|    492|        me = &m->export_entries[i];
33455|    492|        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
33456|    492|            idx = find_closure_var(ctx, fd, me->local_name);
33457|    492|            if (idx < 0) {
33458|      3|                JS_ThrowSyntaxErrorAtom(ctx, "exported variable '%s' does not exist",
33459|      3|                                        me->local_name);
33460|      3|                return -1;
33461|      3|            }
33462|    489|            me->u.local.var_idx = idx;
33463|    489|        }
33464|    492|    }
33465|    502|    return 0;
33466|    505|}
33467|       |
33468|       |/* create a function object from a function definition. The function
33469|       |   definition is freed. All the child functions are also created. It
33470|       |   must be done this way to resolve all the variables. */
33471|       |static JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)
33472|   122k|{
33473|   122k|    JSValue func_obj;
33474|   122k|    JSFunctionBytecode *b;
33475|   122k|    struct list_head *el, *el1;
33476|   122k|    int stack_size, scope, idx;
33477|   122k|    int function_size, byte_code_offset, cpool_offset;
33478|   122k|    int closure_var_offset, vardefs_offset;
33479|       |
33480|       |    /* recompute scope linkage */
33481|   385k|    for (scope = 0; scope < fd->scope_count; scope++) {
33482|   263k|        fd->scopes[scope].first = -1;
33483|   263k|    }
33484|   122k|    if (fd->has_parameter_expressions) {
33485|       |        /* special end of variable list marker for the argument scope */
33486|      0|        fd->scopes[ARG_SCOPE_INDEX].first = ARG_SCOPE_END;
33487|      0|    }
33488|   144k|    for (idx = 0; idx < fd->var_count; idx++) {
33489|  21.8k|        JSVarDef *vd = &fd->vars[idx];
33490|  21.8k|        vd->scope_next = fd->scopes[vd->scope_level].first;
33491|  21.8k|        fd->scopes[vd->scope_level].first = idx;
33492|  21.8k|    }
33493|   140k|    for (scope = 2; scope < fd->scope_count; scope++) {
33494|  17.7k|        JSVarScope *sd = &fd->scopes[scope];
33495|  17.7k|        if (sd->first < 0)
33496|  11.7k|            sd->first = fd->scopes[sd->parent].first;
33497|  17.7k|    }
33498|   144k|    for (idx = 0; idx < fd->var_count; idx++) {
33499|  21.8k|        JSVarDef *vd = &fd->vars[idx];
33500|  21.8k|        if (vd->scope_next < 0 && vd->scope_level > 1) {
33501|  5.95k|            scope = fd->scopes[vd->scope_level].parent;
33502|  5.95k|            vd->scope_next = fd->scopes[scope].first;
33503|  5.95k|        }
33504|  21.8k|    }
33505|       |
33506|       |    /* if the function contains an eval call, the closure variables
33507|       |       are used to compile the eval and they must be ordered by scope,
33508|       |       so it is necessary to create the closure variables before any
33509|       |       other variable lookup is done. */
33510|   122k|    if (fd->has_eval_call)
33511|      0|        add_eval_variables(ctx, fd);
33512|       |
33513|       |    /* add the module global variables in the closure */
33514|   122k|    if (fd->module) {
33515|    505|        if (add_module_variables(ctx, fd))
33516|      3|            goto fail;
33517|    505|    }
33518|       |
33519|       |    /* first create all the child functions */
33520|   122k|    list_for_each_safe(el, el1, &fd->child_list) {
33521|   113k|        JSFunctionDef *fd1;
33522|   113k|        int cpool_idx;
33523|       |
33524|   113k|        fd1 = list_entry(el, JSFunctionDef, link);
33525|   113k|        cpool_idx = fd1->parent_cpool_idx;
33526|   113k|        func_obj = js_create_function(ctx, fd1);
33527|   113k|        if (JS_IsException(func_obj))
33528|  1.06k|            goto fail;
33529|       |        /* save it in the constant pool */
33530|   112k|        assert(cpool_idx >= 0);
33531|   112k|        fd->cpool[cpool_idx] = func_obj;
33532|   112k|    }
33533|       |
33534|       |#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 4)
33535|       |    if (!fd->strip_debug) {
33536|       |        printf("pass 1\n");
33537|       |        dump_byte_code(ctx, 1, fd->byte_code.buf, fd->byte_code.size,
33538|       |                       fd->args, fd->arg_count, fd->vars, fd->var_count,
33539|       |                       fd->closure_var, fd->closure_var_count,
33540|       |                       fd->cpool, fd->cpool_count, fd->source,
33541|       |                       fd->label_slots, NULL);
33542|       |        printf("\n");
33543|       |    }
33544|       |#endif
33545|       |
33546|   121k|    if (resolve_variables(ctx, fd))
33547|     68|        goto fail;
33548|       |
33549|       |#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 2)
33550|       |    if (!fd->strip_debug) {
33551|       |        printf("pass 2\n");
33552|       |        dump_byte_code(ctx, 2, fd->byte_code.buf, fd->byte_code.size,
33553|       |                       fd->args, fd->arg_count, fd->vars, fd->var_count,
33554|       |                       fd->closure_var, fd->closure_var_count,
33555|       |                       fd->cpool, fd->cpool_count, fd->source,
33556|       |                       fd->label_slots, NULL);
33557|       |        printf("\n");
33558|       |    }
33559|       |#endif
33560|       |
33561|   121k|    if (resolve_labels(ctx, fd))
33562|      0|        goto fail;
33563|       |
33564|   121k|    if (compute_stack_size(ctx, fd, &stack_size) < 0)
33565|      0|        goto fail;
33566|       |
33567|   121k|    if (fd->strip_debug) {
33568|      0|        function_size = offsetof(JSFunctionBytecode, debug);
33569|   121k|    } else {
33570|   121k|        function_size = sizeof(*b);
33571|   121k|    }
33572|   121k|    cpool_offset = function_size;
33573|   121k|    function_size += fd->cpool_count * sizeof(*fd->cpool);
33574|   121k|    vardefs_offset = function_size;
33575|   121k|    if (!fd->strip_debug || fd->has_eval_call) {
33576|   121k|        function_size += (fd->arg_count + fd->var_count) * sizeof(*b->vardefs);
33577|   121k|    }
33578|   121k|    closure_var_offset = function_size;
33579|   121k|    function_size += fd->closure_var_count * sizeof(*fd->closure_var);
33580|   121k|    byte_code_offset = function_size;
33581|   121k|    function_size += fd->byte_code.size;
33582|       |
33583|   121k|    b = js_mallocz(ctx, function_size);
33584|   121k|    if (!b)
33585|      0|        goto fail;
33586|   121k|    b->header.ref_count = 1;
33587|       |
33588|   121k|    b->byte_code_buf = (void *)((uint8_t*)b + byte_code_offset);
33589|   121k|    b->byte_code_len = fd->byte_code.size;
33590|   121k|    memcpy(b->byte_code_buf, fd->byte_code.buf, fd->byte_code.size);
33591|   121k|    js_free(ctx, fd->byte_code.buf);
33592|   121k|    fd->byte_code.buf = NULL;
33593|       |
33594|   121k|    b->func_name = fd->func_name;
33595|   121k|    if (fd->arg_count + fd->var_count > 0) {
33596|   121k|        if (fd->strip_debug && !fd->has_eval_call) {
33597|       |            /* Strip variable definitions not needed at runtime */
33598|      0|            int i;
33599|      0|            for(i = 0; i < fd->var_count; i++) {
33600|      0|                JS_FreeAtom(ctx, fd->vars[i].var_name);
33601|      0|            }
33602|      0|            for(i = 0; i < fd->arg_count; i++) {
33603|      0|                JS_FreeAtom(ctx, fd->args[i].var_name);
33604|      0|            }
33605|      0|            for(i = 0; i < fd->closure_var_count; i++) {
33606|      0|                JS_FreeAtom(ctx, fd->closure_var[i].var_name);
33607|      0|                fd->closure_var[i].var_name = JS_ATOM_NULL;
33608|      0|            }
33609|   121k|        } else {
33610|   121k|            b->vardefs = (void *)((uint8_t*)b + vardefs_offset);
33611|   121k|            memcpy_no_ub(b->vardefs, fd->args, fd->arg_count * sizeof(fd->args[0]));
33612|   121k|            memcpy_no_ub(b->vardefs + fd->arg_count, fd->vars, fd->var_count * sizeof(fd->vars[0]));
33613|   121k|        }
33614|   121k|        b->var_count = fd->var_count;
33615|   121k|        b->arg_count = fd->arg_count;
33616|   121k|        b->defined_arg_count = fd->defined_arg_count;
33617|   121k|        js_free(ctx, fd->args);
33618|   121k|        js_free(ctx, fd->vars);
33619|   121k|    }
33620|   121k|    b->cpool_count = fd->cpool_count;
33621|   121k|    if (b->cpool_count) {
33622|  44.6k|        b->cpool = (void *)((uint8_t*)b + cpool_offset);
33623|  44.6k|        memcpy(b->cpool, fd->cpool, b->cpool_count * sizeof(*b->cpool));
33624|  44.6k|    }
33625|   121k|    js_free(ctx, fd->cpool);
33626|   121k|    fd->cpool = NULL;
33627|       |
33628|   121k|    b->stack_size = stack_size;
33629|       |
33630|   121k|    if (fd->strip_debug) {
33631|      0|        JS_FreeAtom(ctx, fd->filename);
33632|      0|        dbuf_free(&fd->pc2line);    // probably useless
33633|   121k|    } else {
33634|       |        /* XXX: source and pc2line info should be packed at the end of the
33635|       |           JSFunctionBytecode structure, avoiding allocation overhead
33636|       |         */
33637|   121k|        b->has_debug = 1;
33638|   121k|        b->debug.filename = fd->filename;
33639|       |
33640|       |        //DynBuf pc2line;
33641|       |        //compute_pc2line_info(fd, &pc2line);
33642|       |        //js_free(ctx, fd->line_number_slots)
33643|   121k|        b->debug.pc2line_buf = js_realloc(ctx, fd->pc2line.buf, fd->pc2line.size);
33644|   121k|        if (!b->debug.pc2line_buf)
33645|      0|            b->debug.pc2line_buf = fd->pc2line.buf;
33646|   121k|        b->debug.pc2line_len = fd->pc2line.size;
33647|   121k|        b->debug.source = fd->source;
33648|   121k|        b->debug.source_len = fd->source_len;
33649|   121k|    }
33650|   121k|    if (fd->scopes != fd->def_scope_array)
33651|  1.46k|        js_free(ctx, fd->scopes);
33652|       |
33653|   121k|    b->closure_var_count = fd->closure_var_count;
33654|   121k|    if (b->closure_var_count) {
33655|  69.0k|        b->closure_var = (void *)((uint8_t*)b + closure_var_offset);
33656|  69.0k|        memcpy(b->closure_var, fd->closure_var, b->closure_var_count * sizeof(*b->closure_var));
33657|  69.0k|    }
33658|   121k|    js_free(ctx, fd->closure_var);
33659|   121k|    fd->closure_var = NULL;
33660|       |
33661|   121k|    b->has_prototype = fd->has_prototype;
33662|   121k|    b->has_simple_parameter_list = fd->has_simple_parameter_list;
33663|   121k|    b->js_mode = fd->js_mode;
33664|   121k|    b->is_derived_class_constructor = fd->is_derived_class_constructor;
33665|   121k|    b->func_kind = fd->func_kind;
33666|   121k|    b->need_home_object = (fd->home_object_var_idx >= 0 ||
33667|   121k|                           fd->need_home_object);
33668|   121k|    b->new_target_allowed = fd->new_target_allowed;
33669|   121k|    b->super_call_allowed = fd->super_call_allowed;
33670|   121k|    b->super_allowed = fd->super_allowed;
33671|   121k|    b->arguments_allowed = fd->arguments_allowed;
33672|   121k|    b->is_direct_or_indirect_eval = (fd->eval_type == JS_EVAL_TYPE_DIRECT ||
33673|   121k|                                     fd->eval_type == JS_EVAL_TYPE_INDIRECT);
33674|   121k|    b->realm = JS_DupContext(ctx);
33675|       |
33676|   121k|    add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
33677|       |
33678|       |#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
33679|       |    if (!fd->strip_debug) {
33680|       |        js_dump_function_bytecode(ctx, b);
33681|       |    }
33682|       |#endif
33683|       |
33684|   121k|    if (fd->parent) {
33685|       |        /* remove from parent list */
33686|   112k|        list_del(&fd->link);
33687|   112k|    }
33688|       |
33689|   121k|    js_free(ctx, fd);
33690|   121k|    return JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);
33691|  1.13k| fail:
33692|  1.13k|    js_free_function_def(ctx, fd);
33693|  1.13k|    return JS_EXCEPTION;
33694|   121k|}
33695|       |
33696|       |static void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b)
33697|   102k|{
33698|   102k|    int i;
33699|       |
33700|       |#if 0
33701|       |    {
33702|       |        char buf[ATOM_GET_STR_BUF_SIZE];
33703|       |        printf("freeing %s\n",
33704|       |               JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));
33705|       |    }
33706|       |#endif
33707|   102k|    free_bytecode_atoms(rt, b->byte_code_buf, b->byte_code_len, TRUE);
33708|       |
33709|   102k|    if (b->vardefs) {
33710|   209k|        for(i = 0; i < b->arg_count + b->var_count; i++) {
33711|   107k|            JS_FreeAtomRT(rt, b->vardefs[i].var_name);
33712|   107k|        }
33713|   101k|    }
33714|   458k|    for(i = 0; i < b->cpool_count; i++)
33715|   356k|        JS_FreeValueRT(rt, b->cpool[i]);
33716|       |
33717|   205k|    for(i = 0; i < b->closure_var_count; i++) {
33718|   103k|        JSClosureVar *cv = &b->closure_var[i];
33719|   103k|        JS_FreeAtomRT(rt, cv->var_name);
33720|   103k|    }
33721|   102k|    if (b->realm)
33722|   102k|        JS_FreeContext(b->realm);
33723|       |
33724|   102k|    JS_FreeAtomRT(rt, b->func_name);
33725|   102k|    if (b->has_debug) {
33726|   102k|        JS_FreeAtomRT(rt, b->debug.filename);
33727|   102k|        js_free_rt(rt, b->debug.pc2line_buf);
33728|   102k|        js_free_rt(rt, b->debug.source);
33729|   102k|    }
33730|       |
33731|   102k|    remove_gc_object(&b->header);
33732|   102k|    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && b->header.ref_count != 0) {
33733|  12.0k|        list_add_tail(&b->header.link, &rt->gc_zero_ref_count_list);
33734|  89.9k|    } else {
33735|  89.9k|        js_free_rt(rt, b);
33736|  89.9k|    }
33737|   102k|}
33738|       |
33739|       |static __exception int js_parse_directives(JSParseState *s)
33740|  20.4k|{
33741|  20.4k|    char str[20];
33742|  20.4k|    JSParsePos pos;
33743|  20.4k|    BOOL has_semi;
33744|       |
33745|  20.4k|    if (s->token.val != TOK_STRING)
33746|  19.8k|        return 0;
33747|       |
33748|    601|    js_parse_get_pos(s, &pos);
33749|       |
33750|  2.22k|    while(s->token.val == TOK_STRING) {
33751|       |        /* Copy actual source string representation */
33752|  1.99k|        snprintf(str, sizeof str, "%.*s",
33753|  1.99k|                 (int)(s->buf_ptr - s->token.ptr - 2), s->token.ptr + 1);
33754|       |
33755|  1.99k|        if (next_token(s))
33756|      3|            return -1;
33757|       |
33758|  1.99k|        has_semi = FALSE;
33759|  1.99k|        switch (s->token.val) {
33760|     12|        case ';':
33761|     12|            if (next_token(s))
33762|      2|                return -1;
33763|     10|            has_semi = TRUE;
33764|     10|            break;
33765|      1|        case '}':
33766|      6|        case TOK_EOF:
33767|      6|            has_semi = TRUE;
33768|      6|            break;
33769|     22|        case TOK_NUMBER:
33770|  1.41k|        case TOK_STRING:
33771|  1.41k|        case TOK_TEMPLATE:
33772|  1.55k|        case TOK_IDENT:
33773|  1.55k|        case TOK_REGEXP:
33774|  1.55k|        case TOK_DEC:
33775|  1.56k|        case TOK_INC:
33776|  1.56k|        case TOK_NULL:
33777|  1.56k|        case TOK_FALSE:
33778|  1.56k|        case TOK_TRUE:
33779|  1.56k|        case TOK_IF:
33780|  1.56k|        case TOK_RETURN:
33781|  1.56k|        case TOK_VAR:
33782|  1.56k|        case TOK_THIS:
33783|  1.56k|        case TOK_DELETE:
33784|  1.56k|        case TOK_TYPEOF:
33785|  1.56k|        case TOK_NEW:
33786|  1.56k|        case TOK_DO:
33787|  1.56k|        case TOK_WHILE:
33788|  1.56k|        case TOK_FOR:
33789|  1.56k|        case TOK_SWITCH:
33790|  1.56k|        case TOK_THROW:
33791|  1.56k|        case TOK_TRY:
33792|  1.56k|        case TOK_FUNCTION:
33793|  1.56k|        case TOK_DEBUGGER:
33794|  1.56k|        case TOK_WITH:
33795|  1.56k|        case TOK_CLASS:
33796|  1.56k|        case TOK_CONST:
33797|  1.56k|        case TOK_ENUM:
33798|  1.57k|        case TOK_EXPORT:
33799|  1.57k|        case TOK_IMPORT:
33800|  1.57k|        case TOK_SUPER:
33801|  1.57k|        case TOK_INTERFACE:
33802|  1.62k|        case TOK_LET:
33803|  1.62k|        case TOK_PACKAGE:
33804|  1.62k|        case TOK_PRIVATE:
33805|  1.62k|        case TOK_PROTECTED:
33806|  1.62k|        case TOK_PUBLIC:
33807|  1.62k|        case TOK_STATIC:
33808|       |            /* automatic insertion of ';' */
33809|  1.62k|            if (s->got_lf)
33810|  1.60k|                has_semi = TRUE;
33811|  1.62k|            break;
33812|    351|        default:
33813|    351|            break;
33814|  1.99k|        }
33815|  1.99k|        if (!has_semi)
33816|    375|            break;
33817|  1.61k|        if (!strcmp(str, "use strict")) {
33818|      0|            s->cur_func->has_use_strict = TRUE;
33819|      0|            s->cur_func->js_mode |= JS_MODE_STRICT;
33820|      0|        }
33821|  1.61k|    }
33822|    596|    return js_parse_seek_token(s, &pos);
33823|    601|}
33824|       |
33825|       |static int js_parse_function_check_names(JSParseState *s, JSFunctionDef *fd,
33826|       |                                         JSAtom func_name)
33827|   133k|{
33828|   133k|    JSAtom name;
33829|   133k|    int i, idx;
33830|       |
33831|   133k|    if (fd->js_mode & JS_MODE_STRICT) {
33832|  25.8k|        if (!fd->has_simple_parameter_list && fd->has_use_strict) {
33833|      0|            return js_parse_error(s, "\"use strict\" not allowed in function with default or destructuring parameter");
33834|      0|        }
33835|  25.8k|        if (func_name == JS_ATOM_eval || func_name == JS_ATOM_arguments) {
33836|      0|            return js_parse_error(s, "invalid function name in strict code");
33837|      0|        }
33838|  51.8k|        for (idx = 0; idx < fd->arg_count; idx++) {
33839|  25.9k|            name = fd->args[idx].var_name;
33840|       |
33841|  25.9k|            if (name == JS_ATOM_eval || name == JS_ATOM_arguments) {
33842|      0|                return js_parse_error(s, "invalid argument name in strict code");
33843|      0|            }
33844|  25.9k|        }
33845|  25.8k|    }
33846|       |    /* check async_generator case */
33847|   133k|    if ((fd->js_mode & JS_MODE_STRICT)
33848|   133k|    ||  !fd->has_simple_parameter_list
33849|   133k|    ||  (fd->func_type == JS_PARSE_FUNC_METHOD && fd->func_kind == JS_FUNC_ASYNC)
33850|   133k|    ||  fd->func_type == JS_PARSE_FUNC_ARROW
33851|   133k|    ||  fd->func_type == JS_PARSE_FUNC_METHOD) {
33852|   267k|        for (idx = 0; idx < fd->arg_count; idx++) {
33853|   133k|            name = fd->args[idx].var_name;
33854|   133k|            if (name != JS_ATOM_NULL) {
33855|   134k|                for (i = 0; i < idx; i++) {
33856|    858|                    if (fd->args[i].var_name == name)
33857|      1|                        goto duplicate;
33858|    858|                }
33859|       |                /* Check if argument name duplicates a destructuring parameter */
33860|       |                /* XXX: should have a flag for such variables */
33861|   134k|                for (i = 0; i < fd->var_count; i++) {
33862|  1.49k|                    if (fd->vars[i].var_name == name &&
33863|  1.49k|                        fd->vars[i].scope_level == 0)
33864|      0|                        goto duplicate;
33865|  1.49k|                }
33866|   133k|            }
33867|   133k|        }
33868|   133k|    }
33869|   133k|    return 0;
33870|       |
33871|      1|duplicate:
33872|      1|    return js_parse_error(s, "duplicate argument names not allowed in this context");
33873|   133k|}
33874|       |
33875|       |/* create a function to initialize class fields */
33876|       |static JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s)
33877|      0|{
33878|      0|    JSFunctionDef *fd;
33879|       |
33880|      0|    fd = js_new_function_def(s->ctx, s->cur_func, FALSE, FALSE,
33881|      0|                             s->filename, s->buf_start,
33882|      0|                             &s->get_line_col_cache);
33883|      0|    if (!fd)
33884|      0|        return NULL;
33885|      0|    fd->func_name = JS_ATOM_NULL;
33886|      0|    fd->has_prototype = FALSE;
33887|      0|    fd->has_home_object = TRUE;
33888|       |
33889|      0|    fd->has_arguments_binding = FALSE;
33890|      0|    fd->has_this_binding = TRUE;
33891|      0|    fd->is_derived_class_constructor = FALSE;
33892|      0|    fd->new_target_allowed = TRUE;
33893|      0|    fd->super_call_allowed = FALSE;
33894|      0|    fd->super_allowed = fd->has_home_object;
33895|      0|    fd->arguments_allowed = FALSE;
33896|       |
33897|      0|    fd->func_kind = JS_FUNC_NORMAL;
33898|      0|    fd->func_type = JS_PARSE_FUNC_METHOD;
33899|      0|    return fd;
33900|      0|}
33901|       |
33902|       |/* func_name must be JS_ATOM_NULL for JS_PARSE_FUNC_STATEMENT and
33903|       |   JS_PARSE_FUNC_EXPR, JS_PARSE_FUNC_ARROW and JS_PARSE_FUNC_VAR */
33904|       |static __exception int js_parse_function_decl2(JSParseState *s,
33905|       |                                               JSParseFunctionEnum func_type,
33906|       |                                               JSFunctionKindEnum func_kind,
33907|       |                                               JSAtom func_name,
33908|       |                                               const uint8_t *ptr,
33909|       |                                               JSParseExportEnum export_flag,
33910|       |                                               JSFunctionDef **pfd)
33911|   136k|{
33912|   136k|    JSContext *ctx = s->ctx;
33913|   136k|    JSFunctionDef *fd = s->cur_func;
33914|   136k|    BOOL is_expr;
33915|   136k|    int func_idx, lexical_func_idx = -1;
33916|   136k|    BOOL has_opt_arg;
33917|   136k|    BOOL create_func_var = FALSE;
33918|       |
33919|   136k|    is_expr = (func_type != JS_PARSE_FUNC_STATEMENT &&
33920|   136k|               func_type != JS_PARSE_FUNC_VAR);
33921|       |
33922|   136k|    if (func_type == JS_PARSE_FUNC_STATEMENT ||
33923|   136k|        func_type == JS_PARSE_FUNC_VAR ||
33924|   136k|        func_type == JS_PARSE_FUNC_EXPR) {
33925|      0|        if (func_kind == JS_FUNC_NORMAL &&
33926|      0|            token_is_pseudo_keyword(s, JS_ATOM_async) &&
33927|      0|            peek_token(s, TRUE) != '\n') {
33928|      0|            if (next_token(s))
33929|      0|                return -1;
33930|      0|            func_kind = JS_FUNC_ASYNC;
33931|      0|        }
33932|      0|        if (next_token(s))
33933|      0|            return -1;
33934|      0|        if (s->token.val == '*') {
33935|      0|            if (next_token(s))
33936|      0|                return -1;
33937|      0|            func_kind |= JS_FUNC_GENERATOR;
33938|      0|        }
33939|       |
33940|      0|        if (s->token.val == TOK_IDENT) {
33941|      0|            if (s->token.u.ident.is_reserved ||
33942|      0|                (s->token.u.ident.atom == JS_ATOM_yield &&
33943|      0|                 func_type == JS_PARSE_FUNC_EXPR &&
33944|      0|                 (func_kind & JS_FUNC_GENERATOR)) ||
33945|      0|                (s->token.u.ident.atom == JS_ATOM_await &&
33946|      0|                 ((func_type == JS_PARSE_FUNC_EXPR &&
33947|      0|                   (func_kind & JS_FUNC_ASYNC)) ||
33948|      0|                  func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT))) {
33949|      0|                return js_parse_error_reserved_identifier(s);
33950|      0|            }
33951|      0|        }
33952|      0|        if (s->token.val == TOK_IDENT ||
33953|      0|            (((s->token.val == TOK_YIELD && !(fd->js_mode & JS_MODE_STRICT)) ||
33954|      0|             (s->token.val == TOK_AWAIT && !s->is_module)) &&
33955|      0|             func_type == JS_PARSE_FUNC_EXPR)) {
33956|      0|            func_name = JS_DupAtom(ctx, s->token.u.ident.atom);
33957|      0|            if (next_token(s)) {
33958|      0|                JS_FreeAtom(ctx, func_name);
33959|      0|                return -1;
33960|      0|            }
33961|      0|        } else {
33962|      0|            if (func_type != JS_PARSE_FUNC_EXPR &&
33963|      0|                export_flag != JS_PARSE_EXPORT_DEFAULT) {
33964|      0|                return js_parse_error(s, "function name expected");
33965|      0|            }
33966|      0|        }
33967|   136k|    } else if (func_type != JS_PARSE_FUNC_ARROW) {
33968|  3.98k|        func_name = JS_DupAtom(ctx, func_name);
33969|  3.98k|    }
33970|       |
33971|   136k|    if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_MODULE &&
33972|   136k|        (func_type == JS_PARSE_FUNC_STATEMENT || func_type == JS_PARSE_FUNC_VAR)) {
33973|      0|        JSGlobalVar *hf;
33974|      0|        hf = find_global_var(fd, func_name);
33975|       |        /* XXX: should check scope chain */
33976|      0|        if (hf && hf->scope_level == fd->scope_level) {
33977|      0|            js_parse_error(s, "invalid redefinition of global identifier in module code");
33978|      0|            JS_FreeAtom(ctx, func_name);
33979|      0|            return -1;
33980|      0|        }
33981|      0|    }
33982|       |
33983|   136k|    if (func_type == JS_PARSE_FUNC_VAR) {
33984|      0|        if (!(fd->js_mode & JS_MODE_STRICT)
33985|      0|        && func_kind == JS_FUNC_NORMAL
33986|      0|        &&  find_lexical_decl(ctx, fd, func_name, fd->scope_first, FALSE) < 0
33987|      0|        &&  !((func_idx = find_var(ctx, fd, func_name)) >= 0 && (func_idx & ARGUMENT_VAR_OFFSET))
33988|      0|        &&  !(func_name == JS_ATOM_arguments && fd->has_arguments_binding)) {
33989|      0|            create_func_var = TRUE;
33990|      0|        }
33991|       |        /* Create the lexical name here so that the function closure
33992|       |           contains it */
33993|      0|        if (fd->is_eval &&
33994|      0|            (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||
33995|      0|             fd->eval_type == JS_EVAL_TYPE_MODULE) &&
33996|      0|            fd->scope_level == fd->body_scope) {
33997|       |            /* avoid creating a lexical variable in the global
33998|       |               scope. XXX: check annex B */
33999|      0|            JSGlobalVar *hf;
34000|      0|            hf = find_global_var(fd, func_name);
34001|       |            /* XXX: should check scope chain */
34002|      0|            if (hf && hf->scope_level == fd->scope_level) {
34003|      0|                js_parse_error(s, "invalid redefinition of global identifier");
34004|      0|                JS_FreeAtom(ctx, func_name);
34005|      0|                return -1;
34006|      0|            }
34007|      0|        } else {
34008|       |            /* Always create a lexical name, fail if at the same scope as
34009|       |               existing name */
34010|       |            /* Lexical variable will be initialized upon entering scope */
34011|      0|            lexical_func_idx = define_var(s, fd, func_name,
34012|      0|                                          func_kind != JS_FUNC_NORMAL ?
34013|      0|                                          JS_VAR_DEF_NEW_FUNCTION_DECL :
34014|      0|                                          JS_VAR_DEF_FUNCTION_DECL);
34015|      0|            if (lexical_func_idx < 0) {
34016|      0|                JS_FreeAtom(ctx, func_name);
34017|      0|                return -1;
34018|      0|            }
34019|      0|        }
34020|      0|    }
34021|       |
34022|   136k|    fd = js_new_function_def(ctx, fd, FALSE, is_expr,
34023|   136k|                             s->filename, ptr,
34024|   136k|                             &s->get_line_col_cache);
34025|   136k|    if (!fd) {
34026|      0|        JS_FreeAtom(ctx, func_name);
34027|      0|        return -1;
34028|      0|    }
34029|   136k|    if (pfd)
34030|      0|        *pfd = fd;
34031|   136k|    s->cur_func = fd;
34032|   136k|    fd->func_name = func_name;
34033|       |    /* XXX: test !fd->is_generator is always false */
34034|   136k|    fd->has_prototype = (func_type == JS_PARSE_FUNC_STATEMENT ||
34035|   136k|                         func_type == JS_PARSE_FUNC_VAR ||
34036|   136k|                         func_type == JS_PARSE_FUNC_EXPR) &&
34037|   136k|                        func_kind == JS_FUNC_NORMAL;
34038|   136k|    fd->has_home_object = (func_type == JS_PARSE_FUNC_METHOD ||
34039|   136k|                           func_type == JS_PARSE_FUNC_GETTER ||
34040|   136k|                           func_type == JS_PARSE_FUNC_SETTER ||
34041|   136k|                           func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
34042|   136k|                           func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
34043|   136k|    fd->has_arguments_binding = (func_type != JS_PARSE_FUNC_ARROW &&
34044|   136k|                                 func_type != JS_PARSE_FUNC_CLASS_STATIC_INIT);
34045|   136k|    fd->has_this_binding = fd->has_arguments_binding;
34046|   136k|    fd->is_derived_class_constructor = (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
34047|   136k|    if (func_type == JS_PARSE_FUNC_ARROW) {
34048|   132k|        fd->new_target_allowed = fd->parent->new_target_allowed;
34049|   132k|        fd->super_call_allowed = fd->parent->super_call_allowed;
34050|   132k|        fd->super_allowed = fd->parent->super_allowed;
34051|   132k|        fd->arguments_allowed = fd->parent->arguments_allowed;
34052|   132k|    } else if (func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT) {
34053|      0|        fd->new_target_allowed = TRUE; // although new.target === undefined
34054|      0|        fd->super_call_allowed = FALSE;
34055|      0|        fd->super_allowed = TRUE;
34056|      0|        fd->arguments_allowed = FALSE;
34057|  3.98k|    } else {
34058|  3.98k|        fd->new_target_allowed = TRUE;
34059|  3.98k|        fd->super_call_allowed = fd->is_derived_class_constructor;
34060|  3.98k|        fd->super_allowed = fd->has_home_object;
34061|  3.98k|        fd->arguments_allowed = TRUE;
34062|  3.98k|    }
34063|       |
34064|       |    /* fd->in_function_body == FALSE prevents yield/await during the parsing
34065|       |       of the arguments in generator/async functions. They are parsed as
34066|       |       regular identifiers for other function kinds. */
34067|   136k|    fd->func_kind = func_kind;
34068|   136k|    fd->func_type = func_type;
34069|       |
34070|   136k|    if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
34071|   136k|        func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {
34072|       |        /* error if not invoked as a constructor */
34073|      0|        emit_op(s, OP_check_ctor);
34074|      0|    }
34075|       |
34076|   136k|    if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
34077|      0|        emit_class_field_init(s);
34078|      0|    }
34079|       |
34080|       |    /* parse arguments */
34081|   136k|    fd->has_simple_parameter_list = TRUE;
34082|   136k|    fd->has_parameter_expressions = FALSE;
34083|   136k|    has_opt_arg = FALSE;
34084|   136k|    if (func_type == JS_PARSE_FUNC_ARROW && s->token.val == TOK_IDENT) {
34085|   132k|        JSAtom name;
34086|   132k|        if (s->token.u.ident.is_reserved) {
34087|      0|            js_parse_error_reserved_identifier(s);
34088|      0|            goto fail;
34089|      0|        }
34090|   132k|        name = s->token.u.ident.atom;
34091|   132k|        if (add_arg(ctx, fd, name) < 0)
34092|      0|            goto fail;
34093|   132k|        fd->defined_arg_count = 1;
34094|   132k|    } else if (func_type != JS_PARSE_FUNC_CLASS_STATIC_INIT) {
34095|  3.99k|        if (s->token.val == '(') {
34096|  3.99k|            int skip_bits;
34097|       |            /* if there is an '=' inside the parameter list, we
34098|       |               consider there is a parameter expression inside */
34099|  3.99k|            js_parse_skip_parens_token(s, &skip_bits, FALSE);
34100|  3.99k|            if (skip_bits & SKIP_HAS_ASSIGNMENT)
34101|  2.32k|                fd->has_parameter_expressions = TRUE;
34102|  3.99k|            if (next_token(s))
34103|      6|                goto fail;
34104|  3.99k|        } else {
34105|      0|            if (js_parse_expect(s, '('))
34106|      0|                goto fail;
34107|      0|        }
34108|       |
34109|  3.99k|        if (fd->has_parameter_expressions) {
34110|  2.32k|            fd->scope_level = -1; /* force no parent scope */
34111|  2.32k|            if (push_scope(s) < 0)
34112|      0|                return -1;
34113|  2.32k|        }
34114|       |
34115|  7.22k|        while (s->token.val != ')') {
34116|  6.83k|            JSAtom name;
34117|  6.83k|            BOOL rest = FALSE;
34118|  6.83k|            int idx, has_initializer;
34119|       |
34120|  6.83k|            if (s->token.val == TOK_ELLIPSIS) {
34121|  1.72k|                fd->has_simple_parameter_list = FALSE;
34122|  1.72k|                rest = TRUE;
34123|  1.72k|                if (next_token(s))
34124|      1|                    goto fail;
34125|  1.72k|            }
34126|  6.83k|            if (s->token.val == '[' || s->token.val == '{') {
34127|  2.86k|                fd->has_simple_parameter_list = FALSE;
34128|  2.86k|                if (rest) {
34129|  1.71k|                    emit_op(s, OP_rest);
34130|  1.71k|                    emit_u16(s, fd->arg_count);
34131|  1.71k|                } else {
34132|       |                    /* unnamed arg for destructuring */
34133|  1.14k|                    idx = add_arg(ctx, fd, JS_ATOM_NULL);
34134|  1.14k|                    emit_op(s, OP_get_arg);
34135|  1.14k|                    emit_u16(s, idx);
34136|  1.14k|                }
34137|  2.86k|                has_initializer = js_parse_destructuring_element(s, fd->has_parameter_expressions ? TOK_LET : TOK_VAR, 1, TRUE, -1, TRUE, FALSE);
34138|  2.86k|                if (has_initializer < 0)
34139|  2.32k|                    goto fail;
34140|    538|                if (has_initializer)
34141|    521|                    has_opt_arg = TRUE;
34142|    538|                if (!has_opt_arg)
34143|      9|                    fd->defined_arg_count++;
34144|  3.97k|            } else if (s->token.val == TOK_IDENT) {
34145|  3.94k|                if (s->token.u.ident.is_reserved) {
34146|      1|                    js_parse_error_reserved_identifier(s);
34147|      1|                    goto fail;
34148|      1|                }
34149|  3.94k|                name = s->token.u.ident.atom;
34150|  3.94k|                if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {
34151|      0|                    js_parse_error_reserved_identifier(s);
34152|      0|                    goto fail;
34153|      0|                }
34154|  3.94k|                if (fd->has_parameter_expressions) {
34155|  3.52k|                    if (js_parse_check_duplicate_parameter(s, name))
34156|     12|                        goto fail;
34157|  3.51k|                    if (define_var(s, fd, name, JS_VAR_DEF_LET) < 0)
34158|      0|                        goto fail;
34159|  3.51k|                }
34160|       |                /* XXX: could avoid allocating an argument if rest is true */
34161|  3.92k|                idx = add_arg(ctx, fd, name);
34162|  3.92k|                if (idx < 0)
34163|      0|                    goto fail;
34164|  3.92k|                if (next_token(s))
34165|      7|                    goto fail;
34166|  3.92k|                if (rest) {
34167|      4|                    emit_op(s, OP_rest);
34168|      4|                    emit_u16(s, idx);
34169|      4|                    if (fd->has_parameter_expressions) {
34170|      2|                        emit_op(s, OP_dup);
34171|      2|                        emit_op(s, OP_scope_put_var_init);
34172|      2|                        emit_atom(s, name);
34173|      2|                        emit_u16(s, fd->scope_level);
34174|      2|                    }
34175|      4|                    emit_op(s, OP_put_arg);
34176|      4|                    emit_u16(s, idx);
34177|      4|                    fd->has_simple_parameter_list = FALSE;
34178|      4|                    has_opt_arg = TRUE;
34179|  3.91k|                } else if (s->token.val == '=') {
34180|  2.03k|                    int label;
34181|       |
34182|  2.03k|                    fd->has_simple_parameter_list = FALSE;
34183|  2.03k|                    has_opt_arg = TRUE;
34184|       |
34185|  2.03k|                    if (next_token(s))
34186|      1|                        goto fail;
34187|       |
34188|  2.02k|                    label = new_label(s);
34189|  2.02k|                    emit_op(s, OP_get_arg);
34190|  2.02k|                    emit_u16(s, idx);
34191|  2.02k|                    emit_op(s, OP_dup);
34192|  2.02k|                    emit_op(s, OP_undefined);
34193|  2.02k|                    emit_op(s, OP_strict_eq);
34194|  2.02k|                    emit_goto(s, OP_if_false, label);
34195|  2.02k|                    emit_op(s, OP_drop);
34196|  2.02k|                    if (js_parse_assign_expr(s))
34197|    428|                        goto fail;
34198|  1.60k|                    set_object_name(s, name);
34199|  1.60k|                    emit_op(s, OP_dup);
34200|  1.60k|                    emit_op(s, OP_put_arg);
34201|  1.60k|                    emit_u16(s, idx);
34202|  1.60k|                    emit_label(s, label);
34203|  1.60k|                    emit_op(s, OP_scope_put_var_init);
34204|  1.60k|                    emit_atom(s, name);
34205|  1.60k|                    emit_u16(s, fd->scope_level);
34206|  1.88k|                } else {
34207|  1.88k|                    if (!has_opt_arg) {
34208|    486|                        fd->defined_arg_count++;
34209|    486|                    }
34210|  1.88k|                    if (fd->has_parameter_expressions) {
34211|       |                        /* copy the argument to the argument scope */
34212|  1.47k|                        emit_op(s, OP_get_arg);
34213|  1.47k|                        emit_u16(s, idx);
34214|  1.47k|                        emit_op(s, OP_scope_put_var_init);
34215|  1.47k|                        emit_atom(s, name);
34216|  1.47k|                        emit_u16(s, fd->scope_level);
34217|  1.47k|                    }
34218|  1.88k|                }
34219|  3.92k|            } else {
34220|     34|                js_parse_error(s, "missing formal parameter");
34221|     34|                goto fail;
34222|     34|            }
34223|  4.03k|            if (rest && s->token.val != ')') {
34224|      6|                js_parse_expect(s, ')');
34225|      6|                goto fail;
34226|      6|            }
34227|  4.02k|            if (s->token.val == ')')
34228|    729|                break;
34229|  3.29k|            if (js_parse_expect(s, ','))
34230|     59|                goto fail;
34231|  3.29k|        }
34232|  1.11k|        if ((func_type == JS_PARSE_FUNC_GETTER && fd->arg_count != 0) ||
34233|  1.11k|            (func_type == JS_PARSE_FUNC_SETTER && fd->arg_count != 1)) {
34234|      2|            js_parse_error(s, "invalid number of arguments for getter or setter");
34235|      2|            goto fail;
34236|      2|        }
34237|  1.11k|    }
34238|       |
34239|   133k|    if (fd->has_parameter_expressions) {
34240|    620|        int idx;
34241|       |
34242|       |        /* Copy the variables in the argument scope to the variable
34243|       |           scope (see FunctionDeclarationInstantiation() in spec). The
34244|       |           normal arguments are already present, so no need to copy
34245|       |           them. */
34246|    620|        idx = fd->scopes[fd->scope_level].first;
34247|  1.57k|        while (idx >= 0) {
34248|    950|            JSVarDef *vd = &fd->vars[idx];
34249|    950|            if (vd->scope_level != fd->scope_level)
34250|      0|                break;
34251|    950|            if (find_var(ctx, fd, vd->var_name) < 0) {
34252|    486|                if (add_var(ctx, fd, vd->var_name) < 0)
34253|      0|                    goto fail;
34254|    486|                vd = &fd->vars[idx]; /* fd->vars may have been reallocated */
34255|    486|                emit_op(s, OP_scope_get_var);
34256|    486|                emit_atom(s, vd->var_name);
34257|    486|                emit_u16(s, fd->scope_level);
34258|    486|                emit_op(s, OP_scope_put_var);
34259|    486|                emit_atom(s, vd->var_name);
34260|    486|                emit_u16(s, 0);
34261|    486|            }
34262|    950|            idx = vd->scope_next;
34263|    950|        }
34264|       |
34265|       |        /* the argument scope has no parent, hence we don't use pop_scope(s) */
34266|    620|        emit_op(s, OP_leave_scope);
34267|    620|        emit_u16(s, fd->scope_level);
34268|       |
34269|       |        /* set the variable scope as the current scope */
34270|    620|        fd->scope_level = 0;
34271|    620|        fd->scope_first = fd->scopes[fd->scope_level].first;
34272|    620|    }
34273|       |
34274|   133k|    if (next_token(s))
34275|      1|        goto fail;
34276|       |
34277|       |    /* generator function: yield after the parameters are evaluated */
34278|   133k|    if (func_kind == JS_FUNC_GENERATOR ||
34279|   133k|        func_kind == JS_FUNC_ASYNC_GENERATOR)
34280|      1|        emit_op(s, OP_initial_yield);
34281|       |
34282|       |    /* in generators, yield expression is forbidden during the parsing
34283|       |       of the arguments */
34284|   133k|    fd->in_function_body = TRUE;
34285|   133k|    push_scope(s);  /* enter body scope */
34286|   133k|    fd->body_scope = fd->scope_level;
34287|       |
34288|   133k|    if (s->token.val == TOK_ARROW) {
34289|   132k|        if (next_token(s))
34290|      6|            goto fail;
34291|       |
34292|   132k|        if (s->token.val != '{') {
34293|   130k|            if (js_parse_function_check_names(s, fd, func_name))
34294|      0|                goto fail;
34295|       |
34296|   130k|            if (js_parse_assign_expr(s))
34297|  4.41k|                goto fail;
34298|       |
34299|   126k|            if (func_kind != JS_FUNC_NORMAL)
34300|      0|                emit_op(s, OP_return_async);
34301|   126k|            else
34302|   126k|                emit_op(s, OP_return);
34303|       |
34304|   126k|            if (!fd->strip_source) {
34305|       |                /* save the function source code */
34306|       |                /* the end of the function source code is after the last
34307|       |                   token of the function source stored into s->last_ptr */
34308|   126k|                fd->source_len = s->last_ptr - ptr;
34309|   126k|                fd->source = js_strndup(ctx, (const char *)ptr, fd->source_len);
34310|   126k|                if (!fd->source)
34311|      0|                    goto fail;
34312|   126k|            }
34313|   126k|            goto done;
34314|   126k|        }
34315|   132k|    }
34316|       |
34317|  2.75k|    if (func_type != JS_PARSE_FUNC_CLASS_STATIC_INIT) {
34318|  2.75k|        if (js_parse_expect(s, '{'))
34319|     34|            goto fail;
34320|  2.75k|    }
34321|       |
34322|  2.71k|    if (js_parse_directives(s))
34323|      1|        goto fail;
34324|       |
34325|       |    /* in strict_mode, check function and argument names */
34326|  2.71k|    if (js_parse_function_check_names(s, fd, func_name))
34327|      1|        goto fail;
34328|       |
34329|  14.5k|    while (s->token.val != '}') {
34330|  13.9k|        if (js_parse_source_element(s))
34331|  2.08k|            goto fail;
34332|  13.9k|    }
34333|    627|    if (!fd->strip_source) {
34334|       |        /* save the function source code */
34335|    627|        fd->source_len = s->buf_ptr - ptr;
34336|    627|        fd->source = js_strndup(ctx, (const char *)ptr, fd->source_len);
34337|    627|        if (!fd->source)
34338|      0|            goto fail;
34339|    627|    }
34340|       |
34341|    627|    if (next_token(s)) {
34342|       |        /* consume the '}' */
34343|      1|        goto fail;
34344|      1|    }
34345|       |
34346|       |    /* in case there is no return, add one */
34347|    626|    if (js_is_live_code(s)) {
34348|    625|        emit_return(s, FALSE);
34349|    625|    }
34350|   127k| done:
34351|   127k|    s->cur_func = fd->parent;
34352|       |
34353|       |    /* Reparse identifiers after the function is terminated so that
34354|       |       the token is parsed in the englobing function. It could be done
34355|       |       by just using next_token() here for normal functions, but it is
34356|       |       necessary for arrow functions with an expression body. */
34357|   127k|    reparse_ident_token(s);
34358|       |
34359|       |    /* create the function object */
34360|   127k|    {
34361|   127k|        int idx;
34362|   127k|        JSAtom func_name = fd->func_name;
34363|       |
34364|       |        /* the real object will be set at the end of the compilation */
34365|   127k|        idx = cpool_add(s, JS_NULL);
34366|   127k|        fd->parent_cpool_idx = idx;
34367|       |
34368|   127k|        if (is_expr) {
34369|       |            /* for constructors, no code needs to be generated here */
34370|   127k|            if (func_type != JS_PARSE_FUNC_CLASS_CONSTRUCTOR &&
34371|   127k|                func_type != JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {
34372|       |                /* OP_fclosure creates the function object from the bytecode
34373|       |                   and adds the scope information */
34374|   127k|                emit_op(s, OP_fclosure);
34375|   127k|                emit_u32(s, idx);
34376|   127k|                if (func_name == JS_ATOM_NULL) {
34377|   127k|                    emit_op(s, OP_set_name);
34378|   127k|                    emit_u32(s, JS_ATOM_NULL);
34379|   127k|                }
34380|   127k|            }
34381|   127k|        } else if (func_type == JS_PARSE_FUNC_VAR) {
34382|      0|            emit_op(s, OP_fclosure);
34383|      0|            emit_u32(s, idx);
34384|      0|            if (create_func_var) {
34385|      0|                if (s->cur_func->is_global_var) {
34386|      0|                    JSGlobalVar *hf;
34387|       |                    /* the global variable must be defined at the start of the
34388|       |                       function */
34389|      0|                    hf = add_global_var(ctx, s->cur_func, func_name);
34390|      0|                    if (!hf)
34391|      0|                        goto fail;
34392|       |                    /* it is considered as defined at the top level
34393|       |                       (needed for annex B.3.3.4 and B.3.3.5
34394|       |                       checks) */
34395|      0|                    hf->scope_level = 0;
34396|      0|                    hf->force_init = ((s->cur_func->js_mode & JS_MODE_STRICT) != 0);
34397|       |                    /* store directly into global var, bypass lexical scope */
34398|      0|                    emit_op(s, OP_dup);
34399|      0|                    emit_op(s, OP_scope_put_var);
34400|      0|                    emit_atom(s, func_name);
34401|      0|                    emit_u16(s, 0);
34402|      0|                } else {
34403|       |                    /* do not call define_var to bypass lexical scope check */
34404|      0|                    func_idx = find_var(ctx, s->cur_func, func_name);
34405|      0|                    if (func_idx < 0) {
34406|      0|                        func_idx = add_var(ctx, s->cur_func, func_name);
34407|      0|                        if (func_idx < 0)
34408|      0|                            goto fail;
34409|      0|                    }
34410|       |                    /* store directly into local var, bypass lexical catch scope */
34411|      0|                    emit_op(s, OP_dup);
34412|      0|                    emit_op(s, OP_scope_put_var);
34413|      0|                    emit_atom(s, func_name);
34414|      0|                    emit_u16(s, 0);
34415|      0|                }
34416|      0|            }
34417|      0|            if (lexical_func_idx >= 0) {
34418|       |                /* lexical variable will be initialized upon entering scope */
34419|      0|                s->cur_func->vars[lexical_func_idx].func_pool_idx = idx;
34420|      0|                emit_op(s, OP_drop);
34421|      0|            } else {
34422|       |                /* store function object into its lexical name */
34423|       |                /* XXX: could use OP_put_loc directly */
34424|      0|                emit_op(s, OP_scope_put_var_init);
34425|      0|                emit_atom(s, func_name);
34426|      0|                emit_u16(s, s->cur_func->scope_level);
34427|      0|            }
34428|      0|        } else {
34429|      0|            if (!s->cur_func->is_global_var) {
34430|      0|                int var_idx = define_var(s, s->cur_func, func_name, JS_VAR_DEF_VAR);
34431|       |
34432|      0|                if (var_idx < 0)
34433|      0|                    goto fail;
34434|       |                /* the variable will be assigned at the top of the function */
34435|      0|                if (var_idx & ARGUMENT_VAR_OFFSET) {
34436|      0|                    s->cur_func->args[var_idx - ARGUMENT_VAR_OFFSET].func_pool_idx = idx;
34437|      0|                } else {
34438|      0|                    s->cur_func->vars[var_idx].func_pool_idx = idx;
34439|      0|                }
34440|      0|            } else {
34441|      0|                JSAtom func_var_name;
34442|      0|                JSGlobalVar *hf;
34443|      0|                if (func_name == JS_ATOM_NULL)
34444|      0|                    func_var_name = JS_ATOM__default_; /* export default */
34445|      0|                else
34446|      0|                    func_var_name = func_name;
34447|       |                /* the variable will be assigned at the top of the function */
34448|      0|                hf = add_global_var(ctx, s->cur_func, func_var_name);
34449|      0|                if (!hf)
34450|      0|                    goto fail;
34451|      0|                hf->cpool_idx = idx;
34452|      0|                if (export_flag != JS_PARSE_EXPORT_NONE) {
34453|      0|                    if (!add_export_entry(s, s->cur_func->module, func_var_name,
34454|      0|                                          export_flag == JS_PARSE_EXPORT_NAMED ? func_var_name : JS_ATOM_default, JS_EXPORT_TYPE_LOCAL))
34455|      0|                        goto fail;
34456|      0|                }
34457|      0|            }
34458|      0|        }
34459|   127k|    }
34460|   127k|    return 0;
34461|  9.42k| fail:
34462|  9.42k|    s->cur_func = fd->parent;
34463|  9.42k|    js_free_function_def(ctx, fd);
34464|  9.42k|    if (pfd)
34465|      0|        *pfd = NULL;
34466|  9.42k|    return -1;
34467|   127k|}
34468|       |
34469|       |static __exception int js_parse_function_decl(JSParseState *s,
34470|       |                                              JSParseFunctionEnum func_type,
34471|       |                                              JSFunctionKindEnum func_kind,
34472|       |                                              JSAtom func_name,
34473|       |                                              const uint8_t *ptr)
34474|   136k|{
34475|   136k|    return js_parse_function_decl2(s, func_type, func_kind, func_name, ptr,
34476|   136k|                                   JS_PARSE_EXPORT_NONE, NULL);
34477|   136k|}
34478|       |
34479|       |static __exception int js_parse_program(JSParseState *s)
34480|  17.7k|{
34481|  17.7k|    JSFunctionDef *fd = s->cur_func;
34482|  17.7k|    int idx;
34483|       |
34484|  17.7k|    if (next_token(s))
34485|     57|        return -1;
34486|       |
34487|  17.7k|    if (js_parse_directives(s))
34488|      4|        return -1;
34489|       |
34490|  17.7k|    fd->is_global_var = (fd->eval_type == JS_EVAL_TYPE_GLOBAL) ||
34491|  17.7k|        (fd->eval_type == JS_EVAL_TYPE_MODULE) ||
34492|  17.7k|        !(fd->js_mode & JS_MODE_STRICT);
34493|       |
34494|  17.7k|    if (!s->is_module) {
34495|       |        /* hidden variable for the return value */
34496|  16.8k|        fd->eval_ret_idx = idx = add_var(s->ctx, fd, JS_ATOM__ret_);
34497|  16.8k|        if (idx < 0)
34498|      0|            return -1;
34499|  16.8k|    }
34500|       |
34501|   110k|    while (s->token.val != TOK_EOF) {
34502|   101k|        if (js_parse_source_element(s))
34503|  8.21k|            return -1;
34504|   101k|    }
34505|       |
34506|  9.49k|    if (!s->is_module) {
34507|       |        /* return the value of the hidden variable eval_ret_idx  */
34508|  8.98k|        if (fd->func_kind == JS_FUNC_ASYNC) {
34509|       |            /* wrap the return value in an object so that promises can
34510|       |               be safely returned */
34511|      0|            emit_op(s, OP_object);
34512|      0|            emit_op(s, OP_dup);
34513|       |
34514|      0|            emit_op(s, OP_get_loc);
34515|      0|            emit_u16(s, fd->eval_ret_idx);
34516|       |
34517|      0|            emit_op(s, OP_put_field);
34518|      0|            emit_atom(s, JS_ATOM_value);
34519|  8.98k|        } else {
34520|  8.98k|            emit_op(s, OP_get_loc);
34521|  8.98k|            emit_u16(s, fd->eval_ret_idx);
34522|  8.98k|        }
34523|  8.98k|        emit_return(s, TRUE);
34524|  8.98k|    } else {
34525|    505|        emit_return(s, FALSE);
34526|    505|    }
34527|       |
34528|  9.49k|    return 0;
34529|  17.7k|}
34530|       |
34531|       |static void js_parse_init(JSContext *ctx, JSParseState *s,
34532|       |                          const char *input, size_t input_len,
34533|       |                          const char *filename)
34534|  17.7k|{
34535|  17.7k|    memset(s, 0, sizeof(*s));
34536|  17.7k|    s->ctx = ctx;
34537|  17.7k|    s->filename = filename;
34538|  17.7k|    s->buf_start = s->buf_ptr = (const uint8_t *)input;
34539|  17.7k|    s->buf_end = s->buf_ptr + input_len;
34540|  17.7k|    s->token.val = ' ';
34541|  17.7k|    s->token.ptr = s->buf_ptr;
34542|       |
34543|  17.7k|    s->get_line_col_cache.ptr = s->buf_start;
34544|  17.7k|    s->get_line_col_cache.buf_start = s->buf_start;
34545|  17.7k|    s->get_line_col_cache.line_num = 0;
34546|  17.7k|    s->get_line_col_cache.col_num = 0;
34547|  17.7k|}
34548|       |
34549|       |static JSValue JS_EvalFunctionInternal(JSContext *ctx, JSValue fun_obj,
34550|       |                                       JSValueConst this_obj,
34551|       |                                       JSVarRef **var_refs, JSStackFrame *sf)
34552|  9.30k|{
34553|  9.30k|    JSValue ret_val;
34554|  9.30k|    uint32_t tag;
34555|       |
34556|  9.30k|    tag = JS_VALUE_GET_TAG(fun_obj);
34557|  9.30k|    if (tag == JS_TAG_FUNCTION_BYTECODE) {
34558|  8.93k|        fun_obj = js_closure(ctx, fun_obj, var_refs, sf);
34559|  8.93k|        ret_val = JS_CallFree(ctx, fun_obj, this_obj, 0, NULL);
34560|  8.93k|    } else if (tag == JS_TAG_MODULE) {
34561|    367|        JSModuleDef *m;
34562|    367|        m = JS_VALUE_GET_PTR(fun_obj);
34563|       |        /* the module refcount should be >= 2 */
34564|    367|        JS_FreeValue(ctx, fun_obj);
34565|    367|        if (js_create_module_function(ctx, m) < 0)
34566|      0|            goto fail;
34567|    367|        if (js_link_module(ctx, m) < 0)
34568|      0|            goto fail;
34569|    367|        ret_val = js_evaluate_module(ctx, m);
34570|    367|        if (JS_IsException(ret_val)) {
34571|      0|        fail:
34572|      0|            return JS_EXCEPTION;
34573|      0|        }
34574|    367|    } else {
34575|      0|        JS_FreeValue(ctx, fun_obj);
34576|      0|        ret_val = JS_ThrowTypeError(ctx, "bytecode function expected");
34577|      0|    }
34578|  9.30k|    return ret_val;
34579|  9.30k|}
34580|       |
34581|       |JSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj)
34582|    367|{
34583|    367|    return JS_EvalFunctionInternal(ctx, fun_obj, ctx->global_obj, NULL, NULL);
34584|    367|}
34585|       |
34586|       |/* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
34587|       |static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
34588|       |                                 const char *input, size_t input_len,
34589|       |                                 const char *filename, int flags, int scope_idx)
34590|  17.7k|{
34591|  17.7k|    JSParseState s1, *s = &s1;
34592|  17.7k|    int err, js_mode, eval_type;
34593|  17.7k|    JSValue fun_obj, ret_val;
34594|  17.7k|    JSStackFrame *sf;
34595|  17.7k|    JSVarRef **var_refs;
34596|  17.7k|    JSFunctionBytecode *b;
34597|  17.7k|    JSFunctionDef *fd;
34598|  17.7k|    JSModuleDef *m;
34599|       |
34600|  17.7k|    js_parse_init(ctx, s, input, input_len, filename);
34601|  17.7k|    skip_shebang(&s->buf_ptr, s->buf_end);
34602|       |
34603|  17.7k|    eval_type = flags & JS_EVAL_TYPE_MASK;
34604|  17.7k|    m = NULL;
34605|  17.7k|    if (eval_type == JS_EVAL_TYPE_DIRECT) {
34606|      0|        JSObject *p;
34607|      0|        sf = ctx->rt->current_stack_frame;
34608|      0|        assert(sf != NULL);
34609|      0|        assert(JS_VALUE_GET_TAG(sf->cur_func) == JS_TAG_OBJECT);
34610|      0|        p = JS_VALUE_GET_OBJ(sf->cur_func);
34611|      0|        assert(js_class_has_bytecode(p->class_id));
34612|      0|        b = p->u.func.function_bytecode;
34613|      0|        var_refs = p->u.func.var_refs;
34614|      0|        js_mode = b->js_mode;
34615|  17.7k|    } else {
34616|  17.7k|        sf = NULL;
34617|  17.7k|        b = NULL;
34618|  17.7k|        var_refs = NULL;
34619|  17.7k|        js_mode = 0;
34620|  17.7k|        if (flags & JS_EVAL_FLAG_STRICT)
34621|      0|            js_mode |= JS_MODE_STRICT;
34622|  17.7k|        if (eval_type == JS_EVAL_TYPE_MODULE) {
34623|    885|            JSAtom module_name = JS_NewAtom(ctx, filename);
34624|    885|            if (module_name == JS_ATOM_NULL)
34625|      0|                return JS_EXCEPTION;
34626|    885|            m = js_new_module_def(ctx, module_name);
34627|    885|            if (!m)
34628|      0|                return JS_EXCEPTION;
34629|    885|            js_mode |= JS_MODE_STRICT;
34630|    885|        }
34631|  17.7k|    }
34632|  17.7k|    fd = js_new_function_def(ctx, NULL, TRUE, FALSE, filename,
34633|  17.7k|                             s->buf_start, &s->get_line_col_cache);
34634|  17.7k|    if (!fd)
34635|      0|        goto fail1;
34636|  17.7k|    s->cur_func = fd;
34637|  17.7k|    fd->eval_type = eval_type;
34638|  17.7k|    fd->has_this_binding = (eval_type != JS_EVAL_TYPE_DIRECT);
34639|  17.7k|    if (eval_type == JS_EVAL_TYPE_DIRECT) {
34640|      0|        fd->new_target_allowed = b->new_target_allowed;
34641|      0|        fd->super_call_allowed = b->super_call_allowed;
34642|      0|        fd->super_allowed = b->super_allowed;
34643|      0|        fd->arguments_allowed = b->arguments_allowed;
34644|  17.7k|    } else {
34645|  17.7k|        fd->new_target_allowed = FALSE;
34646|  17.7k|        fd->super_call_allowed = FALSE;
34647|  17.7k|        fd->super_allowed = FALSE;
34648|  17.7k|        fd->arguments_allowed = TRUE;
34649|  17.7k|    }
34650|  17.7k|    fd->js_mode = js_mode;
34651|  17.7k|    fd->func_name = JS_DupAtom(ctx, JS_ATOM__eval_);
34652|  17.7k|    if (b) {
34653|      0|        if (add_closure_variables(ctx, fd, b, scope_idx))
34654|      0|            goto fail;
34655|      0|    }
34656|  17.7k|    fd->module = m;
34657|  17.7k|    if (m != NULL || (flags & JS_EVAL_FLAG_ASYNC)) {
34658|    885|        fd->in_function_body = TRUE;
34659|    885|        fd->func_kind = JS_FUNC_ASYNC;
34660|    885|    }
34661|  17.7k|    s->is_module = (m != NULL);
34662|  17.7k|    s->allow_html_comments = !s->is_module;
34663|       |
34664|  17.7k|    push_scope(s); /* body scope */
34665|  17.7k|    fd->body_scope = fd->scope_level;
34666|       |
34667|  17.7k|    err = js_parse_program(s);
34668|  17.7k|    if (err) {
34669|  8.27k|    fail:
34670|  8.27k|        free_token(s, &s->token);
34671|  8.27k|        js_free_function_def(ctx, fd);
34672|  8.27k|        goto fail1;
34673|  8.27k|    }
34674|       |
34675|  9.49k|    if (m != NULL)
34676|    505|        m->has_tla = fd->has_await;
34677|       |
34678|       |    /* create the function object and all the enclosed functions */
34679|  9.49k|    fun_obj = js_create_function(ctx, fd);
34680|  9.49k|    if (JS_IsException(fun_obj))
34681|     71|        goto fail1;
34682|       |    /* Could add a flag to avoid resolution if necessary */
34683|  9.42k|    if (m) {
34684|    485|        m->func_obj = fun_obj;
34685|    485|        if (js_resolve_module(ctx, m) < 0)
34686|    118|            goto fail1;
34687|    367|        fun_obj = JS_NewModuleValue(ctx, m);
34688|    367|    }
34689|  9.30k|    if (flags & JS_EVAL_FLAG_COMPILE_ONLY) {
34690|    367|        ret_val = fun_obj;
34691|  8.93k|    } else {
34692|  8.93k|        ret_val = JS_EvalFunctionInternal(ctx, fun_obj, this_obj, var_refs, sf);
34693|  8.93k|    }
34694|  9.30k|    return ret_val;
34695|  8.46k| fail1:
34696|       |    /* XXX: should free all the unresolved dependencies */
34697|  8.46k|    if (m)
34698|    518|        js_free_module_def(ctx, m);
34699|  8.46k|    return JS_EXCEPTION;
34700|  9.42k|}
34701|       |
34702|       |/* the indirection is needed to make 'eval' optional */
34703|       |static JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
34704|       |                               const char *input, size_t input_len,
34705|       |                               const char *filename, int flags, int scope_idx)
34706|  17.7k|{
34707|  17.7k|    BOOL backtrace_barrier = ((flags & JS_EVAL_FLAG_BACKTRACE_BARRIER) != 0);
34708|  17.7k|    int saved_js_mode = 0;
34709|  17.7k|    JSValue ret;
34710|       |    
34711|  17.7k|    if (unlikely(!ctx->eval_internal)) {
34712|      0|        return JS_ThrowTypeError(ctx, "eval is not supported");
34713|      0|    }
34714|  17.7k|    if (backtrace_barrier && ctx->rt->current_stack_frame) {
34715|      0|        saved_js_mode = ctx->rt->current_stack_frame->js_mode;
34716|      0|        ctx->rt->current_stack_frame->js_mode |= JS_MODE_BACKTRACE_BARRIER;
34717|      0|    }
34718|  17.7k|    ret = ctx->eval_internal(ctx, this_obj, input, input_len, filename,
34719|  17.7k|                             flags, scope_idx);
34720|  17.7k|    if (backtrace_barrier && ctx->rt->current_stack_frame)
34721|      0|        ctx->rt->current_stack_frame->js_mode = saved_js_mode;
34722|  17.7k|    return ret;
34723|  17.7k|}
34724|       |
34725|       |static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
34726|       |                             JSValueConst val, int flags, int scope_idx)
34727|      0|{
34728|      0|    JSValue ret;
34729|      0|    const char *str;
34730|      0|    size_t len;
34731|       |
34732|      0|    if (!JS_IsString(val))
34733|      0|        return JS_DupValue(ctx, val);
34734|      0|    str = JS_ToCStringLen(ctx, &len, val);
34735|      0|    if (!str)
34736|      0|        return JS_EXCEPTION;
34737|      0|    ret = JS_EvalInternal(ctx, this_obj, str, len, "<input>", flags, scope_idx);
34738|      0|    JS_FreeCString(ctx, str);
34739|      0|    return ret;
34740|       |
34741|      0|}
34742|       |
34743|       |JSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,
34744|       |                    const char *input, size_t input_len,
34745|       |                    const char *filename, int eval_flags)
34746|  17.7k|{
34747|  17.7k|    int eval_type = eval_flags & JS_EVAL_TYPE_MASK;
34748|  17.7k|    JSValue ret;
34749|       |
34750|  17.7k|    assert(eval_type == JS_EVAL_TYPE_GLOBAL ||
34751|  17.7k|           eval_type == JS_EVAL_TYPE_MODULE);
34752|  17.7k|    ret = JS_EvalInternal(ctx, this_obj, input, input_len, filename,
34753|  17.7k|                          eval_flags, -1);
34754|  17.7k|    return ret;
34755|  17.7k|}
34756|       |
34757|       |JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
34758|       |                const char *filename, int eval_flags)
34759|  17.7k|{
34760|  17.7k|    return JS_EvalThis(ctx, ctx->global_obj, input, input_len, filename,
34761|  17.7k|                       eval_flags);
34762|  17.7k|}
34763|       |
34764|       |int JS_ResolveModule(JSContext *ctx, JSValueConst obj)
34765|      0|{
34766|      0|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
34767|      0|        JSModuleDef *m = JS_VALUE_GET_PTR(obj);
34768|      0|        if (js_resolve_module(ctx, m) < 0) {
34769|      0|            js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
34770|      0|            return -1;
34771|      0|        }
34772|      0|    }
34773|      0|    return 0;
34774|      0|}
34775|       |
34776|       |/*******************************************************************/
34777|       |/* object list */
34778|       |
34779|       |typedef struct {
34780|       |    JSObject *obj;
34781|       |    uint32_t hash_next; /* -1 if no next entry */
34782|       |} JSObjectListEntry;
34783|       |
34784|       |/* XXX: reuse it to optimize weak references */
34785|       |typedef struct {
34786|       |    JSObjectListEntry *object_tab;
34787|       |    int object_count;
34788|       |    int object_size;
34789|       |    uint32_t *hash_table;
34790|       |    uint32_t hash_size;
34791|       |} JSObjectList;
34792|       |
34793|       |static void js_object_list_init(JSObjectList *s)
34794|      0|{
34795|      0|    memset(s, 0, sizeof(*s));
34796|      0|}
34797|       |
34798|       |static uint32_t js_object_list_get_hash(JSObject *p, uint32_t hash_size)
34799|      0|{
34800|      0|    return ((uintptr_t)p * 3163) & (hash_size - 1);
34801|      0|}
34802|       |
34803|       |static int js_object_list_resize_hash(JSContext *ctx, JSObjectList *s,
34804|       |                                 uint32_t new_hash_size)
34805|      0|{
34806|      0|    JSObjectListEntry *e;
34807|      0|    uint32_t i, h, *new_hash_table;
34808|       |
34809|      0|    new_hash_table = js_malloc(ctx, sizeof(new_hash_table[0]) * new_hash_size);
34810|      0|    if (!new_hash_table)
34811|      0|        return -1;
34812|      0|    js_free(ctx, s->hash_table);
34813|      0|    s->hash_table = new_hash_table;
34814|      0|    s->hash_size = new_hash_size;
34815|       |
34816|      0|    for(i = 0; i < s->hash_size; i++) {
34817|      0|        s->hash_table[i] = -1;
34818|      0|    }
34819|      0|    for(i = 0; i < s->object_count; i++) {
34820|      0|        e = &s->object_tab[i];
34821|      0|        h = js_object_list_get_hash(e->obj, s->hash_size);
34822|      0|        e->hash_next = s->hash_table[h];
34823|      0|        s->hash_table[h] = i;
34824|      0|    }
34825|      0|    return 0;
34826|      0|}
34827|       |
34828|       |/* the reference count of 'obj' is not modified. Return 0 if OK, -1 if
34829|       |   memory error */
34830|       |static int js_object_list_add(JSContext *ctx, JSObjectList *s, JSObject *obj)
34831|      0|{
34832|      0|    JSObjectListEntry *e;
34833|      0|    uint32_t h, new_hash_size;
34834|       |
34835|      0|    if (js_resize_array(ctx, (void *)&s->object_tab,
34836|      0|                        sizeof(s->object_tab[0]),
34837|      0|                        &s->object_size, s->object_count + 1))
34838|      0|        return -1;
34839|      0|    if (unlikely((s->object_count + 1) >= s->hash_size)) {
34840|      0|        new_hash_size = max_uint32(s->hash_size, 4);
34841|      0|        while (new_hash_size <= s->object_count)
34842|      0|            new_hash_size *= 2;
34843|      0|        if (js_object_list_resize_hash(ctx, s, new_hash_size))
34844|      0|            return -1;
34845|      0|    }
34846|      0|    e = &s->object_tab[s->object_count++];
34847|      0|    h = js_object_list_get_hash(obj, s->hash_size);
34848|      0|    e->obj = obj;
34849|      0|    e->hash_next = s->hash_table[h];
34850|      0|    s->hash_table[h] = s->object_count - 1;
34851|      0|    return 0;
34852|      0|}
34853|       |
34854|       |/* return -1 if not present or the object index */
34855|       |static int js_object_list_find(JSContext *ctx, JSObjectList *s, JSObject *obj)
34856|      0|{
34857|      0|    JSObjectListEntry *e;
34858|      0|    uint32_t h, p;
34859|       |
34860|       |    /* must test empty size because there is no hash table */
34861|      0|    if (s->object_count == 0)
34862|      0|        return -1;
34863|      0|    h = js_object_list_get_hash(obj, s->hash_size);
34864|      0|    p = s->hash_table[h];
34865|      0|    while (p != -1) {
34866|      0|        e = &s->object_tab[p];
34867|      0|        if (e->obj == obj)
34868|      0|            return p;
34869|      0|        p = e->hash_next;
34870|      0|    }
34871|      0|    return -1;
34872|      0|}
34873|       |
34874|       |static void js_object_list_end(JSContext *ctx, JSObjectList *s)
34875|      0|{
34876|      0|    js_free(ctx, s->object_tab);
34877|      0|    js_free(ctx, s->hash_table);
34878|      0|}
34879|       |
34880|       |/*******************************************************************/
34881|       |/* binary object writer & reader */
34882|       |
34883|       |typedef enum BCTagEnum {
34884|       |    BC_TAG_NULL = 1,
34885|       |    BC_TAG_UNDEFINED,
34886|       |    BC_TAG_BOOL_FALSE,
34887|       |    BC_TAG_BOOL_TRUE,
34888|       |    BC_TAG_INT32,
34889|       |    BC_TAG_FLOAT64,
34890|       |    BC_TAG_STRING,
34891|       |    BC_TAG_OBJECT,
34892|       |    BC_TAG_ARRAY,
34893|       |    BC_TAG_BIG_INT,
34894|       |    BC_TAG_TEMPLATE_OBJECT,
34895|       |    BC_TAG_FUNCTION_BYTECODE,
34896|       |    BC_TAG_MODULE,
34897|       |    BC_TAG_TYPED_ARRAY,
34898|       |    BC_TAG_ARRAY_BUFFER,
34899|       |    BC_TAG_SHARED_ARRAY_BUFFER,
34900|       |    BC_TAG_DATE,
34901|       |    BC_TAG_OBJECT_VALUE,
34902|       |    BC_TAG_OBJECT_REFERENCE,
34903|       |} BCTagEnum;
34904|       |
34905|      0|#define BC_VERSION 4
34906|       |
34907|       |typedef struct BCWriterState {
34908|       |    JSContext *ctx;
34909|       |    DynBuf dbuf;
34910|       |    BOOL allow_bytecode : 8;
34911|       |    BOOL allow_sab : 8;
34912|       |    BOOL allow_reference : 8;
34913|       |    uint32_t first_atom;
34914|       |    uint32_t *atom_to_idx;
34915|       |    int atom_to_idx_size;
34916|       |    JSAtom *idx_to_atom;
34917|       |    int idx_to_atom_count;
34918|       |    int idx_to_atom_size;
34919|       |    uint8_t **sab_tab;
34920|       |    int sab_tab_len;
34921|       |    int sab_tab_size;
34922|       |    /* list of referenced objects (used if allow_reference = TRUE) */
34923|       |    JSObjectList object_list;
34924|       |} BCWriterState;
34925|       |
34926|       |#ifdef DUMP_READ_OBJECT
34927|       |static const char * const bc_tag_str[] = {
34928|       |    "invalid",
34929|       |    "null",
34930|       |    "undefined",
34931|       |    "false",
34932|       |    "true",
34933|       |    "int32",
34934|       |    "float64",
34935|       |    "string",
34936|       |    "object",
34937|       |    "array",
34938|       |    "bigint",
34939|       |    "template",
34940|       |    "function",
34941|       |    "module",
34942|       |    "TypedArray",
34943|       |    "ArrayBuffer",
34944|       |    "SharedArrayBuffer",
34945|       |    "Date",
34946|       |    "ObjectValue",
34947|       |    "ObjectReference",
34948|       |};
34949|       |#endif
34950|       |
34951|       |static inline BOOL is_be(void)
34952|      0|{
34953|      0|    union {
34954|      0|        uint16_t a;
34955|      0|        uint8_t  b;
34956|      0|    } u = {0x100};
34957|      0|    return u.b;
34958|      0|}
34959|       |
34960|       |static void bc_put_u8(BCWriterState *s, uint8_t v)
34961|      0|{
34962|      0|    dbuf_putc(&s->dbuf, v);
34963|      0|}
34964|       |
34965|       |static void bc_put_u16(BCWriterState *s, uint16_t v)
34966|      0|{
34967|      0|    if (is_be())
34968|      0|        v = bswap16(v);
34969|      0|    dbuf_put_u16(&s->dbuf, v);
34970|      0|}
34971|       |
34972|       |static __maybe_unused void bc_put_u32(BCWriterState *s, uint32_t v)
34973|      0|{
34974|      0|    if (is_be())
34975|      0|        v = bswap32(v);
34976|      0|    dbuf_put_u32(&s->dbuf, v);
34977|      0|}
34978|       |
34979|       |static void bc_put_u64(BCWriterState *s, uint64_t v)
34980|      0|{
34981|      0|    if (is_be())
34982|      0|        v = bswap64(v);
34983|      0|    dbuf_put(&s->dbuf, (uint8_t *)&v, sizeof(v));
34984|      0|}
34985|       |
34986|       |static void bc_put_leb128(BCWriterState *s, uint32_t v)
34987|      0|{
34988|      0|    dbuf_put_leb128(&s->dbuf, v);
34989|      0|}
34990|       |
34991|       |static void bc_put_sleb128(BCWriterState *s, int32_t v)
34992|      0|{
34993|      0|    dbuf_put_sleb128(&s->dbuf, v);
34994|      0|}
34995|       |
34996|       |static void bc_set_flags(uint32_t *pflags, int *pidx, uint32_t val, int n)
34997|      0|{
34998|      0|    *pflags = *pflags | (val << *pidx);
34999|      0|    *pidx += n;
35000|      0|}
35001|       |
35002|       |static int bc_atom_to_idx(BCWriterState *s, uint32_t *pres, JSAtom atom)
35003|      0|{
35004|      0|    uint32_t v;
35005|       |
35006|      0|    if (atom < s->first_atom || __JS_AtomIsTaggedInt(atom)) {
35007|      0|        *pres = atom;
35008|      0|        return 0;
35009|      0|    }
35010|      0|    atom -= s->first_atom;
35011|      0|    if (atom < s->atom_to_idx_size && s->atom_to_idx[atom] != 0) {
35012|      0|        *pres = s->atom_to_idx[atom];
35013|      0|        return 0;
35014|      0|    }
35015|      0|    if (atom >= s->atom_to_idx_size) {
35016|      0|        int old_size, i;
35017|      0|        old_size = s->atom_to_idx_size;
35018|      0|        if (js_resize_array(s->ctx, (void **)&s->atom_to_idx,
35019|      0|                            sizeof(s->atom_to_idx[0]), &s->atom_to_idx_size,
35020|      0|                            atom + 1))
35021|      0|            return -1;
35022|       |        /* XXX: could add a specific js_resize_array() function to do it */
35023|      0|        for(i = old_size; i < s->atom_to_idx_size; i++)
35024|      0|            s->atom_to_idx[i] = 0;
35025|      0|    }
35026|      0|    if (js_resize_array(s->ctx, (void **)&s->idx_to_atom,
35027|      0|                        sizeof(s->idx_to_atom[0]),
35028|      0|                        &s->idx_to_atom_size, s->idx_to_atom_count + 1))
35029|      0|        goto fail;
35030|       |
35031|      0|    v = s->idx_to_atom_count++;
35032|      0|    s->idx_to_atom[v] = atom + s->first_atom;
35033|      0|    v += s->first_atom;
35034|      0|    s->atom_to_idx[atom] = v;
35035|      0|    *pres = v;
35036|      0|    return 0;
35037|      0| fail:
35038|      0|    *pres = 0;
35039|      0|    return -1;
35040|      0|}
35041|       |
35042|       |static int bc_put_atom(BCWriterState *s, JSAtom atom)
35043|      0|{
35044|      0|    uint32_t v;
35045|       |
35046|      0|    if (__JS_AtomIsTaggedInt(atom)) {
35047|      0|        v = (__JS_AtomToUInt32(atom) << 1) | 1;
35048|      0|    } else {
35049|      0|        if (bc_atom_to_idx(s, &v, atom))
35050|      0|            return -1;
35051|      0|        v <<= 1;
35052|      0|    }
35053|      0|    bc_put_leb128(s, v);
35054|      0|    return 0;
35055|      0|}
35056|       |
35057|       |static void bc_byte_swap(uint8_t *bc_buf, int bc_len)
35058|      0|{
35059|      0|    int pos, len, op, fmt;
35060|       |
35061|      0|    pos = 0;
35062|      0|    while (pos < bc_len) {
35063|      0|        op = bc_buf[pos];
35064|      0|        len = short_opcode_info(op).size;
35065|      0|        fmt = short_opcode_info(op).fmt;
35066|      0|        switch(fmt) {
35067|      0|        case OP_FMT_u16:
35068|      0|        case OP_FMT_i16:
35069|      0|        case OP_FMT_label16:
35070|      0|        case OP_FMT_npop:
35071|      0|        case OP_FMT_loc:
35072|      0|        case OP_FMT_arg:
35073|      0|        case OP_FMT_var_ref:
35074|      0|            put_u16(bc_buf + pos + 1,
35075|      0|                    bswap16(get_u16(bc_buf + pos + 1)));
35076|      0|            break;
35077|      0|        case OP_FMT_i32:
35078|      0|        case OP_FMT_u32:
35079|      0|        case OP_FMT_const:
35080|      0|        case OP_FMT_label:
35081|      0|        case OP_FMT_atom:
35082|      0|        case OP_FMT_atom_u8:
35083|      0|            put_u32(bc_buf + pos + 1,
35084|      0|                    bswap32(get_u32(bc_buf + pos + 1)));
35085|      0|            break;
35086|      0|        case OP_FMT_atom_u16:
35087|      0|        case OP_FMT_label_u16:
35088|      0|            put_u32(bc_buf + pos + 1,
35089|      0|                    bswap32(get_u32(bc_buf + pos + 1)));
35090|      0|            put_u16(bc_buf + pos + 1 + 4,
35091|      0|                    bswap16(get_u16(bc_buf + pos + 1 + 4)));
35092|      0|            break;
35093|      0|        case OP_FMT_atom_label_u8:
35094|      0|        case OP_FMT_atom_label_u16:
35095|      0|            put_u32(bc_buf + pos + 1,
35096|      0|                    bswap32(get_u32(bc_buf + pos + 1)));
35097|      0|            put_u32(bc_buf + pos + 1 + 4,
35098|      0|                    bswap32(get_u32(bc_buf + pos + 1 + 4)));
35099|      0|            if (fmt == OP_FMT_atom_label_u16) {
35100|      0|                put_u16(bc_buf + pos + 1 + 4 + 4,
35101|      0|                        bswap16(get_u16(bc_buf + pos + 1 + 4 + 4)));
35102|      0|            }
35103|      0|            break;
35104|      0|        case OP_FMT_npop_u16:
35105|      0|            put_u16(bc_buf + pos + 1,
35106|      0|                    bswap16(get_u16(bc_buf + pos + 1)));
35107|      0|            put_u16(bc_buf + pos + 1 + 2,
35108|      0|                    bswap16(get_u16(bc_buf + pos + 1 + 2)));
35109|      0|            break;
35110|      0|        default:
35111|      0|            break;
35112|      0|        }
35113|      0|        pos += len;
35114|      0|    }
35115|      0|}
35116|       |
35117|       |static int JS_WriteFunctionBytecode(BCWriterState *s,
35118|       |                                    const uint8_t *bc_buf1, int bc_len)
35119|      0|{
35120|      0|    int pos, len, op;
35121|      0|    JSAtom atom;
35122|      0|    uint8_t *bc_buf;
35123|      0|    uint32_t val;
35124|       |
35125|      0|    bc_buf = js_malloc(s->ctx, bc_len);
35126|      0|    if (!bc_buf)
35127|      0|        return -1;
35128|      0|    memcpy(bc_buf, bc_buf1, bc_len);
35129|       |
35130|      0|    pos = 0;
35131|      0|    while (pos < bc_len) {
35132|      0|        op = bc_buf[pos];
35133|      0|        len = short_opcode_info(op).size;
35134|      0|        switch(short_opcode_info(op).fmt) {
35135|      0|        case OP_FMT_atom:
35136|      0|        case OP_FMT_atom_u8:
35137|      0|        case OP_FMT_atom_u16:
35138|      0|        case OP_FMT_atom_label_u8:
35139|      0|        case OP_FMT_atom_label_u16:
35140|      0|            atom = get_u32(bc_buf + pos + 1);
35141|      0|            if (bc_atom_to_idx(s, &val, atom))
35142|      0|                goto fail;
35143|      0|            put_u32(bc_buf + pos + 1, val);
35144|      0|            break;
35145|      0|        default:
35146|      0|            break;
35147|      0|        }
35148|      0|        pos += len;
35149|      0|    }
35150|       |
35151|      0|    if (is_be())
35152|      0|        bc_byte_swap(bc_buf, bc_len);
35153|       |
35154|      0|    dbuf_put(&s->dbuf, bc_buf, bc_len);
35155|       |
35156|      0|    js_free(s->ctx, bc_buf);
35157|      0|    return 0;
35158|      0| fail:
35159|      0|    js_free(s->ctx, bc_buf);
35160|      0|    return -1;
35161|      0|}
35162|       |
35163|       |static void JS_WriteString(BCWriterState *s, JSString *p)
35164|      0|{
35165|      0|    int i;
35166|      0|    bc_put_leb128(s, ((uint32_t)p->len << 1) | p->is_wide_char);
35167|      0|    if (p->is_wide_char) {
35168|      0|        for(i = 0; i < p->len; i++)
35169|      0|            bc_put_u16(s, p->u.str16[i]);
35170|      0|    } else {
35171|      0|        dbuf_put(&s->dbuf, p->u.str8, p->len);
35172|      0|    }
35173|      0|}
35174|       |
35175|       |static int JS_WriteBigInt(BCWriterState *s, JSValueConst obj)
35176|      0|{
35177|      0|    JSBigIntBuf buf;
35178|      0|    JSBigInt *p;
35179|      0|    uint32_t len, i;
35180|      0|    js_limb_t v, b;
35181|      0|    int shift;
35182|       |    
35183|      0|    bc_put_u8(s, BC_TAG_BIG_INT);
35184|       |
35185|      0|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_SHORT_BIG_INT)
35186|      0|        p = js_bigint_set_short(&buf, obj);
35187|      0|    else
35188|      0|        p = JS_VALUE_GET_PTR(obj);
35189|      0|    if (p->len == 1 && p->tab[0] == 0) {
35190|       |        /* zero case */
35191|      0|        len = 0;
35192|      0|    } else {
35193|       |        /* compute the length of the two's complement representation
35194|       |           in bytes */
35195|      0|        len = p->len * (JS_LIMB_BITS / 8);
35196|      0|        v = p->tab[p->len - 1];
35197|      0|        shift = JS_LIMB_BITS - 8;
35198|      0|        while (shift > 0) {
35199|      0|            b = (v >> shift) & 0xff;
35200|      0|            if (b != 0x00 && b != 0xff)
35201|      0|                break;
35202|      0|            if ((b & 1) != ((v >> (shift - 1)) & 1))
35203|      0|                break;
35204|      0|            shift -= 8;
35205|      0|            len--;
35206|      0|        }
35207|      0|    }
35208|      0|    bc_put_leb128(s, len);
35209|      0|    if (len > 0) {
35210|      0|        for(i = 0; i < (len / (JS_LIMB_BITS / 8)); i++) {
35211|       |#if JS_LIMB_BITS == 32
35212|       |            bc_put_u32(s, p->tab[i]);
35213|       |#else
35214|      0|            bc_put_u64(s, p->tab[i]);
35215|      0|#endif
35216|      0|        }
35217|      0|        for(i = 0; i < len % (JS_LIMB_BITS / 8); i++) {
35218|      0|            bc_put_u8(s, (p->tab[p->len - 1] >> (i * 8)) & 0xff);
35219|      0|        }
35220|      0|    }
35221|      0|    return 0;
35222|      0|}
35223|       |
35224|       |static int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj);
35225|       |
35226|       |static int JS_WriteFunctionTag(BCWriterState *s, JSValueConst obj)
35227|      0|{
35228|      0|    JSFunctionBytecode *b = JS_VALUE_GET_PTR(obj);
35229|      0|    uint32_t flags;
35230|      0|    int idx, i;
35231|       |
35232|      0|    bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);
35233|      0|    flags = idx = 0;
35234|      0|    bc_set_flags(&flags, &idx, b->has_prototype, 1);
35235|      0|    bc_set_flags(&flags, &idx, b->has_simple_parameter_list, 1);
35236|      0|    bc_set_flags(&flags, &idx, b->is_derived_class_constructor, 1);
35237|      0|    bc_set_flags(&flags, &idx, b->need_home_object, 1);
35238|      0|    bc_set_flags(&flags, &idx, b->func_kind, 2);
35239|      0|    bc_set_flags(&flags, &idx, b->new_target_allowed, 1);
35240|      0|    bc_set_flags(&flags, &idx, b->super_call_allowed, 1);
35241|      0|    bc_set_flags(&flags, &idx, b->super_allowed, 1);
35242|      0|    bc_set_flags(&flags, &idx, b->arguments_allowed, 1);
35243|      0|    bc_set_flags(&flags, &idx, b->has_debug, 1);
35244|      0|    bc_set_flags(&flags, &idx, b->is_direct_or_indirect_eval, 1);
35245|      0|    assert(idx <= 16);
35246|      0|    bc_put_u16(s, flags);
35247|      0|    bc_put_u8(s, b->js_mode);
35248|      0|    bc_put_atom(s, b->func_name);
35249|       |
35250|      0|    bc_put_leb128(s, b->arg_count);
35251|      0|    bc_put_leb128(s, b->var_count);
35252|      0|    bc_put_leb128(s, b->defined_arg_count);
35253|      0|    bc_put_leb128(s, b->stack_size);
35254|      0|    bc_put_leb128(s, b->closure_var_count);
35255|      0|    bc_put_leb128(s, b->cpool_count);
35256|      0|    bc_put_leb128(s, b->byte_code_len);
35257|      0|    if (b->vardefs) {
35258|       |        /* XXX: this field is redundant */
35259|      0|        bc_put_leb128(s, b->arg_count + b->var_count);
35260|      0|        for(i = 0; i < b->arg_count + b->var_count; i++) {
35261|      0|            JSVarDef *vd = &b->vardefs[i];
35262|      0|            bc_put_atom(s, vd->var_name);
35263|      0|            bc_put_leb128(s, vd->scope_level);
35264|      0|            bc_put_leb128(s, vd->scope_next + 1);
35265|      0|            flags = idx = 0;
35266|      0|            bc_set_flags(&flags, &idx, vd->var_kind, 4);
35267|      0|            bc_set_flags(&flags, &idx, vd->is_const, 1);
35268|      0|            bc_set_flags(&flags, &idx, vd->is_lexical, 1);
35269|      0|            bc_set_flags(&flags, &idx, vd->is_captured, 1);
35270|      0|            assert(idx <= 8);
35271|      0|            bc_put_u8(s, flags);
35272|      0|        }
35273|      0|    } else {
35274|      0|        bc_put_leb128(s, 0);
35275|      0|    }
35276|       |
35277|      0|    for(i = 0; i < b->closure_var_count; i++) {
35278|      0|        JSClosureVar *cv = &b->closure_var[i];
35279|      0|        bc_put_atom(s, cv->var_name);
35280|      0|        bc_put_leb128(s, cv->var_idx);
35281|      0|        flags = idx = 0;
35282|      0|        bc_set_flags(&flags, &idx, cv->is_local, 1);
35283|      0|        bc_set_flags(&flags, &idx, cv->is_arg, 1);
35284|      0|        bc_set_flags(&flags, &idx, cv->is_const, 1);
35285|      0|        bc_set_flags(&flags, &idx, cv->is_lexical, 1);
35286|      0|        bc_set_flags(&flags, &idx, cv->var_kind, 4);
35287|      0|        assert(idx <= 8);
35288|      0|        bc_put_u8(s, flags);
35289|      0|    }
35290|       |
35291|      0|    if (JS_WriteFunctionBytecode(s, b->byte_code_buf, b->byte_code_len))
35292|      0|        goto fail;
35293|       |
35294|      0|    if (b->has_debug) {
35295|      0|        bc_put_atom(s, b->debug.filename);
35296|      0|        bc_put_leb128(s, b->debug.pc2line_len);
35297|      0|        dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);
35298|      0|        if (b->debug.source) {
35299|      0|            bc_put_leb128(s, b->debug.source_len);
35300|      0|            dbuf_put(&s->dbuf, (uint8_t *)b->debug.source, b->debug.source_len);
35301|      0|        } else {
35302|      0|            bc_put_leb128(s, 0);
35303|      0|        }
35304|      0|    }
35305|       |
35306|      0|    for(i = 0; i < b->cpool_count; i++) {
35307|      0|        if (JS_WriteObjectRec(s, b->cpool[i]))
35308|      0|            goto fail;
35309|      0|    }
35310|      0|    return 0;
35311|      0| fail:
35312|      0|    return -1;
35313|      0|}
35314|       |
35315|       |static int JS_WriteModule(BCWriterState *s, JSValueConst obj)
35316|      0|{
35317|      0|    JSModuleDef *m = JS_VALUE_GET_PTR(obj);
35318|      0|    int i;
35319|       |
35320|      0|    bc_put_u8(s, BC_TAG_MODULE);
35321|      0|    bc_put_atom(s, m->module_name);
35322|       |
35323|      0|    bc_put_leb128(s, m->req_module_entries_count);
35324|      0|    for(i = 0; i < m->req_module_entries_count; i++) {
35325|      0|        JSReqModuleEntry *rme = &m->req_module_entries[i];
35326|      0|        bc_put_atom(s, rme->module_name);
35327|      0|    }
35328|       |
35329|      0|    bc_put_leb128(s, m->export_entries_count);
35330|      0|    for(i = 0; i < m->export_entries_count; i++) {
35331|      0|        JSExportEntry *me = &m->export_entries[i];
35332|      0|        bc_put_u8(s, me->export_type);
35333|      0|        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
35334|      0|            bc_put_leb128(s, me->u.local.var_idx);
35335|      0|        } else {
35336|      0|            bc_put_leb128(s, me->u.req_module_idx);
35337|      0|            bc_put_atom(s, me->local_name);
35338|      0|        }
35339|      0|        bc_put_atom(s, me->export_name);
35340|      0|    }
35341|       |
35342|      0|    bc_put_leb128(s, m->star_export_entries_count);
35343|      0|    for(i = 0; i < m->star_export_entries_count; i++) {
35344|      0|        JSStarExportEntry *se = &m->star_export_entries[i];
35345|      0|        bc_put_leb128(s, se->req_module_idx);
35346|      0|    }
35347|       |
35348|      0|    bc_put_leb128(s, m->import_entries_count);
35349|      0|    for(i = 0; i < m->import_entries_count; i++) {
35350|      0|        JSImportEntry *mi = &m->import_entries[i];
35351|      0|        bc_put_leb128(s, mi->var_idx);
35352|      0|        bc_put_atom(s, mi->import_name);
35353|      0|        bc_put_leb128(s, mi->req_module_idx);
35354|      0|    }
35355|       |
35356|      0|    bc_put_u8(s, m->has_tla);
35357|       |
35358|      0|    if (JS_WriteObjectRec(s, m->func_obj))
35359|      0|        goto fail;
35360|      0|    return 0;
35361|      0| fail:
35362|      0|    return -1;
35363|      0|}
35364|       |
35365|       |static int JS_WriteArray(BCWriterState *s, JSValueConst obj)
35366|      0|{
35367|      0|    JSObject *p = JS_VALUE_GET_OBJ(obj);
35368|      0|    uint32_t i, len;
35369|      0|    JSValue val;
35370|      0|    int ret;
35371|      0|    BOOL is_template;
35372|       |
35373|      0|    if (s->allow_bytecode && !p->extensible) {
35374|       |        /* not extensible array: we consider it is a
35375|       |           template when we are saving bytecode */
35376|      0|        bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT);
35377|      0|        is_template = TRUE;
35378|      0|    } else {
35379|      0|        bc_put_u8(s, BC_TAG_ARRAY);
35380|      0|        is_template = FALSE;
35381|      0|    }
35382|      0|    if (js_get_length32(s->ctx, &len, obj))
35383|      0|        goto fail1;
35384|      0|    bc_put_leb128(s, len);
35385|      0|    for(i = 0; i < len; i++) {
35386|      0|        val = JS_GetPropertyUint32(s->ctx, obj, i);
35387|      0|        if (JS_IsException(val))
35388|      0|            goto fail1;
35389|      0|        ret = JS_WriteObjectRec(s, val);
35390|      0|        JS_FreeValue(s->ctx, val);
35391|      0|        if (ret)
35392|      0|            goto fail1;
35393|      0|    }
35394|      0|    if (is_template) {
35395|      0|        val = JS_GetProperty(s->ctx, obj, JS_ATOM_raw);
35396|      0|        if (JS_IsException(val))
35397|      0|            goto fail1;
35398|      0|        ret = JS_WriteObjectRec(s, val);
35399|      0|        JS_FreeValue(s->ctx, val);
35400|      0|        if (ret)
35401|      0|            goto fail1;
35402|      0|    }
35403|      0|    return 0;
35404|      0| fail1:
35405|      0|    return -1;
35406|      0|}
35407|       |
35408|       |static int JS_WriteObjectTag(BCWriterState *s, JSValueConst obj)
35409|      0|{
35410|      0|    JSObject *p = JS_VALUE_GET_OBJ(obj);
35411|      0|    uint32_t i, prop_count;
35412|      0|    JSShape *sh;
35413|      0|    JSShapeProperty *pr;
35414|      0|    int pass;
35415|      0|    JSAtom atom;
35416|       |
35417|      0|    bc_put_u8(s, BC_TAG_OBJECT);
35418|      0|    prop_count = 0;
35419|      0|    sh = p->shape;
35420|      0|    for(pass = 0; pass < 2; pass++) {
35421|      0|        if (pass == 1)
35422|      0|            bc_put_leb128(s, prop_count);
35423|      0|        for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
35424|      0|            atom = pr->atom;
35425|      0|            if (atom != JS_ATOM_NULL &&
35426|      0|                JS_AtomIsString(s->ctx, atom) &&
35427|      0|                (pr->flags & JS_PROP_ENUMERABLE)) {
35428|      0|                if (pr->flags & JS_PROP_TMASK) {
35429|      0|                    JS_ThrowTypeError(s->ctx, "only value properties are supported");
35430|      0|                    goto fail;
35431|      0|                }
35432|      0|                if (pass == 0) {
35433|      0|                    prop_count++;
35434|      0|                } else {
35435|      0|                    bc_put_atom(s, atom);
35436|      0|                    if (JS_WriteObjectRec(s, p->prop[i].u.value))
35437|      0|                        goto fail;
35438|      0|                }
35439|      0|            }
35440|      0|        }
35441|      0|    }
35442|      0|    return 0;
35443|      0| fail:
35444|      0|    return -1;
35445|      0|}
35446|       |
35447|       |static int JS_WriteTypedArray(BCWriterState *s, JSValueConst obj)
35448|      0|{
35449|      0|    JSObject *p = JS_VALUE_GET_OBJ(obj);
35450|      0|    JSTypedArray *ta = p->u.typed_array;
35451|       |
35452|      0|    bc_put_u8(s, BC_TAG_TYPED_ARRAY);
35453|      0|    bc_put_u8(s, p->class_id - JS_CLASS_UINT8C_ARRAY);
35454|      0|    bc_put_leb128(s, p->u.array.count);
35455|      0|    bc_put_leb128(s, ta->offset);
35456|      0|    if (JS_WriteObjectRec(s, JS_MKPTR(JS_TAG_OBJECT, ta->buffer)))
35457|      0|        return -1;
35458|      0|    return 0;
35459|      0|}
35460|       |
35461|       |static int JS_WriteArrayBuffer(BCWriterState *s, JSValueConst obj)
35462|      0|{
35463|      0|    JSObject *p = JS_VALUE_GET_OBJ(obj);
35464|      0|    JSArrayBuffer *abuf = p->u.array_buffer;
35465|      0|    if (abuf->detached) {
35466|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(s->ctx);
35467|      0|        return -1;
35468|      0|    }
35469|      0|    bc_put_u8(s, BC_TAG_ARRAY_BUFFER);
35470|      0|    bc_put_leb128(s, abuf->byte_length);
35471|      0|    dbuf_put(&s->dbuf, abuf->data, abuf->byte_length);
35472|      0|    return 0;
35473|      0|}
35474|       |
35475|       |static int JS_WriteSharedArrayBuffer(BCWriterState *s, JSValueConst obj)
35476|      0|{
35477|      0|    JSObject *p = JS_VALUE_GET_OBJ(obj);
35478|      0|    JSArrayBuffer *abuf = p->u.array_buffer;
35479|      0|    assert(!abuf->detached); /* SharedArrayBuffer are never detached */
35480|      0|    bc_put_u8(s, BC_TAG_SHARED_ARRAY_BUFFER);
35481|      0|    bc_put_leb128(s, abuf->byte_length);
35482|      0|    bc_put_u64(s, (uintptr_t)abuf->data);
35483|      0|    if (js_resize_array(s->ctx, (void **)&s->sab_tab, sizeof(s->sab_tab[0]),
35484|      0|                        &s->sab_tab_size, s->sab_tab_len + 1))
35485|      0|        return -1;
35486|       |    /* keep the SAB pointer so that the user can clone it or free it */
35487|      0|    s->sab_tab[s->sab_tab_len++] = abuf->data;
35488|      0|    return 0;
35489|      0|}
35490|       |
35491|       |static int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj)
35492|      0|{
35493|      0|    uint32_t tag;
35494|       |
35495|      0|    if (js_check_stack_overflow(s->ctx->rt, 0)) {
35496|      0|        JS_ThrowStackOverflow(s->ctx);
35497|      0|        return -1;
35498|      0|    }
35499|       |
35500|      0|    tag = JS_VALUE_GET_NORM_TAG(obj);
35501|      0|    switch(tag) {
35502|      0|    case JS_TAG_NULL:
35503|      0|        bc_put_u8(s, BC_TAG_NULL);
35504|      0|        break;
35505|      0|    case JS_TAG_UNDEFINED:
35506|      0|        bc_put_u8(s, BC_TAG_UNDEFINED);
35507|      0|        break;
35508|      0|    case JS_TAG_BOOL:
35509|      0|        bc_put_u8(s, BC_TAG_BOOL_FALSE + JS_VALUE_GET_INT(obj));
35510|      0|        break;
35511|      0|    case JS_TAG_INT:
35512|      0|        bc_put_u8(s, BC_TAG_INT32);
35513|      0|        bc_put_sleb128(s, JS_VALUE_GET_INT(obj));
35514|      0|        break;
35515|      0|    case JS_TAG_FLOAT64:
35516|      0|        {
35517|      0|            JSFloat64Union u;
35518|      0|            bc_put_u8(s, BC_TAG_FLOAT64);
35519|      0|            u.d = JS_VALUE_GET_FLOAT64(obj);
35520|      0|            bc_put_u64(s, u.u64);
35521|      0|        }
35522|      0|        break;
35523|      0|    case JS_TAG_STRING:
35524|      0|        {
35525|      0|            JSString *p = JS_VALUE_GET_STRING(obj);
35526|      0|            bc_put_u8(s, BC_TAG_STRING);
35527|      0|            JS_WriteString(s, p);
35528|      0|        }
35529|      0|        break;
35530|      0|    case JS_TAG_STRING_ROPE:
35531|      0|        {
35532|      0|            JSValue str;
35533|      0|            str = JS_ToString(s->ctx, obj);
35534|      0|            if (JS_IsException(str))
35535|      0|                goto fail;
35536|      0|            JS_WriteObjectRec(s, str);
35537|      0|            JS_FreeValue(s->ctx, str);
35538|      0|        }
35539|      0|        break;
35540|      0|    case JS_TAG_FUNCTION_BYTECODE:
35541|      0|        if (!s->allow_bytecode)
35542|      0|            goto invalid_tag;
35543|      0|        if (JS_WriteFunctionTag(s, obj))
35544|      0|            goto fail;
35545|      0|        break;
35546|      0|    case JS_TAG_MODULE:
35547|      0|        if (!s->allow_bytecode)
35548|      0|            goto invalid_tag;
35549|      0|        if (JS_WriteModule(s, obj))
35550|      0|            goto fail;
35551|      0|        break;
35552|      0|    case JS_TAG_OBJECT:
35553|      0|        {
35554|      0|            JSObject *p = JS_VALUE_GET_OBJ(obj);
35555|      0|            int ret, idx;
35556|       |
35557|      0|            if (s->allow_reference) {
35558|      0|                idx = js_object_list_find(s->ctx, &s->object_list, p);
35559|      0|                if (idx >= 0) {
35560|      0|                    bc_put_u8(s, BC_TAG_OBJECT_REFERENCE);
35561|      0|                    bc_put_leb128(s, idx);
35562|      0|                    break;
35563|      0|                } else {
35564|      0|                    if (js_object_list_add(s->ctx, &s->object_list, p))
35565|      0|                        goto fail;
35566|      0|                }
35567|      0|            } else {
35568|      0|                if (p->tmp_mark) {
35569|      0|                    JS_ThrowTypeError(s->ctx, "circular reference");
35570|      0|                    goto fail;
35571|      0|                }
35572|      0|                p->tmp_mark = 1;
35573|      0|            }
35574|      0|            switch(p->class_id) {
35575|      0|            case JS_CLASS_ARRAY:
35576|      0|                ret = JS_WriteArray(s, obj);
35577|      0|                break;
35578|      0|            case JS_CLASS_OBJECT:
35579|      0|                ret = JS_WriteObjectTag(s, obj);
35580|      0|                break;
35581|      0|            case JS_CLASS_ARRAY_BUFFER:
35582|      0|                ret = JS_WriteArrayBuffer(s, obj);
35583|      0|                break;
35584|      0|            case JS_CLASS_SHARED_ARRAY_BUFFER:
35585|      0|                if (!s->allow_sab)
35586|      0|                    goto invalid_tag;
35587|      0|                ret = JS_WriteSharedArrayBuffer(s, obj);
35588|      0|                break;
35589|      0|            case JS_CLASS_DATE:
35590|      0|                bc_put_u8(s, BC_TAG_DATE);
35591|      0|                ret = JS_WriteObjectRec(s, p->u.object_data);
35592|      0|                break;
35593|      0|            case JS_CLASS_NUMBER:
35594|      0|            case JS_CLASS_STRING:
35595|      0|            case JS_CLASS_BOOLEAN:
35596|      0|            case JS_CLASS_BIG_INT:
35597|      0|                bc_put_u8(s, BC_TAG_OBJECT_VALUE);
35598|      0|                ret = JS_WriteObjectRec(s, p->u.object_data);
35599|      0|                break;
35600|      0|            default:
35601|      0|                if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
35602|      0|                    p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
35603|      0|                    ret = JS_WriteTypedArray(s, obj);
35604|      0|                } else {
35605|      0|                    JS_ThrowTypeError(s->ctx, "unsupported object class");
35606|      0|                    ret = -1;
35607|      0|                }
35608|      0|                break;
35609|      0|            }
35610|      0|            p->tmp_mark = 0;
35611|      0|            if (ret)
35612|      0|                goto fail;
35613|      0|        }
35614|      0|        break;
35615|      0|    case JS_TAG_SHORT_BIG_INT:
35616|      0|    case JS_TAG_BIG_INT:
35617|      0|        if (JS_WriteBigInt(s, obj))
35618|      0|            goto fail;
35619|      0|        break;
35620|      0|    default:
35621|      0|    invalid_tag:
35622|      0|        JS_ThrowInternalError(s->ctx, "unsupported tag (%d)", tag);
35623|      0|        goto fail;
35624|      0|    }
35625|      0|    return 0;
35626|       |
35627|      0| fail:
35628|      0|    return -1;
35629|      0|}
35630|       |
35631|       |/* create the atom table */
35632|       |static int JS_WriteObjectAtoms(BCWriterState *s)
35633|      0|{
35634|      0|    JSRuntime *rt = s->ctx->rt;
35635|      0|    DynBuf dbuf1;
35636|      0|    int i, atoms_size;
35637|       |
35638|      0|    dbuf1 = s->dbuf;
35639|      0|    js_dbuf_init(s->ctx, &s->dbuf);
35640|      0|    bc_put_u8(s, BC_VERSION);
35641|       |
35642|      0|    bc_put_leb128(s, s->idx_to_atom_count);
35643|      0|    for(i = 0; i < s->idx_to_atom_count; i++) {
35644|      0|        JSAtomStruct *p = rt->atom_array[s->idx_to_atom[i]];
35645|      0|        JS_WriteString(s, p);
35646|      0|    }
35647|       |    /* XXX: should check for OOM in above phase */
35648|       |
35649|       |    /* move the atoms at the start */
35650|       |    /* XXX: could just append dbuf1 data, but it uses more memory if
35651|       |       dbuf1 is larger than dbuf */
35652|      0|    atoms_size = s->dbuf.size;
35653|      0|    if (dbuf_realloc(&dbuf1, dbuf1.size + atoms_size))
35654|      0|        goto fail;
35655|      0|    memmove(dbuf1.buf + atoms_size, dbuf1.buf, dbuf1.size);
35656|      0|    memcpy(dbuf1.buf, s->dbuf.buf, atoms_size);
35657|      0|    dbuf1.size += atoms_size;
35658|      0|    dbuf_free(&s->dbuf);
35659|      0|    s->dbuf = dbuf1;
35660|      0|    return 0;
35661|      0| fail:
35662|      0|    dbuf_free(&dbuf1);
35663|      0|    return -1;
35664|      0|}
35665|       |
35666|       |uint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,
35667|       |                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len)
35668|      0|{
35669|      0|    BCWriterState ss, *s = &ss;
35670|       |
35671|      0|    memset(s, 0, sizeof(*s));
35672|      0|    s->ctx = ctx;
35673|      0|    s->allow_bytecode = ((flags & JS_WRITE_OBJ_BYTECODE) != 0);
35674|      0|    s->allow_sab = ((flags & JS_WRITE_OBJ_SAB) != 0);
35675|      0|    s->allow_reference = ((flags & JS_WRITE_OBJ_REFERENCE) != 0);
35676|       |    /* XXX: could use a different version when bytecode is included */
35677|      0|    if (s->allow_bytecode)
35678|      0|        s->first_atom = JS_ATOM_END;
35679|      0|    else
35680|      0|        s->first_atom = 1;
35681|      0|    js_dbuf_init(ctx, &s->dbuf);
35682|      0|    js_object_list_init(&s->object_list);
35683|       |
35684|      0|    if (JS_WriteObjectRec(s, obj))
35685|      0|        goto fail;
35686|      0|    if (JS_WriteObjectAtoms(s))
35687|      0|        goto fail;
35688|      0|    js_object_list_end(ctx, &s->object_list);
35689|      0|    js_free(ctx, s->atom_to_idx);
35690|      0|    js_free(ctx, s->idx_to_atom);
35691|      0|    *psize = s->dbuf.size;
35692|      0|    if (psab_tab)
35693|      0|        *psab_tab = s->sab_tab;
35694|      0|    if (psab_tab_len)
35695|      0|        *psab_tab_len = s->sab_tab_len;
35696|      0|    return s->dbuf.buf;
35697|      0| fail:
35698|      0|    js_object_list_end(ctx, &s->object_list);
35699|      0|    js_free(ctx, s->atom_to_idx);
35700|      0|    js_free(ctx, s->idx_to_atom);
35701|      0|    dbuf_free(&s->dbuf);
35702|      0|    *psize = 0;
35703|      0|    if (psab_tab)
35704|      0|        *psab_tab = NULL;
35705|      0|    if (psab_tab_len)
35706|      0|        *psab_tab_len = 0;
35707|      0|    return NULL;
35708|      0|}
35709|       |
35710|       |uint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,
35711|       |                        int flags)
35712|      0|{
35713|      0|    return JS_WriteObject2(ctx, psize, obj, flags, NULL, NULL);
35714|      0|}
35715|       |
35716|       |typedef struct BCReaderState {
35717|       |    JSContext *ctx;
35718|       |    const uint8_t *buf_start, *ptr, *buf_end;
35719|       |    uint32_t first_atom;
35720|       |    uint32_t idx_to_atom_count;
35721|       |    JSAtom *idx_to_atom;
35722|       |    int error_state;
35723|       |    BOOL allow_sab : 8;
35724|       |    BOOL allow_bytecode : 8;
35725|       |    BOOL is_rom_data : 8;
35726|       |    BOOL allow_reference : 8;
35727|       |    /* object references */
35728|       |    JSObject **objects;
35729|       |    int objects_count;
35730|       |    int objects_size;
35731|       |
35732|       |#ifdef DUMP_READ_OBJECT
35733|       |    const uint8_t *ptr_last;
35734|       |    int level;
35735|       |#endif
35736|       |} BCReaderState;
35737|       |
35738|       |#ifdef DUMP_READ_OBJECT
35739|       |static void __attribute__((format(printf, 2, 3))) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
35740|       |    va_list ap;
35741|       |    int i, n, n0;
35742|       |
35743|       |    if (!s->ptr_last)
35744|       |        s->ptr_last = s->buf_start;
35745|       |
35746|       |    n = n0 = 0;
35747|       |    if (s->ptr > s->ptr_last || s->ptr == s->buf_start) {
35748|       |        n0 = printf("%04x: ", (int)(s->ptr_last - s->buf_start));
35749|       |        n += n0;
35750|       |    }
35751|       |    for (i = 0; s->ptr_last < s->ptr; i++) {
35752|       |        if ((i & 7) == 0 && i > 0) {
35753|       |            printf("\n%*s", n0, "");
35754|       |            n = n0;
35755|       |        }
35756|       |        n += printf(" %02x", *s->ptr_last++);
35757|       |    }
35758|       |    if (*fmt == '}')
35759|       |        s->level--;
35760|       |    if (n < 32 + s->level * 2) {
35761|       |        printf("%*s", 32 + s->level * 2 - n, "");
35762|       |    }
35763|       |    va_start(ap, fmt);
35764|       |    vfprintf(stdout, fmt, ap);
35765|       |    va_end(ap);
35766|       |    if (strchr(fmt, '{'))
35767|       |        s->level++;
35768|       |}
35769|       |#else
35770|       |#define bc_read_trace(...)
35771|       |#endif
35772|       |
35773|       |static int bc_read_error_end(BCReaderState *s)
35774|      0|{
35775|      0|    if (!s->error_state) {
35776|      0|        JS_ThrowSyntaxError(s->ctx, "read after the end of the buffer");
35777|      0|    }
35778|      0|    return s->error_state = -1;
35779|      0|}
35780|       |
35781|       |static int bc_get_u8(BCReaderState *s, uint8_t *pval)
35782|      0|{
35783|      0|    if (unlikely(s->buf_end - s->ptr < 1)) {
35784|      0|        *pval = 0; /* avoid warning */
35785|      0|        return bc_read_error_end(s);
35786|      0|    }
35787|      0|    *pval = *s->ptr++;
35788|      0|    return 0;
35789|      0|}
35790|       |
35791|       |static int bc_get_u16(BCReaderState *s, uint16_t *pval)
35792|      0|{
35793|      0|    uint16_t v;
35794|      0|    if (unlikely(s->buf_end - s->ptr < 2)) {
35795|      0|        *pval = 0; /* avoid warning */
35796|      0|        return bc_read_error_end(s);
35797|      0|    }
35798|      0|    v = get_u16(s->ptr);
35799|      0|    if (is_be())
35800|      0|        v = bswap16(v);
35801|      0|    *pval = v;
35802|      0|    s->ptr += 2;
35803|      0|    return 0;
35804|      0|}
35805|       |
35806|       |static __maybe_unused int bc_get_u32(BCReaderState *s, uint32_t *pval)
35807|      0|{
35808|      0|    uint32_t v;
35809|      0|    if (unlikely(s->buf_end - s->ptr < 4)) {
35810|      0|        *pval = 0; /* avoid warning */
35811|      0|        return bc_read_error_end(s);
35812|      0|    }
35813|      0|    v = get_u32(s->ptr);
35814|      0|    if (is_be())
35815|      0|        v = bswap32(v);
35816|      0|    *pval = v;
35817|      0|    s->ptr += 4;
35818|      0|    return 0;
35819|      0|}
35820|       |
35821|       |static int bc_get_u64(BCReaderState *s, uint64_t *pval)
35822|      0|{
35823|      0|    uint64_t v;
35824|      0|    if (unlikely(s->buf_end - s->ptr < 8)) {
35825|      0|        *pval = 0; /* avoid warning */
35826|      0|        return bc_read_error_end(s);
35827|      0|    }
35828|      0|    v = get_u64(s->ptr);
35829|      0|    if (is_be())
35830|      0|        v = bswap64(v);
35831|      0|    *pval = v;
35832|      0|    s->ptr += 8;
35833|      0|    return 0;
35834|      0|}
35835|       |
35836|       |static int bc_get_leb128(BCReaderState *s, uint32_t *pval)
35837|      0|{
35838|      0|    int ret;
35839|      0|    ret = get_leb128(pval, s->ptr, s->buf_end);
35840|      0|    if (unlikely(ret < 0))
35841|      0|        return bc_read_error_end(s);
35842|      0|    s->ptr += ret;
35843|      0|    return 0;
35844|      0|}
35845|       |
35846|       |static int bc_get_sleb128(BCReaderState *s, int32_t *pval)
35847|      0|{
35848|      0|    int ret;
35849|      0|    ret = get_sleb128(pval, s->ptr, s->buf_end);
35850|      0|    if (unlikely(ret < 0))
35851|      0|        return bc_read_error_end(s);
35852|      0|    s->ptr += ret;
35853|      0|    return 0;
35854|      0|}
35855|       |
35856|       |/* XXX: used to read an `int` with a positive value */
35857|       |static int bc_get_leb128_int(BCReaderState *s, int *pval)
35858|      0|{
35859|      0|    return bc_get_leb128(s, (uint32_t *)pval);
35860|      0|}
35861|       |
35862|       |static int bc_get_leb128_u16(BCReaderState *s, uint16_t *pval)
35863|      0|{
35864|      0|    uint32_t val;
35865|      0|    if (bc_get_leb128(s, &val)) {
35866|      0|        *pval = 0;
35867|      0|        return -1;
35868|      0|    }
35869|      0|    *pval = val;
35870|      0|    return 0;
35871|      0|}
35872|       |
35873|       |static int bc_get_buf(BCReaderState *s, uint8_t *buf, uint32_t buf_len)
35874|      0|{
35875|      0|    if (buf_len != 0) {
35876|      0|        if (unlikely(!buf || s->buf_end - s->ptr < buf_len))
35877|      0|            return bc_read_error_end(s);
35878|      0|        memcpy(buf, s->ptr, buf_len);
35879|      0|        s->ptr += buf_len;
35880|      0|    }
35881|      0|    return 0;
35882|      0|}
35883|       |
35884|       |static int bc_idx_to_atom(BCReaderState *s, JSAtom *patom, uint32_t idx)
35885|      0|{
35886|      0|    JSAtom atom;
35887|       |
35888|      0|    if (__JS_AtomIsTaggedInt(idx)) {
35889|      0|        atom = idx;
35890|      0|    } else if (idx < s->first_atom) {
35891|      0|        atom = JS_DupAtom(s->ctx, idx);
35892|      0|    } else {
35893|      0|        idx -= s->first_atom;
35894|      0|        if (idx >= s->idx_to_atom_count) {
35895|      0|            JS_ThrowSyntaxError(s->ctx, "invalid atom index (pos=%u)",
35896|      0|                                (unsigned int)(s->ptr - s->buf_start));
35897|      0|            *patom = JS_ATOM_NULL;
35898|      0|            return s->error_state = -1;
35899|      0|        }
35900|      0|        atom = JS_DupAtom(s->ctx, s->idx_to_atom[idx]);
35901|      0|    }
35902|      0|    *patom = atom;
35903|      0|    return 0;
35904|      0|}
35905|       |
35906|       |static int bc_get_atom(BCReaderState *s, JSAtom *patom)
35907|      0|{
35908|      0|    uint32_t v;
35909|      0|    if (bc_get_leb128(s, &v))
35910|      0|        return -1;
35911|      0|    if (v & 1) {
35912|      0|        *patom = __JS_AtomFromUInt32(v >> 1);
35913|      0|        return 0;
35914|      0|    } else {
35915|      0|        return bc_idx_to_atom(s, patom, v >> 1);
35916|      0|    }
35917|      0|}
35918|       |
35919|       |static JSString *JS_ReadString(BCReaderState *s)
35920|      0|{
35921|      0|    uint32_t len;
35922|      0|    size_t size;
35923|      0|    BOOL is_wide_char;
35924|      0|    JSString *p;
35925|       |
35926|      0|    if (bc_get_leb128(s, &len))
35927|      0|        return NULL;
35928|      0|    is_wide_char = len & 1;
35929|      0|    len >>= 1;
35930|      0|    if (len > JS_STRING_LEN_MAX) {
35931|      0|        JS_ThrowInternalError(s->ctx, "string too long");
35932|      0|        return NULL;
35933|      0|    }
35934|      0|    p = js_alloc_string(s->ctx, len, is_wide_char);
35935|      0|    if (!p) {
35936|      0|        s->error_state = -1;
35937|      0|        return NULL;
35938|      0|    }
35939|      0|    size = (size_t)len << is_wide_char;
35940|      0|    if ((s->buf_end - s->ptr) < size) {
35941|      0|        bc_read_error_end(s);
35942|      0|        js_free_string(s->ctx->rt, p);
35943|      0|        return NULL;
35944|      0|    }
35945|      0|    memcpy(p->u.str8, s->ptr, size);
35946|      0|    s->ptr += size;
35947|      0|    if (is_wide_char) {
35948|      0|        if (is_be()) {
35949|      0|            uint32_t i;
35950|      0|            for (i = 0; i < len; i++)
35951|      0|                p->u.str16[i] = bswap16(p->u.str16[i]);
35952|      0|        }
35953|      0|    } else {
35954|      0|        p->u.str8[size] = '\0'; /* add the trailing zero for 8 bit strings */
35955|      0|    }
35956|       |#ifdef DUMP_READ_OBJECT
35957|       |    JS_DumpString(s->ctx->rt, p); printf("\n");
35958|       |#endif
35959|      0|    return p;
35960|      0|}
35961|       |
35962|       |static uint32_t bc_get_flags(uint32_t flags, int *pidx, int n)
35963|      0|{
35964|      0|    uint32_t val;
35965|       |    /* XXX: this does not work for n == 32 */
35966|      0|    val = (flags >> *pidx) & ((1U << n) - 1);
35967|      0|    *pidx += n;
35968|      0|    return val;
35969|      0|}
35970|       |
35971|       |static int JS_ReadFunctionBytecode(BCReaderState *s, JSFunctionBytecode *b,
35972|       |                                   int byte_code_offset, uint32_t bc_len)
35973|      0|{
35974|      0|    uint8_t *bc_buf;
35975|      0|    int pos, len, op;
35976|      0|    JSAtom atom;
35977|      0|    uint32_t idx;
35978|       |
35979|      0|    if (s->is_rom_data) {
35980|       |        /* directly use the input buffer */
35981|      0|        if (unlikely(s->buf_end - s->ptr < bc_len))
35982|      0|            return bc_read_error_end(s);
35983|      0|        bc_buf = (uint8_t *)s->ptr;
35984|      0|        s->ptr += bc_len;
35985|      0|    } else {
35986|      0|        bc_buf = (void *)((uint8_t*)b + byte_code_offset);
35987|      0|        if (bc_get_buf(s, bc_buf, bc_len))
35988|      0|            return -1;
35989|      0|    }
35990|      0|    b->byte_code_buf = bc_buf;
35991|       |
35992|      0|    if (is_be())
35993|      0|        bc_byte_swap(bc_buf, bc_len);
35994|       |
35995|      0|    pos = 0;
35996|      0|    while (pos < bc_len) {
35997|      0|        op = bc_buf[pos];
35998|      0|        len = short_opcode_info(op).size;
35999|      0|        switch(short_opcode_info(op).fmt) {
36000|      0|        case OP_FMT_atom:
36001|      0|        case OP_FMT_atom_u8:
36002|      0|        case OP_FMT_atom_u16:
36003|      0|        case OP_FMT_atom_label_u8:
36004|      0|        case OP_FMT_atom_label_u16:
36005|      0|            idx = get_u32(bc_buf + pos + 1);
36006|      0|            if (s->is_rom_data) {
36007|       |                /* just increment the reference count of the atom */
36008|      0|                JS_DupAtom(s->ctx, (JSAtom)idx);
36009|      0|            } else {
36010|      0|                if (bc_idx_to_atom(s, &atom, idx)) {
36011|       |                    /* Note: the atoms will be freed up to this position */
36012|      0|                    b->byte_code_len = pos;
36013|      0|                    return -1;
36014|      0|                }
36015|      0|                put_u32(bc_buf + pos + 1, atom);
36016|       |#ifdef DUMP_READ_OBJECT
36017|       |                bc_read_trace(s, "at %d, fixup atom: ", pos + 1); print_atom(s->ctx, atom); printf("\n");
36018|       |#endif
36019|      0|            }
36020|      0|            break;
36021|      0|        default:
36022|      0|            break;
36023|      0|        }
36024|      0|        pos += len;
36025|      0|    }
36026|      0|    return 0;
36027|      0|}
36028|       |
36029|       |static JSValue JS_ReadBigInt(BCReaderState *s)
36030|      0|{
36031|      0|    JSValue obj = JS_UNDEFINED;
36032|      0|    uint32_t len, i, n;
36033|      0|    JSBigInt *p;
36034|      0|    js_limb_t v;
36035|      0|    uint8_t v8;
36036|       |    
36037|      0|    if (bc_get_leb128(s, &len))
36038|      0|        goto fail;
36039|      0|    bc_read_trace(s, "len=%" PRId64 "\n", (int64_t)len);
36040|      0|    if (len == 0) {
36041|       |        /* zero case */
36042|      0|        bc_read_trace(s, "}\n");
36043|      0|        return __JS_NewShortBigInt(s->ctx, 0);
36044|      0|    }
36045|      0|    p = js_bigint_new(s->ctx, (len - 1) / (JS_LIMB_BITS / 8) + 1);
36046|      0|    if (!p)
36047|      0|        goto fail;
36048|      0|    for(i = 0; i < len / (JS_LIMB_BITS / 8); i++) {
36049|       |#if JS_LIMB_BITS == 32
36050|       |        if (bc_get_u32(s, &v))
36051|       |            goto fail;
36052|       |#else
36053|      0|        if (bc_get_u64(s, &v))
36054|      0|            goto fail;
36055|      0|#endif
36056|      0|        p->tab[i] = v;
36057|      0|    }
36058|      0|    n = len % (JS_LIMB_BITS / 8);
36059|      0|    if (n != 0) {
36060|      0|        int shift;
36061|      0|        v = 0;
36062|      0|        for(i = 0; i < n; i++) {
36063|      0|            if (bc_get_u8(s, &v8))
36064|      0|                goto fail;
36065|      0|            v |= (js_limb_t)v8 << (i * 8);
36066|      0|        }
36067|      0|        shift = JS_LIMB_BITS - n * 8;
36068|       |        /* extend the sign */
36069|      0|        if (shift != 0) {
36070|      0|            v = (js_slimb_t)(v << shift) >> shift;
36071|      0|        }
36072|      0|        p->tab[p->len - 1] = v;
36073|      0|    }
36074|      0|    bc_read_trace(s, "}\n");
36075|      0|    return JS_CompactBigInt(s->ctx, p);
36076|      0| fail:
36077|      0|    JS_FreeValue(s->ctx, obj);
36078|      0|    return JS_EXCEPTION;
36079|      0|}
36080|       |
36081|       |static JSValue JS_ReadObjectRec(BCReaderState *s);
36082|       |
36083|       |static int BC_add_object_ref1(BCReaderState *s, JSObject *p)
36084|      0|{
36085|      0|    if (s->allow_reference) {
36086|      0|        if (js_resize_array(s->ctx, (void *)&s->objects,
36087|      0|                            sizeof(s->objects[0]),
36088|      0|                            &s->objects_size, s->objects_count + 1))
36089|      0|            return -1;
36090|      0|        s->objects[s->objects_count++] = p;
36091|      0|    }
36092|      0|    return 0;
36093|      0|}
36094|       |
36095|       |static int BC_add_object_ref(BCReaderState *s, JSValueConst obj)
36096|      0|{
36097|      0|    return BC_add_object_ref1(s, JS_VALUE_GET_OBJ(obj));
36098|      0|}
36099|       |
36100|       |static JSValue JS_ReadFunctionTag(BCReaderState *s)
36101|      0|{
36102|      0|    JSContext *ctx = s->ctx;
36103|      0|    JSFunctionBytecode bc, *b;
36104|      0|    JSValue obj = JS_UNDEFINED;
36105|      0|    uint16_t v16;
36106|      0|    uint8_t v8;
36107|      0|    int idx, i, local_count;
36108|      0|    int function_size, cpool_offset, byte_code_offset;
36109|      0|    int closure_var_offset, vardefs_offset;
36110|       |
36111|      0|    memset(&bc, 0, sizeof(bc));
36112|      0|    bc.header.ref_count = 1;
36113|       |    //bc.gc_header.mark = 0;
36114|       |
36115|      0|    if (bc_get_u16(s, &v16))
36116|      0|        goto fail;
36117|      0|    idx = 0;
36118|      0|    bc.has_prototype = bc_get_flags(v16, &idx, 1);
36119|      0|    bc.has_simple_parameter_list = bc_get_flags(v16, &idx, 1);
36120|      0|    bc.is_derived_class_constructor = bc_get_flags(v16, &idx, 1);
36121|      0|    bc.need_home_object = bc_get_flags(v16, &idx, 1);
36122|      0|    bc.func_kind = bc_get_flags(v16, &idx, 2);
36123|      0|    bc.new_target_allowed = bc_get_flags(v16, &idx, 1);
36124|      0|    bc.super_call_allowed = bc_get_flags(v16, &idx, 1);
36125|      0|    bc.super_allowed = bc_get_flags(v16, &idx, 1);
36126|      0|    bc.arguments_allowed = bc_get_flags(v16, &idx, 1);
36127|      0|    bc.has_debug = bc_get_flags(v16, &idx, 1);
36128|      0|    bc.is_direct_or_indirect_eval = bc_get_flags(v16, &idx, 1);
36129|      0|    bc.read_only_bytecode = s->is_rom_data;
36130|      0|    if (bc_get_u8(s, &v8))
36131|      0|        goto fail;
36132|      0|    bc.js_mode = v8;
36133|      0|    if (bc_get_atom(s, &bc.func_name))  //@ atom leak if failure
36134|      0|        goto fail;
36135|      0|    if (bc_get_leb128_u16(s, &bc.arg_count))
36136|      0|        goto fail;
36137|      0|    if (bc_get_leb128_u16(s, &bc.var_count))
36138|      0|        goto fail;
36139|      0|    if (bc_get_leb128_u16(s, &bc.defined_arg_count))
36140|      0|        goto fail;
36141|      0|    if (bc_get_leb128_u16(s, &bc.stack_size))
36142|      0|        goto fail;
36143|      0|    if (bc_get_leb128_int(s, &bc.closure_var_count))
36144|      0|        goto fail;
36145|      0|    if (bc_get_leb128_int(s, &bc.cpool_count))
36146|      0|        goto fail;
36147|      0|    if (bc_get_leb128_int(s, &bc.byte_code_len))
36148|      0|        goto fail;
36149|      0|    if (bc_get_leb128_int(s, &local_count))
36150|      0|        goto fail;
36151|       |
36152|      0|    if (bc.has_debug) {
36153|      0|        function_size = sizeof(*b);
36154|      0|    } else {
36155|      0|        function_size = offsetof(JSFunctionBytecode, debug);
36156|      0|    }
36157|      0|    cpool_offset = function_size;
36158|      0|    function_size += bc.cpool_count * sizeof(*bc.cpool);
36159|      0|    vardefs_offset = function_size;
36160|      0|    function_size += local_count * sizeof(*bc.vardefs);
36161|      0|    closure_var_offset = function_size;
36162|      0|    function_size += bc.closure_var_count * sizeof(*bc.closure_var);
36163|      0|    byte_code_offset = function_size;
36164|      0|    if (!bc.read_only_bytecode) {
36165|      0|        function_size += bc.byte_code_len;
36166|      0|    }
36167|       |
36168|      0|    b = js_mallocz(ctx, function_size);
36169|      0|    if (!b)
36170|      0|        return JS_EXCEPTION;
36171|       |
36172|      0|    memcpy(b, &bc, offsetof(JSFunctionBytecode, debug));
36173|      0|    b->header.ref_count = 1;
36174|      0|    if (local_count != 0) {
36175|      0|        b->vardefs = (void *)((uint8_t*)b + vardefs_offset);
36176|      0|    }
36177|      0|    if (b->closure_var_count != 0) {
36178|      0|        b->closure_var = (void *)((uint8_t*)b + closure_var_offset);
36179|      0|    }
36180|      0|    if (b->cpool_count != 0) {
36181|      0|        b->cpool = (void *)((uint8_t*)b + cpool_offset);
36182|      0|    }
36183|       |
36184|      0|    add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
36185|       |
36186|      0|    obj = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);
36187|       |
36188|       |#ifdef DUMP_READ_OBJECT
36189|       |    bc_read_trace(s, "name: "); print_atom(s->ctx, b->func_name); printf("\n");
36190|       |#endif
36191|      0|    bc_read_trace(s, "args=%d vars=%d defargs=%d closures=%d cpool=%d\n",
36192|      0|                  b->arg_count, b->var_count, b->defined_arg_count,
36193|      0|                  b->closure_var_count, b->cpool_count);
36194|      0|    bc_read_trace(s, "stack=%d bclen=%d locals=%d\n",
36195|      0|                  b->stack_size, b->byte_code_len, local_count);
36196|       |
36197|      0|    if (local_count != 0) {
36198|      0|        bc_read_trace(s, "vars {\n");
36199|      0|        for(i = 0; i < local_count; i++) {
36200|      0|            JSVarDef *vd = &b->vardefs[i];
36201|      0|            if (bc_get_atom(s, &vd->var_name))
36202|      0|                goto fail;
36203|      0|            if (bc_get_leb128_int(s, &vd->scope_level))
36204|      0|                goto fail;
36205|      0|            if (bc_get_leb128_int(s, &vd->scope_next))
36206|      0|                goto fail;
36207|      0|            vd->scope_next--;
36208|      0|            if (bc_get_u8(s, &v8))
36209|      0|                goto fail;
36210|      0|            idx = 0;
36211|      0|            vd->var_kind = bc_get_flags(v8, &idx, 4);
36212|      0|            vd->is_const = bc_get_flags(v8, &idx, 1);
36213|      0|            vd->is_lexical = bc_get_flags(v8, &idx, 1);
36214|      0|            vd->is_captured = bc_get_flags(v8, &idx, 1);
36215|       |#ifdef DUMP_READ_OBJECT
36216|       |            bc_read_trace(s, "name: "); print_atom(s->ctx, vd->var_name); printf("\n");
36217|       |#endif
36218|      0|        }
36219|      0|        bc_read_trace(s, "}\n");
36220|      0|    }
36221|      0|    if (b->closure_var_count != 0) {
36222|      0|        bc_read_trace(s, "closure vars {\n");
36223|      0|        for(i = 0; i < b->closure_var_count; i++) {
36224|      0|            JSClosureVar *cv = &b->closure_var[i];
36225|      0|            int var_idx;
36226|      0|            if (bc_get_atom(s, &cv->var_name))
36227|      0|                goto fail;
36228|      0|            if (bc_get_leb128_int(s, &var_idx))
36229|      0|                goto fail;
36230|      0|            cv->var_idx = var_idx;
36231|      0|            if (bc_get_u8(s, &v8))
36232|      0|                goto fail;
36233|      0|            idx = 0;
36234|      0|            cv->is_local = bc_get_flags(v8, &idx, 1);
36235|      0|            cv->is_arg = bc_get_flags(v8, &idx, 1);
36236|      0|            cv->is_const = bc_get_flags(v8, &idx, 1);
36237|      0|            cv->is_lexical = bc_get_flags(v8, &idx, 1);
36238|      0|            cv->var_kind = bc_get_flags(v8, &idx, 4);
36239|       |#ifdef DUMP_READ_OBJECT
36240|       |            bc_read_trace(s, "name: "); print_atom(s->ctx, cv->var_name); printf("\n");
36241|       |#endif
36242|      0|        }
36243|      0|        bc_read_trace(s, "}\n");
36244|      0|    }
36245|      0|    {
36246|      0|        bc_read_trace(s, "bytecode {\n");
36247|      0|        if (JS_ReadFunctionBytecode(s, b, byte_code_offset, b->byte_code_len))
36248|      0|            goto fail;
36249|      0|        bc_read_trace(s, "}\n");
36250|      0|    }
36251|      0|    if (b->has_debug) {
36252|       |        /* read optional debug information */
36253|      0|        bc_read_trace(s, "debug {\n");
36254|      0|        if (bc_get_atom(s, &b->debug.filename))
36255|      0|            goto fail;
36256|       |#ifdef DUMP_READ_OBJECT
36257|       |        bc_read_trace(s, "filename: "); print_atom(s->ctx, b->debug.filename); printf("\n");
36258|       |#endif
36259|      0|        if (bc_get_leb128_int(s, &b->debug.pc2line_len))
36260|      0|            goto fail;
36261|      0|        if (b->debug.pc2line_len) {
36262|      0|            b->debug.pc2line_buf = js_mallocz(ctx, b->debug.pc2line_len);
36263|      0|            if (!b->debug.pc2line_buf)
36264|      0|                goto fail;
36265|      0|            if (bc_get_buf(s, b->debug.pc2line_buf, b->debug.pc2line_len))
36266|      0|                goto fail;
36267|      0|        }
36268|      0|        if (bc_get_leb128_int(s, &b->debug.source_len))
36269|      0|            goto fail;
36270|      0|        if (b->debug.source_len) {
36271|      0|            bc_read_trace(s, "source: %d bytes\n", b->source_len);
36272|      0|            b->debug.source = js_mallocz(ctx, b->debug.source_len);
36273|      0|            if (!b->debug.source)
36274|      0|                goto fail;
36275|      0|            if (bc_get_buf(s, (uint8_t *)b->debug.source, b->debug.source_len))
36276|      0|                goto fail;
36277|      0|        }
36278|      0|        bc_read_trace(s, "}\n");
36279|      0|    }
36280|      0|    if (b->cpool_count != 0) {
36281|      0|        bc_read_trace(s, "cpool {\n");
36282|      0|        for(i = 0; i < b->cpool_count; i++) {
36283|      0|            JSValue val;
36284|      0|            val = JS_ReadObjectRec(s);
36285|      0|            if (JS_IsException(val))
36286|      0|                goto fail;
36287|      0|            b->cpool[i] = val;
36288|      0|        }
36289|      0|        bc_read_trace(s, "}\n");
36290|      0|    }
36291|      0|    b->realm = JS_DupContext(ctx);
36292|      0|    return obj;
36293|      0| fail:
36294|      0|    JS_FreeValue(ctx, obj);
36295|      0|    return JS_EXCEPTION;
36296|      0|}
36297|       |
36298|       |static JSValue JS_ReadModule(BCReaderState *s)
36299|      0|{
36300|      0|    JSContext *ctx = s->ctx;
36301|      0|    JSValue obj;
36302|      0|    JSModuleDef *m = NULL;
36303|      0|    JSAtom module_name;
36304|      0|    int i;
36305|      0|    uint8_t v8;
36306|       |
36307|      0|    if (bc_get_atom(s, &module_name))
36308|      0|        goto fail;
36309|       |#ifdef DUMP_READ_OBJECT
36310|       |    bc_read_trace(s, "name: "); print_atom(s->ctx, module_name); printf("\n");
36311|       |#endif
36312|      0|    m = js_new_module_def(ctx, module_name);
36313|      0|    if (!m)
36314|      0|        goto fail;
36315|      0|    obj = JS_NewModuleValue(ctx, m);
36316|      0|    if (bc_get_leb128_int(s, &m->req_module_entries_count))
36317|      0|        goto fail;
36318|      0|    if (m->req_module_entries_count != 0) {
36319|      0|        m->req_module_entries_size = m->req_module_entries_count;
36320|      0|        m->req_module_entries = js_mallocz(ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size);
36321|      0|        if (!m->req_module_entries)
36322|      0|            goto fail;
36323|      0|        for(i = 0; i < m->req_module_entries_count; i++) {
36324|      0|            JSReqModuleEntry *rme = &m->req_module_entries[i];
36325|      0|            if (bc_get_atom(s, &rme->module_name))
36326|      0|                goto fail;
36327|      0|        }
36328|      0|    }
36329|       |
36330|      0|    if (bc_get_leb128_int(s, &m->export_entries_count))
36331|      0|        goto fail;
36332|      0|    if (m->export_entries_count != 0) {
36333|      0|        m->export_entries_size = m->export_entries_count;
36334|      0|        m->export_entries = js_mallocz(ctx, sizeof(m->export_entries[0]) * m->export_entries_size);
36335|      0|        if (!m->export_entries)
36336|      0|            goto fail;
36337|      0|        for(i = 0; i < m->export_entries_count; i++) {
36338|      0|            JSExportEntry *me = &m->export_entries[i];
36339|      0|            if (bc_get_u8(s, &v8))
36340|      0|                goto fail;
36341|      0|            me->export_type = v8;
36342|      0|            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
36343|      0|                if (bc_get_leb128_int(s, &me->u.local.var_idx))
36344|      0|                    goto fail;
36345|      0|            } else {
36346|      0|                if (bc_get_leb128_int(s, &me->u.req_module_idx))
36347|      0|                    goto fail;
36348|      0|                if (bc_get_atom(s, &me->local_name))
36349|      0|                    goto fail;
36350|      0|            }
36351|      0|            if (bc_get_atom(s, &me->export_name))
36352|      0|                goto fail;
36353|      0|        }
36354|      0|    }
36355|       |
36356|      0|    if (bc_get_leb128_int(s, &m->star_export_entries_count))
36357|      0|        goto fail;
36358|      0|    if (m->star_export_entries_count != 0) {
36359|      0|        m->star_export_entries_size = m->star_export_entries_count;
36360|      0|        m->star_export_entries = js_mallocz(ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size);
36361|      0|        if (!m->star_export_entries)
36362|      0|            goto fail;
36363|      0|        for(i = 0; i < m->star_export_entries_count; i++) {
36364|      0|            JSStarExportEntry *se = &m->star_export_entries[i];
36365|      0|            if (bc_get_leb128_int(s, &se->req_module_idx))
36366|      0|                goto fail;
36367|      0|        }
36368|      0|    }
36369|       |
36370|      0|    if (bc_get_leb128_int(s, &m->import_entries_count))
36371|      0|        goto fail;
36372|      0|    if (m->import_entries_count != 0) {
36373|      0|        m->import_entries_size = m->import_entries_count;
36374|      0|        m->import_entries = js_mallocz(ctx, sizeof(m->import_entries[0]) * m->import_entries_size);
36375|      0|        if (!m->import_entries)
36376|      0|            goto fail;
36377|      0|        for(i = 0; i < m->import_entries_count; i++) {
36378|      0|            JSImportEntry *mi = &m->import_entries[i];
36379|      0|            if (bc_get_leb128_int(s, &mi->var_idx))
36380|      0|                goto fail;
36381|      0|            if (bc_get_atom(s, &mi->import_name))
36382|      0|                goto fail;
36383|      0|            if (bc_get_leb128_int(s, &mi->req_module_idx))
36384|      0|                goto fail;
36385|      0|        }
36386|      0|    }
36387|       |
36388|      0|    if (bc_get_u8(s, &v8))
36389|      0|        goto fail;
36390|      0|    m->has_tla = (v8 != 0);
36391|       |
36392|      0|    m->func_obj = JS_ReadObjectRec(s);
36393|      0|    if (JS_IsException(m->func_obj))
36394|      0|        goto fail;
36395|      0|    return obj;
36396|      0| fail:
36397|      0|    if (m) {
36398|      0|        js_free_module_def(ctx, m);
36399|      0|    }
36400|      0|    return JS_EXCEPTION;
36401|      0|}
36402|       |
36403|       |static JSValue JS_ReadObjectTag(BCReaderState *s)
36404|      0|{
36405|      0|    JSContext *ctx = s->ctx;
36406|      0|    JSValue obj;
36407|      0|    uint32_t prop_count, i;
36408|      0|    JSAtom atom;
36409|      0|    JSValue val;
36410|      0|    int ret;
36411|       |
36412|      0|    obj = JS_NewObject(ctx);
36413|      0|    if (BC_add_object_ref(s, obj))
36414|      0|        goto fail;
36415|      0|    if (bc_get_leb128(s, &prop_count))
36416|      0|        goto fail;
36417|      0|    for(i = 0; i < prop_count; i++) {
36418|      0|        if (bc_get_atom(s, &atom))
36419|      0|            goto fail;
36420|       |#ifdef DUMP_READ_OBJECT
36421|       |        bc_read_trace(s, "propname: "); print_atom(s->ctx, atom); printf("\n");
36422|       |#endif
36423|      0|        val = JS_ReadObjectRec(s);
36424|      0|        if (JS_IsException(val)) {
36425|      0|            JS_FreeAtom(ctx, atom);
36426|      0|            goto fail;
36427|      0|        }
36428|      0|        ret = JS_DefinePropertyValue(ctx, obj, atom, val, JS_PROP_C_W_E);
36429|      0|        JS_FreeAtom(ctx, atom);
36430|      0|        if (ret < 0)
36431|      0|            goto fail;
36432|      0|    }
36433|      0|    return obj;
36434|      0| fail:
36435|      0|    JS_FreeValue(ctx, obj);
36436|      0|    return JS_EXCEPTION;
36437|      0|}
36438|       |
36439|       |static JSValue JS_ReadArray(BCReaderState *s, int tag)
36440|      0|{
36441|      0|    JSContext *ctx = s->ctx;
36442|      0|    JSValue obj;
36443|      0|    uint32_t len, i;
36444|      0|    JSValue val;
36445|      0|    int ret, prop_flags;
36446|      0|    BOOL is_template;
36447|       |
36448|      0|    obj = JS_NewArray(ctx);
36449|      0|    if (BC_add_object_ref(s, obj))
36450|      0|        goto fail;
36451|      0|    is_template = (tag == BC_TAG_TEMPLATE_OBJECT);
36452|      0|    if (bc_get_leb128(s, &len))
36453|      0|        goto fail;
36454|      0|    for(i = 0; i < len; i++) {
36455|      0|        val = JS_ReadObjectRec(s);
36456|      0|        if (JS_IsException(val))
36457|      0|            goto fail;
36458|      0|        if (is_template)
36459|      0|            prop_flags = JS_PROP_ENUMERABLE;
36460|      0|        else
36461|      0|            prop_flags = JS_PROP_C_W_E;
36462|      0|        ret = JS_DefinePropertyValueUint32(ctx, obj, i, val,
36463|      0|                                           prop_flags);
36464|      0|        if (ret < 0)
36465|      0|            goto fail;
36466|      0|    }
36467|      0|    if (is_template) {
36468|      0|        val = JS_ReadObjectRec(s);
36469|      0|        if (JS_IsException(val))
36470|      0|            goto fail;
36471|      0|        if (!JS_IsUndefined(val)) {
36472|      0|            ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_raw, val, 0);
36473|      0|            if (ret < 0)
36474|      0|                goto fail;
36475|      0|        }
36476|      0|        JS_PreventExtensions(ctx, obj);
36477|      0|    }
36478|      0|    return obj;
36479|      0| fail:
36480|      0|    JS_FreeValue(ctx, obj);
36481|      0|    return JS_EXCEPTION;
36482|      0|}
36483|       |
36484|       |static JSValue JS_ReadTypedArray(BCReaderState *s)
36485|      0|{
36486|      0|    JSContext *ctx = s->ctx;
36487|      0|    JSValue obj = JS_UNDEFINED, array_buffer = JS_UNDEFINED;
36488|      0|    uint8_t array_tag;
36489|      0|    JSValueConst args[3];
36490|      0|    uint32_t offset, len, idx;
36491|       |
36492|      0|    if (bc_get_u8(s, &array_tag))
36493|      0|        return JS_EXCEPTION;
36494|      0|    if (array_tag >= JS_TYPED_ARRAY_COUNT)
36495|      0|        return JS_ThrowTypeError(ctx, "invalid typed array");
36496|      0|    if (bc_get_leb128(s, &len))
36497|      0|        return JS_EXCEPTION;
36498|      0|    if (bc_get_leb128(s, &offset))
36499|      0|        return JS_EXCEPTION;
36500|       |    /* XXX: this hack could be avoided if the typed array could be
36501|       |       created before the array buffer */
36502|      0|    idx = s->objects_count;
36503|      0|    if (BC_add_object_ref1(s, NULL))
36504|      0|        goto fail;
36505|      0|    array_buffer = JS_ReadObjectRec(s);
36506|      0|    if (JS_IsException(array_buffer))
36507|      0|        return JS_EXCEPTION;
36508|      0|    if (!js_get_array_buffer(ctx, array_buffer)) {
36509|      0|        JS_FreeValue(ctx, array_buffer);
36510|      0|        return JS_EXCEPTION;
36511|      0|    }
36512|      0|    args[0] = array_buffer;
36513|      0|    args[1] = JS_NewInt64(ctx, offset);
36514|      0|    args[2] = JS_NewInt64(ctx, len);
36515|      0|    obj = js_typed_array_constructor(ctx, JS_UNDEFINED,
36516|      0|                                     3, args,
36517|      0|                                     JS_CLASS_UINT8C_ARRAY + array_tag);
36518|      0|    if (JS_IsException(obj))
36519|      0|        goto fail;
36520|      0|    if (s->allow_reference) {
36521|      0|        s->objects[idx] = JS_VALUE_GET_OBJ(obj);
36522|      0|    }
36523|      0|    JS_FreeValue(ctx, array_buffer);
36524|      0|    return obj;
36525|      0| fail:
36526|      0|    JS_FreeValue(ctx, array_buffer);
36527|      0|    JS_FreeValue(ctx, obj);
36528|      0|    return JS_EXCEPTION;
36529|      0|}
36530|       |
36531|       |static JSValue JS_ReadArrayBuffer(BCReaderState *s)
36532|      0|{
36533|      0|    JSContext *ctx = s->ctx;
36534|      0|    uint32_t byte_length;
36535|      0|    JSValue obj;
36536|       |
36537|      0|    if (bc_get_leb128(s, &byte_length))
36538|      0|        return JS_EXCEPTION;
36539|      0|    if (unlikely(s->buf_end - s->ptr < byte_length)) {
36540|      0|        bc_read_error_end(s);
36541|      0|        return JS_EXCEPTION;
36542|      0|    }
36543|      0|    obj = JS_NewArrayBufferCopy(ctx, s->ptr, byte_length);
36544|      0|    if (JS_IsException(obj))
36545|      0|        goto fail;
36546|      0|    if (BC_add_object_ref(s, obj))
36547|      0|        goto fail;
36548|      0|    s->ptr += byte_length;
36549|      0|    return obj;
36550|      0| fail:
36551|      0|    JS_FreeValue(ctx, obj);
36552|      0|    return JS_EXCEPTION;
36553|      0|}
36554|       |
36555|       |static JSValue JS_ReadSharedArrayBuffer(BCReaderState *s)
36556|      0|{
36557|      0|    JSContext *ctx = s->ctx;
36558|      0|    uint32_t byte_length;
36559|      0|    uint8_t *data_ptr;
36560|      0|    JSValue obj;
36561|      0|    uint64_t u64;
36562|       |
36563|      0|    if (bc_get_leb128(s, &byte_length))
36564|      0|        return JS_EXCEPTION;
36565|      0|    if (bc_get_u64(s, &u64))
36566|      0|        return JS_EXCEPTION;
36567|      0|    data_ptr = (uint8_t *)(uintptr_t)u64;
36568|       |    /* the SharedArrayBuffer is cloned */
36569|      0|    obj = js_array_buffer_constructor3(ctx, JS_UNDEFINED, byte_length,
36570|      0|                                       JS_CLASS_SHARED_ARRAY_BUFFER,
36571|      0|                                       data_ptr,
36572|      0|                                       NULL, NULL, FALSE);
36573|      0|    if (JS_IsException(obj))
36574|      0|        goto fail;
36575|      0|    if (BC_add_object_ref(s, obj))
36576|      0|        goto fail;
36577|      0|    return obj;
36578|      0| fail:
36579|      0|    JS_FreeValue(ctx, obj);
36580|      0|    return JS_EXCEPTION;
36581|      0|}
36582|       |
36583|       |static JSValue JS_ReadDate(BCReaderState *s)
36584|      0|{
36585|      0|    JSContext *ctx = s->ctx;
36586|      0|    JSValue val, obj = JS_UNDEFINED;
36587|       |
36588|      0|    val = JS_ReadObjectRec(s);
36589|      0|    if (JS_IsException(val))
36590|      0|        goto fail;
36591|      0|    if (!JS_IsNumber(val)) {
36592|      0|        JS_ThrowTypeError(ctx, "Number tag expected for date");
36593|      0|        goto fail;
36594|      0|    }
36595|      0|    obj = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_DATE],
36596|      0|                                 JS_CLASS_DATE);
36597|      0|    if (JS_IsException(obj))
36598|      0|        goto fail;
36599|      0|    if (BC_add_object_ref(s, obj))
36600|      0|        goto fail;
36601|      0|    JS_SetObjectData(ctx, obj, val);
36602|      0|    return obj;
36603|      0| fail:
36604|      0|    JS_FreeValue(ctx, val);
36605|      0|    JS_FreeValue(ctx, obj);
36606|      0|    return JS_EXCEPTION;
36607|      0|}
36608|       |
36609|       |static JSValue JS_ReadObjectValue(BCReaderState *s)
36610|      0|{
36611|      0|    JSContext *ctx = s->ctx;
36612|      0|    JSValue val, obj = JS_UNDEFINED;
36613|       |
36614|      0|    val = JS_ReadObjectRec(s);
36615|      0|    if (JS_IsException(val))
36616|      0|        goto fail;
36617|      0|    obj = JS_ToObject(ctx, val);
36618|      0|    if (JS_IsException(obj))
36619|      0|        goto fail;
36620|      0|    if (BC_add_object_ref(s, obj))
36621|      0|        goto fail;
36622|      0|    JS_FreeValue(ctx, val);
36623|      0|    return obj;
36624|      0| fail:
36625|      0|    JS_FreeValue(ctx, val);
36626|      0|    JS_FreeValue(ctx, obj);
36627|      0|    return JS_EXCEPTION;
36628|      0|}
36629|       |
36630|       |static JSValue JS_ReadObjectRec(BCReaderState *s)
36631|      0|{
36632|      0|    JSContext *ctx = s->ctx;
36633|      0|    uint8_t tag;
36634|      0|    JSValue obj = JS_UNDEFINED;
36635|       |
36636|      0|    if (js_check_stack_overflow(ctx->rt, 0))
36637|      0|        return JS_ThrowStackOverflow(ctx);
36638|       |
36639|      0|    if (bc_get_u8(s, &tag))
36640|      0|        return JS_EXCEPTION;
36641|       |
36642|      0|    bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
36643|       |
36644|      0|    switch(tag) {
36645|      0|    case BC_TAG_NULL:
36646|      0|        obj = JS_NULL;
36647|      0|        break;
36648|      0|    case BC_TAG_UNDEFINED:
36649|      0|        obj = JS_UNDEFINED;
36650|      0|        break;
36651|      0|    case BC_TAG_BOOL_FALSE:
36652|      0|    case BC_TAG_BOOL_TRUE:
36653|      0|        obj = JS_NewBool(ctx, tag - BC_TAG_BOOL_FALSE);
36654|      0|        break;
36655|      0|    case BC_TAG_INT32:
36656|      0|        {
36657|      0|            int32_t val;
36658|      0|            if (bc_get_sleb128(s, &val))
36659|      0|                return JS_EXCEPTION;
36660|      0|            bc_read_trace(s, "%d\n", val);
36661|      0|            obj = JS_NewInt32(ctx, val);
36662|      0|        }
36663|      0|        break;
36664|      0|    case BC_TAG_FLOAT64:
36665|      0|        {
36666|      0|            JSFloat64Union u;
36667|      0|            if (bc_get_u64(s, &u.u64))
36668|      0|                return JS_EXCEPTION;
36669|      0|            bc_read_trace(s, "%g\n", u.d);
36670|      0|            obj = __JS_NewFloat64(ctx, u.d);
36671|      0|        }
36672|      0|        break;
36673|      0|    case BC_TAG_STRING:
36674|      0|        {
36675|      0|            JSString *p;
36676|      0|            p = JS_ReadString(s);
36677|      0|            if (!p)
36678|      0|                return JS_EXCEPTION;
36679|      0|            obj = JS_MKPTR(JS_TAG_STRING, p);
36680|      0|        }
36681|      0|        break;
36682|      0|    case BC_TAG_FUNCTION_BYTECODE:
36683|      0|        if (!s->allow_bytecode)
36684|      0|            goto invalid_tag;
36685|      0|        obj = JS_ReadFunctionTag(s);
36686|      0|        break;
36687|      0|    case BC_TAG_MODULE:
36688|      0|        if (!s->allow_bytecode)
36689|      0|            goto invalid_tag;
36690|      0|        obj = JS_ReadModule(s);
36691|      0|        break;
36692|      0|    case BC_TAG_OBJECT:
36693|      0|        obj = JS_ReadObjectTag(s);
36694|      0|        break;
36695|      0|    case BC_TAG_ARRAY:
36696|      0|    case BC_TAG_TEMPLATE_OBJECT:
36697|      0|        obj = JS_ReadArray(s, tag);
36698|      0|        break;
36699|      0|    case BC_TAG_TYPED_ARRAY:
36700|      0|        obj = JS_ReadTypedArray(s);
36701|      0|        break;
36702|      0|    case BC_TAG_ARRAY_BUFFER:
36703|      0|        obj = JS_ReadArrayBuffer(s);
36704|      0|        break;
36705|      0|    case BC_TAG_SHARED_ARRAY_BUFFER:
36706|      0|        if (!s->allow_sab || !ctx->rt->sab_funcs.sab_dup)
36707|      0|            goto invalid_tag;
36708|      0|        obj = JS_ReadSharedArrayBuffer(s);
36709|      0|        break;
36710|      0|    case BC_TAG_DATE:
36711|      0|        obj = JS_ReadDate(s);
36712|      0|        break;
36713|      0|    case BC_TAG_OBJECT_VALUE:
36714|      0|        obj = JS_ReadObjectValue(s);
36715|      0|        break;
36716|      0|    case BC_TAG_BIG_INT:
36717|      0|        obj = JS_ReadBigInt(s);
36718|      0|        break;
36719|      0|    case BC_TAG_OBJECT_REFERENCE:
36720|      0|        {
36721|      0|            uint32_t val;
36722|      0|            if (!s->allow_reference)
36723|      0|                return JS_ThrowSyntaxError(ctx, "object references are not allowed");
36724|      0|            if (bc_get_leb128(s, &val))
36725|      0|                return JS_EXCEPTION;
36726|      0|            bc_read_trace(s, "%u\n", val);
36727|      0|            if (val >= s->objects_count) {
36728|      0|                return JS_ThrowSyntaxError(ctx, "invalid object reference (%u >= %u)",
36729|      0|                                           val, s->objects_count);
36730|      0|            }
36731|      0|            obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, s->objects[val]));
36732|      0|        }
36733|      0|        break;
36734|      0|    default:
36735|      0|    invalid_tag:
36736|      0|        return JS_ThrowSyntaxError(ctx, "invalid tag (tag=%d pos=%u)",
36737|      0|                                   tag, (unsigned int)(s->ptr - s->buf_start));
36738|      0|    }
36739|      0|    bc_read_trace(s, "}\n");
36740|      0|    return obj;
36741|      0|}
36742|       |
36743|       |static int JS_ReadObjectAtoms(BCReaderState *s)
36744|      0|{
36745|      0|    uint8_t v8;
36746|      0|    JSString *p;
36747|      0|    int i;
36748|      0|    JSAtom atom;
36749|       |
36750|      0|    if (bc_get_u8(s, &v8))
36751|      0|        return -1;
36752|      0|    if (v8 != BC_VERSION) {
36753|      0|        JS_ThrowSyntaxError(s->ctx, "invalid version (%d expected=%d)",
36754|      0|                            v8, BC_VERSION);
36755|      0|        return -1;
36756|      0|    }
36757|      0|    if (bc_get_leb128(s, &s->idx_to_atom_count))
36758|      0|        return -1;
36759|       |
36760|      0|    bc_read_trace(s, "%d atom indexes {\n", s->idx_to_atom_count);
36761|       |
36762|      0|    if (s->idx_to_atom_count != 0) {
36763|      0|        s->idx_to_atom = js_mallocz(s->ctx, s->idx_to_atom_count *
36764|      0|                                    sizeof(s->idx_to_atom[0]));
36765|      0|        if (!s->idx_to_atom)
36766|      0|            return s->error_state = -1;
36767|      0|    }
36768|      0|    for(i = 0; i < s->idx_to_atom_count; i++) {
36769|      0|        p = JS_ReadString(s);
36770|      0|        if (!p)
36771|      0|            return -1;
36772|      0|        atom = JS_NewAtomStr(s->ctx, p);
36773|      0|        if (atom == JS_ATOM_NULL)
36774|      0|            return s->error_state = -1;
36775|      0|        s->idx_to_atom[i] = atom;
36776|      0|        if (s->is_rom_data && (atom != (i + s->first_atom)))
36777|      0|            s->is_rom_data = FALSE; /* atoms must be relocated */
36778|      0|    }
36779|      0|    bc_read_trace(s, "}\n");
36780|      0|    return 0;
36781|      0|}
36782|       |
36783|       |static void bc_reader_free(BCReaderState *s)
36784|      0|{
36785|      0|    int i;
36786|      0|    if (s->idx_to_atom) {
36787|      0|        for(i = 0; i < s->idx_to_atom_count; i++) {
36788|      0|            JS_FreeAtom(s->ctx, s->idx_to_atom[i]);
36789|      0|        }
36790|      0|        js_free(s->ctx, s->idx_to_atom);
36791|      0|    }
36792|      0|    js_free(s->ctx, s->objects);
36793|      0|}
36794|       |
36795|       |JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
36796|       |                       int flags)
36797|      0|{
36798|      0|    BCReaderState ss, *s = &ss;
36799|      0|    JSValue obj;
36800|       |
36801|      0|    ctx->binary_object_count += 1;
36802|      0|    ctx->binary_object_size += buf_len;
36803|       |
36804|      0|    memset(s, 0, sizeof(*s));
36805|      0|    s->ctx = ctx;
36806|      0|    s->buf_start = buf;
36807|      0|    s->buf_end = buf + buf_len;
36808|      0|    s->ptr = buf;
36809|      0|    s->allow_bytecode = ((flags & JS_READ_OBJ_BYTECODE) != 0);
36810|      0|    s->is_rom_data = ((flags & JS_READ_OBJ_ROM_DATA) != 0);
36811|      0|    s->allow_sab = ((flags & JS_READ_OBJ_SAB) != 0);
36812|      0|    s->allow_reference = ((flags & JS_READ_OBJ_REFERENCE) != 0);
36813|      0|    if (s->allow_bytecode)
36814|      0|        s->first_atom = JS_ATOM_END;
36815|      0|    else
36816|      0|        s->first_atom = 1;
36817|      0|    if (JS_ReadObjectAtoms(s)) {
36818|      0|        obj = JS_EXCEPTION;
36819|      0|    } else {
36820|      0|        obj = JS_ReadObjectRec(s);
36821|      0|    }
36822|      0|    bc_reader_free(s);
36823|      0|    return obj;
36824|      0|}
36825|       |
36826|       |/*******************************************************************/
36827|       |/* runtime functions & objects */
36828|       |
36829|       |static JSValue js_string_constructor(JSContext *ctx, JSValueConst this_val,
36830|       |                                     int argc, JSValueConst *argv);
36831|       |static JSValue js_boolean_constructor(JSContext *ctx, JSValueConst this_val,
36832|       |                                      int argc, JSValueConst *argv);
36833|       |static JSValue js_number_constructor(JSContext *ctx, JSValueConst this_val,
36834|       |                                     int argc, JSValueConst *argv);
36835|       |
36836|       |static int check_function(JSContext *ctx, JSValueConst obj)
36837|   155k|{
36838|   155k|    if (likely(JS_IsFunction(ctx, obj)))
36839|   155k|        return 0;
36840|      0|    JS_ThrowTypeError(ctx, "not a function");
36841|      0|    return -1;
36842|   155k|}
36843|       |
36844|       |static int check_exception_free(JSContext *ctx, JSValue obj)
36845|      0|{
36846|      0|    JS_FreeValue(ctx, obj);
36847|      0|    return JS_IsException(obj);
36848|      0|}
36849|       |
36850|       |static JSAtom find_atom(JSContext *ctx, const char *name)
36851|  7.60M|{
36852|  7.60M|    JSAtom atom;
36853|  7.60M|    int len;
36854|       |
36855|  7.60M|    if (*name == '[') {
36856|   835k|        name++;
36857|   835k|        len = strlen(name) - 1;
36858|       |        /* We assume 8 bit non null strings, which is the case for these
36859|       |           symbols */
36860|  6.07M|        for(atom = JS_ATOM_Symbol_toPrimitive; atom < JS_ATOM_END; atom++) {
36861|  6.07M|            JSAtomStruct *p = ctx->rt->atom_array[atom];
36862|  6.07M|            JSString *str = p;
36863|  6.07M|            if (str->len == len && !memcmp(str->u.str8, name, len))
36864|   835k|                return JS_DupAtom(ctx, atom);
36865|  6.07M|        }
36866|      0|        abort();
36867|  6.76M|    } else {
36868|  6.76M|        atom = JS_NewAtom(ctx, name);
36869|  6.76M|    }
36870|  6.76M|    return atom;
36871|  7.60M|}
36872|       |
36873|       |static JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,
36874|       |                                               JSAtom atom, void *opaque)
36875|   198k|{
36876|   198k|    const JSCFunctionListEntry *e = opaque;
36877|   198k|    JSValue val;
36878|       |
36879|   198k|    switch(e->def_type) {
36880|   198k|    case JS_DEF_CFUNC:
36881|   198k|        val = JS_NewCFunction2(ctx, e->u.func.cfunc.generic,
36882|   198k|                               e->name, e->u.func.length, e->u.func.cproto, e->magic);
36883|   198k|        break;
36884|      0|    case JS_DEF_PROP_STRING:
36885|      0|        val = JS_NewAtomString(ctx, e->u.str);
36886|      0|        break;
36887|      0|    case JS_DEF_OBJECT:
36888|      0|        val = JS_NewObject(ctx);
36889|      0|        JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);
36890|      0|        break;
36891|      0|    default:
36892|      0|        abort();
36893|   198k|    }
36894|   198k|    return val;
36895|   198k|}
36896|       |
36897|       |static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
36898|       |                                          JSAtom atom,
36899|       |                                          const JSCFunctionListEntry *e)
36900|  7.42M|{
36901|  7.42M|    JSValue val;
36902|  7.42M|    int prop_flags = e->prop_flags;
36903|       |
36904|  7.42M|    switch(e->def_type) {
36905|   177k|    case JS_DEF_ALIAS: /* using autoinit for aliases is not safe */
36906|   177k|        {
36907|   177k|            JSAtom atom1 = find_atom(ctx, e->u.alias.name);
36908|   177k|            switch (e->u.alias.base) {
36909|   142k|            case -1:
36910|   142k|                val = JS_GetProperty(ctx, obj, atom1);
36911|   142k|                break;
36912|  35.5k|            case 0:
36913|  35.5k|                val = JS_GetProperty(ctx, ctx->global_obj, atom1);
36914|  35.5k|                break;
36915|      0|            case 1:
36916|      0|                val = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_ARRAY], atom1);
36917|      0|                break;
36918|      0|            default:
36919|      0|                abort();
36920|   177k|            }
36921|   177k|            JS_FreeAtom(ctx, atom1);
36922|   177k|            if (atom == JS_ATOM_Symbol_toPrimitive) {
36923|       |                /* Symbol.toPrimitive functions are not writable */
36924|      0|                prop_flags = JS_PROP_CONFIGURABLE;
36925|   177k|            } else if (atom == JS_ATOM_Symbol_hasInstance) {
36926|       |                /* Function.prototype[Symbol.hasInstance] is not writable nor configurable */
36927|      0|                prop_flags = 0;
36928|      0|            }
36929|   177k|        }
36930|      0|        break;
36931|  5.91M|    case JS_DEF_CFUNC:
36932|  5.91M|        if (atom == JS_ATOM_Symbol_toPrimitive) {
36933|       |            /* Symbol.toPrimitive functions are not writable */
36934|  35.5k|            prop_flags = JS_PROP_CONFIGURABLE;
36935|  5.88M|        } else if (atom == JS_ATOM_Symbol_hasInstance) {
36936|       |            /* Function.prototype[Symbol.hasInstance] is not writable nor configurable */
36937|  17.7k|            prop_flags = 0;
36938|  17.7k|        }
36939|  5.91M|        JS_DefineAutoInitProperty(ctx, obj, atom, JS_AUTOINIT_ID_PROP,
36940|  5.91M|                                  (void *)e, prop_flags);
36941|  5.91M|        return 0;
36942|   266k|    case JS_DEF_CGETSET: /* XXX: use autoinit again ? */
36943|   604k|    case JS_DEF_CGETSET_MAGIC:
36944|   604k|        {
36945|   604k|            JSValue getter, setter;
36946|   604k|            char buf[64];
36947|       |
36948|   604k|            getter = JS_UNDEFINED;
36949|   604k|            if (e->u.getset.get.generic) {
36950|   604k|                snprintf(buf, sizeof(buf), "get %s", e->name);
36951|   604k|                getter = JS_NewCFunction2(ctx, e->u.getset.get.generic,
36952|   604k|                                          buf, 0, e->def_type == JS_DEF_CGETSET_MAGIC ? JS_CFUNC_getter_magic : JS_CFUNC_getter,
36953|   604k|                                          e->magic);
36954|   604k|            }
36955|   604k|            setter = JS_UNDEFINED;
36956|   604k|            if (e->u.getset.set.generic) {
36957|  17.7k|                snprintf(buf, sizeof(buf), "set %s", e->name);
36958|  17.7k|                setter = JS_NewCFunction2(ctx, e->u.getset.set.generic,
36959|  17.7k|                                          buf, 1, e->def_type == JS_DEF_CGETSET_MAGIC ? JS_CFUNC_setter_magic : JS_CFUNC_setter,
36960|  17.7k|                                          e->magic);
36961|  17.7k|            }
36962|   604k|            JS_DefinePropertyGetSet(ctx, obj, atom, getter, setter, prop_flags);
36963|   604k|            return 0;
36964|   266k|        }
36965|      0|        break;
36966|  17.7k|    case JS_DEF_PROP_INT32:
36967|  17.7k|        val = JS_NewInt32(ctx, e->u.i32);
36968|  17.7k|        break;
36969|      0|    case JS_DEF_PROP_INT64:
36970|      0|        val = JS_NewInt64(ctx, e->u.i64);
36971|      0|        break;
36972|   177k|    case JS_DEF_PROP_DOUBLE:
36973|   177k|        val = __JS_NewFloat64(ctx, e->u.f64);
36974|   177k|        break;
36975|  17.7k|    case JS_DEF_PROP_UNDEFINED:
36976|  17.7k|        val = JS_UNDEFINED;
36977|  17.7k|        break;
36978|   444k|    case JS_DEF_PROP_STRING:
36979|   515k|    case JS_DEF_OBJECT:
36980|   515k|        JS_DefineAutoInitProperty(ctx, obj, atom, JS_AUTOINIT_ID_PROP,
36981|   515k|                                  (void *)e, prop_flags);
36982|   515k|        return 0;
36983|      0|    default:
36984|      0|        abort();
36985|  7.42M|    }
36986|   390k|    JS_DefinePropertyValue(ctx, obj, atom, val, prop_flags);
36987|   390k|    return 0;
36988|  7.42M|}
36989|       |
36990|       |void JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,
36991|       |                                const JSCFunctionListEntry *tab, int len)
36992|   995k|{
36993|   995k|    int i;
36994|       |
36995|  8.42M|    for (i = 0; i < len; i++) {
36996|  7.42M|        const JSCFunctionListEntry *e = &tab[i];
36997|  7.42M|        JSAtom atom = find_atom(ctx, e->name);
36998|  7.42M|        JS_InstantiateFunctionListItem(ctx, obj, atom, e);
36999|  7.42M|        JS_FreeAtom(ctx, atom);
37000|  7.42M|    }
37001|   995k|}
37002|       |
37003|       |int JS_AddModuleExportList(JSContext *ctx, JSModuleDef *m,
37004|       |                           const JSCFunctionListEntry *tab, int len)
37005|  35.5k|{
37006|  35.5k|    int i;
37007|  1.70M|    for(i = 0; i < len; i++) {
37008|  1.67M|        if (JS_AddModuleExport(ctx, m, tab[i].name))
37009|      0|            return -1;
37010|  1.67M|    }
37011|  35.5k|    return 0;
37012|  35.5k|}
37013|       |
37014|       |int JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,
37015|       |                           const JSCFunctionListEntry *tab, int len)
37016|      0|{
37017|      0|    int i;
37018|      0|    JSValue val;
37019|       |
37020|      0|    for(i = 0; i < len; i++) {
37021|      0|        const JSCFunctionListEntry *e = &tab[i];
37022|      0|        switch(e->def_type) {
37023|      0|        case JS_DEF_CFUNC:
37024|      0|            val = JS_NewCFunction2(ctx, e->u.func.cfunc.generic,
37025|      0|                                   e->name, e->u.func.length, e->u.func.cproto, e->magic);
37026|      0|            break;
37027|      0|        case JS_DEF_PROP_STRING:
37028|      0|            val = JS_NewString(ctx, e->u.str);
37029|      0|            break;
37030|      0|        case JS_DEF_PROP_INT32:
37031|      0|            val = JS_NewInt32(ctx, e->u.i32);
37032|      0|            break;
37033|      0|        case JS_DEF_PROP_INT64:
37034|      0|            val = JS_NewInt64(ctx, e->u.i64);
37035|      0|            break;
37036|      0|        case JS_DEF_PROP_DOUBLE:
37037|      0|            val = __JS_NewFloat64(ctx, e->u.f64);
37038|      0|            break;
37039|      0|        case JS_DEF_OBJECT:
37040|      0|            val = JS_NewObject(ctx);
37041|      0|            JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);
37042|      0|            break;
37043|      0|        default:
37044|      0|            abort();
37045|      0|        }
37046|      0|        if (JS_SetModuleExport(ctx, m, e->name, val))
37047|      0|            return -1;
37048|      0|    }
37049|      0|    return 0;
37050|      0|}
37051|       |
37052|       |/* Note: 'func_obj' is not necessarily a constructor */
37053|       |static void JS_SetConstructor2(JSContext *ctx,
37054|       |                               JSValueConst func_obj,
37055|       |                               JSValueConst proto,
37056|       |                               int proto_flags, int ctor_flags)
37057|   817k|{
37058|   817k|    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_prototype,
37059|   817k|                           JS_DupValue(ctx, proto), proto_flags);
37060|   817k|    JS_DefinePropertyValue(ctx, proto, JS_ATOM_constructor,
37061|   817k|                           JS_DupValue(ctx, func_obj),
37062|   817k|                           ctor_flags);
37063|   817k|    set_cycle_flag(ctx, func_obj);
37064|   817k|    set_cycle_flag(ctx, proto);
37065|   817k|}
37066|       |
37067|       |void JS_SetConstructor(JSContext *ctx, JSValueConst func_obj,
37068|       |                       JSValueConst proto)
37069|   728k|{
37070|   728k|    JS_SetConstructor2(ctx, func_obj, proto,
37071|   728k|                       0, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
37072|   728k|}
37073|       |
37074|       |static void JS_NewGlobalCConstructor2(JSContext *ctx,
37075|       |                                      JSValue func_obj,
37076|       |                                      const char *name,
37077|       |                                      JSValueConst proto)
37078|   710k|{
37079|   710k|    JS_DefinePropertyValueStr(ctx, ctx->global_obj, name,
37080|   710k|                           JS_DupValue(ctx, func_obj),
37081|   710k|                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
37082|   710k|    JS_SetConstructor(ctx, func_obj, proto);
37083|   710k|    JS_FreeValue(ctx, func_obj);
37084|   710k|}
37085|       |
37086|       |static JSValueConst JS_NewGlobalCConstructor(JSContext *ctx, const char *name,
37087|       |                                             JSCFunction *func, int length,
37088|       |                                             JSValueConst proto)
37089|   195k|{
37090|   195k|    JSValue func_obj;
37091|   195k|    func_obj = JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_constructor_or_func, 0);
37092|   195k|    JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
37093|   195k|    return func_obj;
37094|   195k|}
37095|       |
37096|       |static JSValueConst JS_NewGlobalCConstructorOnly(JSContext *ctx, const char *name,
37097|       |                                                 JSCFunction *func, int length,
37098|       |                                                 JSValueConst proto)
37099|  53.3k|{
37100|  53.3k|    JSValue func_obj;
37101|  53.3k|    func_obj = JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_constructor, 0);
37102|  53.3k|    JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
37103|  53.3k|    return func_obj;
37104|  53.3k|}
37105|       |
37106|       |static JSValue js_global_eval(JSContext *ctx, JSValueConst this_val,
37107|       |                              int argc, JSValueConst *argv)
37108|      0|{
37109|      0|    return JS_EvalObject(ctx, ctx->global_obj, argv[0], JS_EVAL_TYPE_INDIRECT, -1);
37110|      0|}
37111|       |
37112|       |static JSValue js_global_isNaN(JSContext *ctx, JSValueConst this_val,
37113|       |                               int argc, JSValueConst *argv)
37114|      0|{
37115|      0|    double d;
37116|       |
37117|      0|    if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))
37118|      0|        return JS_EXCEPTION;
37119|      0|    return JS_NewBool(ctx, isnan(d));
37120|      0|}
37121|       |
37122|       |static JSValue js_global_isFinite(JSContext *ctx, JSValueConst this_val,
37123|       |                                  int argc, JSValueConst *argv)
37124|      0|{
37125|      0|    double d;
37126|      0|    if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))
37127|      0|        return JS_EXCEPTION;
37128|      0|    return JS_NewBool(ctx, isfinite(d));
37129|      0|}
37130|       |
37131|       |/* Object class */
37132|       |
37133|       |static JSValue JS_ToObject(JSContext *ctx, JSValueConst val)
37134|  3.45M|{
37135|  3.45M|    int tag = JS_VALUE_GET_NORM_TAG(val);
37136|  3.45M|    JSValue obj;
37137|       |
37138|  3.45M|    switch(tag) {
37139|      0|    default:
37140|      0|    case JS_TAG_NULL:
37141|      1|    case JS_TAG_UNDEFINED:
37142|      1|        return JS_ThrowTypeError(ctx, "cannot convert to object");
37143|  1.58M|    case JS_TAG_OBJECT:
37144|  1.58M|    case JS_TAG_EXCEPTION:
37145|  1.58M|        return JS_DupValue(ctx, val);
37146|   316k|    case JS_TAG_SHORT_BIG_INT:
37147|   318k|    case JS_TAG_BIG_INT:
37148|   318k|        obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_INT);
37149|   318k|        goto set_value;
37150|  1.04M|    case JS_TAG_INT:
37151|  1.04M|    case JS_TAG_FLOAT64:
37152|  1.04M|        obj = JS_NewObjectClass(ctx, JS_CLASS_NUMBER);
37153|  1.04M|        goto set_value;
37154|   195k|    case JS_TAG_STRING:
37155|   196k|    case JS_TAG_STRING_ROPE:
37156|       |        /* XXX: should call the string constructor */
37157|   196k|        {
37158|   196k|            JSValue str;
37159|   196k|            str = JS_ToString(ctx, val); /* ensure that we never store a rope */
37160|   196k|            if (JS_IsException(str))
37161|      0|                return JS_EXCEPTION;
37162|   196k|            obj = JS_NewObjectClass(ctx, JS_CLASS_STRING);
37163|   196k|            if (!JS_IsException(obj)) {
37164|   196k|                JS_DefinePropertyValue(ctx, obj, JS_ATOM_length,
37165|   196k|                                       JS_NewInt32(ctx, JS_VALUE_GET_STRING(str)->len), 0);
37166|   196k|                JS_SetObjectData(ctx, obj, JS_DupValue(ctx, str));
37167|   196k|            }
37168|   196k|            JS_FreeValue(ctx, str);
37169|   196k|            return obj;
37170|   196k|        }
37171|   306k|    case JS_TAG_BOOL:
37172|   306k|        obj = JS_NewObjectClass(ctx, JS_CLASS_BOOLEAN);
37173|   306k|        goto set_value;
37174|      0|    case JS_TAG_SYMBOL:
37175|      0|        obj = JS_NewObjectClass(ctx, JS_CLASS_SYMBOL);
37176|  1.67M|    set_value:
37177|  1.67M|        if (!JS_IsException(obj))
37178|  1.67M|            JS_SetObjectData(ctx, obj, JS_DupValue(ctx, val));
37179|  1.67M|        return obj;
37180|  3.45M|    }
37181|  3.45M|}
37182|       |
37183|       |static JSValue JS_ToObjectFree(JSContext *ctx, JSValue val)
37184|  1.86M|{
37185|  1.86M|    JSValue obj = JS_ToObject(ctx, val);
37186|  1.86M|    JS_FreeValue(ctx, val);
37187|  1.86M|    return obj;
37188|  1.86M|}
37189|       |
37190|       |static int js_obj_to_desc(JSContext *ctx, JSPropertyDescriptor *d,
37191|       |                          JSValueConst desc)
37192|      0|{
37193|      0|    JSValue val, getter, setter;
37194|      0|    int flags;
37195|       |
37196|      0|    if (!JS_IsObject(desc)) {
37197|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
37198|      0|        return -1;
37199|      0|    }
37200|      0|    flags = 0;
37201|      0|    val = JS_UNDEFINED;
37202|      0|    getter = JS_UNDEFINED;
37203|      0|    setter = JS_UNDEFINED;
37204|      0|    if (JS_HasProperty(ctx, desc, JS_ATOM_configurable)) {
37205|      0|        JSValue prop = JS_GetProperty(ctx, desc, JS_ATOM_configurable);
37206|      0|        if (JS_IsException(prop))
37207|      0|            goto fail;
37208|      0|        flags |= JS_PROP_HAS_CONFIGURABLE;
37209|      0|        if (JS_ToBoolFree(ctx, prop))
37210|      0|            flags |= JS_PROP_CONFIGURABLE;
37211|      0|    }
37212|      0|    if (JS_HasProperty(ctx, desc, JS_ATOM_writable)) {
37213|      0|        JSValue prop = JS_GetProperty(ctx, desc, JS_ATOM_writable);
37214|      0|        if (JS_IsException(prop))
37215|      0|            goto fail;
37216|      0|        flags |= JS_PROP_HAS_WRITABLE;
37217|      0|        if (JS_ToBoolFree(ctx, prop))
37218|      0|            flags |= JS_PROP_WRITABLE;
37219|      0|    }
37220|      0|    if (JS_HasProperty(ctx, desc, JS_ATOM_enumerable)) {
37221|      0|        JSValue prop = JS_GetProperty(ctx, desc, JS_ATOM_enumerable);
37222|      0|        if (JS_IsException(prop))
37223|      0|            goto fail;
37224|      0|        flags |= JS_PROP_HAS_ENUMERABLE;
37225|      0|        if (JS_ToBoolFree(ctx, prop))
37226|      0|            flags |= JS_PROP_ENUMERABLE;
37227|      0|    }
37228|      0|    if (JS_HasProperty(ctx, desc, JS_ATOM_value)) {
37229|      0|        flags |= JS_PROP_HAS_VALUE;
37230|      0|        val = JS_GetProperty(ctx, desc, JS_ATOM_value);
37231|      0|        if (JS_IsException(val))
37232|      0|            goto fail;
37233|      0|    }
37234|      0|    if (JS_HasProperty(ctx, desc, JS_ATOM_get)) {
37235|      0|        flags |= JS_PROP_HAS_GET;
37236|      0|        getter = JS_GetProperty(ctx, desc, JS_ATOM_get);
37237|      0|        if (JS_IsException(getter) ||
37238|      0|            !(JS_IsUndefined(getter) || JS_IsFunction(ctx, getter))) {
37239|      0|            JS_ThrowTypeError(ctx, "invalid getter");
37240|      0|            goto fail;
37241|      0|        }
37242|      0|    }
37243|      0|    if (JS_HasProperty(ctx, desc, JS_ATOM_set)) {
37244|      0|        flags |= JS_PROP_HAS_SET;
37245|      0|        setter = JS_GetProperty(ctx, desc, JS_ATOM_set);
37246|      0|        if (JS_IsException(setter) ||
37247|      0|            !(JS_IsUndefined(setter) || JS_IsFunction(ctx, setter))) {
37248|      0|            JS_ThrowTypeError(ctx, "invalid setter");
37249|      0|            goto fail;
37250|      0|        }
37251|      0|    }
37252|      0|    if ((flags & (JS_PROP_HAS_SET | JS_PROP_HAS_GET)) &&
37253|      0|        (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE))) {
37254|      0|        JS_ThrowTypeError(ctx, "cannot have setter/getter and value or writable");
37255|      0|        goto fail;
37256|      0|    }
37257|      0|    d->flags = flags;
37258|      0|    d->value = val;
37259|      0|    d->getter = getter;
37260|      0|    d->setter = setter;
37261|      0|    return 0;
37262|      0| fail:
37263|      0|    JS_FreeValue(ctx, val);
37264|      0|    JS_FreeValue(ctx, getter);
37265|      0|    JS_FreeValue(ctx, setter);
37266|      0|    return -1;
37267|      0|}
37268|       |
37269|       |static __exception int JS_DefinePropertyDesc(JSContext *ctx, JSValueConst obj,
37270|       |                                             JSAtom prop, JSValueConst desc,
37271|       |                                             int flags)
37272|      0|{
37273|      0|    JSPropertyDescriptor d;
37274|      0|    int ret;
37275|       |
37276|      0|    if (js_obj_to_desc(ctx, &d, desc) < 0)
37277|      0|        return -1;
37278|       |
37279|      0|    ret = JS_DefineProperty(ctx, obj, prop,
37280|      0|                            d.value, d.getter, d.setter, d.flags | flags);
37281|      0|    js_free_desc(ctx, &d);
37282|      0|    return ret;
37283|      0|}
37284|       |
37285|       |static __exception int JS_ObjectDefineProperties(JSContext *ctx,
37286|       |                                                 JSValueConst obj,
37287|       |                                                 JSValueConst properties)
37288|      0|{
37289|      0|    JSValue props, desc;
37290|      0|    JSObject *p;
37291|      0|    JSPropertyEnum *atoms;
37292|      0|    uint32_t len, i;
37293|      0|    int ret = -1;
37294|       |
37295|      0|    if (!JS_IsObject(obj)) {
37296|      0|        JS_ThrowTypeErrorNotAnObject(ctx);
37297|      0|        return -1;
37298|      0|    }
37299|      0|    desc = JS_UNDEFINED;
37300|      0|    props = JS_ToObject(ctx, properties);
37301|      0|    if (JS_IsException(props))
37302|      0|        return -1;
37303|      0|    p = JS_VALUE_GET_OBJ(props);
37304|      0|    if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p, JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK) < 0)
37305|      0|        goto exception;
37306|      0|    for(i = 0; i < len; i++) {
37307|      0|        JS_FreeValue(ctx, desc);
37308|      0|        desc = JS_GetProperty(ctx, props, atoms[i].atom);
37309|      0|        if (JS_IsException(desc))
37310|      0|            goto exception;
37311|      0|        if (JS_DefinePropertyDesc(ctx, obj, atoms[i].atom, desc, JS_PROP_THROW) < 0)
37312|      0|            goto exception;
37313|      0|    }
37314|      0|    ret = 0;
37315|       |
37316|      0|exception:
37317|      0|    js_free_prop_enum(ctx, atoms, len);
37318|      0|    JS_FreeValue(ctx, props);
37319|      0|    JS_FreeValue(ctx, desc);
37320|      0|    return ret;
37321|      0|}
37322|       |
37323|       |static JSValue js_object_constructor(JSContext *ctx, JSValueConst new_target,
37324|       |                                     int argc, JSValueConst *argv)
37325|      0|{
37326|      0|    JSValue ret;
37327|      0|    if (!JS_IsUndefined(new_target) &&
37328|      0|        JS_VALUE_GET_OBJ(new_target) !=
37329|      0|        JS_VALUE_GET_OBJ(JS_GetActiveFunction(ctx))) {
37330|      0|        ret = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);
37331|      0|    } else {
37332|      0|        int tag = JS_VALUE_GET_NORM_TAG(argv[0]);
37333|      0|        switch(tag) {
37334|      0|        case JS_TAG_NULL:
37335|      0|        case JS_TAG_UNDEFINED:
37336|      0|            ret = JS_NewObject(ctx);
37337|      0|            break;
37338|      0|        default:
37339|      0|            ret = JS_ToObject(ctx, argv[0]);
37340|      0|            break;
37341|      0|        }
37342|      0|    }
37343|      0|    return ret;
37344|      0|}
37345|       |
37346|       |static JSValue js_object_create(JSContext *ctx, JSValueConst this_val,
37347|       |                                int argc, JSValueConst *argv)
37348|      0|{
37349|      0|    JSValueConst proto, props;
37350|      0|    JSValue obj;
37351|       |
37352|      0|    proto = argv[0];
37353|      0|    if (!JS_IsObject(proto) && !JS_IsNull(proto))
37354|      0|        return JS_ThrowTypeError(ctx, "not a prototype");
37355|      0|    obj = JS_NewObjectProto(ctx, proto);
37356|      0|    if (JS_IsException(obj))
37357|      0|        return JS_EXCEPTION;
37358|      0|    props = argv[1];
37359|      0|    if (!JS_IsUndefined(props)) {
37360|      0|        if (JS_ObjectDefineProperties(ctx, obj, props)) {
37361|      0|            JS_FreeValue(ctx, obj);
37362|      0|            return JS_EXCEPTION;
37363|      0|        }
37364|      0|    }
37365|      0|    return obj;
37366|      0|}
37367|       |
37368|       |static JSValue js_object_getPrototypeOf(JSContext *ctx, JSValueConst this_val,
37369|       |                                        int argc, JSValueConst *argv, int magic)
37370|      0|{
37371|      0|    JSValueConst val;
37372|       |
37373|      0|    val = argv[0];
37374|      0|    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT) {
37375|       |        /* ES6 feature non compatible with ES5.1: primitive types are
37376|       |           accepted */
37377|      0|        if (magic || JS_VALUE_GET_TAG(val) == JS_TAG_NULL ||
37378|      0|            JS_VALUE_GET_TAG(val) == JS_TAG_UNDEFINED)
37379|      0|            return JS_ThrowTypeErrorNotAnObject(ctx);
37380|      0|    }
37381|      0|    return JS_GetPrototype(ctx, val);
37382|      0|}
37383|       |
37384|       |static JSValue js_object_setPrototypeOf(JSContext *ctx, JSValueConst this_val,
37385|       |                                        int argc, JSValueConst *argv)
37386|      0|{
37387|      0|    JSValueConst obj;
37388|      0|    obj = argv[0];
37389|      0|    if (JS_SetPrototypeInternal(ctx, obj, argv[1], TRUE) < 0)
37390|      0|        return JS_EXCEPTION;
37391|      0|    return JS_DupValue(ctx, obj);
37392|      0|}
37393|       |
37394|       |/* magic = 1 if called as Reflect.defineProperty */
37395|       |static JSValue js_object_defineProperty(JSContext *ctx, JSValueConst this_val,
37396|       |                                        int argc, JSValueConst *argv, int magic)
37397|      0|{
37398|      0|    JSValueConst obj, prop, desc;
37399|      0|    int ret, flags;
37400|      0|    JSAtom atom;
37401|       |
37402|      0|    obj = argv[0];
37403|      0|    prop = argv[1];
37404|      0|    desc = argv[2];
37405|       |
37406|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
37407|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
37408|      0|    atom = JS_ValueToAtom(ctx, prop);
37409|      0|    if (unlikely(atom == JS_ATOM_NULL))
37410|      0|        return JS_EXCEPTION;
37411|      0|    flags = 0;
37412|      0|    if (!magic)
37413|      0|        flags |= JS_PROP_THROW;
37414|      0|    ret = JS_DefinePropertyDesc(ctx, obj, atom, desc, flags);
37415|      0|    JS_FreeAtom(ctx, atom);
37416|      0|    if (ret < 0) {
37417|      0|        return JS_EXCEPTION;
37418|      0|    } else if (magic) {
37419|      0|        return JS_NewBool(ctx, ret);
37420|      0|    } else {
37421|      0|        return JS_DupValue(ctx, obj);
37422|      0|    }
37423|      0|}
37424|       |
37425|       |static JSValue js_object_defineProperties(JSContext *ctx, JSValueConst this_val,
37426|       |                                          int argc, JSValueConst *argv)
37427|      0|{
37428|       |    // defineProperties(obj, properties)
37429|      0|    JSValueConst obj = argv[0];
37430|       |
37431|      0|    if (JS_ObjectDefineProperties(ctx, obj, argv[1]))
37432|      0|        return JS_EXCEPTION;
37433|      0|    else
37434|      0|        return JS_DupValue(ctx, obj);
37435|      0|}
37436|       |
37437|       |/* magic = 1 if called as __defineSetter__ */
37438|       |static JSValue js_object___defineGetter__(JSContext *ctx, JSValueConst this_val,
37439|       |                                          int argc, JSValueConst *argv, int magic)
37440|      0|{
37441|      0|    JSValue obj;
37442|      0|    JSValueConst prop, value, get, set;
37443|      0|    int ret, flags;
37444|      0|    JSAtom atom;
37445|       |
37446|      0|    prop = argv[0];
37447|      0|    value = argv[1];
37448|       |
37449|      0|    obj = JS_ToObject(ctx, this_val);
37450|      0|    if (JS_IsException(obj))
37451|      0|        return JS_EXCEPTION;
37452|       |
37453|      0|    if (check_function(ctx, value)) {
37454|      0|        JS_FreeValue(ctx, obj);
37455|      0|        return JS_EXCEPTION;
37456|      0|    }
37457|      0|    atom = JS_ValueToAtom(ctx, prop);
37458|      0|    if (unlikely(atom == JS_ATOM_NULL)) {
37459|      0|        JS_FreeValue(ctx, obj);
37460|      0|        return JS_EXCEPTION;
37461|      0|    }
37462|      0|    flags = JS_PROP_THROW |
37463|      0|        JS_PROP_HAS_ENUMERABLE | JS_PROP_ENUMERABLE |
37464|      0|        JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE;
37465|      0|    if (magic) {
37466|      0|        get = JS_UNDEFINED;
37467|      0|        set = value;
37468|      0|        flags |= JS_PROP_HAS_SET;
37469|      0|    } else {
37470|      0|        get = value;
37471|      0|        set = JS_UNDEFINED;
37472|      0|        flags |= JS_PROP_HAS_GET;
37473|      0|    }
37474|      0|    ret = JS_DefineProperty(ctx, obj, atom, JS_UNDEFINED, get, set, flags);
37475|      0|    JS_FreeValue(ctx, obj);
37476|      0|    JS_FreeAtom(ctx, atom);
37477|      0|    if (ret < 0) {
37478|      0|        return JS_EXCEPTION;
37479|      0|    } else {
37480|      0|        return JS_UNDEFINED;
37481|      0|    }
37482|      0|}
37483|       |
37484|       |static JSValue js_object_getOwnPropertyDescriptor(JSContext *ctx, JSValueConst this_val,
37485|       |                                                  int argc, JSValueConst *argv, int magic)
37486|      0|{
37487|      0|    JSValueConst prop;
37488|      0|    JSAtom atom;
37489|      0|    JSValue ret, obj;
37490|      0|    JSPropertyDescriptor desc;
37491|      0|    int res, flags;
37492|       |
37493|      0|    if (magic) {
37494|       |        /* Reflect.getOwnPropertyDescriptor case */
37495|      0|        if (JS_VALUE_GET_TAG(argv[0]) != JS_TAG_OBJECT)
37496|      0|            return JS_ThrowTypeErrorNotAnObject(ctx);
37497|      0|        obj = JS_DupValue(ctx, argv[0]);
37498|      0|    } else {
37499|      0|        obj = JS_ToObject(ctx, argv[0]);
37500|      0|        if (JS_IsException(obj))
37501|      0|            return obj;
37502|      0|    }
37503|      0|    prop = argv[1];
37504|      0|    atom = JS_ValueToAtom(ctx, prop);
37505|      0|    if (unlikely(atom == JS_ATOM_NULL))
37506|      0|        goto exception;
37507|      0|    ret = JS_UNDEFINED;
37508|      0|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
37509|      0|        res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), atom);
37510|      0|        if (res < 0)
37511|      0|            goto exception;
37512|      0|        if (res) {
37513|      0|            ret = JS_NewObject(ctx);
37514|      0|            if (JS_IsException(ret))
37515|      0|                goto exception1;
37516|      0|            flags = JS_PROP_C_W_E | JS_PROP_THROW;
37517|      0|            if (desc.flags & JS_PROP_GETSET) {
37518|      0|                if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_get, JS_DupValue(ctx, desc.getter), flags) < 0
37519|      0|                ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_set, JS_DupValue(ctx, desc.setter), flags) < 0)
37520|      0|                    goto exception1;
37521|      0|            } else {
37522|      0|                if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_value, JS_DupValue(ctx, desc.value), flags) < 0
37523|      0|                ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_writable,
37524|      0|                                           JS_NewBool(ctx, desc.flags & JS_PROP_WRITABLE), flags) < 0)
37525|      0|                    goto exception1;
37526|      0|            }
37527|      0|            if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_enumerable,
37528|      0|                                       JS_NewBool(ctx, desc.flags & JS_PROP_ENUMERABLE), flags) < 0
37529|      0|            ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_configurable,
37530|      0|                                       JS_NewBool(ctx, desc.flags & JS_PROP_CONFIGURABLE), flags) < 0)
37531|      0|                goto exception1;
37532|      0|            js_free_desc(ctx, &desc);
37533|      0|        }
37534|      0|    }
37535|      0|    JS_FreeAtom(ctx, atom);
37536|      0|    JS_FreeValue(ctx, obj);
37537|      0|    return ret;
37538|       |
37539|      0|exception1:
37540|      0|    js_free_desc(ctx, &desc);
37541|      0|    JS_FreeValue(ctx, ret);
37542|      0|exception:
37543|      0|    JS_FreeAtom(ctx, atom);
37544|      0|    JS_FreeValue(ctx, obj);
37545|      0|    return JS_EXCEPTION;
37546|      0|}
37547|       |
37548|       |static JSValue js_object_getOwnPropertyDescriptors(JSContext *ctx, JSValueConst this_val,
37549|       |                                                   int argc, JSValueConst *argv)
37550|      0|{
37551|       |    //getOwnPropertyDescriptors(obj)
37552|      0|    JSValue obj, r;
37553|      0|    JSObject *p;
37554|      0|    JSPropertyEnum *props;
37555|      0|    uint32_t len, i;
37556|       |
37557|      0|    r = JS_UNDEFINED;
37558|      0|    obj = JS_ToObject(ctx, argv[0]);
37559|      0|    if (JS_IsException(obj))
37560|      0|        return JS_EXCEPTION;
37561|       |
37562|      0|    p = JS_VALUE_GET_OBJ(obj);
37563|      0|    if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p,
37564|      0|                               JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK))
37565|      0|        goto exception;
37566|      0|    r = JS_NewObject(ctx);
37567|      0|    if (JS_IsException(r))
37568|      0|        goto exception;
37569|      0|    for(i = 0; i < len; i++) {
37570|      0|        JSValue atomValue, desc;
37571|      0|        JSValueConst args[2];
37572|       |
37573|      0|        atomValue = JS_AtomToValue(ctx, props[i].atom);
37574|      0|        if (JS_IsException(atomValue))
37575|      0|            goto exception;
37576|      0|        args[0] = obj;
37577|      0|        args[1] = atomValue;
37578|      0|        desc = js_object_getOwnPropertyDescriptor(ctx, JS_UNDEFINED, 2, args, 0);
37579|      0|        JS_FreeValue(ctx, atomValue);
37580|      0|        if (JS_IsException(desc))
37581|      0|            goto exception;
37582|      0|        if (!JS_IsUndefined(desc)) {
37583|      0|            if (JS_DefinePropertyValue(ctx, r, props[i].atom, desc,
37584|      0|                                       JS_PROP_C_W_E | JS_PROP_THROW) < 0)
37585|      0|                goto exception;
37586|      0|        }
37587|      0|    }
37588|      0|    js_free_prop_enum(ctx, props, len);
37589|      0|    JS_FreeValue(ctx, obj);
37590|      0|    return r;
37591|       |
37592|      0|exception:
37593|      0|    js_free_prop_enum(ctx, props, len);
37594|      0|    JS_FreeValue(ctx, obj);
37595|      0|    JS_FreeValue(ctx, r);
37596|      0|    return JS_EXCEPTION;
37597|      0|}
37598|       |
37599|       |static JSValue JS_GetOwnPropertyNames2(JSContext *ctx, JSValueConst obj1,
37600|       |                                       int flags, int kind)
37601|      0|{
37602|      0|    JSValue obj, r, val, key, value;
37603|      0|    JSObject *p;
37604|      0|    JSPropertyEnum *atoms;
37605|      0|    uint32_t len, i, j;
37606|       |
37607|      0|    r = JS_UNDEFINED;
37608|      0|    val = JS_UNDEFINED;
37609|      0|    obj = JS_ToObject(ctx, obj1);
37610|      0|    if (JS_IsException(obj))
37611|      0|        return JS_EXCEPTION;
37612|      0|    p = JS_VALUE_GET_OBJ(obj);
37613|      0|    if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p, flags & ~JS_GPN_ENUM_ONLY))
37614|      0|        goto exception;
37615|      0|    r = JS_NewArray(ctx);
37616|      0|    if (JS_IsException(r))
37617|      0|        goto exception;
37618|      0|    for(j = i = 0; i < len; i++) {
37619|      0|        JSAtom atom = atoms[i].atom;
37620|      0|        if (flags & JS_GPN_ENUM_ONLY) {
37621|      0|            JSPropertyDescriptor desc;
37622|      0|            int res;
37623|       |
37624|       |            /* Check if property is still enumerable */
37625|      0|            res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);
37626|      0|            if (res < 0)
37627|      0|                goto exception;
37628|      0|            if (!res)
37629|      0|                continue;
37630|      0|            js_free_desc(ctx, &desc);
37631|      0|            if (!(desc.flags & JS_PROP_ENUMERABLE))
37632|      0|                continue;
37633|      0|        }
37634|      0|        switch(kind) {
37635|      0|        default:
37636|      0|        case JS_ITERATOR_KIND_KEY:
37637|      0|            val = JS_AtomToValue(ctx, atom);
37638|      0|            if (JS_IsException(val))
37639|      0|                goto exception;
37640|      0|            break;
37641|      0|        case JS_ITERATOR_KIND_VALUE:
37642|      0|            val = JS_GetProperty(ctx, obj, atom);
37643|      0|            if (JS_IsException(val))
37644|      0|                goto exception;
37645|      0|            break;
37646|      0|        case JS_ITERATOR_KIND_KEY_AND_VALUE:
37647|      0|            val = JS_NewArray(ctx);
37648|      0|            if (JS_IsException(val))
37649|      0|                goto exception;
37650|      0|            key = JS_AtomToValue(ctx, atom);
37651|      0|            if (JS_IsException(key))
37652|      0|                goto exception1;
37653|      0|            if (JS_CreateDataPropertyUint32(ctx, val, 0, key, JS_PROP_THROW) < 0)
37654|      0|                goto exception1;
37655|      0|            value = JS_GetProperty(ctx, obj, atom);
37656|      0|            if (JS_IsException(value))
37657|      0|                goto exception1;
37658|      0|            if (JS_CreateDataPropertyUint32(ctx, val, 1, value, JS_PROP_THROW) < 0)
37659|      0|                goto exception1;
37660|      0|            break;
37661|      0|        }
37662|      0|        if (JS_CreateDataPropertyUint32(ctx, r, j++, val, 0) < 0)
37663|      0|            goto exception;
37664|      0|    }
37665|      0|    goto done;
37666|       |
37667|      0|exception1:
37668|      0|    JS_FreeValue(ctx, val);
37669|      0|exception:
37670|      0|    JS_FreeValue(ctx, r);
37671|      0|    r = JS_EXCEPTION;
37672|      0|done:
37673|      0|    js_free_prop_enum(ctx, atoms, len);
37674|      0|    JS_FreeValue(ctx, obj);
37675|      0|    return r;
37676|      0|}
37677|       |
37678|       |static JSValue js_object_getOwnPropertyNames(JSContext *ctx, JSValueConst this_val,
37679|       |                                             int argc, JSValueConst *argv)
37680|      0|{
37681|      0|    return JS_GetOwnPropertyNames2(ctx, argv[0],
37682|      0|                                   JS_GPN_STRING_MASK, JS_ITERATOR_KIND_KEY);
37683|      0|}
37684|       |
37685|       |static JSValue js_object_getOwnPropertySymbols(JSContext *ctx, JSValueConst this_val,
37686|       |                                             int argc, JSValueConst *argv)
37687|      0|{
37688|      0|    return JS_GetOwnPropertyNames2(ctx, argv[0],
37689|      0|                                   JS_GPN_SYMBOL_MASK, JS_ITERATOR_KIND_KEY);
37690|      0|}
37691|       |
37692|       |static JSValue js_object_keys(JSContext *ctx, JSValueConst this_val,
37693|       |                              int argc, JSValueConst *argv, int kind)
37694|      0|{
37695|      0|    return JS_GetOwnPropertyNames2(ctx, argv[0],
37696|      0|                                   JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK, kind);
37697|      0|}
37698|       |
37699|       |static JSValue js_object_isExtensible(JSContext *ctx, JSValueConst this_val,
37700|       |                                      int argc, JSValueConst *argv, int reflect)
37701|      0|{
37702|      0|    JSValueConst obj;
37703|      0|    int ret;
37704|       |
37705|      0|    obj = argv[0];
37706|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {
37707|      0|        if (reflect)
37708|      0|            return JS_ThrowTypeErrorNotAnObject(ctx);
37709|      0|        else
37710|      0|            return JS_FALSE;
37711|      0|    }
37712|      0|    ret = JS_IsExtensible(ctx, obj);
37713|      0|    if (ret < 0)
37714|      0|        return JS_EXCEPTION;
37715|      0|    else
37716|      0|        return JS_NewBool(ctx, ret);
37717|      0|}
37718|       |
37719|       |static JSValue js_object_preventExtensions(JSContext *ctx, JSValueConst this_val,
37720|       |                                           int argc, JSValueConst *argv, int reflect)
37721|      0|{
37722|      0|    JSValueConst obj;
37723|      0|    int ret;
37724|       |
37725|      0|    obj = argv[0];
37726|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {
37727|      0|        if (reflect)
37728|      0|            return JS_ThrowTypeErrorNotAnObject(ctx);
37729|      0|        else
37730|      0|            return JS_DupValue(ctx, obj);
37731|      0|    }
37732|      0|    ret = JS_PreventExtensions(ctx, obj);
37733|      0|    if (ret < 0)
37734|      0|        return JS_EXCEPTION;
37735|      0|    if (reflect) {
37736|      0|        return JS_NewBool(ctx, ret);
37737|      0|    } else {
37738|      0|        if (!ret)
37739|      0|            return JS_ThrowTypeError(ctx, "proxy preventExtensions handler returned false");
37740|      0|        return JS_DupValue(ctx, obj);
37741|      0|    }
37742|      0|}
37743|       |
37744|       |static JSValue js_object_hasOwnProperty(JSContext *ctx, JSValueConst this_val,
37745|       |                                        int argc, JSValueConst *argv)
37746|      0|{
37747|      0|    JSValue obj;
37748|      0|    JSAtom atom;
37749|      0|    JSObject *p;
37750|      0|    BOOL ret;
37751|       |
37752|      0|    atom = JS_ValueToAtom(ctx, argv[0]); /* must be done first */
37753|      0|    if (unlikely(atom == JS_ATOM_NULL))
37754|      0|        return JS_EXCEPTION;
37755|      0|    obj = JS_ToObject(ctx, this_val);
37756|      0|    if (JS_IsException(obj)) {
37757|      0|        JS_FreeAtom(ctx, atom);
37758|      0|        return obj;
37759|      0|    }
37760|      0|    p = JS_VALUE_GET_OBJ(obj);
37761|      0|    ret = JS_GetOwnPropertyInternal(ctx, NULL, p, atom);
37762|      0|    JS_FreeAtom(ctx, atom);
37763|      0|    JS_FreeValue(ctx, obj);
37764|      0|    if (ret < 0)
37765|      0|        return JS_EXCEPTION;
37766|      0|    else
37767|      0|        return JS_NewBool(ctx, ret);
37768|      0|}
37769|       |
37770|       |static JSValue js_object_hasOwn(JSContext *ctx, JSValueConst this_val,
37771|       |                                int argc, JSValueConst *argv)
37772|      0|{
37773|      0|    JSValue obj;
37774|      0|    JSAtom atom;
37775|      0|    JSObject *p;
37776|      0|    BOOL ret;
37777|       |
37778|      0|    obj = JS_ToObject(ctx, argv[0]);
37779|      0|    if (JS_IsException(obj))
37780|      0|        return obj;
37781|      0|    atom = JS_ValueToAtom(ctx, argv[1]);
37782|      0|    if (unlikely(atom == JS_ATOM_NULL)) {
37783|      0|        JS_FreeValue(ctx, obj);
37784|      0|        return JS_EXCEPTION;
37785|      0|    }
37786|      0|    p = JS_VALUE_GET_OBJ(obj);
37787|      0|    ret = JS_GetOwnPropertyInternal(ctx, NULL, p, atom);
37788|      0|    JS_FreeAtom(ctx, atom);
37789|      0|    JS_FreeValue(ctx, obj);
37790|      0|    if (ret < 0)
37791|      0|        return JS_EXCEPTION;
37792|      0|    else
37793|      0|        return JS_NewBool(ctx, ret);
37794|      0|}
37795|       |
37796|       |static JSValue js_object_valueOf(JSContext *ctx, JSValueConst this_val,
37797|       |                                 int argc, JSValueConst *argv)
37798|  1.12M|{
37799|  1.12M|    return JS_ToObject(ctx, this_val);
37800|  1.12M|}
37801|       |
37802|       |static JSValue js_object_toString(JSContext *ctx, JSValueConst this_val,
37803|       |                                  int argc, JSValueConst *argv)
37804|    619|{
37805|    619|    JSValue obj, tag;
37806|    619|    int is_array;
37807|    619|    JSAtom atom;
37808|    619|    JSObject *p;
37809|       |
37810|    619|    if (JS_IsNull(this_val)) {
37811|      0|        tag = js_new_string8(ctx, "Null");
37812|    619|    } else if (JS_IsUndefined(this_val)) {
37813|      0|        tag = js_new_string8(ctx, "Undefined");
37814|    619|    } else {
37815|    619|        obj = JS_ToObject(ctx, this_val);
37816|    619|        if (JS_IsException(obj))
37817|      0|            return obj;
37818|    619|        is_array = JS_IsArray(ctx, obj);
37819|    619|        if (is_array < 0) {
37820|      0|            JS_FreeValue(ctx, obj);
37821|      0|            return JS_EXCEPTION;
37822|      0|        }
37823|    619|        if (is_array) {
37824|      0|            atom = JS_ATOM_Array;
37825|    619|        } else if (JS_IsFunction(ctx, obj)) {
37826|      0|            atom = JS_ATOM_Function;
37827|    619|        } else {
37828|    619|            p = JS_VALUE_GET_OBJ(obj);
37829|    619|            switch(p->class_id) {
37830|      0|            case JS_CLASS_STRING:
37831|      0|            case JS_CLASS_ARGUMENTS:
37832|      0|            case JS_CLASS_MAPPED_ARGUMENTS:
37833|      0|            case JS_CLASS_ERROR:
37834|      0|            case JS_CLASS_BOOLEAN:
37835|      0|            case JS_CLASS_NUMBER:
37836|      0|            case JS_CLASS_DATE:
37837|      0|            case JS_CLASS_REGEXP:
37838|      0|                atom = ctx->rt->class_array[p->class_id].class_name;
37839|      0|                break;
37840|    619|            default:
37841|    619|                atom = JS_ATOM_Object;
37842|    619|                break;
37843|    619|            }
37844|    619|        }
37845|    619|        tag = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_toStringTag);
37846|    619|        JS_FreeValue(ctx, obj);
37847|    619|        if (JS_IsException(tag))
37848|      0|            return JS_EXCEPTION;
37849|    619|        if (!JS_IsString(tag)) {
37850|    619|            JS_FreeValue(ctx, tag);
37851|    619|            tag = JS_AtomToString(ctx, atom);
37852|    619|        }
37853|    619|    }
37854|    619|    return JS_ConcatString3(ctx, "[object ", tag, "]");
37855|    619|}
37856|       |
37857|       |static JSValue js_object_toLocaleString(JSContext *ctx, JSValueConst this_val,
37858|       |                                        int argc, JSValueConst *argv)
37859|      0|{
37860|      0|    return JS_Invoke(ctx, this_val, JS_ATOM_toString, 0, NULL);
37861|      0|}
37862|       |
37863|       |static JSValue js_object_assign(JSContext *ctx, JSValueConst this_val,
37864|       |                                int argc, JSValueConst *argv)
37865|      0|{
37866|       |    // Object.assign(obj, source1)
37867|      0|    JSValue obj, s;
37868|      0|    int i;
37869|       |
37870|      0|    s = JS_UNDEFINED;
37871|      0|    obj = JS_ToObject(ctx, argv[0]);
37872|      0|    if (JS_IsException(obj))
37873|      0|        goto exception;
37874|      0|    for (i = 1; i < argc; i++) {
37875|      0|        if (!JS_IsNull(argv[i]) && !JS_IsUndefined(argv[i])) {
37876|      0|            s = JS_ToObject(ctx, argv[i]);
37877|      0|            if (JS_IsException(s))
37878|      0|                goto exception;
37879|      0|            if (JS_CopyDataProperties(ctx, obj, s, JS_UNDEFINED, TRUE))
37880|      0|                goto exception;
37881|      0|            JS_FreeValue(ctx, s);
37882|      0|        }
37883|      0|    }
37884|      0|    return obj;
37885|      0|exception:
37886|      0|    JS_FreeValue(ctx, obj);
37887|      0|    JS_FreeValue(ctx, s);
37888|      0|    return JS_EXCEPTION;
37889|      0|}
37890|       |
37891|       |static JSValue js_object_seal(JSContext *ctx, JSValueConst this_val,
37892|       |                              int argc, JSValueConst *argv, int freeze_flag)
37893|  17.7k|{
37894|  17.7k|    JSValueConst obj = argv[0];
37895|  17.7k|    JSObject *p;
37896|  17.7k|    JSPropertyEnum *props;
37897|  17.7k|    uint32_t len, i;
37898|  17.7k|    int flags, desc_flags, res;
37899|       |
37900|  17.7k|    if (!JS_IsObject(obj))
37901|      0|        return JS_DupValue(ctx, obj);
37902|       |
37903|  17.7k|    res = JS_PreventExtensions(ctx, obj);
37904|  17.7k|    if (res < 0)
37905|      0|        return JS_EXCEPTION;
37906|  17.7k|    if (!res) {
37907|      0|        return JS_ThrowTypeError(ctx, "proxy preventExtensions handler returned false");
37908|      0|    }
37909|       |
37910|  17.7k|    p = JS_VALUE_GET_OBJ(obj);
37911|  17.7k|    flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK;
37912|  17.7k|    if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
37913|      0|        return JS_EXCEPTION;
37914|       |
37915|  53.3k|    for(i = 0; i < len; i++) {
37916|  35.5k|        JSPropertyDescriptor desc;
37917|  35.5k|        JSAtom prop = props[i].atom;
37918|       |
37919|  35.5k|        desc_flags = JS_PROP_THROW | JS_PROP_HAS_CONFIGURABLE;
37920|  35.5k|        if (freeze_flag) {
37921|  35.5k|            res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
37922|  35.5k|            if (res < 0)
37923|      0|                goto exception;
37924|  35.5k|            if (res) {
37925|  35.5k|                if (desc.flags & JS_PROP_WRITABLE)
37926|      0|                    desc_flags |= JS_PROP_HAS_WRITABLE;
37927|  35.5k|                js_free_desc(ctx, &desc);
37928|  35.5k|            }
37929|  35.5k|        }
37930|  35.5k|        if (JS_DefineProperty(ctx, obj, prop, JS_UNDEFINED,
37931|  35.5k|                              JS_UNDEFINED, JS_UNDEFINED, desc_flags) < 0)
37932|      0|            goto exception;
37933|  35.5k|    }
37934|  17.7k|    js_free_prop_enum(ctx, props, len);
37935|  17.7k|    return JS_DupValue(ctx, obj);
37936|       |
37937|      0| exception:
37938|      0|    js_free_prop_enum(ctx, props, len);
37939|      0|    return JS_EXCEPTION;
37940|  17.7k|}
37941|       |
37942|       |static JSValue js_object_isSealed(JSContext *ctx, JSValueConst this_val,
37943|       |                                  int argc, JSValueConst *argv, int is_frozen)
37944|      0|{
37945|      0|    JSValueConst obj = argv[0];
37946|      0|    JSObject *p;
37947|      0|    JSPropertyEnum *props;
37948|      0|    uint32_t len, i;
37949|      0|    int flags, res;
37950|       |
37951|      0|    if (!JS_IsObject(obj))
37952|      0|        return JS_TRUE;
37953|       |
37954|      0|    p = JS_VALUE_GET_OBJ(obj);
37955|      0|    flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK;
37956|      0|    if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
37957|      0|        return JS_EXCEPTION;
37958|       |
37959|      0|    for(i = 0; i < len; i++) {
37960|      0|        JSPropertyDescriptor desc;
37961|      0|        JSAtom prop = props[i].atom;
37962|       |
37963|      0|        res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
37964|      0|        if (res < 0)
37965|      0|            goto exception;
37966|      0|        if (res) {
37967|      0|            js_free_desc(ctx, &desc);
37968|      0|            if ((desc.flags & JS_PROP_CONFIGURABLE)
37969|      0|            ||  (is_frozen && (desc.flags & JS_PROP_WRITABLE))) {
37970|      0|                res = FALSE;
37971|      0|                goto done;
37972|      0|            }
37973|      0|        }
37974|      0|    }
37975|      0|    res = JS_IsExtensible(ctx, obj);
37976|      0|    if (res < 0)
37977|      0|        return JS_EXCEPTION;
37978|      0|    res ^= 1;
37979|      0|done:
37980|      0|    js_free_prop_enum(ctx, props, len);
37981|      0|    return JS_NewBool(ctx, res);
37982|       |
37983|      0|exception:
37984|      0|    js_free_prop_enum(ctx, props, len);
37985|      0|    return JS_EXCEPTION;
37986|      0|}
37987|       |
37988|       |static JSValue js_object_fromEntries(JSContext *ctx, JSValueConst this_val,
37989|       |                                     int argc, JSValueConst *argv)
37990|      0|{
37991|      0|    JSValue obj, iter, next_method = JS_UNDEFINED;
37992|      0|    JSValueConst iterable;
37993|      0|    BOOL done;
37994|       |
37995|       |    /*  RequireObjectCoercible() not necessary because it is tested in
37996|       |        JS_GetIterator() by JS_GetProperty() */
37997|      0|    iterable = argv[0];
37998|       |
37999|      0|    obj = JS_NewObject(ctx);
38000|      0|    if (JS_IsException(obj))
38001|      0|        return obj;
38002|       |
38003|      0|    iter = JS_GetIterator(ctx, iterable, FALSE);
38004|      0|    if (JS_IsException(iter))
38005|      0|        goto fail;
38006|      0|    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
38007|      0|    if (JS_IsException(next_method))
38008|      0|        goto fail;
38009|       |
38010|      0|    for(;;) {
38011|      0|        JSValue key, value, item;
38012|      0|        item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
38013|      0|        if (JS_IsException(item))
38014|      0|            goto fail;
38015|      0|        if (done)
38016|      0|            break;
38017|       |
38018|      0|        key = JS_UNDEFINED;
38019|      0|        value = JS_UNDEFINED;
38020|      0|        if (!JS_IsObject(item)) {
38021|      0|            JS_ThrowTypeErrorNotAnObject(ctx);
38022|      0|            goto fail1;
38023|      0|        }
38024|      0|        key = JS_GetPropertyUint32(ctx, item, 0);
38025|      0|        if (JS_IsException(key))
38026|      0|            goto fail1;
38027|      0|        value = JS_GetPropertyUint32(ctx, item, 1);
38028|      0|        if (JS_IsException(value)) {
38029|      0|            JS_FreeValue(ctx, key);
38030|      0|            goto fail1;
38031|      0|        }
38032|      0|        if (JS_DefinePropertyValueValue(ctx, obj, key, value,
38033|      0|                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0) {
38034|      0|        fail1:
38035|      0|            JS_FreeValue(ctx, item);
38036|      0|            goto fail;
38037|      0|        }
38038|      0|        JS_FreeValue(ctx, item);
38039|      0|    }
38040|      0|    JS_FreeValue(ctx, next_method);
38041|      0|    JS_FreeValue(ctx, iter);
38042|      0|    return obj;
38043|      0| fail:
38044|      0|    if (JS_IsObject(iter)) {
38045|       |        /* close the iterator object, preserving pending exception */
38046|      0|        JS_IteratorClose(ctx, iter, TRUE);
38047|      0|    }
38048|      0|    JS_FreeValue(ctx, next_method);
38049|      0|    JS_FreeValue(ctx, iter);
38050|      0|    JS_FreeValue(ctx, obj);
38051|      0|    return JS_EXCEPTION;
38052|      0|}
38053|       |
38054|       |#if 0
38055|       |/* Note: corresponds to ECMA spec: CreateDataPropertyOrThrow() */
38056|       |static JSValue js_object___setOwnProperty(JSContext *ctx, JSValueConst this_val,
38057|       |                                          int argc, JSValueConst *argv)
38058|       |{
38059|       |    int ret;
38060|       |    ret = JS_DefinePropertyValueValue(ctx, argv[0], JS_DupValue(ctx, argv[1]),
38061|       |                                      JS_DupValue(ctx, argv[2]),
38062|       |                                      JS_PROP_C_W_E | JS_PROP_THROW);
38063|       |    if (ret < 0)
38064|       |        return JS_EXCEPTION;
38065|       |    else
38066|       |        return JS_NewBool(ctx, ret);
38067|       |}
38068|       |
38069|       |static JSValue js_object___toObject(JSContext *ctx, JSValueConst this_val,
38070|       |                                    int argc, JSValueConst *argv)
38071|       |{
38072|       |    return JS_ToObject(ctx, argv[0]);
38073|       |}
38074|       |
38075|       |static JSValue js_object___toPrimitive(JSContext *ctx, JSValueConst this_val,
38076|       |                                       int argc, JSValueConst *argv)
38077|       |{
38078|       |    int hint = HINT_NONE;
38079|       |
38080|       |    if (JS_VALUE_GET_TAG(argv[1]) == JS_TAG_INT)
38081|       |        hint = JS_VALUE_GET_INT(argv[1]);
38082|       |
38083|       |    return JS_ToPrimitive(ctx, argv[0], hint);
38084|       |}
38085|       |#endif
38086|       |
38087|       |/* return an empty string if not an object */
38088|       |static JSValue js_object___getClass(JSContext *ctx, JSValueConst this_val,
38089|       |                                    int argc, JSValueConst *argv)
38090|      0|{
38091|      0|    JSAtom atom;
38092|      0|    JSObject *p;
38093|      0|    uint32_t tag;
38094|      0|    int class_id;
38095|       |
38096|      0|    tag = JS_VALUE_GET_NORM_TAG(argv[0]);
38097|      0|    if (tag == JS_TAG_OBJECT) {
38098|      0|        p = JS_VALUE_GET_OBJ(argv[0]);
38099|      0|        class_id = p->class_id;
38100|      0|        if (class_id == JS_CLASS_PROXY && JS_IsFunction(ctx, argv[0]))
38101|      0|            class_id = JS_CLASS_BYTECODE_FUNCTION;
38102|      0|        atom = ctx->rt->class_array[class_id].class_name;
38103|      0|    } else {
38104|      0|        atom = JS_ATOM_empty_string;
38105|      0|    }
38106|      0|    return JS_AtomToString(ctx, atom);
38107|      0|}
38108|       |
38109|       |static JSValue js_object_is(JSContext *ctx, JSValueConst this_val,
38110|       |                            int argc, JSValueConst *argv)
38111|      0|{
38112|      0|    return JS_NewBool(ctx, js_same_value(ctx, argv[0], argv[1]));
38113|      0|}
38114|       |
38115|       |#if 0
38116|       |static JSValue js_object___getObjectData(JSContext *ctx, JSValueConst this_val,
38117|       |                                         int argc, JSValueConst *argv)
38118|       |{
38119|       |    return JS_GetObjectData(ctx, argv[0]);
38120|       |}
38121|       |
38122|       |static JSValue js_object___setObjectData(JSContext *ctx, JSValueConst this_val,
38123|       |                                         int argc, JSValueConst *argv)
38124|       |{
38125|       |    if (JS_SetObjectData(ctx, argv[0], JS_DupValue(ctx, argv[1])))
38126|       |        return JS_EXCEPTION;
38127|       |    return JS_DupValue(ctx, argv[1]);
38128|       |}
38129|       |
38130|       |static JSValue js_object___toPropertyKey(JSContext *ctx, JSValueConst this_val,
38131|       |                                         int argc, JSValueConst *argv)
38132|       |{
38133|       |    return JS_ToPropertyKey(ctx, argv[0]);
38134|       |}
38135|       |
38136|       |static JSValue js_object___isObject(JSContext *ctx, JSValueConst this_val,
38137|       |                                    int argc, JSValueConst *argv)
38138|       |{
38139|       |    return JS_NewBool(ctx, JS_IsObject(argv[0]));
38140|       |}
38141|       |
38142|       |static JSValue js_object___isSameValueZero(JSContext *ctx, JSValueConst this_val,
38143|       |                                           int argc, JSValueConst *argv)
38144|       |{
38145|       |    return JS_NewBool(ctx, js_same_value_zero(ctx, argv[0], argv[1]));
38146|       |}
38147|       |
38148|       |static JSValue js_object___isConstructor(JSContext *ctx, JSValueConst this_val,
38149|       |                                         int argc, JSValueConst *argv)
38150|       |{
38151|       |    return JS_NewBool(ctx, JS_IsConstructor(ctx, argv[0]));
38152|       |}
38153|       |#endif
38154|       |
38155|       |static JSValue JS_SpeciesConstructor(JSContext *ctx, JSValueConst obj,
38156|       |                                     JSValueConst defaultConstructor)
38157|      0|{
38158|      0|    JSValue ctor, species;
38159|       |
38160|      0|    if (!JS_IsObject(obj))
38161|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
38162|      0|    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor);
38163|      0|    if (JS_IsException(ctor))
38164|      0|        return ctor;
38165|      0|    if (JS_IsUndefined(ctor))
38166|      0|        return JS_DupValue(ctx, defaultConstructor);
38167|      0|    if (!JS_IsObject(ctor)) {
38168|      0|        JS_FreeValue(ctx, ctor);
38169|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
38170|      0|    }
38171|      0|    species = JS_GetProperty(ctx, ctor, JS_ATOM_Symbol_species);
38172|      0|    JS_FreeValue(ctx, ctor);
38173|      0|    if (JS_IsException(species))
38174|      0|        return species;
38175|      0|    if (JS_IsUndefined(species) || JS_IsNull(species))
38176|      0|        return JS_DupValue(ctx, defaultConstructor);
38177|      0|    if (!JS_IsConstructor(ctx, species)) {
38178|      0|        JS_FreeValue(ctx, species);
38179|      0|        return JS_ThrowTypeError(ctx, "not a constructor");
38180|      0|    }
38181|      0|    return species;
38182|      0|}
38183|       |
38184|       |#if 0
38185|       |static JSValue js_object___speciesConstructor(JSContext *ctx, JSValueConst this_val,
38186|       |                                              int argc, JSValueConst *argv)
38187|       |{
38188|       |    return JS_SpeciesConstructor(ctx, argv[0], argv[1]);
38189|       |}
38190|       |#endif
38191|       |
38192|       |static JSValue js_object_get___proto__(JSContext *ctx, JSValueConst this_val)
38193|      0|{
38194|      0|    JSValue val, ret;
38195|       |
38196|      0|    val = JS_ToObject(ctx, this_val);
38197|      0|    if (JS_IsException(val))
38198|      0|        return val;
38199|      0|    ret = JS_GetPrototype(ctx, val);
38200|      0|    JS_FreeValue(ctx, val);
38201|      0|    return ret;
38202|      0|}
38203|       |
38204|       |static JSValue js_object_set___proto__(JSContext *ctx, JSValueConst this_val,
38205|       |                                       JSValueConst proto)
38206|      0|{
38207|      0|    if (JS_IsUndefined(this_val) || JS_IsNull(this_val))
38208|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
38209|      0|    if (!JS_IsObject(proto) && !JS_IsNull(proto))
38210|      0|        return JS_UNDEFINED;
38211|      0|    if (JS_SetPrototypeInternal(ctx, this_val, proto, TRUE) < 0)
38212|      0|        return JS_EXCEPTION;
38213|      0|    else
38214|      0|        return JS_UNDEFINED;
38215|      0|}
38216|       |
38217|       |static JSValue js_object_isPrototypeOf(JSContext *ctx, JSValueConst this_val,
38218|       |                                       int argc, JSValueConst *argv)
38219|      0|{
38220|      0|    JSValue obj, v1;
38221|      0|    JSValueConst v;
38222|      0|    int res;
38223|       |
38224|      0|    v = argv[0];
38225|      0|    if (!JS_IsObject(v))
38226|      0|        return JS_FALSE;
38227|      0|    obj = JS_ToObject(ctx, this_val);
38228|      0|    if (JS_IsException(obj))
38229|      0|        return JS_EXCEPTION;
38230|      0|    v1 = JS_DupValue(ctx, v);
38231|      0|    for(;;) {
38232|      0|        v1 = JS_GetPrototypeFree(ctx, v1);
38233|      0|        if (JS_IsException(v1))
38234|      0|            goto exception;
38235|      0|        if (JS_IsNull(v1)) {
38236|      0|            res = FALSE;
38237|      0|            break;
38238|      0|        }
38239|      0|        if (JS_VALUE_GET_OBJ(obj) == JS_VALUE_GET_OBJ(v1)) {
38240|      0|            res = TRUE;
38241|      0|            break;
38242|      0|        }
38243|       |        /* avoid infinite loop (possible with proxies) */
38244|      0|        if (js_poll_interrupts(ctx))
38245|      0|            goto exception;
38246|      0|    }
38247|      0|    JS_FreeValue(ctx, v1);
38248|      0|    JS_FreeValue(ctx, obj);
38249|      0|    return JS_NewBool(ctx, res);
38250|       |
38251|      0|exception:
38252|      0|    JS_FreeValue(ctx, v1);
38253|      0|    JS_FreeValue(ctx, obj);
38254|      0|    return JS_EXCEPTION;
38255|      0|}
38256|       |
38257|       |static JSValue js_object_propertyIsEnumerable(JSContext *ctx, JSValueConst this_val,
38258|       |                                              int argc, JSValueConst *argv)
38259|      0|{
38260|      0|    JSValue obj, res = JS_EXCEPTION;
38261|      0|    JSAtom prop = JS_ATOM_NULL;
38262|      0|    JSPropertyDescriptor desc;
38263|      0|    int has_prop;
38264|       |
38265|      0|    obj = JS_ToObject(ctx, this_val);
38266|      0|    if (JS_IsException(obj))
38267|      0|        goto exception;
38268|      0|    prop = JS_ValueToAtom(ctx, argv[0]);
38269|      0|    if (unlikely(prop == JS_ATOM_NULL))
38270|      0|        goto exception;
38271|       |
38272|      0|    has_prop = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), prop);
38273|      0|    if (has_prop < 0)
38274|      0|        goto exception;
38275|      0|    if (has_prop) {
38276|      0|        res = JS_NewBool(ctx, desc.flags & JS_PROP_ENUMERABLE);
38277|      0|        js_free_desc(ctx, &desc);
38278|      0|    } else {
38279|      0|        res = JS_FALSE;
38280|      0|    }
38281|       |
38282|      0|exception:
38283|      0|    JS_FreeAtom(ctx, prop);
38284|      0|    JS_FreeValue(ctx, obj);
38285|      0|    return res;
38286|      0|}
38287|       |
38288|       |static JSValue js_object___lookupGetter__(JSContext *ctx, JSValueConst this_val,
38289|       |                                          int argc, JSValueConst *argv, int setter)
38290|      0|{
38291|      0|    JSValue obj, res = JS_EXCEPTION;
38292|      0|    JSAtom prop = JS_ATOM_NULL;
38293|      0|    JSPropertyDescriptor desc;
38294|      0|    int has_prop;
38295|       |
38296|      0|    obj = JS_ToObject(ctx, this_val);
38297|      0|    if (JS_IsException(obj))
38298|      0|        goto exception;
38299|      0|    prop = JS_ValueToAtom(ctx, argv[0]);
38300|      0|    if (unlikely(prop == JS_ATOM_NULL))
38301|      0|        goto exception;
38302|       |
38303|      0|    for (;;) {
38304|      0|        has_prop = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), prop);
38305|      0|        if (has_prop < 0)
38306|      0|            goto exception;
38307|      0|        if (has_prop) {
38308|      0|            if (desc.flags & JS_PROP_GETSET)
38309|      0|                res = JS_DupValue(ctx, setter ? desc.setter : desc.getter);
38310|      0|            else
38311|      0|                res = JS_UNDEFINED;
38312|      0|            js_free_desc(ctx, &desc);
38313|      0|            break;
38314|      0|        }
38315|      0|        obj = JS_GetPrototypeFree(ctx, obj);
38316|      0|        if (JS_IsException(obj))
38317|      0|            goto exception;
38318|      0|        if (JS_IsNull(obj)) {
38319|      0|            res = JS_UNDEFINED;
38320|      0|            break;
38321|      0|        }
38322|       |        /* avoid infinite loop (possible with proxies) */
38323|      0|        if (js_poll_interrupts(ctx))
38324|      0|            goto exception;
38325|      0|    }
38326|       |
38327|      0|exception:
38328|      0|    JS_FreeAtom(ctx, prop);
38329|      0|    JS_FreeValue(ctx, obj);
38330|      0|    return res;
38331|      0|}
38332|       |
38333|       |static const JSCFunctionListEntry js_object_funcs[] = {
38334|       |    JS_CFUNC_DEF("create", 2, js_object_create ),
38335|       |    JS_CFUNC_MAGIC_DEF("getPrototypeOf", 1, js_object_getPrototypeOf, 0 ),
38336|       |    JS_CFUNC_DEF("setPrototypeOf", 2, js_object_setPrototypeOf ),
38337|       |    JS_CFUNC_MAGIC_DEF("defineProperty", 3, js_object_defineProperty, 0 ),
38338|       |    JS_CFUNC_DEF("defineProperties", 2, js_object_defineProperties ),
38339|       |    JS_CFUNC_DEF("getOwnPropertyNames", 1, js_object_getOwnPropertyNames ),
38340|       |    JS_CFUNC_DEF("getOwnPropertySymbols", 1, js_object_getOwnPropertySymbols ),
38341|       |    JS_CFUNC_MAGIC_DEF("groupBy", 2, js_object_groupBy, 0 ),
38342|       |    JS_CFUNC_MAGIC_DEF("keys", 1, js_object_keys, JS_ITERATOR_KIND_KEY ),
38343|       |    JS_CFUNC_MAGIC_DEF("values", 1, js_object_keys, JS_ITERATOR_KIND_VALUE ),
38344|       |    JS_CFUNC_MAGIC_DEF("entries", 1, js_object_keys, JS_ITERATOR_KIND_KEY_AND_VALUE ),
38345|       |    JS_CFUNC_MAGIC_DEF("isExtensible", 1, js_object_isExtensible, 0 ),
38346|       |    JS_CFUNC_MAGIC_DEF("preventExtensions", 1, js_object_preventExtensions, 0 ),
38347|       |    JS_CFUNC_MAGIC_DEF("getOwnPropertyDescriptor", 2, js_object_getOwnPropertyDescriptor, 0 ),
38348|       |    JS_CFUNC_DEF("getOwnPropertyDescriptors", 1, js_object_getOwnPropertyDescriptors ),
38349|       |    JS_CFUNC_DEF("is", 2, js_object_is ),
38350|       |    JS_CFUNC_DEF("assign", 2, js_object_assign ),
38351|       |    JS_CFUNC_MAGIC_DEF("seal", 1, js_object_seal, 0 ),
38352|       |    JS_CFUNC_MAGIC_DEF("freeze", 1, js_object_seal, 1 ),
38353|       |    JS_CFUNC_MAGIC_DEF("isSealed", 1, js_object_isSealed, 0 ),
38354|       |    JS_CFUNC_MAGIC_DEF("isFrozen", 1, js_object_isSealed, 1 ),
38355|       |    JS_CFUNC_DEF("__getClass", 1, js_object___getClass ),
38356|       |    //JS_CFUNC_DEF("__isObject", 1, js_object___isObject ),
38357|       |    //JS_CFUNC_DEF("__isConstructor", 1, js_object___isConstructor ),
38358|       |    //JS_CFUNC_DEF("__toObject", 1, js_object___toObject ),
38359|       |    //JS_CFUNC_DEF("__setOwnProperty", 3, js_object___setOwnProperty ),
38360|       |    //JS_CFUNC_DEF("__toPrimitive", 2, js_object___toPrimitive ),
38361|       |    //JS_CFUNC_DEF("__toPropertyKey", 1, js_object___toPropertyKey ),
38362|       |    //JS_CFUNC_DEF("__speciesConstructor", 2, js_object___speciesConstructor ),
38363|       |    //JS_CFUNC_DEF("__isSameValueZero", 2, js_object___isSameValueZero ),
38364|       |    //JS_CFUNC_DEF("__getObjectData", 1, js_object___getObjectData ),
38365|       |    //JS_CFUNC_DEF("__setObjectData", 2, js_object___setObjectData ),
38366|       |    JS_CFUNC_DEF("fromEntries", 1, js_object_fromEntries ),
38367|       |    JS_CFUNC_DEF("hasOwn", 2, js_object_hasOwn ),
38368|       |};
38369|       |
38370|       |static const JSCFunctionListEntry js_object_proto_funcs[] = {
38371|       |    JS_CFUNC_DEF("toString", 0, js_object_toString ),
38372|       |    JS_CFUNC_DEF("toLocaleString", 0, js_object_toLocaleString ),
38373|       |    JS_CFUNC_DEF("valueOf", 0, js_object_valueOf ),
38374|       |    JS_CFUNC_DEF("hasOwnProperty", 1, js_object_hasOwnProperty ),
38375|       |    JS_CFUNC_DEF("isPrototypeOf", 1, js_object_isPrototypeOf ),
38376|       |    JS_CFUNC_DEF("propertyIsEnumerable", 1, js_object_propertyIsEnumerable ),
38377|       |    JS_CGETSET_DEF("__proto__", js_object_get___proto__, js_object_set___proto__ ),
38378|       |    JS_CFUNC_MAGIC_DEF("__defineGetter__", 2, js_object___defineGetter__, 0 ),
38379|       |    JS_CFUNC_MAGIC_DEF("__defineSetter__", 2, js_object___defineGetter__, 1 ),
38380|       |    JS_CFUNC_MAGIC_DEF("__lookupGetter__", 1, js_object___lookupGetter__, 0 ),
38381|       |    JS_CFUNC_MAGIC_DEF("__lookupSetter__", 1, js_object___lookupGetter__, 1 ),
38382|       |};
38383|       |
38384|       |/* Function class */
38385|       |
38386|       |static JSValue js_function_proto(JSContext *ctx, JSValueConst this_val,
38387|       |                                 int argc, JSValueConst *argv)
38388|      0|{
38389|      0|    return JS_UNDEFINED;
38390|      0|}
38391|       |
38392|       |/* XXX: add a specific eval mode so that Function("}), ({") is rejected */
38393|       |static JSValue js_function_constructor(JSContext *ctx, JSValueConst new_target,
38394|       |                                       int argc, JSValueConst *argv, int magic)
38395|      0|{
38396|      0|    JSFunctionKindEnum func_kind = magic;
38397|      0|    int i, n, ret;
38398|      0|    JSValue s, proto, obj = JS_UNDEFINED;
38399|      0|    StringBuffer b_s, *b = &b_s;
38400|       |
38401|      0|    string_buffer_init(ctx, b, 0);
38402|      0|    string_buffer_putc8(b, '(');
38403|       |
38404|      0|    if (func_kind == JS_FUNC_ASYNC || func_kind == JS_FUNC_ASYNC_GENERATOR) {
38405|      0|        string_buffer_puts8(b, "async ");
38406|      0|    }
38407|      0|    string_buffer_puts8(b, "function");
38408|       |
38409|      0|    if (func_kind == JS_FUNC_GENERATOR || func_kind == JS_FUNC_ASYNC_GENERATOR) {
38410|      0|        string_buffer_putc8(b, '*');
38411|      0|    }
38412|      0|    string_buffer_puts8(b, " anonymous(");
38413|       |
38414|      0|    n = argc - 1;
38415|      0|    for(i = 0; i < n; i++) {
38416|      0|        if (i != 0) {
38417|      0|            string_buffer_putc8(b, ',');
38418|      0|        }
38419|      0|        if (string_buffer_concat_value(b, argv[i]))
38420|      0|            goto fail;
38421|      0|    }
38422|      0|    string_buffer_puts8(b, "\n) {\n");
38423|      0|    if (n >= 0) {
38424|      0|        if (string_buffer_concat_value(b, argv[n]))
38425|      0|            goto fail;
38426|      0|    }
38427|      0|    string_buffer_puts8(b, "\n})");
38428|      0|    s = string_buffer_end(b);
38429|      0|    if (JS_IsException(s))
38430|      0|        goto fail1;
38431|       |
38432|      0|    obj = JS_EvalObject(ctx, ctx->global_obj, s, JS_EVAL_TYPE_INDIRECT, -1);
38433|      0|    JS_FreeValue(ctx, s);
38434|      0|    if (JS_IsException(obj))
38435|      0|        goto fail1;
38436|      0|    if (!JS_IsUndefined(new_target)) {
38437|       |        /* set the prototype */
38438|      0|        proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype);
38439|      0|        if (JS_IsException(proto))
38440|      0|            goto fail1;
38441|      0|        if (!JS_IsObject(proto)) {
38442|      0|            JSContext *realm;
38443|      0|            JS_FreeValue(ctx, proto);
38444|      0|            realm = JS_GetFunctionRealm(ctx, new_target);
38445|      0|            if (!realm)
38446|      0|                goto fail1;
38447|      0|            proto = JS_DupValue(ctx, realm->class_proto[func_kind_to_class_id[func_kind]]);
38448|      0|        }
38449|      0|        ret = JS_SetPrototypeInternal(ctx, obj, proto, TRUE);
38450|      0|        JS_FreeValue(ctx, proto);
38451|      0|        if (ret < 0)
38452|      0|            goto fail1;
38453|      0|    }
38454|      0|    return obj;
38455|       |
38456|      0| fail:
38457|      0|    string_buffer_free(b);
38458|      0| fail1:
38459|      0|    JS_FreeValue(ctx, obj);
38460|      0|    return JS_EXCEPTION;
38461|      0|}
38462|       |
38463|       |static __exception int js_get_length32(JSContext *ctx, uint32_t *pres,
38464|       |                                       JSValueConst obj)
38465|  2.96k|{
38466|  2.96k|    JSValue len_val;
38467|  2.96k|    len_val = JS_GetProperty(ctx, obj, JS_ATOM_length);
38468|  2.96k|    if (JS_IsException(len_val)) {
38469|      0|        *pres = 0;
38470|      0|        return -1;
38471|      0|    }
38472|  2.96k|    return JS_ToUint32Free(ctx, pres, len_val);
38473|  2.96k|}
38474|       |
38475|       |static __exception int js_get_length64(JSContext *ctx, int64_t *pres,
38476|       |                                       JSValueConst obj)
38477|   232k|{
38478|   232k|    JSValue len_val;
38479|   232k|    len_val = JS_GetProperty(ctx, obj, JS_ATOM_length);
38480|   232k|    if (JS_IsException(len_val)) {
38481|      0|        *pres = 0;
38482|      0|        return -1;
38483|      0|    }
38484|   232k|    return JS_ToLengthFree(ctx, pres, len_val);
38485|   232k|}
38486|       |
38487|       |static void free_arg_list(JSContext *ctx, JSValue *tab, uint32_t len)
38488|      0|{
38489|      0|    uint32_t i;
38490|      0|    for(i = 0; i < len; i++) {
38491|      0|        JS_FreeValue(ctx, tab[i]);
38492|      0|    }
38493|      0|    js_free(ctx, tab);
38494|      0|}
38495|       |
38496|       |/* XXX: should use ValueArray */
38497|       |static JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,
38498|       |                               JSValueConst array_arg)
38499|      0|{
38500|      0|    uint32_t len, i;
38501|      0|    JSValue *tab, ret;
38502|      0|    JSObject *p;
38503|       |
38504|      0|    if (JS_VALUE_GET_TAG(array_arg) != JS_TAG_OBJECT) {
38505|      0|        JS_ThrowTypeError(ctx, "not a object");
38506|      0|        return NULL;
38507|      0|    }
38508|      0|    if (js_get_length32(ctx, &len, array_arg))
38509|      0|        return NULL;
38510|      0|    if (len > JS_MAX_LOCAL_VARS) {
38511|       |        // XXX: check for stack overflow?
38512|      0|        JS_ThrowRangeError(ctx, "too many arguments in function call (only %d allowed)",
38513|      0|                           JS_MAX_LOCAL_VARS);
38514|      0|        return NULL;
38515|      0|    }
38516|       |    /* avoid allocating 0 bytes */
38517|      0|    tab = js_mallocz(ctx, sizeof(tab[0]) * max_uint32(1, len));
38518|      0|    if (!tab)
38519|      0|        return NULL;
38520|      0|    p = JS_VALUE_GET_OBJ(array_arg);
38521|      0|    if ((p->class_id == JS_CLASS_ARRAY || p->class_id == JS_CLASS_ARGUMENTS) &&
38522|      0|        p->fast_array &&
38523|      0|        len == p->u.array.count) {
38524|      0|        for(i = 0; i < len; i++) {
38525|      0|            tab[i] = JS_DupValue(ctx, p->u.array.u.values[i]);
38526|      0|        }
38527|      0|    } else {
38528|      0|        for(i = 0; i < len; i++) {
38529|      0|            ret = JS_GetPropertyUint32(ctx, array_arg, i);
38530|      0|            if (JS_IsException(ret)) {
38531|      0|                free_arg_list(ctx, tab, i);
38532|      0|                return NULL;
38533|      0|            }
38534|      0|            tab[i] = ret;
38535|      0|        }
38536|      0|    }
38537|      0|    *plen = len;
38538|      0|    return tab;
38539|      0|}
38540|       |
38541|       |/* magic value: 0 = normal apply, 1 = apply for constructor, 2 =
38542|       |   Reflect.apply */
38543|       |static JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,
38544|       |                                 int argc, JSValueConst *argv, int magic)
38545|      0|{
38546|      0|    JSValueConst this_arg, array_arg;
38547|      0|    uint32_t len;
38548|      0|    JSValue *tab, ret;
38549|       |
38550|      0|    if (check_function(ctx, this_val))
38551|      0|        return JS_EXCEPTION;
38552|      0|    this_arg = argv[0];
38553|      0|    array_arg = argv[1];
38554|      0|    if ((JS_VALUE_GET_TAG(array_arg) == JS_TAG_UNDEFINED ||
38555|      0|         JS_VALUE_GET_TAG(array_arg) == JS_TAG_NULL) && magic != 2) {
38556|      0|        return JS_Call(ctx, this_val, this_arg, 0, NULL);
38557|      0|    }
38558|      0|    tab = build_arg_list(ctx, &len, array_arg);
38559|      0|    if (!tab)
38560|      0|        return JS_EXCEPTION;
38561|      0|    if (magic & 1) {
38562|      0|        ret = JS_CallConstructor2(ctx, this_val, this_arg, len, (JSValueConst *)tab);
38563|      0|    } else {
38564|      0|        ret = JS_Call(ctx, this_val, this_arg, len, (JSValueConst *)tab);
38565|      0|    }
38566|      0|    free_arg_list(ctx, tab, len);
38567|      0|    return ret;
38568|      0|}
38569|       |
38570|       |static JSValue js_function_call(JSContext *ctx, JSValueConst this_val,
38571|       |                                int argc, JSValueConst *argv)
38572|      0|{
38573|      0|    if (argc <= 0) {
38574|      0|        return JS_Call(ctx, this_val, JS_UNDEFINED, 0, NULL);
38575|      0|    } else {
38576|      0|        return JS_Call(ctx, this_val, argv[0], argc - 1, argv + 1);
38577|      0|    }
38578|      0|}
38579|       |
38580|       |static JSValue js_function_bind(JSContext *ctx, JSValueConst this_val,
38581|       |                                int argc, JSValueConst *argv)
38582|      0|{
38583|      0|    JSBoundFunction *bf;
38584|      0|    JSValue func_obj, name1, len_val;
38585|      0|    JSObject *p;
38586|      0|    int arg_count, i, ret;
38587|       |
38588|      0|    if (check_function(ctx, this_val))
38589|      0|        return JS_EXCEPTION;
38590|       |
38591|      0|    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,
38592|      0|                                 JS_CLASS_BOUND_FUNCTION);
38593|      0|    if (JS_IsException(func_obj))
38594|      0|        return JS_EXCEPTION;
38595|      0|    p = JS_VALUE_GET_OBJ(func_obj);
38596|      0|    p->is_constructor = JS_IsConstructor(ctx, this_val);
38597|      0|    arg_count = max_int(0, argc - 1);
38598|      0|    bf = js_malloc(ctx, sizeof(*bf) + arg_count * sizeof(JSValue));
38599|      0|    if (!bf)
38600|      0|        goto exception;
38601|      0|    bf->func_obj = JS_DupValue(ctx, this_val);
38602|      0|    bf->this_val = JS_DupValue(ctx, argv[0]);
38603|      0|    bf->argc = arg_count;
38604|      0|    for(i = 0; i < arg_count; i++) {
38605|      0|        bf->argv[i] = JS_DupValue(ctx, argv[i + 1]);
38606|      0|    }
38607|      0|    p->u.bound_function = bf;
38608|       |
38609|       |    /* XXX: the spec could be simpler by only using GetOwnProperty */
38610|      0|    ret = JS_GetOwnProperty(ctx, NULL, this_val, JS_ATOM_length);
38611|      0|    if (ret < 0)
38612|      0|        goto exception;
38613|      0|    if (!ret) {
38614|      0|        len_val = JS_NewInt32(ctx, 0);
38615|      0|    } else {
38616|      0|        len_val = JS_GetProperty(ctx, this_val, JS_ATOM_length);
38617|      0|        if (JS_IsException(len_val))
38618|      0|            goto exception;
38619|      0|        if (JS_VALUE_GET_TAG(len_val) == JS_TAG_INT) {
38620|       |            /* most common case */
38621|      0|            int len1 = JS_VALUE_GET_INT(len_val);
38622|      0|            if (len1 <= arg_count)
38623|      0|                len1 = 0;
38624|      0|            else
38625|      0|                len1 -= arg_count;
38626|      0|            len_val = JS_NewInt32(ctx, len1);
38627|      0|        } else if (JS_VALUE_GET_NORM_TAG(len_val) == JS_TAG_FLOAT64) {
38628|      0|            double d = JS_VALUE_GET_FLOAT64(len_val);
38629|      0|            if (isnan(d)) {
38630|      0|                d = 0.0;
38631|      0|            } else {
38632|      0|                d = trunc(d);
38633|      0|                if (d <= (double)arg_count)
38634|      0|                    d = 0.0;
38635|      0|                else
38636|      0|                    d -= (double)arg_count; /* also converts -0 to +0 */
38637|      0|            }
38638|      0|            len_val = JS_NewFloat64(ctx, d);
38639|      0|        } else {
38640|      0|            JS_FreeValue(ctx, len_val);
38641|      0|            len_val = JS_NewInt32(ctx, 0);
38642|      0|        }
38643|      0|    }
38644|      0|    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length,
38645|      0|                           len_val, JS_PROP_CONFIGURABLE);
38646|       |
38647|      0|    name1 = JS_GetProperty(ctx, this_val, JS_ATOM_name);
38648|      0|    if (JS_IsException(name1))
38649|      0|        goto exception;
38650|      0|    if (!JS_IsString(name1)) {
38651|      0|        JS_FreeValue(ctx, name1);
38652|      0|        name1 = JS_AtomToString(ctx, JS_ATOM_empty_string);
38653|      0|    }
38654|      0|    name1 = JS_ConcatString3(ctx, "bound ", name1, "");
38655|      0|    if (JS_IsException(name1))
38656|      0|        goto exception;
38657|      0|    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name, name1,
38658|      0|                           JS_PROP_CONFIGURABLE);
38659|      0|    return func_obj;
38660|      0| exception:
38661|      0|    JS_FreeValue(ctx, func_obj);
38662|      0|    return JS_EXCEPTION;
38663|      0|}
38664|       |
38665|       |static JSValue js_function_toString(JSContext *ctx, JSValueConst this_val,
38666|       |                                    int argc, JSValueConst *argv)
38667|   153k|{
38668|   153k|    JSObject *p;
38669|   153k|    JSFunctionKindEnum func_kind = JS_FUNC_NORMAL;
38670|       |
38671|   153k|    if (check_function(ctx, this_val))
38672|      0|        return JS_EXCEPTION;
38673|       |
38674|   153k|    p = JS_VALUE_GET_OBJ(this_val);
38675|   153k|    if (js_class_has_bytecode(p->class_id)) {
38676|  74.0k|        JSFunctionBytecode *b = p->u.func.function_bytecode;
38677|  74.0k|        if (b->has_debug && b->debug.source) {
38678|  74.0k|            return JS_NewStringLen(ctx, b->debug.source, b->debug.source_len);
38679|  74.0k|        }
38680|      0|        func_kind = b->func_kind;
38681|      0|    }
38682|  79.4k|    {
38683|  79.4k|        JSValue name;
38684|  79.4k|        const char *pref, *suff;
38685|       |
38686|  79.4k|        switch(func_kind) {
38687|      0|        default:
38688|  79.4k|        case JS_FUNC_NORMAL:
38689|  79.4k|            pref = "function ";
38690|  79.4k|            break;
38691|      0|        case JS_FUNC_GENERATOR:
38692|      0|            pref = "function *";
38693|      0|            break;
38694|      0|        case JS_FUNC_ASYNC:
38695|      0|            pref = "async function ";
38696|      0|            break;
38697|      0|        case JS_FUNC_ASYNC_GENERATOR:
38698|      0|            pref = "async function *";
38699|      0|            break;
38700|  79.4k|        }
38701|  79.4k|        suff = "() {\n    [native code]\n}";
38702|  79.4k|        name = JS_GetProperty(ctx, this_val, JS_ATOM_name);
38703|  79.4k|        if (JS_IsUndefined(name))
38704|      0|            name = JS_AtomToString(ctx, JS_ATOM_empty_string);
38705|  79.4k|        return JS_ConcatString3(ctx, pref, name, suff);
38706|  79.4k|    }
38707|  79.4k|}
38708|       |
38709|       |static JSValue js_function_hasInstance(JSContext *ctx, JSValueConst this_val,
38710|       |                                       int argc, JSValueConst *argv)
38711|      0|{
38712|      0|    int ret;
38713|      0|    ret = JS_OrdinaryIsInstanceOf(ctx, argv[0], this_val);
38714|      0|    if (ret < 0)
38715|      0|        return JS_EXCEPTION;
38716|      0|    else
38717|      0|        return JS_NewBool(ctx, ret);
38718|      0|}
38719|       |
38720|       |static const JSCFunctionListEntry js_function_proto_funcs[] = {
38721|       |    JS_CFUNC_DEF("call", 1, js_function_call ),
38722|       |    JS_CFUNC_MAGIC_DEF("apply", 2, js_function_apply, 0 ),
38723|       |    JS_CFUNC_DEF("bind", 1, js_function_bind ),
38724|       |    JS_CFUNC_DEF("toString", 0, js_function_toString ),
38725|       |    JS_CFUNC_DEF("[Symbol.hasInstance]", 1, js_function_hasInstance ),
38726|       |    JS_CGETSET_DEF("fileName", js_function_proto_fileName, NULL ),
38727|       |    JS_CGETSET_MAGIC_DEF("lineNumber", js_function_proto_lineNumber, NULL, 0 ),
38728|       |    JS_CGETSET_MAGIC_DEF("columnNumber", js_function_proto_lineNumber, NULL, 1 ),
38729|       |};
38730|       |
38731|       |/* Error class */
38732|       |
38733|       |static JSValue iterator_to_array(JSContext *ctx, JSValueConst items)
38734|      0|{
38735|      0|    JSValue iter, next_method = JS_UNDEFINED;
38736|      0|    JSValue v, r = JS_UNDEFINED;
38737|      0|    int64_t k;
38738|      0|    BOOL done;
38739|       |
38740|      0|    iter = JS_GetIterator(ctx, items, FALSE);
38741|      0|    if (JS_IsException(iter))
38742|      0|        goto exception;
38743|      0|    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
38744|      0|    if (JS_IsException(next_method))
38745|      0|        goto exception;
38746|      0|    r = JS_NewArray(ctx);
38747|      0|    if (JS_IsException(r))
38748|      0|        goto exception;
38749|      0|    for (k = 0;; k++) {
38750|      0|        v = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
38751|      0|        if (JS_IsException(v))
38752|      0|            goto exception_close;
38753|      0|        if (done)
38754|      0|            break;
38755|      0|        if (JS_DefinePropertyValueInt64(ctx, r, k, v,
38756|      0|                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)
38757|      0|            goto exception_close;
38758|      0|    }
38759|      0| done:
38760|      0|    JS_FreeValue(ctx, next_method);
38761|      0|    JS_FreeValue(ctx, iter);
38762|      0|    return r;
38763|      0| exception_close:
38764|      0|    JS_IteratorClose(ctx, iter, TRUE);
38765|      0| exception:
38766|      0|    JS_FreeValue(ctx, r);
38767|      0|    r = JS_EXCEPTION;
38768|      0|    goto done;
38769|      0|}
38770|       |
38771|       |static JSValue js_error_constructor(JSContext *ctx, JSValueConst new_target,
38772|       |                                    int argc, JSValueConst *argv, int magic)
38773|      0|{
38774|      0|    JSValue obj, msg, proto;
38775|      0|    JSValueConst message, options;
38776|      0|    int arg_index;
38777|       |
38778|      0|    if (JS_IsUndefined(new_target))
38779|      0|        new_target = JS_GetActiveFunction(ctx);
38780|      0|    proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype);
38781|      0|    if (JS_IsException(proto))
38782|      0|        return proto;
38783|      0|    if (!JS_IsObject(proto)) {
38784|      0|        JSContext *realm;
38785|      0|        JSValueConst proto1;
38786|       |
38787|      0|        JS_FreeValue(ctx, proto);
38788|      0|        realm = JS_GetFunctionRealm(ctx, new_target);
38789|      0|        if (!realm)
38790|      0|            return JS_EXCEPTION;
38791|      0|        if (magic < 0) {
38792|      0|            proto1 = realm->class_proto[JS_CLASS_ERROR];
38793|      0|        } else {
38794|      0|            proto1 = realm->native_error_proto[magic];
38795|      0|        }
38796|      0|        proto = JS_DupValue(ctx, proto1);
38797|      0|    }
38798|      0|    obj = JS_NewObjectProtoClass(ctx, proto, JS_CLASS_ERROR);
38799|      0|    JS_FreeValue(ctx, proto);
38800|      0|    if (JS_IsException(obj))
38801|      0|        return obj;
38802|      0|    arg_index = (magic == JS_AGGREGATE_ERROR);
38803|       |
38804|      0|    message = argv[arg_index++];
38805|      0|    if (!JS_IsUndefined(message)) {
38806|      0|        msg = JS_ToString(ctx, message);
38807|      0|        if (unlikely(JS_IsException(msg)))
38808|      0|            goto exception;
38809|      0|        JS_DefinePropertyValue(ctx, obj, JS_ATOM_message, msg,
38810|      0|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
38811|      0|    }
38812|       |
38813|      0|    if (arg_index < argc) {
38814|      0|        options = argv[arg_index];
38815|      0|        if (JS_IsObject(options)) {
38816|      0|            int present = JS_HasProperty(ctx, options, JS_ATOM_cause);
38817|      0|            if (present < 0)
38818|      0|                goto exception;
38819|      0|            if (present) {
38820|      0|                JSValue cause = JS_GetProperty(ctx, options, JS_ATOM_cause);
38821|      0|                if (JS_IsException(cause))
38822|      0|                    goto exception;
38823|      0|                JS_DefinePropertyValue(ctx, obj, JS_ATOM_cause, cause,
38824|      0|                                       JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
38825|      0|            }
38826|      0|        }
38827|      0|    }
38828|       |
38829|      0|    if (magic == JS_AGGREGATE_ERROR) {
38830|      0|        JSValue error_list = iterator_to_array(ctx, argv[0]);
38831|      0|        if (JS_IsException(error_list))
38832|      0|            goto exception;
38833|      0|        JS_DefinePropertyValue(ctx, obj, JS_ATOM_errors, error_list,
38834|      0|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
38835|      0|    }
38836|       |
38837|       |    /* skip the Error() function in the backtrace */
38838|      0|    build_backtrace(ctx, obj, NULL, 0, 0, JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL);
38839|      0|    return obj;
38840|      0| exception:
38841|      0|    JS_FreeValue(ctx, obj);
38842|      0|    return JS_EXCEPTION;
38843|      0|}
38844|       |
38845|       |static JSValue js_error_toString(JSContext *ctx, JSValueConst this_val,
38846|       |                                 int argc, JSValueConst *argv)
38847|  14.2k|{
38848|  14.2k|    JSValue name, msg;
38849|       |
38850|  14.2k|    if (!JS_IsObject(this_val))
38851|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
38852|  14.2k|    name = JS_GetProperty(ctx, this_val, JS_ATOM_name);
38853|  14.2k|    if (JS_IsUndefined(name))
38854|      0|        name = JS_AtomToString(ctx, JS_ATOM_Error);
38855|  14.2k|    else
38856|  14.2k|        name = JS_ToStringFree(ctx, name);
38857|  14.2k|    if (JS_IsException(name))
38858|      0|        return JS_EXCEPTION;
38859|       |
38860|  14.2k|    msg = JS_GetProperty(ctx, this_val, JS_ATOM_message);
38861|  14.2k|    if (JS_IsUndefined(msg))
38862|      0|        msg = JS_AtomToString(ctx, JS_ATOM_empty_string);
38863|  14.2k|    else
38864|  14.2k|        msg = JS_ToStringFree(ctx, msg);
38865|  14.2k|    if (JS_IsException(msg)) {
38866|      0|        JS_FreeValue(ctx, name);
38867|      0|        return JS_EXCEPTION;
38868|      0|    }
38869|  14.2k|    if (!JS_IsEmptyString(name) && !JS_IsEmptyString(msg))
38870|  14.2k|        name = JS_ConcatString3(ctx, "", name, ": ");
38871|  14.2k|    return JS_ConcatString(ctx, name, msg);
38872|  14.2k|}
38873|       |
38874|       |static const JSCFunctionListEntry js_error_proto_funcs[] = {
38875|       |    JS_CFUNC_DEF("toString", 0, js_error_toString ),
38876|       |    JS_PROP_STRING_DEF("name", "Error", JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
38877|       |    JS_PROP_STRING_DEF("message", "", JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
38878|       |};
38879|       |
38880|       |/* AggregateError */
38881|       |
38882|       |/* used by C code. */
38883|       |static JSValue js_aggregate_error_constructor(JSContext *ctx,
38884|       |                                              JSValueConst errors)
38885|      0|{
38886|      0|    JSValue obj;
38887|       |
38888|      0|    obj = JS_NewObjectProtoClass(ctx,
38889|      0|                                 ctx->native_error_proto[JS_AGGREGATE_ERROR],
38890|      0|                                 JS_CLASS_ERROR);
38891|      0|    if (JS_IsException(obj))
38892|      0|        return obj;
38893|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_errors, JS_DupValue(ctx, errors),
38894|      0|                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
38895|      0|    return obj;
38896|      0|}
38897|       |
38898|       |/* Array */
38899|       |
38900|       |static int JS_CopySubArray(JSContext *ctx,
38901|       |                           JSValueConst obj, int64_t to_pos,
38902|       |                           int64_t from_pos, int64_t count, int dir)
38903|      0|{
38904|      0|    JSObject *p;
38905|      0|    int64_t i, from, to, len;
38906|      0|    JSValue val;
38907|      0|    int fromPresent;
38908|       |
38909|      0|    p = NULL;
38910|      0|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
38911|      0|        p = JS_VALUE_GET_OBJ(obj);
38912|      0|        if (p->class_id != JS_CLASS_ARRAY || !p->fast_array) {
38913|      0|            p = NULL;
38914|      0|        }
38915|      0|    }
38916|       |
38917|      0|    for (i = 0; i < count; ) {
38918|      0|        if (dir < 0) {
38919|      0|            from = from_pos + count - i - 1;
38920|      0|            to = to_pos + count - i - 1;
38921|      0|        } else {
38922|      0|            from = from_pos + i;
38923|      0|            to = to_pos + i;
38924|      0|        }
38925|      0|        if (p && p->fast_array &&
38926|      0|            from >= 0 && from < (len = p->u.array.count)  &&
38927|      0|            to >= 0 && to < len) {
38928|      0|            int64_t l, j;
38929|       |            /* Fast path for fast arrays. Since we don't look at the
38930|       |               prototype chain, we can optimize only the cases where
38931|       |               all the elements are present in the array. */
38932|      0|            l = count - i;
38933|      0|            if (dir < 0) {
38934|      0|                l = min_int64(l, from + 1);
38935|      0|                l = min_int64(l, to + 1);
38936|      0|                for(j = 0; j < l; j++) {
38937|      0|                    set_value(ctx, &p->u.array.u.values[to - j],
38938|      0|                              JS_DupValue(ctx, p->u.array.u.values[from - j]));
38939|      0|                }
38940|      0|            } else {
38941|      0|                l = min_int64(l, len - from);
38942|      0|                l = min_int64(l, len - to);
38943|      0|                for(j = 0; j < l; j++) {
38944|      0|                    set_value(ctx, &p->u.array.u.values[to + j],
38945|      0|                              JS_DupValue(ctx, p->u.array.u.values[from + j]));
38946|      0|                }
38947|      0|            }
38948|      0|            i += l;
38949|      0|        } else {
38950|      0|            fromPresent = JS_TryGetPropertyInt64(ctx, obj, from, &val);
38951|      0|            if (fromPresent < 0)
38952|      0|                goto exception;
38953|       |
38954|      0|            if (fromPresent) {
38955|      0|                if (JS_SetPropertyInt64(ctx, obj, to, val) < 0)
38956|      0|                    goto exception;
38957|      0|            } else {
38958|      0|                if (JS_DeletePropertyInt64(ctx, obj, to, JS_PROP_THROW) < 0)
38959|      0|                    goto exception;
38960|      0|            }
38961|      0|            i++;
38962|      0|        }
38963|      0|    }
38964|      0|    return 0;
38965|       |
38966|      0| exception:
38967|      0|    return -1;
38968|      0|}
38969|       |
38970|       |static JSValue js_array_constructor(JSContext *ctx, JSValueConst new_target,
38971|       |                                    int argc, JSValueConst *argv)
38972|      0|{
38973|      0|    JSValue obj;
38974|      0|    int i;
38975|       |
38976|      0|    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_ARRAY);
38977|      0|    if (JS_IsException(obj))
38978|      0|        return obj;
38979|      0|    if (argc == 1 && JS_IsNumber(argv[0])) {
38980|      0|        uint32_t len;
38981|      0|        if (JS_ToArrayLengthFree(ctx, &len, JS_DupValue(ctx, argv[0]), TRUE))
38982|      0|            goto fail;
38983|      0|        if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewUint32(ctx, len)) < 0)
38984|      0|            goto fail;
38985|      0|    } else {
38986|      0|        for(i = 0; i < argc; i++) {
38987|      0|            if (JS_SetPropertyUint32(ctx, obj, i, JS_DupValue(ctx, argv[i])) < 0)
38988|      0|                goto fail;
38989|      0|        }
38990|      0|    }
38991|      0|    return obj;
38992|      0|fail:
38993|      0|    JS_FreeValue(ctx, obj);
38994|      0|    return JS_EXCEPTION;
38995|      0|}
38996|       |
38997|       |static JSValue js_array_from(JSContext *ctx, JSValueConst this_val,
38998|       |                             int argc, JSValueConst *argv)
38999|      0|{
39000|       |    // from(items, mapfn = void 0, this_arg = void 0)
39001|      0|    JSValueConst items = argv[0], mapfn, this_arg;
39002|      0|    JSValueConst args[2];
39003|      0|    JSValue stack[2];
39004|      0|    JSValue iter, r, v, v2, arrayLike;
39005|      0|    int64_t k, len;
39006|      0|    int done, mapping;
39007|       |
39008|      0|    mapping = FALSE;
39009|      0|    mapfn = JS_UNDEFINED;
39010|      0|    this_arg = JS_UNDEFINED;
39011|      0|    r = JS_UNDEFINED;
39012|      0|    arrayLike = JS_UNDEFINED;
39013|      0|    stack[0] = JS_UNDEFINED;
39014|      0|    stack[1] = JS_UNDEFINED;
39015|       |
39016|      0|    if (argc > 1) {
39017|      0|        mapfn = argv[1];
39018|      0|        if (!JS_IsUndefined(mapfn)) {
39019|      0|            if (check_function(ctx, mapfn))
39020|      0|                goto exception;
39021|      0|            mapping = 1;
39022|      0|            if (argc > 2)
39023|      0|                this_arg = argv[2];
39024|      0|        }
39025|      0|    }
39026|      0|    iter = JS_GetProperty(ctx, items, JS_ATOM_Symbol_iterator);
39027|      0|    if (JS_IsException(iter))
39028|      0|        goto exception;
39029|      0|    if (!JS_IsUndefined(iter)) {
39030|      0|        JS_FreeValue(ctx, iter);
39031|      0|        if (JS_IsConstructor(ctx, this_val))
39032|      0|            r = JS_CallConstructor(ctx, this_val, 0, NULL);
39033|      0|        else
39034|      0|            r = JS_NewArray(ctx);
39035|      0|        if (JS_IsException(r))
39036|      0|            goto exception;
39037|      0|        stack[0] = JS_DupValue(ctx, items);
39038|      0|        if (js_for_of_start(ctx, &stack[1], FALSE))
39039|      0|            goto exception;
39040|      0|        for (k = 0;; k++) {
39041|      0|            v = JS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);
39042|      0|            if (JS_IsException(v))
39043|      0|                goto exception_close;
39044|      0|            if (done)
39045|      0|                break;
39046|      0|            if (mapping) {
39047|      0|                args[0] = v;
39048|      0|                args[1] = JS_NewInt32(ctx, k);
39049|      0|                v2 = JS_Call(ctx, mapfn, this_arg, 2, args);
39050|      0|                JS_FreeValue(ctx, v);
39051|      0|                v = v2;
39052|      0|                if (JS_IsException(v))
39053|      0|                    goto exception_close;
39054|      0|            }
39055|      0|            if (JS_DefinePropertyValueInt64(ctx, r, k, v,
39056|      0|                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)
39057|      0|                goto exception_close;
39058|      0|        }
39059|      0|    } else {
39060|      0|        arrayLike = JS_ToObject(ctx, items);
39061|      0|        if (JS_IsException(arrayLike))
39062|      0|            goto exception;
39063|      0|        if (js_get_length64(ctx, &len, arrayLike) < 0)
39064|      0|            goto exception;
39065|      0|        v = JS_NewInt64(ctx, len);
39066|      0|        args[0] = v;
39067|      0|        if (JS_IsConstructor(ctx, this_val)) {
39068|      0|            r = JS_CallConstructor(ctx, this_val, 1, args);
39069|      0|        } else {
39070|      0|            r = js_array_constructor(ctx, JS_UNDEFINED, 1, args);
39071|      0|        }
39072|      0|        JS_FreeValue(ctx, v);
39073|      0|        if (JS_IsException(r))
39074|      0|            goto exception;
39075|      0|        for(k = 0; k < len; k++) {
39076|      0|            v = JS_GetPropertyInt64(ctx, arrayLike, k);
39077|      0|            if (JS_IsException(v))
39078|      0|                goto exception;
39079|      0|            if (mapping) {
39080|      0|                args[0] = v;
39081|      0|                args[1] = JS_NewInt32(ctx, k);
39082|      0|                v2 = JS_Call(ctx, mapfn, this_arg, 2, args);
39083|      0|                JS_FreeValue(ctx, v);
39084|      0|                v = v2;
39085|      0|                if (JS_IsException(v))
39086|      0|                    goto exception;
39087|      0|            }
39088|      0|            if (JS_DefinePropertyValueInt64(ctx, r, k, v,
39089|      0|                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)
39090|      0|                goto exception;
39091|      0|        }
39092|      0|    }
39093|      0|    if (JS_SetProperty(ctx, r, JS_ATOM_length, JS_NewUint32(ctx, k)) < 0)
39094|      0|        goto exception;
39095|      0|    goto done;
39096|       |
39097|      0| exception_close:
39098|      0|    if (!JS_IsUndefined(stack[0]))
39099|      0|        JS_IteratorClose(ctx, stack[0], TRUE);
39100|      0| exception:
39101|      0|    JS_FreeValue(ctx, r);
39102|      0|    r = JS_EXCEPTION;
39103|      0| done:
39104|      0|    JS_FreeValue(ctx, arrayLike);
39105|      0|    JS_FreeValue(ctx, stack[0]);
39106|      0|    JS_FreeValue(ctx, stack[1]);
39107|      0|    return r;
39108|      0|}
39109|       |
39110|       |static JSValue js_array_of(JSContext *ctx, JSValueConst this_val,
39111|       |                           int argc, JSValueConst *argv)
39112|      0|{
39113|      0|    JSValue obj, args[1];
39114|      0|    int i;
39115|       |
39116|      0|    if (JS_IsConstructor(ctx, this_val)) {
39117|      0|        args[0] = JS_NewInt32(ctx, argc);
39118|      0|        obj = JS_CallConstructor(ctx, this_val, 1, (JSValueConst *)args);
39119|      0|    } else {
39120|      0|        obj = JS_NewArray(ctx);
39121|      0|    }
39122|      0|    if (JS_IsException(obj))
39123|      0|        return JS_EXCEPTION;
39124|      0|    for(i = 0; i < argc; i++) {
39125|      0|        if (JS_CreateDataPropertyUint32(ctx, obj, i, JS_DupValue(ctx, argv[i]),
39126|      0|                                        JS_PROP_THROW) < 0) {
39127|      0|            goto fail;
39128|      0|        }
39129|      0|    }
39130|      0|    if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewUint32(ctx, argc)) < 0) {
39131|      0|    fail:
39132|      0|        JS_FreeValue(ctx, obj);
39133|      0|        return JS_EXCEPTION;
39134|      0|    }
39135|      0|    return obj;
39136|      0|}
39137|       |
39138|       |static JSValue js_array_isArray(JSContext *ctx, JSValueConst this_val,
39139|       |                                int argc, JSValueConst *argv)
39140|      0|{
39141|      0|    int ret;
39142|      0|    ret = JS_IsArray(ctx, argv[0]);
39143|      0|    if (ret < 0)
39144|      0|        return JS_EXCEPTION;
39145|      0|    else
39146|      0|        return JS_NewBool(ctx, ret);
39147|      0|}
39148|       |
39149|       |static JSValue js_get_this(JSContext *ctx,
39150|       |                           JSValueConst this_val)
39151|      0|{
39152|      0|    return JS_DupValue(ctx, this_val);
39153|      0|}
39154|       |
39155|       |static JSValue JS_ArraySpeciesCreate(JSContext *ctx, JSValueConst obj,
39156|       |                                     JSValueConst len_val)
39157|      0|{
39158|      0|    JSValue ctor, ret, species;
39159|      0|    int res;
39160|      0|    JSContext *realm;
39161|       |
39162|      0|    res = JS_IsArray(ctx, obj);
39163|      0|    if (res < 0)
39164|      0|        return JS_EXCEPTION;
39165|      0|    if (!res)
39166|      0|        return js_array_constructor(ctx, JS_UNDEFINED, 1, &len_val);
39167|      0|    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor);
39168|      0|    if (JS_IsException(ctor))
39169|      0|        return ctor;
39170|      0|    if (JS_IsConstructor(ctx, ctor)) {
39171|       |        /* legacy web compatibility */
39172|      0|        realm = JS_GetFunctionRealm(ctx, ctor);
39173|      0|        if (!realm) {
39174|      0|            JS_FreeValue(ctx, ctor);
39175|      0|            return JS_EXCEPTION;
39176|      0|        }
39177|      0|        if (realm != ctx &&
39178|      0|            js_same_value(ctx, ctor, realm->array_ctor)) {
39179|      0|            JS_FreeValue(ctx, ctor);
39180|      0|            ctor = JS_UNDEFINED;
39181|      0|        }
39182|      0|    }
39183|      0|    if (JS_IsObject(ctor)) {
39184|      0|        species = JS_GetProperty(ctx, ctor, JS_ATOM_Symbol_species);
39185|      0|        JS_FreeValue(ctx, ctor);
39186|      0|        if (JS_IsException(species))
39187|      0|            return species;
39188|      0|        ctor = species;
39189|      0|        if (JS_IsNull(ctor))
39190|      0|            ctor = JS_UNDEFINED;
39191|      0|    }
39192|      0|    if (JS_IsUndefined(ctor)) {
39193|      0|        return js_array_constructor(ctx, JS_UNDEFINED, 1, &len_val);
39194|      0|    } else {
39195|      0|        ret = JS_CallConstructor(ctx, ctor, 1, &len_val);
39196|      0|        JS_FreeValue(ctx, ctor);
39197|      0|        return ret;
39198|      0|    }
39199|      0|}
39200|       |
39201|       |static const JSCFunctionListEntry js_array_funcs[] = {
39202|       |    JS_CFUNC_DEF("isArray", 1, js_array_isArray ),
39203|       |    JS_CFUNC_DEF("from", 1, js_array_from ),
39204|       |    JS_CFUNC_DEF("of", 0, js_array_of ),
39205|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
39206|       |};
39207|       |
39208|       |static int JS_isConcatSpreadable(JSContext *ctx, JSValueConst obj)
39209|      0|{
39210|      0|    JSValue val;
39211|       |
39212|      0|    if (!JS_IsObject(obj))
39213|      0|        return FALSE;
39214|      0|    val = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_isConcatSpreadable);
39215|      0|    if (JS_IsException(val))
39216|      0|        return -1;
39217|      0|    if (!JS_IsUndefined(val))
39218|      0|        return JS_ToBoolFree(ctx, val);
39219|      0|    return JS_IsArray(ctx, obj);
39220|      0|}
39221|       |
39222|       |static JSValue js_array_at(JSContext *ctx, JSValueConst this_val,
39223|       |                           int argc, JSValueConst *argv)
39224|      0|{
39225|      0|    JSValue obj, ret;
39226|      0|    int64_t len, idx;
39227|      0|    JSValue *arrp;
39228|      0|    uint32_t count;
39229|       |
39230|      0|    obj = JS_ToObject(ctx, this_val);
39231|      0|    if (js_get_length64(ctx, &len, obj))
39232|      0|        goto exception;
39233|       |
39234|      0|    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
39235|      0|        goto exception;
39236|       |
39237|      0|    if (idx < 0)
39238|      0|        idx = len + idx;
39239|      0|    if (idx < 0 || idx >= len) {
39240|      0|        ret = JS_UNDEFINED;
39241|      0|    } else if (js_get_fast_array(ctx, obj, &arrp, &count) && idx < count) {
39242|      0|        ret = JS_DupValue(ctx, arrp[idx]);
39243|      0|    } else {
39244|      0|        int present = JS_TryGetPropertyInt64(ctx, obj, idx, &ret);
39245|      0|        if (present < 0)
39246|      0|            goto exception;
39247|      0|        if (!present)
39248|      0|            ret = JS_UNDEFINED;
39249|      0|    }
39250|      0|    JS_FreeValue(ctx, obj);
39251|      0|    return ret;
39252|      0| exception:
39253|      0|    JS_FreeValue(ctx, obj);
39254|      0|    return JS_EXCEPTION;
39255|      0|}
39256|       |
39257|       |static JSValue js_array_with(JSContext *ctx, JSValueConst this_val,
39258|       |                             int argc, JSValueConst *argv)
39259|      0|{
39260|      0|    JSValue arr, obj, ret, *arrp, *pval;
39261|      0|    JSObject *p;
39262|      0|    int64_t i, len, idx;
39263|      0|    uint32_t count32;
39264|       |
39265|      0|    ret = JS_EXCEPTION;
39266|      0|    arr = JS_UNDEFINED;
39267|      0|    obj = JS_ToObject(ctx, this_val);
39268|      0|    if (js_get_length64(ctx, &len, obj))
39269|      0|        goto exception;
39270|       |
39271|      0|    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
39272|      0|        goto exception;
39273|       |
39274|      0|    if (idx < 0)
39275|      0|        idx = len + idx;
39276|       |
39277|      0|    if (idx < 0 || idx >= len) {
39278|      0|        JS_ThrowRangeError(ctx, "invalid array index: %" PRId64, idx);
39279|      0|        goto exception;
39280|      0|    }
39281|       |
39282|      0|    arr = js_allocate_fast_array(ctx, len);
39283|      0|    if (JS_IsException(arr))
39284|      0|        goto exception;
39285|       |
39286|      0|    p = JS_VALUE_GET_OBJ(arr);
39287|      0|    i = 0;
39288|      0|    pval = p->u.array.u.values;
39289|      0|    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
39290|      0|        for (; i < idx; i++, pval++)
39291|      0|            *pval = JS_DupValue(ctx, arrp[i]);
39292|      0|        *pval = JS_DupValue(ctx, argv[1]);
39293|      0|        for (i++, pval++; i < len; i++, pval++)
39294|      0|            *pval = JS_DupValue(ctx, arrp[i]);
39295|      0|    } else {
39296|      0|        for (; i < idx; i++, pval++)
39297|      0|            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval))
39298|      0|                goto fill_and_fail;
39299|      0|        *pval = JS_DupValue(ctx, argv[1]);
39300|      0|        for (i++, pval++; i < len; i++, pval++) {
39301|      0|            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval)) {
39302|      0|            fill_and_fail:
39303|      0|                for (; i < len; i++, pval++)
39304|      0|                    *pval = JS_UNDEFINED;
39305|      0|                goto exception;
39306|      0|            }
39307|      0|        }
39308|      0|    }
39309|       |
39310|      0|    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, len)) < 0)
39311|      0|        goto exception;
39312|       |
39313|      0|    ret = arr;
39314|      0|    arr = JS_UNDEFINED;
39315|       |
39316|      0|exception:
39317|      0|    JS_FreeValue(ctx, arr);
39318|      0|    JS_FreeValue(ctx, obj);
39319|      0|    return ret;
39320|      0|}
39321|       |
39322|       |static JSValue js_array_concat(JSContext *ctx, JSValueConst this_val,
39323|       |                               int argc, JSValueConst *argv)
39324|      0|{
39325|      0|    JSValue obj, arr, val;
39326|      0|    JSValueConst e;
39327|      0|    int64_t len, k, n;
39328|      0|    int i, res;
39329|       |
39330|      0|    arr = JS_UNDEFINED;
39331|      0|    obj = JS_ToObject(ctx, this_val);
39332|      0|    if (JS_IsException(obj))
39333|      0|        goto exception;
39334|       |
39335|      0|    arr = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0));
39336|      0|    if (JS_IsException(arr))
39337|      0|        goto exception;
39338|      0|    n = 0;
39339|      0|    for (i = -1; i < argc; i++) {
39340|      0|        if (i < 0)
39341|      0|            e = obj;
39342|      0|        else
39343|      0|            e = argv[i];
39344|       |
39345|      0|        res = JS_isConcatSpreadable(ctx, e);
39346|      0|        if (res < 0)
39347|      0|            goto exception;
39348|      0|        if (res) {
39349|      0|            if (js_get_length64(ctx, &len, e))
39350|      0|                goto exception;
39351|      0|            if (n + len > MAX_SAFE_INTEGER) {
39352|      0|                JS_ThrowTypeError(ctx, "Array loo long");
39353|      0|                goto exception;
39354|      0|            }
39355|      0|            for (k = 0; k < len; k++, n++) {
39356|      0|                res = JS_TryGetPropertyInt64(ctx, e, k, &val);
39357|      0|                if (res < 0)
39358|      0|                    goto exception;
39359|      0|                if (res) {
39360|      0|                    if (JS_DefinePropertyValueInt64(ctx, arr, n, val,
39361|      0|                                                    JS_PROP_C_W_E | JS_PROP_THROW) < 0)
39362|      0|                        goto exception;
39363|      0|                }
39364|      0|            }
39365|      0|        } else {
39366|      0|            if (n >= MAX_SAFE_INTEGER) {
39367|      0|                JS_ThrowTypeError(ctx, "Array loo long");
39368|      0|                goto exception;
39369|      0|            }
39370|      0|            if (JS_DefinePropertyValueInt64(ctx, arr, n, JS_DupValue(ctx, e),
39371|      0|                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)
39372|      0|                goto exception;
39373|      0|            n++;
39374|      0|        }
39375|      0|    }
39376|      0|    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, n)) < 0)
39377|      0|        goto exception;
39378|       |
39379|      0|    JS_FreeValue(ctx, obj);
39380|      0|    return arr;
39381|       |
39382|      0|exception:
39383|      0|    JS_FreeValue(ctx, arr);
39384|      0|    JS_FreeValue(ctx, obj);
39385|      0|    return JS_EXCEPTION;
39386|      0|}
39387|       |
39388|      0|#define special_every    0
39389|      0|#define special_some     1
39390|       |#define special_forEach  2
39391|      0|#define special_map      3
39392|      0|#define special_filter   4
39393|      0|#define special_TA       8
39394|       |
39395|       |static int js_typed_array_get_length_internal(JSContext *ctx, JSValueConst obj);
39396|       |
39397|       |static JSValue js_typed_array___speciesCreate(JSContext *ctx,
39398|       |                                              JSValueConst this_val,
39399|       |                                              int argc, JSValueConst *argv);
39400|       |
39401|       |static JSValue js_array_every(JSContext *ctx, JSValueConst this_val,
39402|       |                              int argc, JSValueConst *argv, int special)
39403|      0|{
39404|      0|    JSValue obj, val, index_val, res, ret;
39405|      0|    JSValueConst args[3];
39406|      0|    JSValueConst func, this_arg;
39407|      0|    int64_t len, k, n;
39408|      0|    int present;
39409|       |
39410|      0|    ret = JS_UNDEFINED;
39411|      0|    val = JS_UNDEFINED;
39412|      0|    if (special & special_TA) {
39413|      0|        obj = JS_DupValue(ctx, this_val);
39414|      0|        len = js_typed_array_get_length_internal(ctx, obj);
39415|      0|        if (len < 0)
39416|      0|            goto exception;
39417|      0|    } else {
39418|      0|        obj = JS_ToObject(ctx, this_val);
39419|      0|        if (js_get_length64(ctx, &len, obj))
39420|      0|            goto exception;
39421|      0|    }
39422|      0|    func = argv[0];
39423|      0|    this_arg = JS_UNDEFINED;
39424|      0|    if (argc > 1)
39425|      0|        this_arg = argv[1];
39426|       |
39427|      0|    if (check_function(ctx, func))
39428|      0|        goto exception;
39429|       |
39430|      0|    switch (special) {
39431|      0|    case special_every:
39432|      0|    case special_every | special_TA:
39433|      0|        ret = JS_TRUE;
39434|      0|        break;
39435|      0|    case special_some:
39436|      0|    case special_some | special_TA:
39437|      0|        ret = JS_FALSE;
39438|      0|        break;
39439|      0|    case special_map:
39440|       |        /* XXX: JS_ArraySpeciesCreate should take int64_t */
39441|      0|        ret = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt64(ctx, len));
39442|      0|        if (JS_IsException(ret))
39443|      0|            goto exception;
39444|      0|        break;
39445|      0|    case special_filter:
39446|      0|        ret = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0));
39447|      0|        if (JS_IsException(ret))
39448|      0|            goto exception;
39449|      0|        break;
39450|      0|    case special_map | special_TA:
39451|      0|        args[0] = obj;
39452|      0|        args[1] = JS_NewInt32(ctx, len);
39453|      0|        ret = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 2, args);
39454|      0|        if (JS_IsException(ret))
39455|      0|            goto exception;
39456|      0|        break;
39457|      0|    case special_filter | special_TA:
39458|      0|        ret = JS_NewArray(ctx);
39459|      0|        if (JS_IsException(ret))
39460|      0|            goto exception;
39461|      0|        break;
39462|      0|    }
39463|      0|    n = 0;
39464|       |
39465|      0|    for(k = 0; k < len; k++) {
39466|      0|        if (special & special_TA) {
39467|      0|            val = JS_GetPropertyInt64(ctx, obj, k);
39468|      0|            if (JS_IsException(val))
39469|      0|                goto exception;
39470|      0|            present = TRUE;
39471|      0|        } else {
39472|      0|            present = JS_TryGetPropertyInt64(ctx, obj, k, &val);
39473|      0|            if (present < 0)
39474|      0|                goto exception;
39475|      0|        }
39476|      0|        if (present) {
39477|      0|            index_val = JS_NewInt64(ctx, k);
39478|      0|            if (JS_IsException(index_val))
39479|      0|                goto exception;
39480|      0|            args[0] = val;
39481|      0|            args[1] = index_val;
39482|      0|            args[2] = obj;
39483|      0|            res = JS_Call(ctx, func, this_arg, 3, args);
39484|      0|            JS_FreeValue(ctx, index_val);
39485|      0|            if (JS_IsException(res))
39486|      0|                goto exception;
39487|      0|            switch (special) {
39488|      0|            case special_every:
39489|      0|            case special_every | special_TA:
39490|      0|                if (!JS_ToBoolFree(ctx, res)) {
39491|      0|                    ret = JS_FALSE;
39492|      0|                    goto done;
39493|      0|                }
39494|      0|                break;
39495|      0|            case special_some:
39496|      0|            case special_some | special_TA:
39497|      0|                if (JS_ToBoolFree(ctx, res)) {
39498|      0|                    ret = JS_TRUE;
39499|      0|                    goto done;
39500|      0|                }
39501|      0|                break;
39502|      0|            case special_map:
39503|      0|                if (JS_DefinePropertyValueInt64(ctx, ret, k, res,
39504|      0|                                                JS_PROP_C_W_E | JS_PROP_THROW) < 0)
39505|      0|                    goto exception;
39506|      0|                break;
39507|      0|            case special_map | special_TA:
39508|      0|                if (JS_SetPropertyValue(ctx, ret, JS_NewInt32(ctx, k), res, JS_PROP_THROW) < 0)
39509|      0|                    goto exception;
39510|      0|                break;
39511|      0|            case special_filter:
39512|      0|            case special_filter | special_TA:
39513|      0|                if (JS_ToBoolFree(ctx, res)) {
39514|      0|                    if (JS_DefinePropertyValueInt64(ctx, ret, n++, JS_DupValue(ctx, val),
39515|      0|                                                    JS_PROP_C_W_E | JS_PROP_THROW) < 0)
39516|      0|                        goto exception;
39517|      0|                }
39518|      0|                break;
39519|      0|            default:
39520|      0|                JS_FreeValue(ctx, res);
39521|      0|                break;
39522|      0|            }
39523|      0|            JS_FreeValue(ctx, val);
39524|      0|            val = JS_UNDEFINED;
39525|      0|        }
39526|      0|    }
39527|      0|done:
39528|      0|    if (special == (special_filter | special_TA)) {
39529|      0|        JSValue arr;
39530|      0|        args[0] = obj;
39531|      0|        args[1] = JS_NewInt32(ctx, n);
39532|      0|        arr = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 2, args);
39533|      0|        if (JS_IsException(arr))
39534|      0|            goto exception;
39535|      0|        args[0] = ret;
39536|      0|        res = JS_Invoke(ctx, arr, JS_ATOM_set, 1, args);
39537|      0|        if (check_exception_free(ctx, res))
39538|      0|            goto exception;
39539|      0|        JS_FreeValue(ctx, ret);
39540|      0|        ret = arr;
39541|      0|    }
39542|      0|    JS_FreeValue(ctx, val);
39543|      0|    JS_FreeValue(ctx, obj);
39544|      0|    return ret;
39545|       |
39546|      0|exception:
39547|      0|    JS_FreeValue(ctx, ret);
39548|      0|    JS_FreeValue(ctx, val);
39549|      0|    JS_FreeValue(ctx, obj);
39550|      0|    return JS_EXCEPTION;
39551|      0|}
39552|       |
39553|       |#define special_reduce       0
39554|      0|#define special_reduceRight  1
39555|       |
39556|       |static JSValue js_array_reduce(JSContext *ctx, JSValueConst this_val,
39557|       |                               int argc, JSValueConst *argv, int special)
39558|      0|{
39559|      0|    JSValue obj, val, index_val, acc, acc1;
39560|      0|    JSValueConst args[4];
39561|      0|    JSValueConst func;
39562|      0|    int64_t len, k, k1;
39563|      0|    int present;
39564|       |
39565|      0|    acc = JS_UNDEFINED;
39566|      0|    val = JS_UNDEFINED;
39567|      0|    if (special & special_TA) {
39568|      0|        obj = JS_DupValue(ctx, this_val);
39569|      0|        len = js_typed_array_get_length_internal(ctx, obj);
39570|      0|        if (len < 0)
39571|      0|            goto exception;
39572|      0|    } else {
39573|      0|        obj = JS_ToObject(ctx, this_val);
39574|      0|        if (js_get_length64(ctx, &len, obj))
39575|      0|            goto exception;
39576|      0|    }
39577|      0|    func = argv[0];
39578|       |
39579|      0|    if (check_function(ctx, func))
39580|      0|        goto exception;
39581|       |
39582|      0|    k = 0;
39583|      0|    if (argc > 1) {
39584|      0|        acc = JS_DupValue(ctx, argv[1]);
39585|      0|    } else {
39586|      0|        for(;;) {
39587|      0|            if (k >= len) {
39588|      0|                JS_ThrowTypeError(ctx, "empty array");
39589|      0|                goto exception;
39590|      0|            }
39591|      0|            k1 = (special & special_reduceRight) ? len - k - 1 : k;
39592|      0|            k++;
39593|      0|            if (special & special_TA) {
39594|      0|                acc = JS_GetPropertyInt64(ctx, obj, k1);
39595|      0|                if (JS_IsException(acc))
39596|      0|                    goto exception;
39597|      0|                break;
39598|      0|            } else {
39599|      0|                present = JS_TryGetPropertyInt64(ctx, obj, k1, &acc);
39600|      0|                if (present < 0)
39601|      0|                    goto exception;
39602|      0|                if (present)
39603|      0|                    break;
39604|      0|            }
39605|      0|        }
39606|      0|    }
39607|      0|    for (; k < len; k++) {
39608|      0|        k1 = (special & special_reduceRight) ? len - k - 1 : k;
39609|      0|        if (special & special_TA) {
39610|      0|            val = JS_GetPropertyInt64(ctx, obj, k1);
39611|      0|            if (JS_IsException(val))
39612|      0|                goto exception;
39613|      0|            present = TRUE;
39614|      0|        } else {
39615|      0|            present = JS_TryGetPropertyInt64(ctx, obj, k1, &val);
39616|      0|            if (present < 0)
39617|      0|                goto exception;
39618|      0|        }
39619|      0|        if (present) {
39620|      0|            index_val = JS_NewInt64(ctx, k1);
39621|      0|            if (JS_IsException(index_val))
39622|      0|                goto exception;
39623|      0|            args[0] = acc;
39624|      0|            args[1] = val;
39625|      0|            args[2] = index_val;
39626|      0|            args[3] = obj;
39627|      0|            acc1 = JS_Call(ctx, func, JS_UNDEFINED, 4, args);
39628|      0|            JS_FreeValue(ctx, index_val);
39629|      0|            JS_FreeValue(ctx, val);
39630|      0|            val = JS_UNDEFINED;
39631|      0|            if (JS_IsException(acc1))
39632|      0|                goto exception;
39633|      0|            JS_FreeValue(ctx, acc);
39634|      0|            acc = acc1;
39635|      0|        }
39636|      0|    }
39637|      0|    JS_FreeValue(ctx, obj);
39638|      0|    return acc;
39639|       |
39640|      0|exception:
39641|      0|    JS_FreeValue(ctx, acc);
39642|      0|    JS_FreeValue(ctx, val);
39643|      0|    JS_FreeValue(ctx, obj);
39644|      0|    return JS_EXCEPTION;
39645|      0|}
39646|       |
39647|       |static JSValue js_array_fill(JSContext *ctx, JSValueConst this_val,
39648|       |                             int argc, JSValueConst *argv)
39649|      0|{
39650|      0|    JSValue obj;
39651|      0|    int64_t len, start, end;
39652|       |
39653|      0|    obj = JS_ToObject(ctx, this_val);
39654|      0|    if (js_get_length64(ctx, &len, obj))
39655|      0|        goto exception;
39656|       |
39657|      0|    start = 0;
39658|      0|    if (argc > 1 && !JS_IsUndefined(argv[1])) {
39659|      0|        if (JS_ToInt64Clamp(ctx, &start, argv[1], 0, len, len))
39660|      0|            goto exception;
39661|      0|    }
39662|       |
39663|      0|    end = len;
39664|      0|    if (argc > 2 && !JS_IsUndefined(argv[2])) {
39665|      0|        if (JS_ToInt64Clamp(ctx, &end, argv[2], 0, len, len))
39666|      0|            goto exception;
39667|      0|    }
39668|       |
39669|       |    /* XXX: should special case fast arrays */
39670|      0|    while (start < end) {
39671|      0|        if (JS_SetPropertyInt64(ctx, obj, start,
39672|      0|                                JS_DupValue(ctx, argv[0])) < 0)
39673|      0|            goto exception;
39674|      0|        start++;
39675|      0|    }
39676|      0|    return obj;
39677|       |
39678|      0| exception:
39679|      0|    JS_FreeValue(ctx, obj);
39680|      0|    return JS_EXCEPTION;
39681|      0|}
39682|       |
39683|       |static JSValue js_array_includes(JSContext *ctx, JSValueConst this_val,
39684|       |                                 int argc, JSValueConst *argv)
39685|      0|{
39686|      0|    JSValue obj, val;
39687|      0|    int64_t len, n;
39688|      0|    JSValue *arrp;
39689|      0|    uint32_t count;
39690|      0|    int res;
39691|       |
39692|      0|    obj = JS_ToObject(ctx, this_val);
39693|      0|    if (js_get_length64(ctx, &len, obj))
39694|      0|        goto exception;
39695|       |
39696|      0|    res = FALSE;
39697|      0|    if (len > 0) {
39698|      0|        n = 0;
39699|      0|        if (argc > 1) {
39700|      0|            if (JS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len))
39701|      0|                goto exception;
39702|      0|        }
39703|      0|        if (js_get_fast_array(ctx, obj, &arrp, &count)) {
39704|      0|            for (; n < count; n++) {
39705|      0|                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]),
39706|      0|                                  JS_DupValue(ctx, arrp[n]),
39707|      0|                                  JS_EQ_SAME_VALUE_ZERO)) {
39708|      0|                    res = TRUE;
39709|      0|                    goto done;
39710|      0|                }
39711|      0|            }
39712|      0|        }
39713|      0|        for (; n < len; n++) {
39714|      0|            val = JS_GetPropertyInt64(ctx, obj, n);
39715|      0|            if (JS_IsException(val))
39716|      0|                goto exception;
39717|      0|            if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]), val,
39718|      0|                              JS_EQ_SAME_VALUE_ZERO)) {
39719|      0|                res = TRUE;
39720|      0|                break;
39721|      0|            }
39722|      0|        }
39723|      0|    }
39724|      0| done:
39725|      0|    JS_FreeValue(ctx, obj);
39726|      0|    return JS_NewBool(ctx, res);
39727|       |
39728|      0| exception:
39729|      0|    JS_FreeValue(ctx, obj);
39730|      0|    return JS_EXCEPTION;
39731|      0|}
39732|       |
39733|       |static JSValue js_array_indexOf(JSContext *ctx, JSValueConst this_val,
39734|       |                                int argc, JSValueConst *argv)
39735|      0|{
39736|      0|    JSValue obj, val;
39737|      0|    int64_t len, n, res;
39738|      0|    JSValue *arrp;
39739|      0|    uint32_t count;
39740|       |
39741|      0|    obj = JS_ToObject(ctx, this_val);
39742|      0|    if (js_get_length64(ctx, &len, obj))
39743|      0|        goto exception;
39744|       |
39745|      0|    res = -1;
39746|      0|    if (len > 0) {
39747|      0|        n = 0;
39748|      0|        if (argc > 1) {
39749|      0|            if (JS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len))
39750|      0|                goto exception;
39751|      0|        }
39752|      0|        if (js_get_fast_array(ctx, obj, &arrp, &count)) {
39753|      0|            for (; n < count; n++) {
39754|      0|                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]),
39755|      0|                                  JS_DupValue(ctx, arrp[n]), JS_EQ_STRICT)) {
39756|      0|                    res = n;
39757|      0|                    goto done;
39758|      0|                }
39759|      0|            }
39760|      0|        }
39761|      0|        for (; n < len; n++) {
39762|      0|            int present = JS_TryGetPropertyInt64(ctx, obj, n, &val);
39763|      0|            if (present < 0)
39764|      0|                goto exception;
39765|      0|            if (present) {
39766|      0|                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]), val, JS_EQ_STRICT)) {
39767|      0|                    res = n;
39768|      0|                    break;
39769|      0|                }
39770|      0|            }
39771|      0|        }
39772|      0|    }
39773|      0| done:
39774|      0|    JS_FreeValue(ctx, obj);
39775|      0|    return JS_NewInt64(ctx, res);
39776|       |
39777|      0| exception:
39778|      0|    JS_FreeValue(ctx, obj);
39779|      0|    return JS_EXCEPTION;
39780|      0|}
39781|       |
39782|       |static JSValue js_array_lastIndexOf(JSContext *ctx, JSValueConst this_val,
39783|       |                                    int argc, JSValueConst *argv)
39784|      0|{
39785|      0|    JSValue obj, val;
39786|      0|    int64_t len, n, res;
39787|      0|    int present;
39788|       |
39789|      0|    obj = JS_ToObject(ctx, this_val);
39790|      0|    if (js_get_length64(ctx, &len, obj))
39791|      0|        goto exception;
39792|       |
39793|      0|    res = -1;
39794|      0|    if (len > 0) {
39795|      0|        n = len - 1;
39796|      0|        if (argc > 1) {
39797|      0|            if (JS_ToInt64Clamp(ctx, &n, argv[1], -1, len - 1, len))
39798|      0|                goto exception;
39799|      0|        }
39800|       |        /* XXX: should special case fast arrays */
39801|      0|        for (; n >= 0; n--) {
39802|      0|            present = JS_TryGetPropertyInt64(ctx, obj, n, &val);
39803|      0|            if (present < 0)
39804|      0|                goto exception;
39805|      0|            if (present) {
39806|      0|                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]), val, JS_EQ_STRICT)) {
39807|      0|                    res = n;
39808|      0|                    break;
39809|      0|                }
39810|      0|            }
39811|      0|        }
39812|      0|    }
39813|      0|    JS_FreeValue(ctx, obj);
39814|      0|    return JS_NewInt64(ctx, res);
39815|       |
39816|      0| exception:
39817|      0|    JS_FreeValue(ctx, obj);
39818|      0|    return JS_EXCEPTION;
39819|      0|}
39820|       |
39821|       |enum {
39822|       |    ArrayFind,
39823|       |    ArrayFindIndex,
39824|       |    ArrayFindLast,
39825|       |    ArrayFindLastIndex,
39826|       |};
39827|       |
39828|       |static JSValue js_array_find(JSContext *ctx, JSValueConst this_val,
39829|       |                             int argc, JSValueConst *argv, int mode)
39830|      0|{
39831|      0|    JSValueConst func, this_arg;
39832|      0|    JSValueConst args[3];
39833|      0|    JSValue obj, val, index_val, res;
39834|      0|    int64_t len, k, end;
39835|      0|    int dir;
39836|       |
39837|      0|    index_val = JS_UNDEFINED;
39838|      0|    val = JS_UNDEFINED;
39839|      0|    obj = JS_ToObject(ctx, this_val);
39840|      0|    if (js_get_length64(ctx, &len, obj))
39841|      0|        goto exception;
39842|       |
39843|      0|    func = argv[0];
39844|      0|    if (check_function(ctx, func))
39845|      0|        goto exception;
39846|       |
39847|      0|    this_arg = JS_UNDEFINED;
39848|      0|    if (argc > 1)
39849|      0|        this_arg = argv[1];
39850|       |
39851|      0|    k = 0;
39852|      0|    dir = 1;
39853|      0|    end = len;
39854|      0|    if (mode == ArrayFindLast || mode == ArrayFindLastIndex) {
39855|      0|        k = len - 1;
39856|      0|        dir = -1;
39857|      0|        end = -1;
39858|      0|    }
39859|       |
39860|       |    // TODO(bnoordhuis) add fast path for fast arrays
39861|      0|    for(; k != end; k += dir) {
39862|      0|        index_val = JS_NewInt64(ctx, k);
39863|      0|        if (JS_IsException(index_val))
39864|      0|            goto exception;
39865|      0|        val = JS_GetPropertyValue(ctx, obj, index_val);
39866|      0|        if (JS_IsException(val))
39867|      0|            goto exception;
39868|      0|        args[0] = val;
39869|      0|        args[1] = index_val;
39870|      0|        args[2] = this_val;
39871|      0|        res = JS_Call(ctx, func, this_arg, 3, args);
39872|      0|        if (JS_IsException(res))
39873|      0|            goto exception;
39874|      0|        if (JS_ToBoolFree(ctx, res)) {
39875|      0|            if (mode == ArrayFindIndex || mode == ArrayFindLastIndex) {
39876|      0|                JS_FreeValue(ctx, val);
39877|      0|                JS_FreeValue(ctx, obj);
39878|      0|                return index_val;
39879|      0|            } else {
39880|      0|                JS_FreeValue(ctx, index_val);
39881|      0|                JS_FreeValue(ctx, obj);
39882|      0|                return val;
39883|      0|            }
39884|      0|        }
39885|      0|        JS_FreeValue(ctx, val);
39886|      0|        JS_FreeValue(ctx, index_val);
39887|      0|    }
39888|      0|    JS_FreeValue(ctx, obj);
39889|      0|    if (mode == ArrayFindIndex || mode == ArrayFindLastIndex)
39890|      0|        return JS_NewInt32(ctx, -1);
39891|      0|    else
39892|      0|        return JS_UNDEFINED;
39893|       |
39894|      0|exception:
39895|      0|    JS_FreeValue(ctx, index_val);
39896|      0|    JS_FreeValue(ctx, val);
39897|      0|    JS_FreeValue(ctx, obj);
39898|      0|    return JS_EXCEPTION;
39899|      0|}
39900|       |
39901|       |static JSValue js_array_toString(JSContext *ctx, JSValueConst this_val,
39902|       |                                 int argc, JSValueConst *argv)
39903|   232k|{
39904|   232k|    JSValue obj, method, ret;
39905|       |
39906|   232k|    obj = JS_ToObject(ctx, this_val);
39907|   232k|    if (JS_IsException(obj))
39908|      0|        return JS_EXCEPTION;
39909|   232k|    method = JS_GetProperty(ctx, obj, JS_ATOM_join);
39910|   232k|    if (JS_IsException(method)) {
39911|      0|        ret = JS_EXCEPTION;
39912|      0|    } else
39913|   232k|    if (!JS_IsFunction(ctx, method)) {
39914|       |        /* Use intrinsic Object.prototype.toString */
39915|      0|        JS_FreeValue(ctx, method);
39916|      0|        ret = js_object_toString(ctx, obj, 0, NULL);
39917|   232k|    } else {
39918|   232k|        ret = JS_CallFree(ctx, method, obj, 0, NULL);
39919|   232k|    }
39920|   232k|    JS_FreeValue(ctx, obj);
39921|   232k|    return ret;
39922|   232k|}
39923|       |
39924|       |static JSValue js_array_join(JSContext *ctx, JSValueConst this_val,
39925|       |                             int argc, JSValueConst *argv, int toLocaleString)
39926|   232k|{
39927|   232k|    JSValue obj, sep = JS_UNDEFINED, el;
39928|   232k|    StringBuffer b_s, *b = &b_s;
39929|   232k|    JSString *p = NULL;
39930|   232k|    int64_t i, n;
39931|   232k|    int c;
39932|       |
39933|   232k|    obj = JS_ToObject(ctx, this_val);
39934|   232k|    if (js_get_length64(ctx, &n, obj))
39935|      0|        goto exception;
39936|       |
39937|   232k|    c = ',';    /* default separator */
39938|   232k|    if (!toLocaleString && argc > 0 && !JS_IsUndefined(argv[0])) {
39939|      0|        sep = JS_ToString(ctx, argv[0]);
39940|      0|        if (JS_IsException(sep))
39941|      0|            goto exception;
39942|      0|        p = JS_VALUE_GET_STRING(sep);
39943|      0|        if (p->len == 1 && !p->is_wide_char)
39944|      0|            c = p->u.str8[0];
39945|      0|        else
39946|      0|            c = -1;
39947|      0|    }
39948|   232k|    string_buffer_init(ctx, b, 0);
39949|       |
39950|  5.98M|    for(i = 0; i < n; i++) {
39951|  5.75M|        if (i > 0) {
39952|  5.52M|            if (c >= 0) {
39953|  5.52M|                string_buffer_putc8(b, c);
39954|  5.52M|            } else {
39955|      0|                string_buffer_concat(b, p, 0, p->len);
39956|      0|            }
39957|  5.52M|        }
39958|  5.75M|        el = JS_GetPropertyUint32(ctx, obj, i);
39959|  5.75M|        if (JS_IsException(el))
39960|      0|            goto fail;
39961|  5.75M|        if (!JS_IsNull(el) && !JS_IsUndefined(el)) {
39962|  1.34M|            if (toLocaleString) {
39963|      0|                el = JS_ToLocaleStringFree(ctx, el);
39964|      0|            }
39965|  1.34M|            if (string_buffer_concat_value_free(b, el))
39966|      0|                goto fail;
39967|  1.34M|        }
39968|  5.75M|    }
39969|   232k|    JS_FreeValue(ctx, sep);
39970|   232k|    JS_FreeValue(ctx, obj);
39971|   232k|    return string_buffer_end(b);
39972|       |
39973|      0|fail:
39974|      0|    string_buffer_free(b);
39975|      0|    JS_FreeValue(ctx, sep);
39976|      0|exception:
39977|      0|    JS_FreeValue(ctx, obj);
39978|      0|    return JS_EXCEPTION;
39979|      0|}
39980|       |
39981|       |static JSValue js_array_pop(JSContext *ctx, JSValueConst this_val,
39982|       |                            int argc, JSValueConst *argv, int shift)
39983|      0|{
39984|      0|    JSValue obj, res = JS_UNDEFINED;
39985|      0|    int64_t len, newLen;
39986|      0|    JSValue *arrp;
39987|      0|    uint32_t count32;
39988|       |
39989|      0|    obj = JS_ToObject(ctx, this_val);
39990|      0|    if (js_get_length64(ctx, &len, obj))
39991|      0|        goto exception;
39992|      0|    newLen = 0;
39993|      0|    if (len > 0) {
39994|      0|        newLen = len - 1;
39995|       |        /* Special case fast arrays */
39996|      0|        if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
39997|      0|            JSObject *p = JS_VALUE_GET_OBJ(obj);
39998|      0|            if (shift) {
39999|      0|                res = arrp[0];
40000|      0|                memmove(arrp, arrp + 1, (count32 - 1) * sizeof(*arrp));
40001|      0|                p->u.array.count--;
40002|      0|            } else {
40003|      0|                res = arrp[count32 - 1];
40004|      0|                p->u.array.count--;
40005|      0|            }
40006|      0|        } else {
40007|      0|            if (shift) {
40008|      0|                res = JS_GetPropertyInt64(ctx, obj, 0);
40009|      0|                if (JS_IsException(res))
40010|      0|                    goto exception;
40011|      0|                if (JS_CopySubArray(ctx, obj, 0, 1, len - 1, +1))
40012|      0|                    goto exception;
40013|      0|            } else {
40014|      0|                res = JS_GetPropertyInt64(ctx, obj, newLen);
40015|      0|                if (JS_IsException(res))
40016|      0|                    goto exception;
40017|      0|            }
40018|      0|            if (JS_DeletePropertyInt64(ctx, obj, newLen, JS_PROP_THROW) < 0)
40019|      0|                goto exception;
40020|      0|        }
40021|      0|    }
40022|      0|    if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)
40023|      0|        goto exception;
40024|       |
40025|      0|    JS_FreeValue(ctx, obj);
40026|      0|    return res;
40027|       |
40028|      0| exception:
40029|      0|    JS_FreeValue(ctx, res);
40030|      0|    JS_FreeValue(ctx, obj);
40031|      0|    return JS_EXCEPTION;
40032|      0|}
40033|       |
40034|       |static JSValue js_array_push(JSContext *ctx, JSValueConst this_val,
40035|       |                             int argc, JSValueConst *argv, int unshift)
40036|      0|{
40037|      0|    JSValue obj;
40038|      0|    int i;
40039|      0|    int64_t len, from, newLen;
40040|       |
40041|      0|    obj = JS_ToObject(ctx, this_val);
40042|      0|    if (js_get_length64(ctx, &len, obj))
40043|      0|        goto exception;
40044|      0|    newLen = len + argc;
40045|      0|    if (newLen > MAX_SAFE_INTEGER) {
40046|      0|        JS_ThrowTypeError(ctx, "Array loo long");
40047|      0|        goto exception;
40048|      0|    }
40049|      0|    from = len;
40050|      0|    if (unshift && argc > 0) {
40051|      0|        if (JS_CopySubArray(ctx, obj, argc, 0, len, -1))
40052|      0|            goto exception;
40053|      0|        from = 0;
40054|      0|    }
40055|      0|    for(i = 0; i < argc; i++) {
40056|      0|        if (JS_SetPropertyInt64(ctx, obj, from + i,
40057|      0|                                JS_DupValue(ctx, argv[i])) < 0)
40058|      0|            goto exception;
40059|      0|    }
40060|      0|    if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)
40061|      0|        goto exception;
40062|       |
40063|      0|    JS_FreeValue(ctx, obj);
40064|      0|    return JS_NewInt64(ctx, newLen);
40065|       |
40066|      0| exception:
40067|      0|    JS_FreeValue(ctx, obj);
40068|      0|    return JS_EXCEPTION;
40069|      0|}
40070|       |
40071|       |static JSValue js_array_reverse(JSContext *ctx, JSValueConst this_val,
40072|       |                                int argc, JSValueConst *argv)
40073|      0|{
40074|      0|    JSValue obj, lval, hval;
40075|      0|    JSValue *arrp;
40076|      0|    int64_t len, l, h;
40077|      0|    int l_present, h_present;
40078|      0|    uint32_t count32;
40079|       |
40080|      0|    lval = JS_UNDEFINED;
40081|      0|    obj = JS_ToObject(ctx, this_val);
40082|      0|    if (js_get_length64(ctx, &len, obj))
40083|      0|        goto exception;
40084|       |
40085|       |    /* Special case fast arrays */
40086|      0|    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
40087|      0|        uint32_t ll, hh;
40088|       |
40089|      0|        if (count32 > 1) {
40090|      0|            for (ll = 0, hh = count32 - 1; ll < hh; ll++, hh--) {
40091|      0|                lval = arrp[ll];
40092|      0|                arrp[ll] = arrp[hh];
40093|      0|                arrp[hh] = lval;
40094|      0|            }
40095|      0|        }
40096|      0|        return obj;
40097|      0|    }
40098|       |
40099|      0|    for (l = 0, h = len - 1; l < h; l++, h--) {
40100|      0|        l_present = JS_TryGetPropertyInt64(ctx, obj, l, &lval);
40101|      0|        if (l_present < 0)
40102|      0|            goto exception;
40103|      0|        h_present = JS_TryGetPropertyInt64(ctx, obj, h, &hval);
40104|      0|        if (h_present < 0)
40105|      0|            goto exception;
40106|      0|        if (h_present) {
40107|      0|            if (JS_SetPropertyInt64(ctx, obj, l, hval) < 0)
40108|      0|                goto exception;
40109|       |
40110|      0|            if (l_present) {
40111|      0|                if (JS_SetPropertyInt64(ctx, obj, h, lval) < 0) {
40112|      0|                    lval = JS_UNDEFINED;
40113|      0|                    goto exception;
40114|      0|                }
40115|      0|                lval = JS_UNDEFINED;
40116|      0|            } else {
40117|      0|                if (JS_DeletePropertyInt64(ctx, obj, h, JS_PROP_THROW) < 0)
40118|      0|                    goto exception;
40119|      0|            }
40120|      0|        } else {
40121|      0|            if (l_present) {
40122|      0|                if (JS_DeletePropertyInt64(ctx, obj, l, JS_PROP_THROW) < 0)
40123|      0|                    goto exception;
40124|      0|                if (JS_SetPropertyInt64(ctx, obj, h, lval) < 0) {
40125|      0|                    lval = JS_UNDEFINED;
40126|      0|                    goto exception;
40127|      0|                }
40128|      0|                lval = JS_UNDEFINED;
40129|      0|            }
40130|      0|        }
40131|      0|    }
40132|      0|    return obj;
40133|       |
40134|      0| exception:
40135|      0|    JS_FreeValue(ctx, lval);
40136|      0|    JS_FreeValue(ctx, obj);
40137|      0|    return JS_EXCEPTION;
40138|      0|}
40139|       |
40140|       |// Note: a.toReversed() is a.slice().reverse() with the twist that a.slice()
40141|       |// leaves holes in sparse arrays intact whereas a.toReversed() replaces them
40142|       |// with undefined, thus in effect creating a dense array.
40143|       |// Does not use Array[@@species], always returns a base Array.
40144|       |static JSValue js_array_toReversed(JSContext *ctx, JSValueConst this_val,
40145|       |                                   int argc, JSValueConst *argv)
40146|      0|{
40147|      0|    JSValue arr, obj, ret, *arrp, *pval;
40148|      0|    JSObject *p;
40149|      0|    int64_t i, len;
40150|      0|    uint32_t count32;
40151|       |
40152|      0|    ret = JS_EXCEPTION;
40153|      0|    arr = JS_UNDEFINED;
40154|      0|    obj = JS_ToObject(ctx, this_val);
40155|      0|    if (js_get_length64(ctx, &len, obj))
40156|      0|        goto exception;
40157|       |
40158|      0|    arr = js_allocate_fast_array(ctx, len);
40159|      0|    if (JS_IsException(arr))
40160|      0|        goto exception;
40161|       |
40162|      0|    if (len > 0) {
40163|      0|        p = JS_VALUE_GET_OBJ(arr);
40164|       |
40165|      0|        i = len - 1;
40166|      0|        pval = p->u.array.u.values;
40167|      0|        if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
40168|      0|            for (; i >= 0; i--, pval++)
40169|      0|                *pval = JS_DupValue(ctx, arrp[i]);
40170|      0|        } else {
40171|       |            // Query order is observable; test262 expects descending order.
40172|      0|            for (; i >= 0; i--, pval++) {
40173|      0|                if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval)) {
40174|       |                    // Exception; initialize remaining elements.
40175|      0|                    for (; i >= 0; i--, pval++)
40176|      0|                        *pval = JS_UNDEFINED;
40177|      0|                    goto exception;
40178|      0|                }
40179|      0|            }
40180|      0|        }
40181|       |
40182|      0|        if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, len)) < 0)
40183|      0|            goto exception;
40184|      0|    }
40185|       |
40186|      0|    ret = arr;
40187|      0|    arr = JS_UNDEFINED;
40188|       |
40189|      0|exception:
40190|      0|    JS_FreeValue(ctx, arr);
40191|      0|    JS_FreeValue(ctx, obj);
40192|      0|    return ret;
40193|      0|}
40194|       |
40195|       |static JSValue js_array_slice(JSContext *ctx, JSValueConst this_val,
40196|       |                              int argc, JSValueConst *argv, int splice)
40197|      0|{
40198|      0|    JSValue obj, arr, val, len_val;
40199|      0|    int64_t len, start, k, final, n, count, del_count, new_len;
40200|      0|    int kPresent;
40201|      0|    JSValue *arrp;
40202|      0|    uint32_t count32, i, item_count;
40203|       |
40204|      0|    arr = JS_UNDEFINED;
40205|      0|    obj = JS_ToObject(ctx, this_val);
40206|      0|    if (js_get_length64(ctx, &len, obj))
40207|      0|        goto exception;
40208|       |
40209|      0|    if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))
40210|      0|        goto exception;
40211|       |
40212|      0|    if (splice) {
40213|      0|        if (argc == 0) {
40214|      0|            item_count = 0;
40215|      0|            del_count = 0;
40216|      0|        } else
40217|      0|        if (argc == 1) {
40218|      0|            item_count = 0;
40219|      0|            del_count = len - start;
40220|      0|        } else {
40221|      0|            item_count = argc - 2;
40222|      0|            if (JS_ToInt64Clamp(ctx, &del_count, argv[1], 0, len - start, 0))
40223|      0|                goto exception;
40224|      0|        }
40225|      0|        if (len + item_count - del_count > MAX_SAFE_INTEGER) {
40226|      0|            JS_ThrowTypeError(ctx, "Array loo long");
40227|      0|            goto exception;
40228|      0|        }
40229|      0|        count = del_count;
40230|      0|    } else {
40231|      0|        item_count = 0; /* avoid warning */
40232|      0|        final = len;
40233|      0|        if (!JS_IsUndefined(argv[1])) {
40234|      0|            if (JS_ToInt64Clamp(ctx, &final, argv[1], 0, len, len))
40235|      0|                goto exception;
40236|      0|        }
40237|      0|        count = max_int64(final - start, 0);
40238|      0|    }
40239|      0|    len_val = JS_NewInt64(ctx, count);
40240|      0|    arr = JS_ArraySpeciesCreate(ctx, obj, len_val);
40241|      0|    JS_FreeValue(ctx, len_val);
40242|      0|    if (JS_IsException(arr))
40243|      0|        goto exception;
40244|       |
40245|      0|    k = start;
40246|      0|    final = start + count;
40247|      0|    n = 0;
40248|       |    /* The fast array test on arr ensures that
40249|       |       JS_CreateDataPropertyUint32() won't modify obj in case arr is
40250|       |       an exotic object */
40251|       |    /* Special case fast arrays */
40252|      0|    if (js_get_fast_array(ctx, obj, &arrp, &count32) &&
40253|      0|        js_is_fast_array(ctx, arr)) {
40254|       |        /* XXX: should share code with fast array constructor */
40255|      0|        for (; k < final && k < count32; k++, n++) {
40256|      0|            if (JS_CreateDataPropertyUint32(ctx, arr, n, JS_DupValue(ctx, arrp[k]), JS_PROP_THROW) < 0)
40257|      0|                goto exception;
40258|      0|        }
40259|      0|    }
40260|       |    /* Copy the remaining elements if any (handle case of inherited properties) */
40261|      0|    for (; k < final; k++, n++) {
40262|      0|        kPresent = JS_TryGetPropertyInt64(ctx, obj, k, &val);
40263|      0|        if (kPresent < 0)
40264|      0|            goto exception;
40265|      0|        if (kPresent) {
40266|      0|            if (JS_CreateDataPropertyUint32(ctx, arr, n, val, JS_PROP_THROW) < 0)
40267|      0|                goto exception;
40268|      0|        }
40269|      0|    }
40270|      0|    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, n)) < 0)
40271|      0|        goto exception;
40272|       |
40273|      0|    if (splice) {
40274|      0|        new_len = len + item_count - del_count;
40275|      0|        if (item_count != del_count) {
40276|      0|            if (JS_CopySubArray(ctx, obj, start + item_count,
40277|      0|                                start + del_count, len - (start + del_count),
40278|      0|                                item_count <= del_count ? +1 : -1) < 0)
40279|      0|                goto exception;
40280|       |
40281|      0|            for (k = len; k-- > new_len; ) {
40282|      0|                if (JS_DeletePropertyInt64(ctx, obj, k, JS_PROP_THROW) < 0)
40283|      0|                    goto exception;
40284|      0|            }
40285|      0|        }
40286|      0|        for (i = 0; i < item_count; i++) {
40287|      0|            if (JS_SetPropertyInt64(ctx, obj, start + i, JS_DupValue(ctx, argv[i + 2])) < 0)
40288|      0|                goto exception;
40289|      0|        }
40290|      0|        if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, new_len)) < 0)
40291|      0|            goto exception;
40292|      0|    }
40293|      0|    JS_FreeValue(ctx, obj);
40294|      0|    return arr;
40295|       |
40296|      0| exception:
40297|      0|    JS_FreeValue(ctx, obj);
40298|      0|    JS_FreeValue(ctx, arr);
40299|      0|    return JS_EXCEPTION;
40300|      0|}
40301|       |
40302|       |static JSValue js_array_toSpliced(JSContext *ctx, JSValueConst this_val,
40303|       |                                  int argc, JSValueConst *argv)
40304|      0|{
40305|      0|    JSValue arr, obj, ret, *arrp, *pval, *last;
40306|      0|    JSObject *p;
40307|      0|    int64_t i, j, len, newlen, start, add, del;
40308|      0|    uint32_t count32;
40309|       |
40310|      0|    pval = NULL;
40311|      0|    last = NULL;
40312|      0|    ret = JS_EXCEPTION;
40313|      0|    arr = JS_UNDEFINED;
40314|       |
40315|      0|    obj = JS_ToObject(ctx, this_val);
40316|      0|    if (js_get_length64(ctx, &len, obj))
40317|      0|        goto exception;
40318|       |
40319|      0|    start = 0;
40320|      0|    if (argc > 0)
40321|      0|        if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))
40322|      0|            goto exception;
40323|       |
40324|      0|    del = 0;
40325|      0|    if (argc > 0)
40326|      0|        del = len - start;
40327|      0|    if (argc > 1)
40328|      0|        if (JS_ToInt64Clamp(ctx, &del, argv[1], 0, del, 0))
40329|      0|            goto exception;
40330|       |
40331|      0|    add = 0;
40332|      0|    if (argc > 2)
40333|      0|        add = argc - 2;
40334|       |
40335|      0|    newlen = len + add - del;
40336|      0|    if (newlen > MAX_SAFE_INTEGER) {
40337|      0|        JS_ThrowTypeError(ctx, "invalid array length");
40338|      0|        goto exception;
40339|      0|    }
40340|       |
40341|      0|    arr = js_allocate_fast_array(ctx, newlen);
40342|      0|    if (JS_IsException(arr))
40343|      0|        goto exception;
40344|       |
40345|      0|    if (newlen <= 0)
40346|      0|        goto done;
40347|       |
40348|      0|    p = JS_VALUE_GET_OBJ(arr);
40349|      0|    pval = &p->u.array.u.values[0];
40350|      0|    last = &p->u.array.u.values[newlen];
40351|       |
40352|      0|    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
40353|      0|        for (i = 0; i < start; i++, pval++)
40354|      0|            *pval = JS_DupValue(ctx, arrp[i]);
40355|      0|        for (j = 0; j < add; j++, pval++)
40356|      0|            *pval = JS_DupValue(ctx, argv[2 + j]);
40357|      0|        for (i += del; i < len; i++, pval++)
40358|      0|            *pval = JS_DupValue(ctx, arrp[i]);
40359|      0|    } else {
40360|      0|        for (i = 0; i < start; i++, pval++)
40361|      0|            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval))
40362|      0|                goto exception;
40363|      0|        for (j = 0; j < add; j++, pval++)
40364|      0|            *pval = JS_DupValue(ctx, argv[2 + j]);
40365|      0|        for (i += del; i < len; i++, pval++)
40366|      0|            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval))
40367|      0|                goto exception;
40368|      0|    }
40369|       |
40370|      0|    assert(pval == last);
40371|       |
40372|      0|    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, newlen)) < 0)
40373|      0|        goto exception;
40374|       |
40375|      0|done:
40376|      0|    ret = arr;
40377|      0|    arr = JS_UNDEFINED;
40378|       |
40379|      0|exception:
40380|      0|    while (pval != last)
40381|      0|        *pval++ = JS_UNDEFINED;
40382|       |
40383|      0|    JS_FreeValue(ctx, arr);
40384|      0|    JS_FreeValue(ctx, obj);
40385|      0|    return ret;
40386|      0|}
40387|       |
40388|       |static JSValue js_array_copyWithin(JSContext *ctx, JSValueConst this_val,
40389|       |                                   int argc, JSValueConst *argv)
40390|      0|{
40391|      0|    JSValue obj;
40392|      0|    int64_t len, from, to, final, count;
40393|       |
40394|      0|    obj = JS_ToObject(ctx, this_val);
40395|      0|    if (js_get_length64(ctx, &len, obj))
40396|      0|        goto exception;
40397|       |
40398|      0|    if (JS_ToInt64Clamp(ctx, &to, argv[0], 0, len, len))
40399|      0|        goto exception;
40400|       |
40401|      0|    if (JS_ToInt64Clamp(ctx, &from, argv[1], 0, len, len))
40402|      0|        goto exception;
40403|       |
40404|      0|    final = len;
40405|      0|    if (argc > 2 && !JS_IsUndefined(argv[2])) {
40406|      0|        if (JS_ToInt64Clamp(ctx, &final, argv[2], 0, len, len))
40407|      0|            goto exception;
40408|      0|    }
40409|       |
40410|      0|    count = min_int64(final - from, len - to);
40411|       |
40412|      0|    if (JS_CopySubArray(ctx, obj, to, from, count,
40413|      0|                        (from < to && to < from + count) ? -1 : +1))
40414|      0|        goto exception;
40415|       |
40416|      0|    return obj;
40417|       |
40418|      0| exception:
40419|      0|    JS_FreeValue(ctx, obj);
40420|      0|    return JS_EXCEPTION;
40421|      0|}
40422|       |
40423|       |static int64_t JS_FlattenIntoArray(JSContext *ctx, JSValueConst target,
40424|       |                                   JSValueConst source, int64_t sourceLen,
40425|       |                                   int64_t targetIndex, int depth,
40426|       |                                   JSValueConst mapperFunction,
40427|       |                                   JSValueConst thisArg)
40428|      0|{
40429|      0|    JSValue element;
40430|      0|    int64_t sourceIndex, elementLen;
40431|      0|    int present, is_array;
40432|       |
40433|      0|    if (js_check_stack_overflow(ctx->rt, 0)) {
40434|      0|        JS_ThrowStackOverflow(ctx);
40435|      0|        return -1;
40436|      0|    }
40437|       |
40438|      0|    for (sourceIndex = 0; sourceIndex < sourceLen; sourceIndex++) {
40439|      0|        present = JS_TryGetPropertyInt64(ctx, source, sourceIndex, &element);
40440|      0|        if (present < 0)
40441|      0|            return -1;
40442|      0|        if (!present)
40443|      0|            continue;
40444|      0|        if (!JS_IsUndefined(mapperFunction)) {
40445|      0|            JSValueConst args[3] = { element, JS_NewInt64(ctx, sourceIndex), source };
40446|      0|            element = JS_Call(ctx, mapperFunction, thisArg, 3, args);
40447|      0|            JS_FreeValue(ctx, (JSValue)args[0]);
40448|      0|            JS_FreeValue(ctx, (JSValue)args[1]);
40449|      0|            if (JS_IsException(element))
40450|      0|                return -1;
40451|      0|        }
40452|      0|        if (depth > 0) {
40453|      0|            is_array = JS_IsArray(ctx, element);
40454|      0|            if (is_array < 0)
40455|      0|                goto fail;
40456|      0|            if (is_array) {
40457|      0|                if (js_get_length64(ctx, &elementLen, element) < 0)
40458|      0|                    goto fail;
40459|      0|                targetIndex = JS_FlattenIntoArray(ctx, target, element,
40460|      0|                                                  elementLen, targetIndex,
40461|      0|                                                  depth - 1,
40462|      0|                                                  JS_UNDEFINED, JS_UNDEFINED);
40463|      0|                if (targetIndex < 0)
40464|      0|                    goto fail;
40465|      0|                JS_FreeValue(ctx, element);
40466|      0|                continue;
40467|      0|            }
40468|      0|        }
40469|      0|        if (targetIndex >= MAX_SAFE_INTEGER) {
40470|      0|            JS_ThrowTypeError(ctx, "Array too long");
40471|      0|            goto fail;
40472|      0|        }
40473|      0|        if (JS_DefinePropertyValueInt64(ctx, target, targetIndex, element,
40474|      0|                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)
40475|      0|            return -1;
40476|      0|        targetIndex++;
40477|      0|    }
40478|      0|    return targetIndex;
40479|       |
40480|      0|fail:
40481|      0|    JS_FreeValue(ctx, element);
40482|      0|    return -1;
40483|      0|}
40484|       |
40485|       |static JSValue js_array_flatten(JSContext *ctx, JSValueConst this_val,
40486|       |                                int argc, JSValueConst *argv, int map)
40487|      0|{
40488|      0|    JSValue obj, arr;
40489|      0|    JSValueConst mapperFunction, thisArg;
40490|      0|    int64_t sourceLen;
40491|      0|    int depthNum;
40492|       |
40493|      0|    arr = JS_UNDEFINED;
40494|      0|    obj = JS_ToObject(ctx, this_val);
40495|      0|    if (js_get_length64(ctx, &sourceLen, obj))
40496|      0|        goto exception;
40497|       |
40498|      0|    depthNum = 1;
40499|      0|    mapperFunction = JS_UNDEFINED;
40500|      0|    thisArg = JS_UNDEFINED;
40501|      0|    if (map) {
40502|      0|        mapperFunction = argv[0];
40503|      0|        if (argc > 1) {
40504|      0|            thisArg = argv[1];
40505|      0|        }
40506|      0|        if (check_function(ctx, mapperFunction))
40507|      0|            goto exception;
40508|      0|    } else {
40509|      0|        if (argc > 0 && !JS_IsUndefined(argv[0])) {
40510|      0|            if (JS_ToInt32Sat(ctx, &depthNum, argv[0]) < 0)
40511|      0|                goto exception;
40512|      0|        }
40513|      0|    }
40514|      0|    arr = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0));
40515|      0|    if (JS_IsException(arr))
40516|      0|        goto exception;
40517|      0|    if (JS_FlattenIntoArray(ctx, arr, obj, sourceLen, 0, depthNum,
40518|      0|                            mapperFunction, thisArg) < 0)
40519|      0|        goto exception;
40520|      0|    JS_FreeValue(ctx, obj);
40521|      0|    return arr;
40522|       |
40523|      0|exception:
40524|      0|    JS_FreeValue(ctx, obj);
40525|      0|    JS_FreeValue(ctx, arr);
40526|      0|    return JS_EXCEPTION;
40527|      0|}
40528|       |
40529|       |/* Array sort */
40530|       |
40531|       |typedef struct ValueSlot {
40532|       |    JSValue val;
40533|       |    JSString *str;
40534|       |    int64_t pos;
40535|       |} ValueSlot;
40536|       |
40537|       |struct array_sort_context {
40538|       |    JSContext *ctx;
40539|       |    int exception;
40540|       |    int has_method;
40541|       |    JSValueConst method;
40542|       |};
40543|       |
40544|      0|static int js_array_cmp_generic(const void *a, const void *b, void *opaque) {
40545|      0|    struct array_sort_context *psc = opaque;
40546|      0|    JSContext *ctx = psc->ctx;
40547|      0|    JSValueConst argv[2];
40548|      0|    JSValue res;
40549|      0|    ValueSlot *ap = (ValueSlot *)(void *)a;
40550|      0|    ValueSlot *bp = (ValueSlot *)(void *)b;
40551|      0|    int cmp;
40552|       |
40553|      0|    if (psc->exception)
40554|      0|        return 0;
40555|       |
40556|      0|    if (psc->has_method) {
40557|       |        /* custom sort function is specified as returning 0 for identical
40558|       |         * objects: avoid method call overhead.
40559|       |         */
40560|      0|        if (!memcmp(&ap->val, &bp->val, sizeof(ap->val)))
40561|      0|            goto cmp_same;
40562|      0|        argv[0] = ap->val;
40563|      0|        argv[1] = bp->val;
40564|      0|        res = JS_Call(ctx, psc->method, JS_UNDEFINED, 2, argv);
40565|      0|        if (JS_IsException(res))
40566|      0|            goto exception;
40567|      0|        if (JS_VALUE_GET_TAG(res) == JS_TAG_INT) {
40568|      0|            int val = JS_VALUE_GET_INT(res);
40569|      0|            cmp = (val > 0) - (val < 0);
40570|      0|        } else {
40571|      0|            double val;
40572|      0|            if (JS_ToFloat64Free(ctx, &val, res) < 0)
40573|      0|                goto exception;
40574|      0|            cmp = (val > 0) - (val < 0);
40575|      0|        }
40576|      0|    } else {
40577|       |        /* Not supposed to bypass ToString even for identical objects as
40578|       |         * tested in test262/test/built-ins/Array/prototype/sort/bug_596_1.js
40579|       |         */
40580|      0|        if (!ap->str) {
40581|      0|            JSValue str = JS_ToString(ctx, ap->val);
40582|      0|            if (JS_IsException(str))
40583|      0|                goto exception;
40584|      0|            ap->str = JS_VALUE_GET_STRING(str);
40585|      0|        }
40586|      0|        if (!bp->str) {
40587|      0|            JSValue str = JS_ToString(ctx, bp->val);
40588|      0|            if (JS_IsException(str))
40589|      0|                goto exception;
40590|      0|            bp->str = JS_VALUE_GET_STRING(str);
40591|      0|        }
40592|      0|        cmp = js_string_compare(ctx, ap->str, bp->str);
40593|      0|    }
40594|      0|    if (cmp != 0)
40595|      0|        return cmp;
40596|      0|cmp_same:
40597|       |    /* make sort stable: compare array offsets */
40598|      0|    return (ap->pos > bp->pos) - (ap->pos < bp->pos);
40599|       |
40600|      0|exception:
40601|      0|    psc->exception = 1;
40602|      0|    return 0;
40603|      0|}
40604|       |
40605|       |static JSValue js_array_sort(JSContext *ctx, JSValueConst this_val,
40606|       |                             int argc, JSValueConst *argv)
40607|      0|{
40608|      0|    struct array_sort_context asc = { ctx, 0, 0, argv[0] };
40609|      0|    JSValue obj = JS_UNDEFINED;
40610|      0|    ValueSlot *array = NULL;
40611|      0|    size_t array_size = 0, pos = 0, n = 0;
40612|      0|    int64_t i, len, undefined_count = 0;
40613|      0|    int present;
40614|       |
40615|      0|    if (!JS_IsUndefined(asc.method)) {
40616|      0|        if (check_function(ctx, asc.method))
40617|      0|            goto exception;
40618|      0|        asc.has_method = 1;
40619|      0|    }
40620|      0|    obj = JS_ToObject(ctx, this_val);
40621|      0|    if (js_get_length64(ctx, &len, obj))
40622|      0|        goto exception;
40623|       |
40624|       |    /* XXX: should special case fast arrays */
40625|      0|    for (i = 0; i < len; i++) {
40626|      0|        if (pos >= array_size) {
40627|      0|            size_t new_size, slack;
40628|      0|            ValueSlot *new_array;
40629|      0|            new_size = (array_size + (array_size >> 1) + 31) & ~15;
40630|      0|            new_array = js_realloc2(ctx, array, new_size * sizeof(*array), &slack);
40631|      0|            if (new_array == NULL)
40632|      0|                goto exception;
40633|      0|            new_size += slack / sizeof(*new_array);
40634|      0|            array = new_array;
40635|      0|            array_size = new_size;
40636|      0|        }
40637|      0|        present = JS_TryGetPropertyInt64(ctx, obj, i, &array[pos].val);
40638|      0|        if (present < 0)
40639|      0|            goto exception;
40640|      0|        if (present == 0)
40641|      0|            continue;
40642|      0|        if (JS_IsUndefined(array[pos].val)) {
40643|      0|            undefined_count++;
40644|      0|            continue;
40645|      0|        }
40646|      0|        array[pos].str = NULL;
40647|      0|        array[pos].pos = i;
40648|      0|        pos++;
40649|      0|    }
40650|      0|    rqsort(array, pos, sizeof(*array), js_array_cmp_generic, &asc);
40651|      0|    if (asc.exception)
40652|      0|        goto exception;
40653|       |
40654|       |    /* XXX: should special case fast arrays */
40655|      0|    while (n < pos) {
40656|      0|        if (array[n].str)
40657|      0|            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, array[n].str));
40658|      0|        if (array[n].pos == n) {
40659|      0|            JS_FreeValue(ctx, array[n].val);
40660|      0|        } else {
40661|      0|            if (JS_SetPropertyInt64(ctx, obj, n, array[n].val) < 0) {
40662|      0|                n++;
40663|      0|                goto exception;
40664|      0|            }
40665|      0|        }
40666|      0|        n++;
40667|      0|    }
40668|      0|    js_free(ctx, array);
40669|      0|    for (i = n; undefined_count-- > 0; i++) {
40670|      0|        if (JS_SetPropertyInt64(ctx, obj, i, JS_UNDEFINED) < 0)
40671|      0|            goto fail;
40672|      0|    }
40673|      0|    for (; i < len; i++) {
40674|      0|        if (JS_DeletePropertyInt64(ctx, obj, i, JS_PROP_THROW) < 0)
40675|      0|            goto fail;
40676|      0|    }
40677|      0|    return obj;
40678|       |
40679|      0|exception:
40680|      0|    for (; n < pos; n++) {
40681|      0|        JS_FreeValue(ctx, array[n].val);
40682|      0|        if (array[n].str)
40683|      0|            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, array[n].str));
40684|      0|    }
40685|      0|    js_free(ctx, array);
40686|      0|fail:
40687|      0|    JS_FreeValue(ctx, obj);
40688|      0|    return JS_EXCEPTION;
40689|      0|}
40690|       |
40691|       |// Note: a.toSorted() is a.slice().sort() with the twist that a.slice()
40692|       |// leaves holes in sparse arrays intact whereas a.toSorted() replaces them
40693|       |// with undefined, thus in effect creating a dense array.
40694|       |// Does not use Array[@@species], always returns a base Array.
40695|       |static JSValue js_array_toSorted(JSContext *ctx, JSValueConst this_val,
40696|       |                                 int argc, JSValueConst *argv)
40697|      0|{
40698|      0|    JSValue arr, obj, ret, *arrp, *pval;
40699|      0|    JSObject *p;
40700|      0|    int64_t i, len;
40701|      0|    uint32_t count32;
40702|      0|    int ok;
40703|       |
40704|      0|    ok = JS_IsUndefined(argv[0]) || JS_IsFunction(ctx, argv[0]);
40705|      0|    if (!ok)
40706|      0|        return JS_ThrowTypeError(ctx, "not a function");
40707|       |
40708|      0|    ret = JS_EXCEPTION;
40709|      0|    arr = JS_UNDEFINED;
40710|      0|    obj = JS_ToObject(ctx, this_val);
40711|      0|    if (js_get_length64(ctx, &len, obj))
40712|      0|        goto exception;
40713|       |
40714|      0|    arr = js_allocate_fast_array(ctx, len);
40715|      0|    if (JS_IsException(arr))
40716|      0|        goto exception;
40717|       |
40718|      0|    if (len > 0) {
40719|      0|        p = JS_VALUE_GET_OBJ(arr);
40720|      0|        i = 0;
40721|      0|        pval = p->u.array.u.values;
40722|      0|        if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
40723|      0|            for (; i < len; i++, pval++)
40724|      0|                *pval = JS_DupValue(ctx, arrp[i]);
40725|      0|        } else {
40726|      0|            for (; i < len; i++, pval++) {
40727|      0|                if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval)) {
40728|      0|                    for (; i < len; i++, pval++)
40729|      0|                        *pval = JS_UNDEFINED;
40730|      0|                    goto exception;
40731|      0|                }
40732|      0|            }
40733|      0|        }
40734|       |
40735|      0|        if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, len)) < 0)
40736|      0|            goto exception;
40737|      0|    }
40738|       |
40739|      0|    ret = js_array_sort(ctx, arr, argc, argv);
40740|      0|    if (JS_IsException(ret))
40741|      0|        goto exception;
40742|      0|    JS_FreeValue(ctx, ret);
40743|       |
40744|      0|    ret = arr;
40745|      0|    arr = JS_UNDEFINED;
40746|       |
40747|      0|exception:
40748|      0|    JS_FreeValue(ctx, arr);
40749|      0|    JS_FreeValue(ctx, obj);
40750|      0|    return ret;
40751|      0|}
40752|       |
40753|       |typedef struct JSArrayIteratorData {
40754|       |    JSValue obj;
40755|       |    JSIteratorKindEnum kind;
40756|       |    uint32_t idx;
40757|       |} JSArrayIteratorData;
40758|       |
40759|       |static void js_array_iterator_finalizer(JSRuntime *rt, JSValue val)
40760|  7.47k|{
40761|  7.47k|    JSObject *p = JS_VALUE_GET_OBJ(val);
40762|  7.47k|    JSArrayIteratorData *it = p->u.array_iterator_data;
40763|  7.47k|    if (it) {
40764|  7.47k|        JS_FreeValueRT(rt, it->obj);
40765|  7.47k|        js_free_rt(rt, it);
40766|  7.47k|    }
40767|  7.47k|}
40768|       |
40769|       |static void js_array_iterator_mark(JSRuntime *rt, JSValueConst val,
40770|       |                                   JS_MarkFunc *mark_func)
40771|      4|{
40772|      4|    JSObject *p = JS_VALUE_GET_OBJ(val);
40773|      4|    JSArrayIteratorData *it = p->u.array_iterator_data;
40774|      4|    if (it) {
40775|      4|        JS_MarkValue(rt, it->obj, mark_func);
40776|      4|    }
40777|      4|}
40778|       |
40779|       |static JSValue js_create_array(JSContext *ctx, int len, JSValueConst *tab)
40780|      0|{
40781|      0|    JSValue obj;
40782|      0|    int i;
40783|       |
40784|      0|    obj = JS_NewArray(ctx);
40785|      0|    if (JS_IsException(obj))
40786|      0|        return JS_EXCEPTION;
40787|      0|    for(i = 0; i < len; i++) {
40788|      0|        if (JS_CreateDataPropertyUint32(ctx, obj, i, JS_DupValue(ctx, tab[i]), 0) < 0) {
40789|      0|            JS_FreeValue(ctx, obj);
40790|      0|            return JS_EXCEPTION;
40791|      0|        }
40792|      0|    }
40793|      0|    return obj;
40794|      0|}
40795|       |
40796|       |static JSValue js_create_array_iterator(JSContext *ctx, JSValueConst this_val,
40797|       |                                        int argc, JSValueConst *argv, int magic)
40798|  7.47k|{
40799|  7.47k|    JSValue enum_obj, arr;
40800|  7.47k|    JSArrayIteratorData *it;
40801|  7.47k|    JSIteratorKindEnum kind;
40802|  7.47k|    int class_id;
40803|       |
40804|  7.47k|    kind = magic & 3;
40805|  7.47k|    if (magic & 4) {
40806|       |        /* string iterator case */
40807|  5.47k|        arr = JS_ToStringCheckObject(ctx, this_val);
40808|  5.47k|        class_id = JS_CLASS_STRING_ITERATOR;
40809|  5.47k|    } else {
40810|  1.99k|        arr = JS_ToObject(ctx, this_val);
40811|  1.99k|        class_id = JS_CLASS_ARRAY_ITERATOR;
40812|  1.99k|    }
40813|  7.47k|    if (JS_IsException(arr))
40814|      0|        goto fail;
40815|  7.47k|    enum_obj = JS_NewObjectClass(ctx, class_id);
40816|  7.47k|    if (JS_IsException(enum_obj))
40817|      0|        goto fail;
40818|  7.47k|    it = js_malloc(ctx, sizeof(*it));
40819|  7.47k|    if (!it)
40820|      0|        goto fail1;
40821|  7.47k|    it->obj = arr;
40822|  7.47k|    it->kind = kind;
40823|  7.47k|    it->idx = 0;
40824|  7.47k|    JS_SetOpaque(enum_obj, it);
40825|  7.47k|    return enum_obj;
40826|      0| fail1:
40827|      0|    JS_FreeValue(ctx, enum_obj);
40828|      0| fail:
40829|      0|    JS_FreeValue(ctx, arr);
40830|      0|    return JS_EXCEPTION;
40831|      0|}
40832|       |
40833|       |static JSValue js_array_iterator_next(JSContext *ctx, JSValueConst this_val,
40834|       |                                      int argc, JSValueConst *argv,
40835|       |                                      BOOL *pdone, int magic)
40836|  2.96k|{
40837|  2.96k|    JSArrayIteratorData *it;
40838|  2.96k|    uint32_t len, idx;
40839|  2.96k|    JSValue val, obj;
40840|  2.96k|    JSObject *p;
40841|       |
40842|  2.96k|    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_ARRAY_ITERATOR);
40843|  2.96k|    if (!it)
40844|      0|        goto fail1;
40845|  2.96k|    if (JS_IsUndefined(it->obj))
40846|      0|        goto done;
40847|  2.96k|    p = JS_VALUE_GET_OBJ(it->obj);
40848|  2.96k|    if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
40849|  2.96k|        p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
40850|      0|        if (typed_array_is_detached(ctx, p)) {
40851|      0|            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
40852|      0|            goto fail1;
40853|      0|        }
40854|      0|        len = p->u.array.count;
40855|  2.96k|    } else {
40856|  2.96k|        if (js_get_length32(ctx, &len, it->obj)) {
40857|      0|        fail1:
40858|      0|            *pdone = FALSE;
40859|      0|            return JS_EXCEPTION;
40860|      0|        }
40861|  2.96k|    }
40862|  2.96k|    idx = it->idx;
40863|  2.96k|    if (idx >= len) {
40864|  1.61k|        JS_FreeValue(ctx, it->obj);
40865|  1.61k|        it->obj = JS_UNDEFINED;
40866|  1.61k|    done:
40867|  1.61k|        *pdone = TRUE;
40868|  1.61k|        return JS_UNDEFINED;
40869|  1.61k|    }
40870|  1.34k|    it->idx = idx + 1;
40871|  1.34k|    *pdone = FALSE;
40872|  1.34k|    if (it->kind == JS_ITERATOR_KIND_KEY) {
40873|      0|        return JS_NewUint32(ctx, idx);
40874|  1.34k|    } else {
40875|  1.34k|        val = JS_GetPropertyUint32(ctx, it->obj, idx);
40876|  1.34k|        if (JS_IsException(val))
40877|      0|            return JS_EXCEPTION;
40878|  1.34k|        if (it->kind == JS_ITERATOR_KIND_VALUE) {
40879|  1.34k|            return val;
40880|  1.34k|        } else {
40881|      0|            JSValueConst args[2];
40882|      0|            JSValue num;
40883|      0|            num = JS_NewUint32(ctx, idx);
40884|      0|            args[0] = num;
40885|      0|            args[1] = val;
40886|      0|            obj = js_create_array(ctx, 2, args);
40887|      0|            JS_FreeValue(ctx, val);
40888|      0|            JS_FreeValue(ctx, num);
40889|      0|            return obj;
40890|      0|        }
40891|  1.34k|    }
40892|  1.34k|}
40893|       |
40894|       |static JSValue js_iterator_proto_iterator(JSContext *ctx, JSValueConst this_val,
40895|       |                                          int argc, JSValueConst *argv)
40896|      0|{
40897|      0|    return JS_DupValue(ctx, this_val);
40898|      0|}
40899|       |
40900|       |static const JSCFunctionListEntry js_iterator_proto_funcs[] = {
40901|       |    JS_CFUNC_DEF("[Symbol.iterator]", 0, js_iterator_proto_iterator ),
40902|       |};
40903|       |
40904|       |static const JSCFunctionListEntry js_array_proto_funcs[] = {
40905|       |    JS_CFUNC_DEF("at", 1, js_array_at ),
40906|       |    JS_CFUNC_DEF("with", 2, js_array_with ),
40907|       |    JS_CFUNC_DEF("concat", 1, js_array_concat ),
40908|       |    JS_CFUNC_MAGIC_DEF("every", 1, js_array_every, special_every ),
40909|       |    JS_CFUNC_MAGIC_DEF("some", 1, js_array_every, special_some ),
40910|       |    JS_CFUNC_MAGIC_DEF("forEach", 1, js_array_every, special_forEach ),
40911|       |    JS_CFUNC_MAGIC_DEF("map", 1, js_array_every, special_map ),
40912|       |    JS_CFUNC_MAGIC_DEF("filter", 1, js_array_every, special_filter ),
40913|       |    JS_CFUNC_MAGIC_DEF("reduce", 1, js_array_reduce, special_reduce ),
40914|       |    JS_CFUNC_MAGIC_DEF("reduceRight", 1, js_array_reduce, special_reduceRight ),
40915|       |    JS_CFUNC_DEF("fill", 1, js_array_fill ),
40916|       |    JS_CFUNC_MAGIC_DEF("find", 1, js_array_find, ArrayFind ),
40917|       |    JS_CFUNC_MAGIC_DEF("findIndex", 1, js_array_find, ArrayFindIndex ),
40918|       |    JS_CFUNC_MAGIC_DEF("findLast", 1, js_array_find, ArrayFindLast ),
40919|       |    JS_CFUNC_MAGIC_DEF("findLastIndex", 1, js_array_find, ArrayFindLastIndex ),
40920|       |    JS_CFUNC_DEF("indexOf", 1, js_array_indexOf ),
40921|       |    JS_CFUNC_DEF("lastIndexOf", 1, js_array_lastIndexOf ),
40922|       |    JS_CFUNC_DEF("includes", 1, js_array_includes ),
40923|       |    JS_CFUNC_MAGIC_DEF("join", 1, js_array_join, 0 ),
40924|       |    JS_CFUNC_DEF("toString", 0, js_array_toString ),
40925|       |    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_array_join, 1 ),
40926|       |    JS_CFUNC_MAGIC_DEF("pop", 0, js_array_pop, 0 ),
40927|       |    JS_CFUNC_MAGIC_DEF("push", 1, js_array_push, 0 ),
40928|       |    JS_CFUNC_MAGIC_DEF("shift", 0, js_array_pop, 1 ),
40929|       |    JS_CFUNC_MAGIC_DEF("unshift", 1, js_array_push, 1 ),
40930|       |    JS_CFUNC_DEF("reverse", 0, js_array_reverse ),
40931|       |    JS_CFUNC_DEF("toReversed", 0, js_array_toReversed ),
40932|       |    JS_CFUNC_DEF("sort", 1, js_array_sort ),
40933|       |    JS_CFUNC_DEF("toSorted", 1, js_array_toSorted ),
40934|       |    JS_CFUNC_MAGIC_DEF("slice", 2, js_array_slice, 0 ),
40935|       |    JS_CFUNC_MAGIC_DEF("splice", 2, js_array_slice, 1 ),
40936|       |    JS_CFUNC_DEF("toSpliced", 2, js_array_toSpliced ),
40937|       |    JS_CFUNC_DEF("copyWithin", 2, js_array_copyWithin ),
40938|       |    JS_CFUNC_MAGIC_DEF("flatMap", 1, js_array_flatten, 1 ),
40939|       |    JS_CFUNC_MAGIC_DEF("flat", 0, js_array_flatten, 0 ),
40940|       |    JS_CFUNC_MAGIC_DEF("values", 0, js_create_array_iterator, JS_ITERATOR_KIND_VALUE ),
40941|       |    JS_ALIAS_DEF("[Symbol.iterator]", "values" ),
40942|       |    JS_CFUNC_MAGIC_DEF("keys", 0, js_create_array_iterator, JS_ITERATOR_KIND_KEY ),
40943|       |    JS_CFUNC_MAGIC_DEF("entries", 0, js_create_array_iterator, JS_ITERATOR_KIND_KEY_AND_VALUE ),
40944|       |};
40945|       |
40946|       |static const JSCFunctionListEntry js_array_iterator_proto_funcs[] = {
40947|       |    JS_ITERATOR_NEXT_DEF("next", 0, js_array_iterator_next, 0 ),
40948|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Array Iterator", JS_PROP_CONFIGURABLE ),
40949|       |};
40950|       |
40951|       |/* Number */
40952|       |
40953|       |static JSValue js_number_constructor(JSContext *ctx, JSValueConst new_target,
40954|       |                                     int argc, JSValueConst *argv)
40955|      0|{
40956|      0|    JSValue val, obj;
40957|      0|    if (argc == 0) {
40958|      0|        val = JS_NewInt32(ctx, 0);
40959|      0|    } else {
40960|      0|        val = JS_ToNumeric(ctx, argv[0]);
40961|      0|        if (JS_IsException(val))
40962|      0|            return val;
40963|      0|        switch(JS_VALUE_GET_TAG(val)) {
40964|      0|        case JS_TAG_SHORT_BIG_INT:
40965|      0|            val = JS_NewInt64(ctx, JS_VALUE_GET_SHORT_BIG_INT(val));
40966|      0|            if (JS_IsException(val))
40967|      0|                return val;
40968|      0|            break;
40969|      0|        case JS_TAG_BIG_INT:
40970|      0|            {
40971|      0|                JSBigInt *p = JS_VALUE_GET_PTR(val);
40972|      0|                double d;
40973|      0|                d = js_bigint_to_float64(ctx, p);
40974|      0|                JS_FreeValue(ctx, val);
40975|      0|                val = JS_NewFloat64(ctx, d);
40976|      0|            }
40977|      0|            break;
40978|      0|        default:
40979|      0|            break;
40980|      0|        }
40981|      0|    }
40982|      0|    if (!JS_IsUndefined(new_target)) {
40983|      0|        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_NUMBER);
40984|      0|        if (!JS_IsException(obj))
40985|      0|            JS_SetObjectData(ctx, obj, val);
40986|      0|        return obj;
40987|      0|    } else {
40988|      0|        return val;
40989|      0|    }
40990|      0|}
40991|       |
40992|       |#if 0
40993|       |static JSValue js_number___toInteger(JSContext *ctx, JSValueConst this_val,
40994|       |                                     int argc, JSValueConst *argv)
40995|       |{
40996|       |    return JS_ToIntegerFree(ctx, JS_DupValue(ctx, argv[0]));
40997|       |}
40998|       |
40999|       |static JSValue js_number___toLength(JSContext *ctx, JSValueConst this_val,
41000|       |                                    int argc, JSValueConst *argv)
41001|       |{
41002|       |    int64_t v;
41003|       |    if (JS_ToLengthFree(ctx, &v, JS_DupValue(ctx, argv[0])))
41004|       |        return JS_EXCEPTION;
41005|       |    return JS_NewInt64(ctx, v);
41006|       |}
41007|       |#endif
41008|       |
41009|       |static JSValue js_number_isNaN(JSContext *ctx, JSValueConst this_val,
41010|       |                               int argc, JSValueConst *argv)
41011|      0|{
41012|      0|    if (!JS_IsNumber(argv[0]))
41013|      0|        return JS_FALSE;
41014|      0|    return js_global_isNaN(ctx, this_val, argc, argv);
41015|      0|}
41016|       |
41017|       |static JSValue js_number_isFinite(JSContext *ctx, JSValueConst this_val,
41018|       |                                  int argc, JSValueConst *argv)
41019|      0|{
41020|      0|    if (!JS_IsNumber(argv[0]))
41021|      0|        return JS_FALSE;
41022|      0|    return js_global_isFinite(ctx, this_val, argc, argv);
41023|      0|}
41024|       |
41025|       |static JSValue js_number_isInteger(JSContext *ctx, JSValueConst this_val,
41026|       |                                   int argc, JSValueConst *argv)
41027|      0|{
41028|      0|    int ret;
41029|      0|    ret = JS_NumberIsInteger(ctx, argv[0]);
41030|      0|    if (ret < 0)
41031|      0|        return JS_EXCEPTION;
41032|      0|    else
41033|      0|        return JS_NewBool(ctx, ret);
41034|      0|}
41035|       |
41036|       |static JSValue js_number_isSafeInteger(JSContext *ctx, JSValueConst this_val,
41037|       |                                       int argc, JSValueConst *argv)
41038|      0|{
41039|      0|    double d;
41040|      0|    if (!JS_IsNumber(argv[0]))
41041|      0|        return JS_FALSE;
41042|      0|    if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))
41043|      0|        return JS_EXCEPTION;
41044|      0|    return JS_NewBool(ctx, is_safe_integer(d));
41045|      0|}
41046|       |
41047|       |static const JSCFunctionListEntry js_number_funcs[] = {
41048|       |    /* global ParseInt and parseFloat should be defined already or delayed */
41049|       |    JS_ALIAS_BASE_DEF("parseInt", "parseInt", 0 ),
41050|       |    JS_ALIAS_BASE_DEF("parseFloat", "parseFloat", 0 ),
41051|       |    JS_CFUNC_DEF("isNaN", 1, js_number_isNaN ),
41052|       |    JS_CFUNC_DEF("isFinite", 1, js_number_isFinite ),
41053|       |    JS_CFUNC_DEF("isInteger", 1, js_number_isInteger ),
41054|       |    JS_CFUNC_DEF("isSafeInteger", 1, js_number_isSafeInteger ),
41055|       |    JS_PROP_DOUBLE_DEF("MAX_VALUE", 1.7976931348623157e+308, 0 ),
41056|       |    JS_PROP_DOUBLE_DEF("MIN_VALUE", 5e-324, 0 ),
41057|       |    JS_PROP_DOUBLE_DEF("NaN", NAN, 0 ),
41058|       |    JS_PROP_DOUBLE_DEF("NEGATIVE_INFINITY", -INFINITY, 0 ),
41059|       |    JS_PROP_DOUBLE_DEF("POSITIVE_INFINITY", INFINITY, 0 ),
41060|       |    JS_PROP_DOUBLE_DEF("EPSILON", 2.220446049250313e-16, 0 ), /* ES6 */
41061|       |    JS_PROP_DOUBLE_DEF("MAX_SAFE_INTEGER", 9007199254740991.0, 0 ), /* ES6 */
41062|       |    JS_PROP_DOUBLE_DEF("MIN_SAFE_INTEGER", -9007199254740991.0, 0 ), /* ES6 */
41063|       |    //JS_CFUNC_DEF("__toInteger", 1, js_number___toInteger ),
41064|       |    //JS_CFUNC_DEF("__toLength", 1, js_number___toLength ),
41065|       |};
41066|       |
41067|       |static JSValue js_thisNumberValue(JSContext *ctx, JSValueConst this_val)
41068|      0|{
41069|      0|    if (JS_IsNumber(this_val))
41070|      0|        return JS_DupValue(ctx, this_val);
41071|       |
41072|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
41073|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
41074|      0|        if (p->class_id == JS_CLASS_NUMBER) {
41075|      0|            if (JS_IsNumber(p->u.object_data))
41076|      0|                return JS_DupValue(ctx, p->u.object_data);
41077|      0|        }
41078|      0|    }
41079|      0|    return JS_ThrowTypeError(ctx, "not a number");
41080|      0|}
41081|       |
41082|       |static JSValue js_number_valueOf(JSContext *ctx, JSValueConst this_val,
41083|       |                                 int argc, JSValueConst *argv)
41084|      0|{
41085|      0|    return js_thisNumberValue(ctx, this_val);
41086|      0|}
41087|       |
41088|       |static int js_get_radix(JSContext *ctx, JSValueConst val)
41089|      0|{
41090|      0|    int radix;
41091|      0|    if (JS_ToInt32Sat(ctx, &radix, val))
41092|      0|        return -1;
41093|      0|    if (radix < 2 || radix > 36) {
41094|      0|        JS_ThrowRangeError(ctx, "radix must be between 2 and 36");
41095|      0|        return -1;
41096|      0|    }
41097|      0|    return radix;
41098|      0|}
41099|       |
41100|       |static JSValue js_number_toString(JSContext *ctx, JSValueConst this_val,
41101|       |                                  int argc, JSValueConst *argv, int magic)
41102|      0|{
41103|      0|    JSValue val;
41104|      0|    int base, flags;
41105|      0|    double d;
41106|       |
41107|      0|    val = js_thisNumberValue(ctx, this_val);
41108|      0|    if (JS_IsException(val))
41109|      0|        return val;
41110|      0|    if (magic || JS_IsUndefined(argv[0])) {
41111|      0|        base = 10;
41112|      0|    } else {
41113|      0|        base = js_get_radix(ctx, argv[0]);
41114|      0|        if (base < 0)
41115|      0|            goto fail;
41116|      0|    }
41117|      0|    if (JS_VALUE_GET_TAG(val) == JS_TAG_INT) {
41118|      0|        char buf1[70];
41119|      0|        int len;
41120|      0|        len = i64toa_radix(buf1, JS_VALUE_GET_INT(val), base);
41121|      0|        return js_new_string8_len(ctx, buf1, len);
41122|      0|    }
41123|      0|    if (JS_ToFloat64Free(ctx, &d, val))
41124|      0|        return JS_EXCEPTION;
41125|      0|    flags = JS_DTOA_FORMAT_FREE;
41126|      0|    if (base != 10)
41127|      0|        flags |= JS_DTOA_EXP_DISABLED;
41128|      0|    return js_dtoa2(ctx, d, base, 0, flags);
41129|      0| fail:
41130|      0|    JS_FreeValue(ctx, val);
41131|      0|    return JS_EXCEPTION;
41132|      0|}
41133|       |
41134|       |static JSValue js_number_toFixed(JSContext *ctx, JSValueConst this_val,
41135|       |                                 int argc, JSValueConst *argv)
41136|      0|{
41137|      0|    JSValue val;
41138|      0|    int f, flags;
41139|      0|    double d;
41140|       |
41141|      0|    val = js_thisNumberValue(ctx, this_val);
41142|      0|    if (JS_IsException(val))
41143|      0|        return val;
41144|      0|    if (JS_ToFloat64Free(ctx, &d, val))
41145|      0|        return JS_EXCEPTION;
41146|      0|    if (JS_ToInt32Sat(ctx, &f, argv[0]))
41147|      0|        return JS_EXCEPTION;
41148|      0|    if (f < 0 || f > 100)
41149|      0|        return JS_ThrowRangeError(ctx, "invalid number of digits");
41150|      0|    if (fabs(d) >= 1e21)
41151|      0|        flags = JS_DTOA_FORMAT_FREE;
41152|      0|    else
41153|      0|        flags = JS_DTOA_FORMAT_FRAC;
41154|      0|    return js_dtoa2(ctx, d, 10, f, flags);
41155|      0|}
41156|       |
41157|       |static JSValue js_number_toExponential(JSContext *ctx, JSValueConst this_val,
41158|       |                                       int argc, JSValueConst *argv)
41159|      0|{
41160|      0|    JSValue val;
41161|      0|    int f, flags;
41162|      0|    double d;
41163|       |
41164|      0|    val = js_thisNumberValue(ctx, this_val);
41165|      0|    if (JS_IsException(val))
41166|      0|        return val;
41167|      0|    if (JS_ToFloat64Free(ctx, &d, val))
41168|      0|        return JS_EXCEPTION;
41169|      0|    if (JS_ToInt32Sat(ctx, &f, argv[0]))
41170|      0|        return JS_EXCEPTION;
41171|      0|    if (!isfinite(d)) {
41172|      0|        return JS_ToStringFree(ctx,  __JS_NewFloat64(ctx, d));
41173|      0|    }
41174|      0|    if (JS_IsUndefined(argv[0])) {
41175|      0|        flags = JS_DTOA_FORMAT_FREE;
41176|      0|        f = 0;
41177|      0|    } else {
41178|      0|        if (f < 0 || f > 100)
41179|      0|            return JS_ThrowRangeError(ctx, "invalid number of digits");
41180|      0|        f++;
41181|      0|        flags = JS_DTOA_FORMAT_FIXED;
41182|      0|    }
41183|      0|    return js_dtoa2(ctx, d, 10, f, flags | JS_DTOA_EXP_ENABLED);
41184|      0|}
41185|       |
41186|       |static JSValue js_number_toPrecision(JSContext *ctx, JSValueConst this_val,
41187|       |                                     int argc, JSValueConst *argv)
41188|      0|{
41189|      0|    JSValue val;
41190|      0|    int p;
41191|      0|    double d;
41192|       |
41193|      0|    val = js_thisNumberValue(ctx, this_val);
41194|      0|    if (JS_IsException(val))
41195|      0|        return val;
41196|      0|    if (JS_ToFloat64Free(ctx, &d, val))
41197|      0|        return JS_EXCEPTION;
41198|      0|    if (JS_IsUndefined(argv[0]))
41199|      0|        goto to_string;
41200|      0|    if (JS_ToInt32Sat(ctx, &p, argv[0]))
41201|      0|        return JS_EXCEPTION;
41202|      0|    if (!isfinite(d)) {
41203|      0|    to_string:
41204|      0|        return JS_ToStringFree(ctx,  __JS_NewFloat64(ctx, d));
41205|      0|    }
41206|      0|    if (p < 1 || p > 100)
41207|      0|        return JS_ThrowRangeError(ctx, "invalid number of digits");
41208|      0|    return js_dtoa2(ctx, d, 10, p, JS_DTOA_FORMAT_FIXED);
41209|      0|}
41210|       |
41211|       |static const JSCFunctionListEntry js_number_proto_funcs[] = {
41212|       |    JS_CFUNC_DEF("toExponential", 1, js_number_toExponential ),
41213|       |    JS_CFUNC_DEF("toFixed", 1, js_number_toFixed ),
41214|       |    JS_CFUNC_DEF("toPrecision", 1, js_number_toPrecision ),
41215|       |    JS_CFUNC_MAGIC_DEF("toString", 1, js_number_toString, 0 ),
41216|       |    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_number_toString, 1 ),
41217|       |    JS_CFUNC_DEF("valueOf", 0, js_number_valueOf ),
41218|       |};
41219|       |
41220|       |static JSValue js_parseInt(JSContext *ctx, JSValueConst this_val,
41221|       |                           int argc, JSValueConst *argv)
41222|      0|{
41223|      0|    const char *str, *p;
41224|      0|    int radix, flags;
41225|      0|    JSValue ret;
41226|       |
41227|      0|    str = JS_ToCString(ctx, argv[0]);
41228|      0|    if (!str)
41229|      0|        return JS_EXCEPTION;
41230|      0|    if (JS_ToInt32(ctx, &radix, argv[1])) {
41231|      0|        JS_FreeCString(ctx, str);
41232|      0|        return JS_EXCEPTION;
41233|      0|    }
41234|      0|    if (radix != 0 && (radix < 2 || radix > 36)) {
41235|      0|        ret = JS_NAN;
41236|      0|    } else {
41237|      0|        p = str;
41238|      0|        p += skip_spaces(p);
41239|      0|        flags = ATOD_INT_ONLY | ATOD_ACCEPT_PREFIX_AFTER_SIGN;
41240|      0|        ret = js_atof(ctx, p, NULL, radix, flags);
41241|      0|    }
41242|      0|    JS_FreeCString(ctx, str);
41243|      0|    return ret;
41244|      0|}
41245|       |
41246|       |static JSValue js_parseFloat(JSContext *ctx, JSValueConst this_val,
41247|       |                             int argc, JSValueConst *argv)
41248|      0|{
41249|      0|    const char *str, *p;
41250|      0|    JSValue ret;
41251|       |
41252|      0|    str = JS_ToCString(ctx, argv[0]);
41253|      0|    if (!str)
41254|      0|        return JS_EXCEPTION;
41255|      0|    p = str;
41256|      0|    p += skip_spaces(p);
41257|      0|    ret = js_atof(ctx, p, NULL, 10, 0);
41258|      0|    JS_FreeCString(ctx, str);
41259|      0|    return ret;
41260|      0|}
41261|       |
41262|       |/* Boolean */
41263|       |static JSValue js_boolean_constructor(JSContext *ctx, JSValueConst new_target,
41264|       |                                     int argc, JSValueConst *argv)
41265|      0|{
41266|      0|    JSValue val, obj;
41267|      0|    val = JS_NewBool(ctx, JS_ToBool(ctx, argv[0]));
41268|      0|    if (!JS_IsUndefined(new_target)) {
41269|      0|        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_BOOLEAN);
41270|      0|        if (!JS_IsException(obj))
41271|      0|            JS_SetObjectData(ctx, obj, val);
41272|      0|        return obj;
41273|      0|    } else {
41274|      0|        return val;
41275|      0|    }
41276|      0|}
41277|       |
41278|       |static JSValue js_thisBooleanValue(JSContext *ctx, JSValueConst this_val)
41279|      0|{
41280|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_BOOL)
41281|      0|        return JS_DupValue(ctx, this_val);
41282|       |
41283|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
41284|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
41285|      0|        if (p->class_id == JS_CLASS_BOOLEAN) {
41286|      0|            if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_BOOL)
41287|      0|                return p->u.object_data;
41288|      0|        }
41289|      0|    }
41290|      0|    return JS_ThrowTypeError(ctx, "not a boolean");
41291|      0|}
41292|       |
41293|       |static JSValue js_boolean_toString(JSContext *ctx, JSValueConst this_val,
41294|       |                                   int argc, JSValueConst *argv)
41295|      0|{
41296|      0|    JSValue val = js_thisBooleanValue(ctx, this_val);
41297|      0|    if (JS_IsException(val))
41298|      0|        return val;
41299|      0|    return JS_AtomToString(ctx, JS_VALUE_GET_BOOL(val) ?
41300|      0|                       JS_ATOM_true : JS_ATOM_false);
41301|      0|}
41302|       |
41303|       |static JSValue js_boolean_valueOf(JSContext *ctx, JSValueConst this_val,
41304|       |                                  int argc, JSValueConst *argv)
41305|      0|{
41306|      0|    return js_thisBooleanValue(ctx, this_val);
41307|      0|}
41308|       |
41309|       |static const JSCFunctionListEntry js_boolean_proto_funcs[] = {
41310|       |    JS_CFUNC_DEF("toString", 0, js_boolean_toString ),
41311|       |    JS_CFUNC_DEF("valueOf", 0, js_boolean_valueOf ),
41312|       |};
41313|       |
41314|       |/* String */
41315|       |
41316|       |static int js_string_get_own_property(JSContext *ctx,
41317|       |                                      JSPropertyDescriptor *desc,
41318|       |                                      JSValueConst obj, JSAtom prop)
41319|  4.96M|{
41320|  4.96M|    JSObject *p;
41321|  4.96M|    JSString *p1;
41322|  4.96M|    uint32_t idx, ch;
41323|       |
41324|       |    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */
41325|  4.96M|    if (__JS_AtomIsTaggedInt(prop)) {
41326|  4.89M|        p = JS_VALUE_GET_OBJ(obj);
41327|  4.89M|        if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {
41328|  4.89M|            p1 = JS_VALUE_GET_STRING(p->u.object_data);
41329|  4.89M|            idx = __JS_AtomToUInt32(prop);
41330|  4.89M|            if (idx < p1->len) {
41331|  4.89M|                if (desc) {
41332|      0|                    ch = string_get(p1, idx);
41333|      0|                    desc->flags = JS_PROP_ENUMERABLE;
41334|      0|                    desc->value = js_new_string_char(ctx, ch);
41335|      0|                    desc->getter = JS_UNDEFINED;
41336|      0|                    desc->setter = JS_UNDEFINED;
41337|      0|                }
41338|  4.89M|                return TRUE;
41339|  4.89M|            }
41340|  4.89M|        }
41341|  4.89M|    }
41342|  67.2k|    return FALSE;
41343|  4.96M|}
41344|       |
41345|       |static int js_string_define_own_property(JSContext *ctx,
41346|       |                                         JSValueConst this_obj,
41347|       |                                         JSAtom prop, JSValueConst val,
41348|       |                                         JSValueConst getter,
41349|       |                                         JSValueConst setter, int flags)
41350|   267k|{
41351|   267k|    uint32_t idx;
41352|   267k|    JSObject *p;
41353|   267k|    JSString *p1, *p2;
41354|       |
41355|   267k|    if (__JS_AtomIsTaggedInt(prop)) {
41356|      0|        idx = __JS_AtomToUInt32(prop);
41357|      0|        p = JS_VALUE_GET_OBJ(this_obj);
41358|      0|        if (JS_VALUE_GET_TAG(p->u.object_data) != JS_TAG_STRING)
41359|      0|            goto def;
41360|      0|        p1 = JS_VALUE_GET_STRING(p->u.object_data);
41361|      0|        if (idx >= p1->len)
41362|      0|            goto def;
41363|      0|        if (!check_define_prop_flags(JS_PROP_ENUMERABLE, flags))
41364|      0|            goto fail;
41365|       |        /* check that the same value is configured */
41366|      0|        if (flags & JS_PROP_HAS_VALUE) {
41367|      0|            if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)
41368|      0|                goto fail;
41369|      0|            p2 = JS_VALUE_GET_STRING(val);
41370|      0|            if (p2->len != 1)
41371|      0|                goto fail;
41372|      0|            if (string_get(p1, idx) != string_get(p2, 0)) {
41373|      0|            fail:
41374|      0|                return JS_ThrowTypeErrorOrFalse(ctx, flags, "property is not configurable");
41375|      0|            }
41376|      0|        }
41377|      0|        return TRUE;
41378|   267k|    } else {
41379|   267k|    def:
41380|   267k|        return JS_DefineProperty(ctx, this_obj, prop, val, getter, setter,
41381|   267k|                                 flags | JS_PROP_NO_EXOTIC);
41382|   267k|    }
41383|   267k|}
41384|       |
41385|       |static int js_string_delete_property(JSContext *ctx,
41386|       |                                     JSValueConst obj, JSAtom prop)
41387|      0|{
41388|      0|    uint32_t idx;
41389|       |
41390|      0|    if (__JS_AtomIsTaggedInt(prop)) {
41391|      0|        idx = __JS_AtomToUInt32(prop);
41392|      0|        if (idx < js_string_obj_get_length(ctx, obj)) {
41393|      0|            return FALSE;
41394|      0|        }
41395|      0|    }
41396|      0|    return TRUE;
41397|      0|}
41398|       |
41399|       |static const JSClassExoticMethods js_string_exotic_methods = {
41400|       |    .get_own_property = js_string_get_own_property,
41401|       |    .define_own_property = js_string_define_own_property,
41402|       |    .delete_property = js_string_delete_property,
41403|       |};
41404|       |
41405|       |static JSValue js_string_constructor(JSContext *ctx, JSValueConst new_target,
41406|       |                                     int argc, JSValueConst *argv)
41407|      0|{
41408|      0|    JSValue val, obj;
41409|      0|    if (argc == 0) {
41410|      0|        val = JS_AtomToString(ctx, JS_ATOM_empty_string);
41411|      0|    } else {
41412|      0|        if (JS_IsUndefined(new_target) && JS_IsSymbol(argv[0])) {
41413|      0|            JSAtomStruct *p = JS_VALUE_GET_PTR(argv[0]);
41414|      0|            val = JS_ConcatString3(ctx, "Symbol(", JS_AtomToString(ctx, js_get_atom_index(ctx->rt, p)), ")");
41415|      0|        } else {
41416|      0|            val = JS_ToString(ctx, argv[0]);
41417|      0|        }
41418|      0|        if (JS_IsException(val))
41419|      0|            return val;
41420|      0|    }
41421|      0|    if (!JS_IsUndefined(new_target)) {
41422|      0|        JSString *p1 = JS_VALUE_GET_STRING(val);
41423|       |
41424|      0|        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_STRING);
41425|      0|        if (JS_IsException(obj)) {
41426|      0|            JS_FreeValue(ctx, val);
41427|      0|        } else {
41428|      0|            JS_SetObjectData(ctx, obj, val);
41429|      0|            JS_DefinePropertyValue(ctx, obj, JS_ATOM_length, JS_NewInt32(ctx, p1->len), 0);
41430|      0|        }
41431|      0|        return obj;
41432|      0|    } else {
41433|      0|        return val;
41434|      0|    }
41435|      0|}
41436|       |
41437|       |static JSValue js_thisStringValue(JSContext *ctx, JSValueConst this_val)
41438|      0|{
41439|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_STRING ||
41440|      0|        JS_VALUE_GET_TAG(this_val) == JS_TAG_STRING_ROPE)
41441|      0|        return JS_DupValue(ctx, this_val);
41442|       |
41443|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
41444|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
41445|      0|        if (p->class_id == JS_CLASS_STRING) {
41446|      0|            if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING)
41447|      0|                return JS_DupValue(ctx, p->u.object_data);
41448|      0|        }
41449|      0|    }
41450|      0|    return JS_ThrowTypeError(ctx, "not a string");
41451|      0|}
41452|       |
41453|       |static JSValue js_string_fromCharCode(JSContext *ctx, JSValueConst this_val,
41454|       |                                      int argc, JSValueConst *argv)
41455|      0|{
41456|      0|    int i;
41457|      0|    StringBuffer b_s, *b = &b_s;
41458|       |
41459|      0|    string_buffer_init(ctx, b, argc);
41460|       |
41461|      0|    for(i = 0; i < argc; i++) {
41462|      0|        int32_t c;
41463|      0|        if (JS_ToInt32(ctx, &c, argv[i]) || string_buffer_putc16(b, c & 0xffff)) {
41464|      0|            string_buffer_free(b);
41465|      0|            return JS_EXCEPTION;
41466|      0|        }
41467|      0|    }
41468|      0|    return string_buffer_end(b);
41469|      0|}
41470|       |
41471|       |static JSValue js_string_fromCodePoint(JSContext *ctx, JSValueConst this_val,
41472|       |                                       int argc, JSValueConst *argv)
41473|      0|{
41474|      0|    double d;
41475|      0|    int i, c;
41476|      0|    StringBuffer b_s, *b = &b_s;
41477|       |
41478|       |    /* XXX: could pre-compute string length if all arguments are JS_TAG_INT */
41479|       |
41480|      0|    if (string_buffer_init(ctx, b, argc))
41481|      0|        goto fail;
41482|      0|    for(i = 0; i < argc; i++) {
41483|      0|        if (JS_VALUE_GET_TAG(argv[i]) == JS_TAG_INT) {
41484|      0|            c = JS_VALUE_GET_INT(argv[i]);
41485|      0|            if (c < 0 || c > 0x10ffff)
41486|      0|                goto range_error;
41487|      0|        } else {
41488|      0|            if (JS_ToFloat64(ctx, &d, argv[i]))
41489|      0|                goto fail;
41490|      0|            if (isnan(d) || d < 0 || d > 0x10ffff || (c = (int)d) != d)
41491|      0|                goto range_error;
41492|      0|        }
41493|      0|        if (string_buffer_putc(b, c))
41494|      0|            goto fail;
41495|      0|    }
41496|      0|    return string_buffer_end(b);
41497|       |
41498|      0| range_error:
41499|      0|    JS_ThrowRangeError(ctx, "invalid code point");
41500|      0| fail:
41501|      0|    string_buffer_free(b);
41502|      0|    return JS_EXCEPTION;
41503|      0|}
41504|       |
41505|       |static JSValue js_string_raw(JSContext *ctx, JSValueConst this_val,
41506|       |                             int argc, JSValueConst *argv)
41507|      0|{
41508|       |    // raw(temp,...a)
41509|      0|    JSValue cooked, val, raw;
41510|      0|    StringBuffer b_s, *b = &b_s;
41511|      0|    int64_t i, n;
41512|       |
41513|      0|    string_buffer_init(ctx, b, 0);
41514|      0|    raw = JS_UNDEFINED;
41515|      0|    cooked = JS_ToObject(ctx, argv[0]);
41516|      0|    if (JS_IsException(cooked))
41517|      0|        goto exception;
41518|      0|    raw = JS_ToObjectFree(ctx, JS_GetProperty(ctx, cooked, JS_ATOM_raw));
41519|      0|    if (JS_IsException(raw))
41520|      0|        goto exception;
41521|      0|    if (js_get_length64(ctx, &n, raw) < 0)
41522|      0|        goto exception;
41523|       |
41524|      0|    for (i = 0; i < n; i++) {
41525|      0|        val = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, raw, i));
41526|      0|        if (JS_IsException(val))
41527|      0|            goto exception;
41528|      0|        string_buffer_concat_value_free(b, val);
41529|      0|        if (i < n - 1 && i + 1 < argc) {
41530|      0|            if (string_buffer_concat_value(b, argv[i + 1]))
41531|      0|                goto exception;
41532|      0|        }
41533|      0|    }
41534|      0|    JS_FreeValue(ctx, cooked);
41535|      0|    JS_FreeValue(ctx, raw);
41536|      0|    return string_buffer_end(b);
41537|       |
41538|      0|exception:
41539|      0|    JS_FreeValue(ctx, cooked);
41540|      0|    JS_FreeValue(ctx, raw);
41541|      0|    string_buffer_free(b);
41542|      0|    return JS_EXCEPTION;
41543|      0|}
41544|       |
41545|       |/* only used in test262 */
41546|       |JSValue js_string_codePointRange(JSContext *ctx, JSValueConst this_val,
41547|       |                                 int argc, JSValueConst *argv)
41548|      0|{
41549|      0|    uint32_t start, end, i, n;
41550|      0|    StringBuffer b_s, *b = &b_s;
41551|       |
41552|      0|    if (JS_ToUint32(ctx, &start, argv[0]) ||
41553|      0|        JS_ToUint32(ctx, &end, argv[1]))
41554|      0|        return JS_EXCEPTION;
41555|      0|    end = min_uint32(end, 0x10ffff + 1);
41556|       |
41557|      0|    if (start > end) {
41558|      0|        start = end;
41559|      0|    }
41560|      0|    n = end - start;
41561|      0|    if (end > 0x10000) {
41562|      0|        n += end - max_uint32(start, 0x10000);
41563|      0|    }
41564|      0|    if (string_buffer_init2(ctx, b, n, end >= 0x100))
41565|      0|        return JS_EXCEPTION;
41566|      0|    for(i = start; i < end; i++) {
41567|      0|        string_buffer_putc(b, i);
41568|      0|    }
41569|      0|    return string_buffer_end(b);
41570|      0|}
41571|       |
41572|       |#if 0
41573|       |static JSValue js_string___isSpace(JSContext *ctx, JSValueConst this_val,
41574|       |                                   int argc, JSValueConst *argv)
41575|       |{
41576|       |    int c;
41577|       |    if (JS_ToInt32(ctx, &c, argv[0]))
41578|       |        return JS_EXCEPTION;
41579|       |    return JS_NewBool(ctx, lre_is_space(c));
41580|       |}
41581|       |#endif
41582|       |
41583|       |static JSValue js_string_charCodeAt(JSContext *ctx, JSValueConst this_val,
41584|       |                                     int argc, JSValueConst *argv)
41585|      0|{
41586|      0|    JSValue val, ret;
41587|      0|    JSString *p;
41588|      0|    int idx, c;
41589|       |
41590|      0|    val = JS_ToStringCheckObject(ctx, this_val);
41591|      0|    if (JS_IsException(val))
41592|      0|        return val;
41593|      0|    p = JS_VALUE_GET_STRING(val);
41594|      0|    if (JS_ToInt32Sat(ctx, &idx, argv[0])) {
41595|      0|        JS_FreeValue(ctx, val);
41596|      0|        return JS_EXCEPTION;
41597|      0|    }
41598|      0|    if (idx < 0 || idx >= p->len) {
41599|      0|        ret = JS_NAN;
41600|      0|    } else {
41601|      0|        c = string_get(p, idx);
41602|      0|        ret = JS_NewInt32(ctx, c);
41603|      0|    }
41604|      0|    JS_FreeValue(ctx, val);
41605|      0|    return ret;
41606|      0|}
41607|       |
41608|       |static JSValue js_string_charAt(JSContext *ctx, JSValueConst this_val,
41609|       |                                int argc, JSValueConst *argv, int is_at)
41610|      0|{
41611|      0|    JSValue val, ret;
41612|      0|    JSString *p;
41613|      0|    int idx, c;
41614|       |
41615|      0|    val = JS_ToStringCheckObject(ctx, this_val);
41616|      0|    if (JS_IsException(val))
41617|      0|        return val;
41618|      0|    p = JS_VALUE_GET_STRING(val);
41619|      0|    if (JS_ToInt32Sat(ctx, &idx, argv[0])) {
41620|      0|        JS_FreeValue(ctx, val);
41621|      0|        return JS_EXCEPTION;
41622|      0|    }
41623|      0|    if (idx < 0 && is_at)
41624|      0|        idx += p->len;
41625|      0|    if (idx < 0 || idx >= p->len) {
41626|      0|        if (is_at)
41627|      0|            ret = JS_UNDEFINED;
41628|      0|        else
41629|      0|            ret = JS_AtomToString(ctx, JS_ATOM_empty_string);
41630|      0|    } else {
41631|      0|        c = string_get(p, idx);
41632|      0|        ret = js_new_string_char(ctx, c);
41633|      0|    }
41634|      0|    JS_FreeValue(ctx, val);
41635|      0|    return ret;
41636|      0|}
41637|       |
41638|       |static JSValue js_string_codePointAt(JSContext *ctx, JSValueConst this_val,
41639|       |                                     int argc, JSValueConst *argv)
41640|      0|{
41641|      0|    JSValue val, ret;
41642|      0|    JSString *p;
41643|      0|    int idx, c;
41644|       |
41645|      0|    val = JS_ToStringCheckObject(ctx, this_val);
41646|      0|    if (JS_IsException(val))
41647|      0|        return val;
41648|      0|    p = JS_VALUE_GET_STRING(val);
41649|      0|    if (JS_ToInt32Sat(ctx, &idx, argv[0])) {
41650|      0|        JS_FreeValue(ctx, val);
41651|      0|        return JS_EXCEPTION;
41652|      0|    }
41653|      0|    if (idx < 0 || idx >= p->len) {
41654|      0|        ret = JS_UNDEFINED;
41655|      0|    } else {
41656|      0|        c = string_getc(p, &idx);
41657|      0|        ret = JS_NewInt32(ctx, c);
41658|      0|    }
41659|      0|    JS_FreeValue(ctx, val);
41660|      0|    return ret;
41661|      0|}
41662|       |
41663|       |static JSValue js_string_concat(JSContext *ctx, JSValueConst this_val,
41664|       |                                int argc, JSValueConst *argv)
41665|  2.13k|{
41666|  2.13k|    JSValue r;
41667|  2.13k|    int i;
41668|       |
41669|       |    /* XXX: Use more efficient method */
41670|       |    /* XXX: This method is OK if r has a single refcount */
41671|       |    /* XXX: should use string_buffer? */
41672|  2.13k|    r = JS_ToStringCheckObject(ctx, this_val);
41673|  6.47k|    for (i = 0; i < argc; i++) {
41674|  4.34k|        if (JS_IsException(r))
41675|      0|            break;
41676|  4.34k|        r = JS_ConcatString(ctx, r, JS_DupValue(ctx, argv[i]));
41677|  4.34k|    }
41678|  2.13k|    return r;
41679|  2.13k|}
41680|       |
41681|       |static int string_cmp(JSString *p1, JSString *p2, int x1, int x2, int len)
41682|      0|{
41683|      0|    int i, c1, c2;
41684|      0|    for (i = 0; i < len; i++) {
41685|      0|        if ((c1 = string_get(p1, x1 + i)) != (c2 = string_get(p2, x2 + i)))
41686|      0|            return c1 - c2;
41687|      0|    }
41688|      0|    return 0;
41689|      0|}
41690|       |
41691|       |static int string_indexof_char(JSString *p, int c, int from)
41692|      0|{
41693|       |    /* assuming 0 <= from <= p->len */
41694|      0|    int i, len = p->len;
41695|      0|    if (p->is_wide_char) {
41696|      0|        for (i = from; i < len; i++) {
41697|      0|            if (p->u.str16[i] == c)
41698|      0|                return i;
41699|      0|        }
41700|      0|    } else {
41701|      0|        if ((c & ~0xff) == 0) {
41702|      0|            for (i = from; i < len; i++) {
41703|      0|                if (p->u.str8[i] == (uint8_t)c)
41704|      0|                    return i;
41705|      0|            }
41706|      0|        }
41707|      0|    }
41708|      0|    return -1;
41709|      0|}
41710|       |
41711|       |static int string_indexof(JSString *p1, JSString *p2, int from)
41712|      0|{
41713|       |    /* assuming 0 <= from <= p1->len */
41714|      0|    int c, i, j, len1 = p1->len, len2 = p2->len;
41715|      0|    if (len2 == 0)
41716|      0|        return from;
41717|      0|    for (i = from, c = string_get(p2, 0); i + len2 <= len1; i = j + 1) {
41718|      0|        j = string_indexof_char(p1, c, i);
41719|      0|        if (j < 0 || j + len2 > len1)
41720|      0|            break;
41721|      0|        if (!string_cmp(p1, p2, j + 1, 1, len2 - 1))
41722|      0|            return j;
41723|      0|    }
41724|      0|    return -1;
41725|      0|}
41726|       |
41727|       |static int64_t string_advance_index(JSString *p, int64_t index, BOOL unicode)
41728|      0|{
41729|      0|    if (!unicode || index >= p->len || !p->is_wide_char) {
41730|      0|        index++;
41731|      0|    } else {
41732|      0|        int index32 = (int)index;
41733|      0|        string_getc(p, &index32);
41734|      0|        index = index32;
41735|      0|    }
41736|      0|    return index;
41737|      0|}
41738|       |
41739|       |/* return the position of the first invalid character in the string or
41740|       |   -1 if none */
41741|       |static int js_string_find_invalid_codepoint(JSString *p)
41742|      0|{
41743|      0|    int i;
41744|      0|    if (!p->is_wide_char)
41745|      0|        return -1;
41746|      0|    for(i = 0; i < p->len; i++) {
41747|      0|        uint32_t c = p->u.str16[i];
41748|      0|        if (is_surrogate(c)) {
41749|      0|            if (is_hi_surrogate(c) && (i + 1) < p->len
41750|      0|            &&  is_lo_surrogate(p->u.str16[i + 1])) {
41751|      0|                i++;
41752|      0|            } else {
41753|      0|                return i;
41754|      0|            }
41755|      0|        }
41756|      0|    }
41757|      0|    return -1;
41758|      0|}
41759|       |
41760|       |static JSValue js_string_isWellFormed(JSContext *ctx, JSValueConst this_val,
41761|       |                                      int argc, JSValueConst *argv)
41762|      0|{
41763|      0|    JSValue str;
41764|      0|    JSString *p;
41765|      0|    BOOL ret;
41766|       |
41767|      0|    str = JS_ToStringCheckObject(ctx, this_val);
41768|      0|    if (JS_IsException(str))
41769|      0|        return JS_EXCEPTION;
41770|      0|    p = JS_VALUE_GET_STRING(str);
41771|      0|    ret = (js_string_find_invalid_codepoint(p) < 0);
41772|      0|    JS_FreeValue(ctx, str);
41773|      0|    return JS_NewBool(ctx, ret);
41774|      0|}
41775|       |
41776|       |static JSValue js_string_toWellFormed(JSContext *ctx, JSValueConst this_val,
41777|       |                                      int argc, JSValueConst *argv)
41778|      0|{
41779|      0|    JSValue str, ret;
41780|      0|    JSString *p;
41781|      0|    int i;
41782|       |
41783|      0|    str = JS_ToStringCheckObject(ctx, this_val);
41784|      0|    if (JS_IsException(str))
41785|      0|        return JS_EXCEPTION;
41786|       |
41787|      0|    p = JS_VALUE_GET_STRING(str);
41788|       |    /* avoid reallocating the string if it is well-formed */
41789|      0|    i = js_string_find_invalid_codepoint(p);
41790|      0|    if (i < 0)
41791|      0|        return str;
41792|       |
41793|      0|    ret = js_new_string16_len(ctx, p->u.str16, p->len);
41794|      0|    JS_FreeValue(ctx, str);
41795|      0|    if (JS_IsException(ret))
41796|      0|        return JS_EXCEPTION;
41797|       |
41798|      0|    p = JS_VALUE_GET_STRING(ret);
41799|      0|    for (; i < p->len; i++) {
41800|      0|        uint32_t c = p->u.str16[i];
41801|      0|        if (is_surrogate(c)) {
41802|      0|            if (is_hi_surrogate(c) && (i + 1) < p->len
41803|      0|            &&  is_lo_surrogate(p->u.str16[i + 1])) {
41804|      0|                i++;
41805|      0|            } else {
41806|      0|                p->u.str16[i] = 0xFFFD;
41807|      0|            }
41808|      0|        }
41809|      0|    }
41810|      0|    return ret;
41811|      0|}
41812|       |
41813|       |static JSValue js_string_indexOf(JSContext *ctx, JSValueConst this_val,
41814|       |                                 int argc, JSValueConst *argv, int lastIndexOf)
41815|      0|{
41816|      0|    JSValue str, v;
41817|      0|    int i, len, v_len, pos, start, stop, ret, inc;
41818|      0|    JSString *p;
41819|      0|    JSString *p1;
41820|       |
41821|      0|    str = JS_ToStringCheckObject(ctx, this_val);
41822|      0|    if (JS_IsException(str))
41823|      0|        return str;
41824|      0|    v = JS_ToString(ctx, argv[0]);
41825|      0|    if (JS_IsException(v))
41826|      0|        goto fail;
41827|      0|    p = JS_VALUE_GET_STRING(str);
41828|      0|    p1 = JS_VALUE_GET_STRING(v);
41829|      0|    len = p->len;
41830|      0|    v_len = p1->len;
41831|      0|    if (lastIndexOf) {
41832|      0|        pos = len - v_len;
41833|      0|        if (argc > 1) {
41834|      0|            double d;
41835|      0|            if (JS_ToFloat64(ctx, &d, argv[1]))
41836|      0|                goto fail;
41837|      0|            if (!isnan(d)) {
41838|      0|                if (d <= 0)
41839|      0|                    pos = 0;
41840|      0|                else if (d < pos)
41841|      0|                    pos = d;
41842|      0|            }
41843|      0|        }
41844|      0|        start = pos;
41845|      0|        stop = 0;
41846|      0|        inc = -1;
41847|      0|    } else {
41848|      0|        pos = 0;
41849|      0|        if (argc > 1) {
41850|      0|            if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0))
41851|      0|                goto fail;
41852|      0|        }
41853|      0|        start = pos;
41854|      0|        stop = len - v_len;
41855|      0|        inc = 1;
41856|      0|    }
41857|      0|    ret = -1;
41858|      0|    if (len >= v_len && inc * (stop - start) >= 0) {
41859|      0|        for (i = start;; i += inc) {
41860|      0|            if (!string_cmp(p, p1, i, 0, v_len)) {
41861|      0|                ret = i;
41862|      0|                break;
41863|      0|            }
41864|      0|            if (i == stop)
41865|      0|                break;
41866|      0|        }
41867|      0|    }
41868|      0|    JS_FreeValue(ctx, str);
41869|      0|    JS_FreeValue(ctx, v);
41870|      0|    return JS_NewInt32(ctx, ret);
41871|       |
41872|      0|fail:
41873|      0|    JS_FreeValue(ctx, str);
41874|      0|    JS_FreeValue(ctx, v);
41875|      0|    return JS_EXCEPTION;
41876|      0|}
41877|       |
41878|       |/* return < 0 if exception or TRUE/FALSE */
41879|       |static int js_is_regexp(JSContext *ctx, JSValueConst obj);
41880|       |
41881|       |static JSValue js_string_includes(JSContext *ctx, JSValueConst this_val,
41882|       |                                  int argc, JSValueConst *argv, int magic)
41883|      0|{
41884|      0|    JSValue str, v = JS_UNDEFINED;
41885|      0|    int i, len, v_len, pos, start, stop, ret;
41886|      0|    JSString *p;
41887|      0|    JSString *p1;
41888|       |
41889|      0|    str = JS_ToStringCheckObject(ctx, this_val);
41890|      0|    if (JS_IsException(str))
41891|      0|        return str;
41892|      0|    ret = js_is_regexp(ctx, argv[0]);
41893|      0|    if (ret) {
41894|      0|        if (ret > 0)
41895|      0|            JS_ThrowTypeError(ctx, "regexp not supported");
41896|      0|        goto fail;
41897|      0|    }
41898|      0|    v = JS_ToString(ctx, argv[0]);
41899|      0|    if (JS_IsException(v))
41900|      0|        goto fail;
41901|      0|    p = JS_VALUE_GET_STRING(str);
41902|      0|    p1 = JS_VALUE_GET_STRING(v);
41903|      0|    len = p->len;
41904|      0|    v_len = p1->len;
41905|      0|    pos = (magic == 2) ? len : 0;
41906|      0|    if (argc > 1 && !JS_IsUndefined(argv[1])) {
41907|      0|        if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0))
41908|      0|            goto fail;
41909|      0|    }
41910|      0|    len -= v_len;
41911|      0|    ret = 0;
41912|      0|    if (magic == 0) {
41913|      0|        start = pos;
41914|      0|        stop = len;
41915|      0|    } else {
41916|      0|        if (magic == 1) {
41917|      0|            if (pos > len)
41918|      0|                goto done;
41919|      0|        } else {
41920|      0|            pos -= v_len;
41921|      0|        }
41922|      0|        start = stop = pos;
41923|      0|    }
41924|      0|    if (start >= 0 && start <= stop) {
41925|      0|        for (i = start;; i++) {
41926|      0|            if (!string_cmp(p, p1, i, 0, v_len)) {
41927|      0|                ret = 1;
41928|      0|                break;
41929|      0|            }
41930|      0|            if (i == stop)
41931|      0|                break;
41932|      0|        }
41933|      0|    }
41934|      0| done:
41935|      0|    JS_FreeValue(ctx, str);
41936|      0|    JS_FreeValue(ctx, v);
41937|      0|    return JS_NewBool(ctx, ret);
41938|       |
41939|      0|fail:
41940|      0|    JS_FreeValue(ctx, str);
41941|      0|    JS_FreeValue(ctx, v);
41942|      0|    return JS_EXCEPTION;
41943|      0|}
41944|       |
41945|       |static int check_regexp_g_flag(JSContext *ctx, JSValueConst regexp)
41946|      0|{
41947|      0|    int ret;
41948|      0|    JSValue flags;
41949|       |
41950|      0|    ret = js_is_regexp(ctx, regexp);
41951|      0|    if (ret < 0)
41952|      0|        return -1;
41953|      0|    if (ret) {
41954|      0|        flags = JS_GetProperty(ctx, regexp, JS_ATOM_flags);
41955|      0|        if (JS_IsException(flags))
41956|      0|            return -1;
41957|      0|        if (JS_IsUndefined(flags) || JS_IsNull(flags)) {
41958|      0|            JS_ThrowTypeError(ctx, "cannot convert to object");
41959|      0|            return -1;
41960|      0|        }
41961|      0|        flags = JS_ToStringFree(ctx, flags);
41962|      0|        if (JS_IsException(flags))
41963|      0|            return -1;
41964|      0|        ret = string_indexof_char(JS_VALUE_GET_STRING(flags), 'g', 0);
41965|      0|        JS_FreeValue(ctx, flags);
41966|      0|        if (ret < 0) {
41967|      0|            JS_ThrowTypeError(ctx, "regexp must have the 'g' flag");
41968|      0|            return -1;
41969|      0|        }
41970|      0|    }
41971|      0|    return 0;
41972|      0|}
41973|       |
41974|       |static JSValue js_string_match(JSContext *ctx, JSValueConst this_val,
41975|       |                               int argc, JSValueConst *argv, int atom)
41976|      0|{
41977|       |    // match(rx), search(rx), matchAll(rx)
41978|       |    // atom is JS_ATOM_Symbol_match, JS_ATOM_Symbol_search, or JS_ATOM_Symbol_matchAll
41979|      0|    JSValueConst O = this_val, regexp = argv[0], args[2];
41980|      0|    JSValue matcher, S, rx, result, str;
41981|      0|    int args_len;
41982|       |
41983|      0|    if (JS_IsUndefined(O) || JS_IsNull(O))
41984|      0|        return JS_ThrowTypeError(ctx, "cannot convert to object");
41985|       |
41986|      0|    if (!JS_IsUndefined(regexp) && !JS_IsNull(regexp)) {
41987|      0|        matcher = JS_GetProperty(ctx, regexp, atom);
41988|      0|        if (JS_IsException(matcher))
41989|      0|            return JS_EXCEPTION;
41990|      0|        if (atom == JS_ATOM_Symbol_matchAll) {
41991|      0|            if (check_regexp_g_flag(ctx, regexp) < 0) {
41992|      0|                JS_FreeValue(ctx, matcher);
41993|      0|                return JS_EXCEPTION;
41994|      0|            }
41995|      0|        }
41996|      0|        if (!JS_IsUndefined(matcher) && !JS_IsNull(matcher)) {
41997|      0|            return JS_CallFree(ctx, matcher, regexp, 1, &O);
41998|      0|        }
41999|      0|    }
42000|      0|    S = JS_ToString(ctx, O);
42001|      0|    if (JS_IsException(S))
42002|      0|        return JS_EXCEPTION;
42003|      0|    args_len = 1;
42004|      0|    args[0] = regexp;
42005|      0|    str = JS_UNDEFINED;
42006|      0|    if (atom == JS_ATOM_Symbol_matchAll) {
42007|      0|        str = js_new_string8(ctx, "g");
42008|      0|        if (JS_IsException(str))
42009|      0|            goto fail;
42010|      0|        args[args_len++] = (JSValueConst)str;
42011|      0|    }
42012|      0|    rx = JS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
42013|      0|    JS_FreeValue(ctx, str);
42014|      0|    if (JS_IsException(rx)) {
42015|      0|    fail:
42016|      0|        JS_FreeValue(ctx, S);
42017|      0|        return JS_EXCEPTION;
42018|      0|    }
42019|      0|    result = JS_InvokeFree(ctx, rx, atom, 1, (JSValueConst *)&S);
42020|      0|    JS_FreeValue(ctx, S);
42021|      0|    return result;
42022|      0|}
42023|       |
42024|       |static JSValue js_string___GetSubstitution(JSContext *ctx, JSValueConst this_val,
42025|       |                                           int argc, JSValueConst *argv)
42026|      0|{
42027|       |    // GetSubstitution(matched, str, position, captures, namedCaptures, rep)
42028|      0|    JSValueConst matched, str, captures, namedCaptures, rep;
42029|      0|    JSValue capture, name, s;
42030|      0|    uint32_t position, len, matched_len, captures_len;
42031|      0|    int i, j, j0, k, k1;
42032|      0|    int c, c1;
42033|      0|    StringBuffer b_s, *b = &b_s;
42034|      0|    JSString *sp, *rp;
42035|       |
42036|      0|    matched = argv[0];
42037|      0|    str = argv[1];
42038|      0|    captures = argv[3];
42039|      0|    namedCaptures = argv[4];
42040|      0|    rep = argv[5];
42041|       |
42042|      0|    if (!JS_IsString(rep) || !JS_IsString(str))
42043|      0|        return JS_ThrowTypeError(ctx, "not a string");
42044|       |
42045|      0|    sp = JS_VALUE_GET_STRING(str);
42046|      0|    rp = JS_VALUE_GET_STRING(rep);
42047|       |
42048|      0|    string_buffer_init(ctx, b, 0);
42049|       |
42050|      0|    captures_len = 0;
42051|      0|    if (!JS_IsUndefined(captures)) {
42052|      0|        if (js_get_length32(ctx, &captures_len, captures))
42053|      0|            goto exception;
42054|      0|    }
42055|      0|    if (js_get_length32(ctx, &matched_len, matched))
42056|      0|        goto exception;
42057|      0|    if (JS_ToUint32(ctx, &position, argv[2]) < 0)
42058|      0|        goto exception;
42059|       |
42060|      0|    len = rp->len;
42061|      0|    i = 0;
42062|      0|    for(;;) {
42063|      0|        j = string_indexof_char(rp, '$', i);
42064|      0|        if (j < 0 || j + 1 >= len)
42065|      0|            break;
42066|      0|        string_buffer_concat(b, rp, i, j);
42067|      0|        j0 = j++;
42068|      0|        c = string_get(rp, j++);
42069|      0|        if (c == '$') {
42070|      0|            string_buffer_putc8(b, '$');
42071|      0|        } else if (c == '&') {
42072|      0|            if (string_buffer_concat_value(b, matched))
42073|      0|                goto exception;
42074|      0|        } else if (c == '`') {
42075|      0|            string_buffer_concat(b, sp, 0, position);
42076|      0|        } else if (c == '\'') {
42077|      0|            string_buffer_concat(b, sp, position + matched_len, sp->len);
42078|      0|        } else if (c >= '0' && c <= '9') {
42079|      0|            k = c - '0';
42080|      0|            if (j < len) {
42081|      0|                c1 = string_get(rp, j);
42082|      0|                if (c1 >= '0' && c1 <= '9') {
42083|       |                    /* This behavior is specified in ES6 and refined in ECMA 2019 */
42084|       |                    /* ECMA 2019 does not have the extra test, but
42085|       |                       Test262 S15.5.4.11_A3_T1..3 require this behavior */
42086|      0|                    k1 = k * 10 + c1 - '0';
42087|      0|                    if (k1 >= 1 && k1 < captures_len) {
42088|      0|                        k = k1;
42089|      0|                        j++;
42090|      0|                    }
42091|      0|                }
42092|      0|            }
42093|      0|            if (k >= 1 && k < captures_len) {
42094|      0|                s = JS_GetPropertyInt64(ctx, captures, k);
42095|      0|                if (JS_IsException(s))
42096|      0|                    goto exception;
42097|      0|                if (!JS_IsUndefined(s)) {
42098|      0|                    if (string_buffer_concat_value_free(b, s))
42099|      0|                        goto exception;
42100|      0|                }
42101|      0|            } else {
42102|      0|                goto norep;
42103|      0|            }
42104|      0|        } else if (c == '<' && !JS_IsUndefined(namedCaptures)) {
42105|      0|            k = string_indexof_char(rp, '>', j);
42106|      0|            if (k < 0)
42107|      0|                goto norep;
42108|      0|            name = js_sub_string(ctx, rp, j, k);
42109|      0|            if (JS_IsException(name))
42110|      0|                goto exception;
42111|      0|            capture = JS_GetPropertyValue(ctx, namedCaptures, name);
42112|      0|            if (JS_IsException(capture))
42113|      0|                goto exception;
42114|      0|            if (!JS_IsUndefined(capture)) {
42115|      0|                if (string_buffer_concat_value_free(b, capture))
42116|      0|                    goto exception;
42117|      0|            }
42118|      0|            j = k + 1;
42119|      0|        } else {
42120|      0|        norep:
42121|      0|            string_buffer_concat(b, rp, j0, j);
42122|      0|        }
42123|      0|        i = j;
42124|      0|    }
42125|      0|    string_buffer_concat(b, rp, i, rp->len);
42126|      0|    return string_buffer_end(b);
42127|      0|exception:
42128|      0|    string_buffer_free(b);
42129|      0|    return JS_EXCEPTION;
42130|      0|}
42131|       |
42132|       |static JSValue js_string_replace(JSContext *ctx, JSValueConst this_val,
42133|       |                                 int argc, JSValueConst *argv,
42134|       |                                 int is_replaceAll)
42135|      0|{
42136|       |    // replace(rx, rep)
42137|      0|    JSValueConst O = this_val, searchValue = argv[0], replaceValue = argv[1];
42138|      0|    JSValueConst args[6];
42139|      0|    JSValue str, search_str, replaceValue_str, repl_str;
42140|      0|    JSString *sp, *searchp;
42141|      0|    StringBuffer b_s, *b = &b_s;
42142|      0|    int pos, functionalReplace, endOfLastMatch;
42143|      0|    BOOL is_first;
42144|       |
42145|      0|    if (JS_IsUndefined(O) || JS_IsNull(O))
42146|      0|        return JS_ThrowTypeError(ctx, "cannot convert to object");
42147|       |
42148|      0|    search_str = JS_UNDEFINED;
42149|      0|    replaceValue_str = JS_UNDEFINED;
42150|      0|    repl_str = JS_UNDEFINED;
42151|       |
42152|      0|    if (!JS_IsUndefined(searchValue) && !JS_IsNull(searchValue)) {
42153|      0|        JSValue replacer;
42154|      0|        if (is_replaceAll) {
42155|      0|            if (check_regexp_g_flag(ctx, searchValue) < 0)
42156|      0|                return JS_EXCEPTION;
42157|      0|        }
42158|      0|        replacer = JS_GetProperty(ctx, searchValue, JS_ATOM_Symbol_replace);
42159|      0|        if (JS_IsException(replacer))
42160|      0|            return JS_EXCEPTION;
42161|      0|        if (!JS_IsUndefined(replacer) && !JS_IsNull(replacer)) {
42162|      0|            args[0] = O;
42163|      0|            args[1] = replaceValue;
42164|      0|            return JS_CallFree(ctx, replacer, searchValue, 2, args);
42165|      0|        }
42166|      0|    }
42167|      0|    string_buffer_init(ctx, b, 0);
42168|       |
42169|      0|    str = JS_ToString(ctx, O);
42170|      0|    if (JS_IsException(str))
42171|      0|        goto exception;
42172|      0|    search_str = JS_ToString(ctx, searchValue);
42173|      0|    if (JS_IsException(search_str))
42174|      0|        goto exception;
42175|      0|    functionalReplace = JS_IsFunction(ctx, replaceValue);
42176|      0|    if (!functionalReplace) {
42177|      0|        replaceValue_str = JS_ToString(ctx, replaceValue);
42178|      0|        if (JS_IsException(replaceValue_str))
42179|      0|            goto exception;
42180|      0|    }
42181|       |
42182|      0|    sp = JS_VALUE_GET_STRING(str);
42183|      0|    searchp = JS_VALUE_GET_STRING(search_str);
42184|      0|    endOfLastMatch = 0;
42185|      0|    is_first = TRUE;
42186|      0|    for(;;) {
42187|      0|        if (unlikely(searchp->len == 0)) {
42188|      0|            if (is_first)
42189|      0|                pos = 0;
42190|      0|            else if (endOfLastMatch >= sp->len)
42191|      0|                pos = -1;
42192|      0|            else
42193|      0|                pos = endOfLastMatch + 1;
42194|      0|        } else {
42195|      0|            pos = string_indexof(sp, searchp, endOfLastMatch);
42196|      0|        }
42197|      0|        if (pos < 0) {
42198|      0|            if (is_first) {
42199|      0|                string_buffer_free(b);
42200|      0|                JS_FreeValue(ctx, search_str);
42201|      0|                JS_FreeValue(ctx, replaceValue_str);
42202|      0|                return str;
42203|      0|            } else {
42204|      0|                break;
42205|      0|            }
42206|      0|        }
42207|      0|        if (functionalReplace) {
42208|      0|            args[0] = search_str;
42209|      0|            args[1] = JS_NewInt32(ctx, pos);
42210|      0|            args[2] = str;
42211|      0|            repl_str = JS_ToStringFree(ctx, JS_Call(ctx, replaceValue, JS_UNDEFINED, 3, args));
42212|      0|        } else {
42213|      0|            args[0] = search_str;
42214|      0|            args[1] = str;
42215|      0|            args[2] = JS_NewInt32(ctx, pos);
42216|      0|            args[3] = JS_UNDEFINED;
42217|      0|            args[4] = JS_UNDEFINED;
42218|      0|            args[5] = replaceValue_str;
42219|      0|            repl_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);
42220|      0|        }
42221|      0|        if (JS_IsException(repl_str))
42222|      0|            goto exception;
42223|       |
42224|      0|        string_buffer_concat(b, sp, endOfLastMatch, pos);
42225|      0|        string_buffer_concat_value_free(b, repl_str);
42226|      0|        endOfLastMatch = pos + searchp->len;
42227|      0|        is_first = FALSE;
42228|      0|        if (!is_replaceAll)
42229|      0|            break;
42230|      0|    }
42231|      0|    string_buffer_concat(b, sp, endOfLastMatch, sp->len);
42232|      0|    JS_FreeValue(ctx, search_str);
42233|      0|    JS_FreeValue(ctx, replaceValue_str);
42234|      0|    JS_FreeValue(ctx, str);
42235|      0|    return string_buffer_end(b);
42236|       |
42237|      0|exception:
42238|      0|    string_buffer_free(b);
42239|      0|    JS_FreeValue(ctx, search_str);
42240|      0|    JS_FreeValue(ctx, replaceValue_str);
42241|      0|    JS_FreeValue(ctx, str);
42242|      0|    return JS_EXCEPTION;
42243|      0|}
42244|       |
42245|       |static JSValue js_string_split(JSContext *ctx, JSValueConst this_val,
42246|       |                               int argc, JSValueConst *argv)
42247|      0|{
42248|       |    // split(sep, limit)
42249|      0|    JSValueConst O = this_val, separator = argv[0], limit = argv[1];
42250|      0|    JSValueConst args[2];
42251|      0|    JSValue S, A, R, T;
42252|      0|    uint32_t lim, lengthA;
42253|      0|    int64_t p, q, s, r, e;
42254|      0|    JSString *sp, *rp;
42255|       |
42256|      0|    if (JS_IsUndefined(O) || JS_IsNull(O))
42257|      0|        return JS_ThrowTypeError(ctx, "cannot convert to object");
42258|       |
42259|      0|    S = JS_UNDEFINED;
42260|      0|    A = JS_UNDEFINED;
42261|      0|    R = JS_UNDEFINED;
42262|       |
42263|      0|    if (!JS_IsUndefined(separator) && !JS_IsNull(separator)) {
42264|      0|        JSValue splitter;
42265|      0|        splitter = JS_GetProperty(ctx, separator, JS_ATOM_Symbol_split);
42266|      0|        if (JS_IsException(splitter))
42267|      0|            return JS_EXCEPTION;
42268|      0|        if (!JS_IsUndefined(splitter) && !JS_IsNull(splitter)) {
42269|      0|            args[0] = O;
42270|      0|            args[1] = limit;
42271|      0|            return JS_CallFree(ctx, splitter, separator, 2, args);
42272|      0|        }
42273|      0|    }
42274|      0|    S = JS_ToString(ctx, O);
42275|      0|    if (JS_IsException(S))
42276|      0|        goto exception;
42277|      0|    A = JS_NewArray(ctx);
42278|      0|    if (JS_IsException(A))
42279|      0|        goto exception;
42280|      0|    lengthA = 0;
42281|      0|    if (JS_IsUndefined(limit)) {
42282|      0|        lim = 0xffffffff;
42283|      0|    } else {
42284|      0|        if (JS_ToUint32(ctx, &lim, limit) < 0)
42285|      0|            goto exception;
42286|      0|    }
42287|      0|    sp = JS_VALUE_GET_STRING(S);
42288|      0|    s = sp->len;
42289|      0|    R = JS_ToString(ctx, separator);
42290|      0|    if (JS_IsException(R))
42291|      0|        goto exception;
42292|      0|    rp = JS_VALUE_GET_STRING(R);
42293|      0|    r = rp->len;
42294|      0|    p = 0;
42295|      0|    if (lim == 0)
42296|      0|        goto done;
42297|      0|    if (JS_IsUndefined(separator))
42298|      0|        goto add_tail;
42299|      0|    if (s == 0) {
42300|      0|        if (r != 0)
42301|      0|            goto add_tail;
42302|      0|        goto done;
42303|      0|    }
42304|      0|    q = p;
42305|      0|    for (q = p; (q += !r) <= s - r - !r; q = p = e + r) {
42306|      0|        e = string_indexof(sp, rp, q);
42307|      0|        if (e < 0)
42308|      0|            break;
42309|      0|        T = js_sub_string(ctx, sp, p, e);
42310|      0|        if (JS_IsException(T))
42311|      0|            goto exception;
42312|      0|        if (JS_CreateDataPropertyUint32(ctx, A, lengthA++, T, 0) < 0)
42313|      0|            goto exception;
42314|      0|        if (lengthA == lim)
42315|      0|            goto done;
42316|      0|    }
42317|      0|add_tail:
42318|      0|    T = js_sub_string(ctx, sp, p, s);
42319|      0|    if (JS_IsException(T))
42320|      0|        goto exception;
42321|      0|    if (JS_CreateDataPropertyUint32(ctx, A, lengthA++, T,0 ) < 0)
42322|      0|        goto exception;
42323|      0|done:
42324|      0|    JS_FreeValue(ctx, S);
42325|      0|    JS_FreeValue(ctx, R);
42326|      0|    return A;
42327|       |
42328|      0|exception:
42329|      0|    JS_FreeValue(ctx, A);
42330|      0|    JS_FreeValue(ctx, S);
42331|      0|    JS_FreeValue(ctx, R);
42332|      0|    return JS_EXCEPTION;
42333|      0|}
42334|       |
42335|       |static JSValue js_string_substring(JSContext *ctx, JSValueConst this_val,
42336|       |                                   int argc, JSValueConst *argv)
42337|      0|{
42338|      0|    JSValue str, ret;
42339|      0|    int a, b, start, end;
42340|      0|    JSString *p;
42341|       |
42342|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42343|      0|    if (JS_IsException(str))
42344|      0|        return str;
42345|      0|    p = JS_VALUE_GET_STRING(str);
42346|      0|    if (JS_ToInt32Clamp(ctx, &a, argv[0], 0, p->len, 0)) {
42347|      0|        JS_FreeValue(ctx, str);
42348|      0|        return JS_EXCEPTION;
42349|      0|    }
42350|      0|    b = p->len;
42351|      0|    if (!JS_IsUndefined(argv[1])) {
42352|      0|        if (JS_ToInt32Clamp(ctx, &b, argv[1], 0, p->len, 0)) {
42353|      0|            JS_FreeValue(ctx, str);
42354|      0|            return JS_EXCEPTION;
42355|      0|        }
42356|      0|    }
42357|      0|    if (a < b) {
42358|      0|        start = a;
42359|      0|        end = b;
42360|      0|    } else {
42361|      0|        start = b;
42362|      0|        end = a;
42363|      0|    }
42364|      0|    ret = js_sub_string(ctx, p, start, end);
42365|      0|    JS_FreeValue(ctx, str);
42366|      0|    return ret;
42367|      0|}
42368|       |
42369|       |static JSValue js_string_substr(JSContext *ctx, JSValueConst this_val,
42370|       |                                int argc, JSValueConst *argv)
42371|      0|{
42372|      0|    JSValue str, ret;
42373|      0|    int a, len, n;
42374|      0|    JSString *p;
42375|       |
42376|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42377|      0|    if (JS_IsException(str))
42378|      0|        return str;
42379|      0|    p = JS_VALUE_GET_STRING(str);
42380|      0|    len = p->len;
42381|      0|    if (JS_ToInt32Clamp(ctx, &a, argv[0], 0, len, len)) {
42382|      0|        JS_FreeValue(ctx, str);
42383|      0|        return JS_EXCEPTION;
42384|      0|    }
42385|      0|    n = len - a;
42386|      0|    if (!JS_IsUndefined(argv[1])) {
42387|      0|        if (JS_ToInt32Clamp(ctx, &n, argv[1], 0, len - a, 0)) {
42388|      0|            JS_FreeValue(ctx, str);
42389|      0|            return JS_EXCEPTION;
42390|      0|        }
42391|      0|    }
42392|      0|    ret = js_sub_string(ctx, p, a, a + n);
42393|      0|    JS_FreeValue(ctx, str);
42394|      0|    return ret;
42395|      0|}
42396|       |
42397|       |static JSValue js_string_slice(JSContext *ctx, JSValueConst this_val,
42398|       |                               int argc, JSValueConst *argv)
42399|      0|{
42400|      0|    JSValue str, ret;
42401|      0|    int len, start, end;
42402|      0|    JSString *p;
42403|       |
42404|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42405|      0|    if (JS_IsException(str))
42406|      0|        return str;
42407|      0|    p = JS_VALUE_GET_STRING(str);
42408|      0|    len = p->len;
42409|      0|    if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) {
42410|      0|        JS_FreeValue(ctx, str);
42411|      0|        return JS_EXCEPTION;
42412|      0|    }
42413|      0|    end = len;
42414|      0|    if (!JS_IsUndefined(argv[1])) {
42415|      0|        if (JS_ToInt32Clamp(ctx, &end, argv[1], 0, len, len)) {
42416|      0|            JS_FreeValue(ctx, str);
42417|      0|            return JS_EXCEPTION;
42418|      0|        }
42419|      0|    }
42420|      0|    ret = js_sub_string(ctx, p, start, max_int(end, start));
42421|      0|    JS_FreeValue(ctx, str);
42422|      0|    return ret;
42423|      0|}
42424|       |
42425|       |static JSValue js_string_pad(JSContext *ctx, JSValueConst this_val,
42426|       |                             int argc, JSValueConst *argv, int padEnd)
42427|      0|{
42428|      0|    JSValue str, v = JS_UNDEFINED;
42429|      0|    StringBuffer b_s, *b = &b_s;
42430|      0|    JSString *p, *p1 = NULL;
42431|      0|    int n, len, c = ' ';
42432|       |
42433|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42434|      0|    if (JS_IsException(str))
42435|      0|        goto fail1;
42436|      0|    if (JS_ToInt32Sat(ctx, &n, argv[0]))
42437|      0|        goto fail2;
42438|      0|    p = JS_VALUE_GET_STRING(str);
42439|      0|    len = p->len;
42440|      0|    if (len >= n)
42441|      0|        return str;
42442|      0|    if (argc > 1 && !JS_IsUndefined(argv[1])) {
42443|      0|        v = JS_ToString(ctx, argv[1]);
42444|      0|        if (JS_IsException(v))
42445|      0|            goto fail2;
42446|      0|        p1 = JS_VALUE_GET_STRING(v);
42447|      0|        if (p1->len == 0) {
42448|      0|            JS_FreeValue(ctx, v);
42449|      0|            return str;
42450|      0|        }
42451|      0|        if (p1->len == 1) {
42452|      0|            c = string_get(p1, 0);
42453|      0|            p1 = NULL;
42454|      0|        }
42455|      0|    }
42456|      0|    if (n > JS_STRING_LEN_MAX) {
42457|      0|        JS_ThrowRangeError(ctx, "invalid string length");
42458|      0|        goto fail3;
42459|      0|    }
42460|      0|    if (string_buffer_init(ctx, b, n))
42461|      0|        goto fail3;
42462|      0|    n -= len;
42463|      0|    if (padEnd) {
42464|      0|        if (string_buffer_concat(b, p, 0, len))
42465|      0|            goto fail;
42466|      0|    }
42467|      0|    if (p1) {
42468|      0|        while (n > 0) {
42469|      0|            int chunk = min_int(n, p1->len);
42470|      0|            if (string_buffer_concat(b, p1, 0, chunk))
42471|      0|                goto fail;
42472|      0|            n -= chunk;
42473|      0|        }
42474|      0|    } else {
42475|      0|        if (string_buffer_fill(b, c, n))
42476|      0|            goto fail;
42477|      0|    }
42478|      0|    if (!padEnd) {
42479|      0|        if (string_buffer_concat(b, p, 0, len))
42480|      0|            goto fail;
42481|      0|    }
42482|      0|    JS_FreeValue(ctx, v);
42483|      0|    JS_FreeValue(ctx, str);
42484|      0|    return string_buffer_end(b);
42485|       |
42486|      0|fail:
42487|      0|    string_buffer_free(b);
42488|      0|fail3:
42489|      0|    JS_FreeValue(ctx, v);
42490|      0|fail2:
42491|      0|    JS_FreeValue(ctx, str);
42492|      0|fail1:
42493|      0|    return JS_EXCEPTION;
42494|      0|}
42495|       |
42496|       |static JSValue js_string_repeat(JSContext *ctx, JSValueConst this_val,
42497|       |                                int argc, JSValueConst *argv)
42498|      0|{
42499|      0|    JSValue str;
42500|      0|    StringBuffer b_s, *b = &b_s;
42501|      0|    JSString *p;
42502|      0|    int64_t val;
42503|      0|    int n, len;
42504|       |
42505|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42506|      0|    if (JS_IsException(str))
42507|      0|        goto fail;
42508|      0|    if (JS_ToInt64Sat(ctx, &val, argv[0]))
42509|      0|        goto fail;
42510|      0|    if (val < 0 || val > 2147483647) {
42511|      0|        JS_ThrowRangeError(ctx, "invalid repeat count");
42512|      0|        goto fail;
42513|      0|    }
42514|      0|    n = val;
42515|      0|    p = JS_VALUE_GET_STRING(str);
42516|      0|    len = p->len;
42517|      0|    if (len == 0 || n == 1)
42518|      0|        return str;
42519|       |    // XXX: potential arithmetic overflow
42520|      0|    if (val * len > JS_STRING_LEN_MAX) {
42521|      0|        JS_ThrowRangeError(ctx, "invalid string length");
42522|      0|        goto fail;
42523|      0|    }
42524|      0|    if (string_buffer_init2(ctx, b, n * len, p->is_wide_char))
42525|      0|        goto fail;
42526|      0|    if (len == 1) {
42527|      0|        string_buffer_fill(b, string_get(p, 0), n);
42528|      0|    } else {
42529|      0|        while (n-- > 0) {
42530|      0|            string_buffer_concat(b, p, 0, len);
42531|      0|        }
42532|      0|    }
42533|      0|    JS_FreeValue(ctx, str);
42534|      0|    return string_buffer_end(b);
42535|       |
42536|      0|fail:
42537|      0|    JS_FreeValue(ctx, str);
42538|      0|    return JS_EXCEPTION;
42539|      0|}
42540|       |
42541|       |static JSValue js_string_trim(JSContext *ctx, JSValueConst this_val,
42542|       |                              int argc, JSValueConst *argv, int magic)
42543|      0|{
42544|      0|    JSValue str, ret;
42545|      0|    int a, b, len;
42546|      0|    JSString *p;
42547|       |
42548|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42549|      0|    if (JS_IsException(str))
42550|      0|        return str;
42551|      0|    p = JS_VALUE_GET_STRING(str);
42552|      0|    a = 0;
42553|      0|    b = len = p->len;
42554|      0|    if (magic & 1) {
42555|      0|        while (a < len && lre_is_space(string_get(p, a)))
42556|      0|            a++;
42557|      0|    }
42558|      0|    if (magic & 2) {
42559|      0|        while (b > a && lre_is_space(string_get(p, b - 1)))
42560|      0|            b--;
42561|      0|    }
42562|      0|    ret = js_sub_string(ctx, p, a, b);
42563|      0|    JS_FreeValue(ctx, str);
42564|      0|    return ret;
42565|      0|}
42566|       |
42567|       |static JSValue js_string___quote(JSContext *ctx, JSValueConst this_val,
42568|       |                                 int argc, JSValueConst *argv)
42569|      0|{
42570|      0|    return JS_ToQuotedString(ctx, this_val);
42571|      0|}
42572|       |
42573|       |/* return 0 if before the first char */
42574|       |static int string_prevc(JSString *p, int *pidx)
42575|      0|{
42576|      0|    int idx, c, c1;
42577|       |
42578|      0|    idx = *pidx;
42579|      0|    if (idx <= 0)
42580|      0|        return 0;
42581|      0|    idx--;
42582|      0|    if (p->is_wide_char) {
42583|      0|        c = p->u.str16[idx];
42584|      0|        if (is_lo_surrogate(c) && idx > 0) {
42585|      0|            c1 = p->u.str16[idx - 1];
42586|      0|            if (is_hi_surrogate(c1)) {
42587|      0|                c = from_surrogate(c1, c);
42588|      0|                idx--;
42589|      0|            }
42590|      0|        }
42591|      0|    } else {
42592|      0|        c = p->u.str8[idx];
42593|      0|    }
42594|      0|    *pidx = idx;
42595|      0|    return c;
42596|      0|}
42597|       |
42598|       |static BOOL test_final_sigma(JSString *p, int sigma_pos)
42599|      0|{
42600|      0|    int k, c1;
42601|       |
42602|       |    /* before C: skip case ignorable chars and check there is
42603|       |       a cased letter */
42604|      0|    k = sigma_pos;
42605|      0|    for(;;) {
42606|      0|        c1 = string_prevc(p, &k);
42607|      0|        if (!lre_is_case_ignorable(c1))
42608|      0|            break;
42609|      0|    }
42610|      0|    if (!lre_is_cased(c1))
42611|      0|        return FALSE;
42612|       |
42613|       |    /* after C: skip case ignorable chars and check there is
42614|       |       no cased letter */
42615|      0|    k = sigma_pos + 1;
42616|      0|    for(;;) {
42617|      0|        if (k >= p->len)
42618|      0|            return TRUE;
42619|      0|        c1 = string_getc(p, &k);
42620|      0|        if (!lre_is_case_ignorable(c1))
42621|      0|            break;
42622|      0|    }
42623|      0|    return !lre_is_cased(c1);
42624|      0|}
42625|       |
42626|       |static JSValue js_string_toLowerCase(JSContext *ctx, JSValueConst this_val,
42627|       |                                     int argc, JSValueConst *argv, int to_lower)
42628|      0|{
42629|      0|    JSValue val;
42630|      0|    StringBuffer b_s, *b = &b_s;
42631|      0|    JSString *p;
42632|      0|    int i, c, j, l;
42633|      0|    uint32_t res[LRE_CC_RES_LEN_MAX];
42634|       |
42635|      0|    val = JS_ToStringCheckObject(ctx, this_val);
42636|      0|    if (JS_IsException(val))
42637|      0|        return val;
42638|      0|    p = JS_VALUE_GET_STRING(val);
42639|      0|    if (p->len == 0)
42640|      0|        return val;
42641|      0|    if (string_buffer_init(ctx, b, p->len))
42642|      0|        goto fail;
42643|      0|    for(i = 0; i < p->len;) {
42644|      0|        c = string_getc(p, &i);
42645|      0|        if (c == 0x3a3 && to_lower && test_final_sigma(p, i - 1)) {
42646|      0|            res[0] = 0x3c2; /* final sigma */
42647|      0|            l = 1;
42648|      0|        } else {
42649|      0|            l = lre_case_conv(res, c, to_lower);
42650|      0|        }
42651|      0|        for(j = 0; j < l; j++) {
42652|      0|            if (string_buffer_putc(b, res[j]))
42653|      0|                goto fail;
42654|      0|        }
42655|      0|    }
42656|      0|    JS_FreeValue(ctx, val);
42657|      0|    return string_buffer_end(b);
42658|      0| fail:
42659|      0|    JS_FreeValue(ctx, val);
42660|      0|    string_buffer_free(b);
42661|      0|    return JS_EXCEPTION;
42662|      0|}
42663|       |
42664|       |#ifdef CONFIG_ALL_UNICODE
42665|       |
42666|       |/* return (-1, NULL) if exception, otherwise (len, buf) */
42667|       |static int JS_ToUTF32String(JSContext *ctx, uint32_t **pbuf, JSValueConst val1)
42668|      0|{
42669|      0|    JSValue val;
42670|      0|    JSString *p;
42671|      0|    uint32_t *buf;
42672|      0|    int i, j, len;
42673|       |
42674|      0|    val = JS_ToString(ctx, val1);
42675|      0|    if (JS_IsException(val))
42676|      0|        return -1;
42677|      0|    p = JS_VALUE_GET_STRING(val);
42678|      0|    len = p->len;
42679|       |    /* UTF32 buffer length is len minus the number of correct surrogates pairs */
42680|      0|    buf = js_malloc(ctx, sizeof(buf[0]) * max_int(len, 1));
42681|      0|    if (!buf) {
42682|      0|        JS_FreeValue(ctx, val);
42683|      0|        goto fail;
42684|      0|    }
42685|      0|    for(i = j = 0; i < len;)
42686|      0|        buf[j++] = string_getc(p, &i);
42687|      0|    JS_FreeValue(ctx, val);
42688|      0|    *pbuf = buf;
42689|      0|    return j;
42690|      0| fail:
42691|      0|    *pbuf = NULL;
42692|      0|    return -1;
42693|      0|}
42694|       |
42695|       |static JSValue JS_NewUTF32String(JSContext *ctx, const uint32_t *buf, int len)
42696|      0|{
42697|      0|    int i;
42698|      0|    StringBuffer b_s, *b = &b_s;
42699|      0|    if (string_buffer_init(ctx, b, len))
42700|      0|        return JS_EXCEPTION;
42701|      0|    for(i = 0; i < len; i++) {
42702|      0|        if (string_buffer_putc(b, buf[i]))
42703|      0|            goto fail;
42704|      0|    }
42705|      0|    return string_buffer_end(b);
42706|      0| fail:
42707|      0|    string_buffer_free(b);
42708|      0|    return JS_EXCEPTION;
42709|      0|}
42710|       |
42711|       |static int js_string_normalize1(JSContext *ctx, uint32_t **pout_buf,
42712|       |                                JSValueConst val,
42713|       |                                UnicodeNormalizationEnum n_type)
42714|      0|{
42715|      0|    int buf_len, out_len;
42716|      0|    uint32_t *buf, *out_buf;
42717|       |
42718|      0|    buf_len = JS_ToUTF32String(ctx, &buf, val);
42719|      0|    if (buf_len < 0)
42720|      0|        return -1;
42721|      0|    out_len = unicode_normalize(&out_buf, buf, buf_len, n_type,
42722|      0|                                ctx->rt, (DynBufReallocFunc *)js_realloc_rt);
42723|      0|    js_free(ctx, buf);
42724|      0|    if (out_len < 0)
42725|      0|        return -1;
42726|      0|    *pout_buf = out_buf;
42727|      0|    return out_len;
42728|      0|}
42729|       |
42730|       |static JSValue js_string_normalize(JSContext *ctx, JSValueConst this_val,
42731|       |                                   int argc, JSValueConst *argv)
42732|      0|{
42733|      0|    const char *form, *p;
42734|      0|    size_t form_len;
42735|      0|    int is_compat, out_len;
42736|      0|    UnicodeNormalizationEnum n_type;
42737|      0|    JSValue val;
42738|      0|    uint32_t *out_buf;
42739|       |
42740|      0|    val = JS_ToStringCheckObject(ctx, this_val);
42741|      0|    if (JS_IsException(val))
42742|      0|        return val;
42743|       |
42744|      0|    if (argc == 0 || JS_IsUndefined(argv[0])) {
42745|      0|        n_type = UNICODE_NFC;
42746|      0|    } else {
42747|      0|        form = JS_ToCStringLen(ctx, &form_len, argv[0]);
42748|      0|        if (!form)
42749|      0|            goto fail1;
42750|      0|        p = form;
42751|      0|        if (p[0] != 'N' || p[1] != 'F')
42752|      0|            goto bad_form;
42753|      0|        p += 2;
42754|      0|        is_compat = FALSE;
42755|      0|        if (*p == 'K') {
42756|      0|            is_compat = TRUE;
42757|      0|            p++;
42758|      0|        }
42759|      0|        if (*p == 'C' || *p == 'D') {
42760|      0|            n_type = UNICODE_NFC + is_compat * 2 + (*p - 'C');
42761|      0|            if ((p + 1 - form) != form_len)
42762|      0|                goto bad_form;
42763|      0|        } else {
42764|      0|        bad_form:
42765|      0|            JS_FreeCString(ctx, form);
42766|      0|            JS_ThrowRangeError(ctx, "bad normalization form");
42767|      0|        fail1:
42768|      0|            JS_FreeValue(ctx, val);
42769|      0|            return JS_EXCEPTION;
42770|      0|        }
42771|      0|        JS_FreeCString(ctx, form);
42772|      0|    }
42773|       |
42774|      0|    out_len = js_string_normalize1(ctx, &out_buf, val, n_type);
42775|      0|    JS_FreeValue(ctx, val);
42776|      0|    if (out_len < 0)
42777|      0|        return JS_EXCEPTION;
42778|      0|    val = JS_NewUTF32String(ctx, out_buf, out_len);
42779|      0|    js_free(ctx, out_buf);
42780|      0|    return val;
42781|      0|}
42782|       |
42783|       |/* return < 0, 0 or > 0 */
42784|       |static int js_UTF32_compare(const uint32_t *buf1, int buf1_len,
42785|       |                            const uint32_t *buf2, int buf2_len)
42786|      0|{
42787|      0|    int i, len, c, res;
42788|      0|    len = min_int(buf1_len, buf2_len);
42789|      0|    for(i = 0; i < len; i++) {
42790|       |        /* Note: range is limited so a subtraction is valid */
42791|      0|        c = buf1[i] - buf2[i];
42792|      0|        if (c != 0)
42793|      0|            return c;
42794|      0|    }
42795|      0|    if (buf1_len == buf2_len)
42796|      0|        res = 0;
42797|      0|    else if (buf1_len < buf2_len)
42798|      0|        res = -1;
42799|      0|    else
42800|      0|        res = 1;
42801|      0|    return res;
42802|      0|}
42803|       |
42804|       |static JSValue js_string_localeCompare(JSContext *ctx, JSValueConst this_val,
42805|       |                                       int argc, JSValueConst *argv)
42806|      0|{
42807|      0|    JSValue a, b;
42808|      0|    int cmp, a_len, b_len;
42809|      0|    uint32_t *a_buf, *b_buf;
42810|       |
42811|      0|    a = JS_ToStringCheckObject(ctx, this_val);
42812|      0|    if (JS_IsException(a))
42813|      0|        return JS_EXCEPTION;
42814|      0|    b = JS_ToString(ctx, argv[0]);
42815|      0|    if (JS_IsException(b)) {
42816|      0|        JS_FreeValue(ctx, a);
42817|      0|        return JS_EXCEPTION;
42818|      0|    }
42819|      0|    a_len = js_string_normalize1(ctx, &a_buf, a, UNICODE_NFC);
42820|      0|    JS_FreeValue(ctx, a);
42821|      0|    if (a_len < 0) {
42822|      0|        JS_FreeValue(ctx, b);
42823|      0|        return JS_EXCEPTION;
42824|      0|    }
42825|       |
42826|      0|    b_len = js_string_normalize1(ctx, &b_buf, b, UNICODE_NFC);
42827|      0|    JS_FreeValue(ctx, b);
42828|      0|    if (b_len < 0) {
42829|      0|        js_free(ctx, a_buf);
42830|      0|        return JS_EXCEPTION;
42831|      0|    }
42832|      0|    cmp = js_UTF32_compare(a_buf, a_len, b_buf, b_len);
42833|      0|    js_free(ctx, a_buf);
42834|      0|    js_free(ctx, b_buf);
42835|      0|    return JS_NewInt32(ctx, cmp);
42836|      0|}
42837|       |#else /* CONFIG_ALL_UNICODE */
42838|       |static JSValue js_string_localeCompare(JSContext *ctx, JSValueConst this_val,
42839|       |                                       int argc, JSValueConst *argv)
42840|       |{
42841|       |    JSValue a, b;
42842|       |    int cmp;
42843|       |
42844|       |    a = JS_ToStringCheckObject(ctx, this_val);
42845|       |    if (JS_IsException(a))
42846|       |        return JS_EXCEPTION;
42847|       |    b = JS_ToString(ctx, argv[0]);
42848|       |    if (JS_IsException(b)) {
42849|       |        JS_FreeValue(ctx, a);
42850|       |        return JS_EXCEPTION;
42851|       |    }
42852|       |    cmp = js_string_compare(ctx, JS_VALUE_GET_STRING(a), JS_VALUE_GET_STRING(b));
42853|       |    JS_FreeValue(ctx, a);
42854|       |    JS_FreeValue(ctx, b);
42855|       |    return JS_NewInt32(ctx, cmp);
42856|       |}
42857|       |#endif /* !CONFIG_ALL_UNICODE */
42858|       |
42859|       |/* also used for String.prototype.valueOf */
42860|       |static JSValue js_string_toString(JSContext *ctx, JSValueConst this_val,
42861|       |                                  int argc, JSValueConst *argv)
42862|      0|{
42863|      0|    return js_thisStringValue(ctx, this_val);
42864|      0|}
42865|       |
42866|       |#if 0
42867|       |static JSValue js_string___toStringCheckObject(JSContext *ctx, JSValueConst this_val,
42868|       |                                               int argc, JSValueConst *argv)
42869|       |{
42870|       |    return JS_ToStringCheckObject(ctx, argv[0]);
42871|       |}
42872|       |
42873|       |static JSValue js_string___toString(JSContext *ctx, JSValueConst this_val,
42874|       |                                    int argc, JSValueConst *argv)
42875|       |{
42876|       |    return JS_ToString(ctx, argv[0]);
42877|       |}
42878|       |
42879|       |static JSValue js_string___advanceStringIndex(JSContext *ctx, JSValueConst
42880|       |                                              this_val,
42881|       |                                              int argc, JSValueConst *argv)
42882|       |{
42883|       |    JSValue str;
42884|       |    int idx;
42885|       |    BOOL is_unicode;
42886|       |    JSString *p;
42887|       |
42888|       |    str = JS_ToString(ctx, argv[0]);
42889|       |    if (JS_IsException(str))
42890|       |        return str;
42891|       |    if (JS_ToInt32Sat(ctx, &idx, argv[1])) {
42892|       |        JS_FreeValue(ctx, str);
42893|       |        return JS_EXCEPTION;
42894|       |    }
42895|       |    is_unicode = JS_ToBool(ctx, argv[2]);
42896|       |    p = JS_VALUE_GET_STRING(str);
42897|       |    if (!is_unicode || (unsigned)idx >= p->len || !p->is_wide_char) {
42898|       |        idx++;
42899|       |    } else {
42900|       |        string_getc(p, &idx);
42901|       |    }
42902|       |    JS_FreeValue(ctx, str);
42903|       |    return JS_NewInt32(ctx, idx);
42904|       |}
42905|       |#endif
42906|       |
42907|       |/* String Iterator */
42908|       |
42909|       |static JSValue js_string_iterator_next(JSContext *ctx, JSValueConst this_val,
42910|       |                                       int argc, JSValueConst *argv,
42911|       |                                       BOOL *pdone, int magic)
42912|  5.48k|{
42913|  5.48k|    JSArrayIteratorData *it;
42914|  5.48k|    uint32_t idx, c, start;
42915|  5.48k|    JSString *p;
42916|       |
42917|  5.48k|    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_STRING_ITERATOR);
42918|  5.48k|    if (!it) {
42919|      0|        *pdone = FALSE;
42920|      0|        return JS_EXCEPTION;
42921|      0|    }
42922|  5.48k|    if (JS_IsUndefined(it->obj))
42923|      0|        goto done;
42924|  5.48k|    p = JS_VALUE_GET_STRING(it->obj);
42925|  5.48k|    idx = it->idx;
42926|  5.48k|    if (idx >= p->len) {
42927|     13|        JS_FreeValue(ctx, it->obj);
42928|     13|        it->obj = JS_UNDEFINED;
42929|     13|    done:
42930|     13|        *pdone = TRUE;
42931|     13|        return JS_UNDEFINED;
42932|     13|    }
42933|       |
42934|  5.46k|    start = idx;
42935|  5.46k|    c = string_getc(p, (int *)&idx);
42936|  5.46k|    it->idx = idx;
42937|  5.46k|    *pdone = FALSE;
42938|  5.46k|    if (c <= 0xffff) {
42939|  5.46k|        return js_new_string_char(ctx, c);
42940|  5.46k|    } else {
42941|      0|        return js_new_string16_len(ctx, p->u.str16 + start, 2);
42942|      0|    }
42943|  5.46k|}
42944|       |
42945|       |/* ES6 Annex B 2.3.2 etc. */
42946|       |enum {
42947|       |    magic_string_anchor,
42948|       |    magic_string_big,
42949|       |    magic_string_blink,
42950|       |    magic_string_bold,
42951|       |    magic_string_fixed,
42952|       |    magic_string_fontcolor,
42953|       |    magic_string_fontsize,
42954|       |    magic_string_italics,
42955|       |    magic_string_link,
42956|       |    magic_string_small,
42957|       |    magic_string_strike,
42958|       |    magic_string_sub,
42959|       |    magic_string_sup,
42960|       |};
42961|       |
42962|       |static JSValue js_string_CreateHTML(JSContext *ctx, JSValueConst this_val,
42963|       |                                    int argc, JSValueConst *argv, int magic)
42964|      0|{
42965|      0|    JSValue str;
42966|      0|    const JSString *p;
42967|      0|    StringBuffer b_s, *b = &b_s;
42968|      0|    static struct { const char *tag, *attr; } const defs[] = {
42969|      0|        { "a", "name" }, { "big", NULL }, { "blink", NULL }, { "b", NULL },
42970|      0|        { "tt", NULL }, { "font", "color" }, { "font", "size" }, { "i", NULL },
42971|      0|        { "a", "href" }, { "small", NULL }, { "strike", NULL },
42972|      0|        { "sub", NULL }, { "sup", NULL },
42973|      0|    };
42974|       |
42975|      0|    str = JS_ToStringCheckObject(ctx, this_val);
42976|      0|    if (JS_IsException(str))
42977|      0|        return JS_EXCEPTION;
42978|      0|    string_buffer_init(ctx, b, 7);
42979|      0|    string_buffer_putc8(b, '<');
42980|      0|    string_buffer_puts8(b, defs[magic].tag);
42981|      0|    if (defs[magic].attr) {
42982|       |        // r += " " + attr + "=\"" + value + "\"";
42983|      0|        JSValue value;
42984|      0|        int i;
42985|       |
42986|      0|        string_buffer_putc8(b, ' ');
42987|      0|        string_buffer_puts8(b, defs[magic].attr);
42988|      0|        string_buffer_puts8(b, "=\"");
42989|      0|        value = JS_ToStringCheckObject(ctx, argv[0]);
42990|      0|        if (JS_IsException(value)) {
42991|      0|            JS_FreeValue(ctx, str);
42992|      0|            string_buffer_free(b);
42993|      0|            return JS_EXCEPTION;
42994|      0|        }
42995|      0|        p = JS_VALUE_GET_STRING(value);
42996|      0|        for (i = 0; i < p->len; i++) {
42997|      0|            int c = string_get(p, i);
42998|      0|            if (c == '"') {
42999|      0|                string_buffer_puts8(b, "&quot;");
43000|      0|            } else {
43001|      0|                string_buffer_putc16(b, c);
43002|      0|            }
43003|      0|        }
43004|      0|        JS_FreeValue(ctx, value);
43005|      0|        string_buffer_putc8(b, '\"');
43006|      0|    }
43007|       |    // return r + ">" + str + "</" + tag + ">";
43008|      0|    string_buffer_putc8(b, '>');
43009|      0|    string_buffer_concat_value_free(b, str);
43010|      0|    string_buffer_puts8(b, "</");
43011|      0|    string_buffer_puts8(b, defs[magic].tag);
43012|      0|    string_buffer_putc8(b, '>');
43013|      0|    return string_buffer_end(b);
43014|      0|}
43015|       |
43016|       |static const JSCFunctionListEntry js_string_funcs[] = {
43017|       |    JS_CFUNC_DEF("fromCharCode", 1, js_string_fromCharCode ),
43018|       |    JS_CFUNC_DEF("fromCodePoint", 1, js_string_fromCodePoint ),
43019|       |    JS_CFUNC_DEF("raw", 1, js_string_raw ),
43020|       |    //JS_CFUNC_DEF("__toString", 1, js_string___toString ),
43021|       |    //JS_CFUNC_DEF("__isSpace", 1, js_string___isSpace ),
43022|       |    //JS_CFUNC_DEF("__toStringCheckObject", 1, js_string___toStringCheckObject ),
43023|       |    //JS_CFUNC_DEF("__advanceStringIndex", 3, js_string___advanceStringIndex ),
43024|       |    //JS_CFUNC_DEF("__GetSubstitution", 6, js_string___GetSubstitution ),
43025|       |};
43026|       |
43027|       |static const JSCFunctionListEntry js_string_proto_funcs[] = {
43028|       |    JS_PROP_INT32_DEF("length", 0, JS_PROP_CONFIGURABLE ),
43029|       |    JS_CFUNC_MAGIC_DEF("at", 1, js_string_charAt, 1 ),
43030|       |    JS_CFUNC_DEF("charCodeAt", 1, js_string_charCodeAt ),
43031|       |    JS_CFUNC_MAGIC_DEF("charAt", 1, js_string_charAt, 0 ),
43032|       |    JS_CFUNC_DEF("concat", 1, js_string_concat ),
43033|       |    JS_CFUNC_DEF("codePointAt", 1, js_string_codePointAt ),
43034|       |    JS_CFUNC_DEF("isWellFormed", 0, js_string_isWellFormed ),
43035|       |    JS_CFUNC_DEF("toWellFormed", 0, js_string_toWellFormed ),
43036|       |    JS_CFUNC_MAGIC_DEF("indexOf", 1, js_string_indexOf, 0 ),
43037|       |    JS_CFUNC_MAGIC_DEF("lastIndexOf", 1, js_string_indexOf, 1 ),
43038|       |    JS_CFUNC_MAGIC_DEF("includes", 1, js_string_includes, 0 ),
43039|       |    JS_CFUNC_MAGIC_DEF("endsWith", 1, js_string_includes, 2 ),
43040|       |    JS_CFUNC_MAGIC_DEF("startsWith", 1, js_string_includes, 1 ),
43041|       |    JS_CFUNC_MAGIC_DEF("match", 1, js_string_match, JS_ATOM_Symbol_match ),
43042|       |    JS_CFUNC_MAGIC_DEF("matchAll", 1, js_string_match, JS_ATOM_Symbol_matchAll ),
43043|       |    JS_CFUNC_MAGIC_DEF("search", 1, js_string_match, JS_ATOM_Symbol_search ),
43044|       |    JS_CFUNC_DEF("split", 2, js_string_split ),
43045|       |    JS_CFUNC_DEF("substring", 2, js_string_substring ),
43046|       |    JS_CFUNC_DEF("substr", 2, js_string_substr ),
43047|       |    JS_CFUNC_DEF("slice", 2, js_string_slice ),
43048|       |    JS_CFUNC_DEF("repeat", 1, js_string_repeat ),
43049|       |    JS_CFUNC_MAGIC_DEF("replace", 2, js_string_replace, 0 ),
43050|       |    JS_CFUNC_MAGIC_DEF("replaceAll", 2, js_string_replace, 1 ),
43051|       |    JS_CFUNC_MAGIC_DEF("padEnd", 1, js_string_pad, 1 ),
43052|       |    JS_CFUNC_MAGIC_DEF("padStart", 1, js_string_pad, 0 ),
43053|       |    JS_CFUNC_MAGIC_DEF("trim", 0, js_string_trim, 3 ),
43054|       |    JS_CFUNC_MAGIC_DEF("trimEnd", 0, js_string_trim, 2 ),
43055|       |    JS_ALIAS_DEF("trimRight", "trimEnd" ),
43056|       |    JS_CFUNC_MAGIC_DEF("trimStart", 0, js_string_trim, 1 ),
43057|       |    JS_ALIAS_DEF("trimLeft", "trimStart" ),
43058|       |    JS_CFUNC_DEF("toString", 0, js_string_toString ),
43059|       |    JS_CFUNC_DEF("valueOf", 0, js_string_toString ),
43060|       |    JS_CFUNC_DEF("__quote", 1, js_string___quote ),
43061|       |    JS_CFUNC_MAGIC_DEF("toLowerCase", 0, js_string_toLowerCase, 1 ),
43062|       |    JS_CFUNC_MAGIC_DEF("toUpperCase", 0, js_string_toLowerCase, 0 ),
43063|       |    JS_CFUNC_MAGIC_DEF("toLocaleLowerCase", 0, js_string_toLowerCase, 1 ),
43064|       |    JS_CFUNC_MAGIC_DEF("toLocaleUpperCase", 0, js_string_toLowerCase, 0 ),
43065|       |    JS_CFUNC_MAGIC_DEF("[Symbol.iterator]", 0, js_create_array_iterator, JS_ITERATOR_KIND_VALUE | 4 ),
43066|       |    /* ES6 Annex B 2.3.2 etc. */
43067|       |    JS_CFUNC_MAGIC_DEF("anchor", 1, js_string_CreateHTML, magic_string_anchor ),
43068|       |    JS_CFUNC_MAGIC_DEF("big", 0, js_string_CreateHTML, magic_string_big ),
43069|       |    JS_CFUNC_MAGIC_DEF("blink", 0, js_string_CreateHTML, magic_string_blink ),
43070|       |    JS_CFUNC_MAGIC_DEF("bold", 0, js_string_CreateHTML, magic_string_bold ),
43071|       |    JS_CFUNC_MAGIC_DEF("fixed", 0, js_string_CreateHTML, magic_string_fixed ),
43072|       |    JS_CFUNC_MAGIC_DEF("fontcolor", 1, js_string_CreateHTML, magic_string_fontcolor ),
43073|       |    JS_CFUNC_MAGIC_DEF("fontsize", 1, js_string_CreateHTML, magic_string_fontsize ),
43074|       |    JS_CFUNC_MAGIC_DEF("italics", 0, js_string_CreateHTML, magic_string_italics ),
43075|       |    JS_CFUNC_MAGIC_DEF("link", 1, js_string_CreateHTML, magic_string_link ),
43076|       |    JS_CFUNC_MAGIC_DEF("small", 0, js_string_CreateHTML, magic_string_small ),
43077|       |    JS_CFUNC_MAGIC_DEF("strike", 0, js_string_CreateHTML, magic_string_strike ),
43078|       |    JS_CFUNC_MAGIC_DEF("sub", 0, js_string_CreateHTML, magic_string_sub ),
43079|       |    JS_CFUNC_MAGIC_DEF("sup", 0, js_string_CreateHTML, magic_string_sup ),
43080|       |};
43081|       |
43082|       |static const JSCFunctionListEntry js_string_iterator_proto_funcs[] = {
43083|       |    JS_ITERATOR_NEXT_DEF("next", 0, js_string_iterator_next, 0 ),
43084|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "String Iterator", JS_PROP_CONFIGURABLE ),
43085|       |};
43086|       |
43087|       |static const JSCFunctionListEntry js_string_proto_normalize[] = {
43088|       |#ifdef CONFIG_ALL_UNICODE
43089|       |    JS_CFUNC_DEF("normalize", 0, js_string_normalize ),
43090|       |#endif
43091|       |    JS_CFUNC_DEF("localeCompare", 1, js_string_localeCompare ),
43092|       |};
43093|       |
43094|       |void JS_AddIntrinsicStringNormalize(JSContext *ctx)
43095|  17.7k|{
43096|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING], js_string_proto_normalize,
43097|  17.7k|                               countof(js_string_proto_normalize));
43098|  17.7k|}
43099|       |
43100|       |/* Math */
43101|       |
43102|       |/* precondition: a and b are not NaN */
43103|       |static double js_fmin(double a, double b)
43104|      0|{
43105|      0|    if (a == 0 && b == 0) {
43106|      0|        JSFloat64Union a1, b1;
43107|      0|        a1.d = a;
43108|      0|        b1.d = b;
43109|      0|        a1.u64 |= b1.u64;
43110|      0|        return a1.d;
43111|      0|    } else {
43112|      0|        return fmin(a, b);
43113|      0|    }
43114|      0|}
43115|       |
43116|       |/* precondition: a and b are not NaN */
43117|       |static double js_fmax(double a, double b)
43118|      0|{
43119|      0|    if (a == 0 && b == 0) {
43120|      0|        JSFloat64Union a1, b1;
43121|      0|        a1.d = a;
43122|      0|        b1.d = b;
43123|      0|        a1.u64 &= b1.u64;
43124|      0|        return a1.d;
43125|      0|    } else {
43126|      0|        return fmax(a, b);
43127|      0|    }
43128|      0|}
43129|       |
43130|       |static JSValue js_math_min_max(JSContext *ctx, JSValueConst this_val,
43131|       |                               int argc, JSValueConst *argv, int magic)
43132|      0|{
43133|      0|    BOOL is_max = magic;
43134|      0|    double r, a;
43135|      0|    int i;
43136|      0|    uint32_t tag;
43137|       |
43138|      0|    if (unlikely(argc == 0)) {
43139|      0|        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
43140|      0|    }
43141|       |
43142|      0|    tag = JS_VALUE_GET_TAG(argv[0]);
43143|      0|    if (tag == JS_TAG_INT) {
43144|      0|        int a1, r1 = JS_VALUE_GET_INT(argv[0]);
43145|      0|        for(i = 1; i < argc; i++) {
43146|      0|            tag = JS_VALUE_GET_TAG(argv[i]);
43147|      0|            if (tag != JS_TAG_INT) {
43148|      0|                r = r1;
43149|      0|                goto generic_case;
43150|      0|            }
43151|      0|            a1 = JS_VALUE_GET_INT(argv[i]);
43152|      0|            if (is_max)
43153|      0|                r1 = max_int(r1, a1);
43154|      0|            else
43155|      0|                r1 = min_int(r1, a1);
43156|       |
43157|      0|        }
43158|      0|        return JS_NewInt32(ctx, r1);
43159|      0|    } else {
43160|      0|        if (JS_ToFloat64(ctx, &r, argv[0]))
43161|      0|            return JS_EXCEPTION;
43162|      0|        i = 1;
43163|      0|    generic_case:
43164|      0|        while (i < argc) {
43165|      0|            if (JS_ToFloat64(ctx, &a, argv[i]))
43166|      0|                return JS_EXCEPTION;
43167|      0|            if (!isnan(r)) {
43168|      0|                if (isnan(a)) {
43169|      0|                    r = a;
43170|      0|                } else {
43171|      0|                    if (is_max)
43172|      0|                        r = js_fmax(r, a);
43173|      0|                    else
43174|      0|                        r = js_fmin(r, a);
43175|      0|                }
43176|      0|            }
43177|      0|            i++;
43178|      0|        }
43179|      0|        return JS_NewFloat64(ctx, r);
43180|      0|    }
43181|      0|}
43182|       |
43183|       |static double js_math_sign(double a)
43184|      0|{
43185|      0|    if (isnan(a) || a == 0.0)
43186|      0|        return a;
43187|      0|    if (a < 0)
43188|      0|        return -1;
43189|      0|    else
43190|      0|        return 1;
43191|      0|}
43192|       |
43193|       |static double js_math_round(double a)
43194|      0|{
43195|      0|    JSFloat64Union u;
43196|      0|    uint64_t frac_mask, one;
43197|      0|    unsigned int e, s;
43198|       |
43199|      0|    u.d = a;
43200|      0|    e = (u.u64 >> 52) & 0x7ff;
43201|      0|    if (e < 1023) {
43202|       |        /* abs(a) < 1 */
43203|      0|        if (e == (1023 - 1) && u.u64 != 0xbfe0000000000000) {
43204|       |            /* abs(a) > 0.5 or a = 0.5: return +/-1.0 */
43205|      0|            u.u64 = (u.u64 & ((uint64_t)1 << 63)) | ((uint64_t)1023 << 52);
43206|      0|        } else {
43207|       |            /* return +/-0.0 */
43208|      0|            u.u64 &= (uint64_t)1 << 63;
43209|      0|        }
43210|      0|    } else if (e < (1023 + 52)) {
43211|      0|        s = u.u64 >> 63;
43212|      0|        one = (uint64_t)1 << (52 - (e - 1023));
43213|      0|        frac_mask = one - 1;
43214|      0|        u.u64 += (one >> 1) - s;
43215|      0|        u.u64 &= ~frac_mask; /* truncate to an integer */
43216|      0|    }
43217|       |    /* otherwise: abs(a) >= 2^52, or NaN, +/-Infinity: no change */
43218|      0|    return u.d;
43219|      0|}
43220|       |
43221|       |static JSValue js_math_hypot(JSContext *ctx, JSValueConst this_val,
43222|       |                             int argc, JSValueConst *argv)
43223|      0|{
43224|      0|    double r, a;
43225|      0|    int i;
43226|       |
43227|      0|    r = 0;
43228|      0|    if (argc > 0) {
43229|      0|        if (JS_ToFloat64(ctx, &r, argv[0]))
43230|      0|            return JS_EXCEPTION;
43231|      0|        if (argc == 1) {
43232|      0|            r = fabs(r);
43233|      0|        } else {
43234|       |            /* use the built-in function to minimize precision loss */
43235|      0|            for (i = 1; i < argc; i++) {
43236|      0|                if (JS_ToFloat64(ctx, &a, argv[i]))
43237|      0|                    return JS_EXCEPTION;
43238|      0|                r = hypot(r, a);
43239|      0|            }
43240|      0|        }
43241|      0|    }
43242|      0|    return JS_NewFloat64(ctx, r);
43243|      0|}
43244|       |
43245|       |static double js_math_fround(double a)
43246|      0|{
43247|      0|    return (float)a;
43248|      0|}
43249|       |
43250|       |static JSValue js_math_imul(JSContext *ctx, JSValueConst this_val,
43251|       |                            int argc, JSValueConst *argv)
43252|      0|{
43253|      0|    uint32_t a, b, c;
43254|      0|    int32_t d;
43255|       |
43256|      0|    if (JS_ToUint32(ctx, &a, argv[0]))
43257|      0|        return JS_EXCEPTION;
43258|      0|    if (JS_ToUint32(ctx, &b, argv[1]))
43259|      0|        return JS_EXCEPTION;
43260|      0|    c = a * b;
43261|      0|    memcpy(&d, &c, sizeof(d));
43262|      0|    return JS_NewInt32(ctx, d);
43263|      0|}
43264|       |
43265|       |static JSValue js_math_clz32(JSContext *ctx, JSValueConst this_val,
43266|       |                             int argc, JSValueConst *argv)
43267|      0|{
43268|      0|    uint32_t a, r;
43269|       |
43270|      0|    if (JS_ToUint32(ctx, &a, argv[0]))
43271|      0|        return JS_EXCEPTION;
43272|      0|    if (a == 0)
43273|      0|        r = 32;
43274|      0|    else
43275|      0|        r = clz32(a);
43276|      0|    return JS_NewInt32(ctx, r);
43277|      0|}
43278|       |
43279|       |/* xorshift* random number generator by Marsaglia */
43280|       |static uint64_t xorshift64star(uint64_t *pstate)
43281|      0|{
43282|      0|    uint64_t x;
43283|      0|    x = *pstate;
43284|      0|    x ^= x >> 12;
43285|      0|    x ^= x << 25;
43286|      0|    x ^= x >> 27;
43287|      0|    *pstate = x;
43288|      0|    return x * 0x2545F4914F6CDD1D;
43289|      0|}
43290|       |
43291|       |static void js_random_init(JSContext *ctx)
43292|  17.7k|{
43293|  17.7k|    struct timeval tv;
43294|  17.7k|    gettimeofday(&tv, NULL);
43295|  17.7k|    ctx->random_state = ((int64_t)tv.tv_sec * 1000000) + tv.tv_usec;
43296|       |    /* the state must be non zero */
43297|  17.7k|    if (ctx->random_state == 0)
43298|      0|        ctx->random_state = 1;
43299|  17.7k|}
43300|       |
43301|       |static JSValue js_math_random(JSContext *ctx, JSValueConst this_val,
43302|       |                              int argc, JSValueConst *argv)
43303|      0|{
43304|      0|    JSFloat64Union u;
43305|      0|    uint64_t v;
43306|       |
43307|      0|    v = xorshift64star(&ctx->random_state);
43308|       |    /* 1.0 <= u.d < 2 */
43309|      0|    u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);
43310|      0|    return __JS_NewFloat64(ctx, u.d - 1.0);
43311|      0|}
43312|       |
43313|       |static const JSCFunctionListEntry js_math_funcs[] = {
43314|       |    JS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0 ),
43315|       |    JS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1 ),
43316|       |    JS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs ),
43317|       |    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor ),
43318|       |    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil ),
43319|       |    JS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round ),
43320|       |    JS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt ),
43321|       |
43322|       |    JS_CFUNC_SPECIAL_DEF("acos", 1, f_f, acos ),
43323|       |    JS_CFUNC_SPECIAL_DEF("asin", 1, f_f, asin ),
43324|       |    JS_CFUNC_SPECIAL_DEF("atan", 1, f_f, atan ),
43325|       |    JS_CFUNC_SPECIAL_DEF("atan2", 2, f_f_f, atan2 ),
43326|       |    JS_CFUNC_SPECIAL_DEF("cos", 1, f_f, cos ),
43327|       |    JS_CFUNC_SPECIAL_DEF("exp", 1, f_f, exp ),
43328|       |    JS_CFUNC_SPECIAL_DEF("log", 1, f_f, log ),
43329|       |    JS_CFUNC_SPECIAL_DEF("pow", 2, f_f_f, js_pow ),
43330|       |    JS_CFUNC_SPECIAL_DEF("sin", 1, f_f, sin ),
43331|       |    JS_CFUNC_SPECIAL_DEF("tan", 1, f_f, tan ),
43332|       |    /* ES6 */
43333|       |    JS_CFUNC_SPECIAL_DEF("trunc", 1, f_f, trunc ),
43334|       |    JS_CFUNC_SPECIAL_DEF("sign", 1, f_f, js_math_sign ),
43335|       |    JS_CFUNC_SPECIAL_DEF("cosh", 1, f_f, cosh ),
43336|       |    JS_CFUNC_SPECIAL_DEF("sinh", 1, f_f, sinh ),
43337|       |    JS_CFUNC_SPECIAL_DEF("tanh", 1, f_f, tanh ),
43338|       |    JS_CFUNC_SPECIAL_DEF("acosh", 1, f_f, acosh ),
43339|       |    JS_CFUNC_SPECIAL_DEF("asinh", 1, f_f, asinh ),
43340|       |    JS_CFUNC_SPECIAL_DEF("atanh", 1, f_f, atanh ),
43341|       |    JS_CFUNC_SPECIAL_DEF("expm1", 1, f_f, expm1 ),
43342|       |    JS_CFUNC_SPECIAL_DEF("log1p", 1, f_f, log1p ),
43343|       |    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, log2 ),
43344|       |    JS_CFUNC_SPECIAL_DEF("log10", 1, f_f, log10 ),
43345|       |    JS_CFUNC_SPECIAL_DEF("cbrt", 1, f_f, cbrt ),
43346|       |    JS_CFUNC_DEF("hypot", 2, js_math_hypot ),
43347|       |    JS_CFUNC_DEF("random", 0, js_math_random ),
43348|       |    JS_CFUNC_SPECIAL_DEF("fround", 1, f_f, js_math_fround ),
43349|       |    JS_CFUNC_DEF("imul", 2, js_math_imul ),
43350|       |    JS_CFUNC_DEF("clz32", 1, js_math_clz32 ),
43351|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Math", JS_PROP_CONFIGURABLE ),
43352|       |    JS_PROP_DOUBLE_DEF("E", 2.718281828459045, 0 ),
43353|       |    JS_PROP_DOUBLE_DEF("LN10", 2.302585092994046, 0 ),
43354|       |    JS_PROP_DOUBLE_DEF("LN2", 0.6931471805599453, 0 ),
43355|       |    JS_PROP_DOUBLE_DEF("LOG2E", 1.4426950408889634, 0 ),
43356|       |    JS_PROP_DOUBLE_DEF("LOG10E", 0.4342944819032518, 0 ),
43357|       |    JS_PROP_DOUBLE_DEF("PI", 3.141592653589793, 0 ),
43358|       |    JS_PROP_DOUBLE_DEF("SQRT1_2", 0.7071067811865476, 0 ),
43359|       |    JS_PROP_DOUBLE_DEF("SQRT2", 1.4142135623730951, 0 ),
43360|       |};
43361|       |
43362|       |static const JSCFunctionListEntry js_math_obj[] = {
43363|       |    JS_OBJECT_DEF("Math", js_math_funcs, countof(js_math_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
43364|       |};
43365|       |
43366|       |/* Date */
43367|       |
43368|       |/* OS dependent. d = argv[0] is in ms from 1970. Return the difference
43369|       |   between UTC time and local time 'd' in minutes */
43370|       |static int getTimezoneOffset(int64_t time)
43371|      0|{
43372|      0|    time_t ti;
43373|      0|    int res;
43374|       |
43375|      0|    time /= 1000; /* convert to seconds */
43376|      0|    if (sizeof(time_t) == 4) {
43377|       |        /* on 32-bit systems, we need to clamp the time value to the
43378|       |           range of `time_t`. This is better than truncating values to
43379|       |           32 bits and hopefully provides the same result as 64-bit
43380|       |           implementation of localtime_r.
43381|       |         */
43382|      0|        if ((time_t)-1 < 0) {
43383|      0|            if (time < INT32_MIN) {
43384|      0|                time = INT32_MIN;
43385|      0|            } else if (time > INT32_MAX) {
43386|      0|                time = INT32_MAX;
43387|      0|            }
43388|      0|        } else {
43389|      0|            if (time < 0) {
43390|      0|                time = 0;
43391|      0|            } else if (time > UINT32_MAX) {
43392|      0|                time = UINT32_MAX;
43393|      0|            }
43394|      0|        }
43395|      0|    }
43396|      0|    ti = time;
43397|       |#if defined(_WIN32)
43398|       |    {
43399|       |        struct tm *tm;
43400|       |        time_t gm_ti, loc_ti;
43401|       |
43402|       |        tm = gmtime(&ti);
43403|       |        gm_ti = mktime(tm);
43404|       |
43405|       |        tm = localtime(&ti);
43406|       |        loc_ti = mktime(tm);
43407|       |
43408|       |        res = (gm_ti - loc_ti) / 60;
43409|       |    }
43410|       |#else
43411|      0|    {
43412|      0|        struct tm tm;
43413|      0|        localtime_r(&ti, &tm);
43414|      0|        res = -tm.tm_gmtoff / 60;
43415|      0|    }
43416|      0|#endif
43417|      0|    return res;
43418|      0|}
43419|       |
43420|       |#if 0
43421|       |static JSValue js___date_getTimezoneOffset(JSContext *ctx, JSValueConst this_val,
43422|       |                                           int argc, JSValueConst *argv)
43423|       |{
43424|       |    double dd;
43425|       |
43426|       |    if (JS_ToFloat64(ctx, &dd, argv[0]))
43427|       |        return JS_EXCEPTION;
43428|       |    if (isnan(dd))
43429|       |        return __JS_NewFloat64(ctx, dd);
43430|       |    else
43431|       |        return JS_NewInt32(ctx, getTimezoneOffset((int64_t)dd));
43432|       |}
43433|       |
43434|       |static JSValue js_get_prototype_from_ctor(JSContext *ctx, JSValueConst ctor,
43435|       |                                          JSValueConst def_proto)
43436|       |{
43437|       |    JSValue proto;
43438|       |    proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype);
43439|       |    if (JS_IsException(proto))
43440|       |        return proto;
43441|       |    if (!JS_IsObject(proto)) {
43442|       |        JS_FreeValue(ctx, proto);
43443|       |        proto = JS_DupValue(ctx, def_proto);
43444|       |    }
43445|       |    return proto;
43446|       |}
43447|       |
43448|       |/* create a new date object */
43449|       |static JSValue js___date_create(JSContext *ctx, JSValueConst this_val,
43450|       |                                int argc, JSValueConst *argv)
43451|       |{
43452|       |    JSValue obj, proto;
43453|       |    proto = js_get_prototype_from_ctor(ctx, argv[0], argv[1]);
43454|       |    if (JS_IsException(proto))
43455|       |        return proto;
43456|       |    obj = JS_NewObjectProtoClass(ctx, proto, JS_CLASS_DATE);
43457|       |    JS_FreeValue(ctx, proto);
43458|       |    if (!JS_IsException(obj))
43459|       |        JS_SetObjectData(ctx, obj, JS_DupValue(ctx, argv[2]));
43460|       |    return obj;
43461|       |}
43462|       |#endif
43463|       |
43464|       |/* RegExp */
43465|       |
43466|       |static void js_regexp_finalizer(JSRuntime *rt, JSValue val)
43467|   849k|{
43468|   849k|    JSObject *p = JS_VALUE_GET_OBJ(val);
43469|   849k|    JSRegExp *re = &p->u.regexp;
43470|   849k|    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_STRING, re->bytecode));
43471|   849k|    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_STRING, re->pattern));
43472|   849k|}
43473|       |
43474|       |/* create a string containing the RegExp bytecode */
43475|       |static JSValue js_compile_regexp(JSContext *ctx, JSValueConst pattern,
43476|       |                                 JSValueConst flags)
43477|  39.3k|{
43478|  39.3k|    const char *str;
43479|  39.3k|    int re_flags, mask;
43480|  39.3k|    uint8_t *re_bytecode_buf;
43481|  39.3k|    size_t i, len;
43482|  39.3k|    int re_bytecode_len;
43483|  39.3k|    JSValue ret;
43484|  39.3k|    char error_msg[64];
43485|       |
43486|  39.3k|    re_flags = 0;
43487|  39.3k|    if (!JS_IsUndefined(flags)) {
43488|  39.3k|        str = JS_ToCStringLen(ctx, &len, flags);
43489|  39.3k|        if (!str)
43490|      0|            return JS_EXCEPTION;
43491|       |        /* XXX: re_flags = LRE_FLAG_OCTAL unless strict mode? */
43492|  42.8k|        for (i = 0; i < len; i++) {
43493|  3.65k|            switch(str[i]) {
43494|     35|            case 'd':
43495|     35|                mask = LRE_FLAG_INDICES;
43496|     35|                break;
43497|  1.81k|            case 'g':
43498|  1.81k|                mask = LRE_FLAG_GLOBAL;
43499|  1.81k|                break;
43500|    671|            case 'i':
43501|    671|                mask = LRE_FLAG_IGNORECASE;
43502|    671|                break;
43503|    264|            case 'm':
43504|    264|                mask = LRE_FLAG_MULTILINE;
43505|    264|                break;
43506|    454|            case 's':
43507|    454|                mask = LRE_FLAG_DOTALL;
43508|    454|                break;
43509|    304|            case 'u':
43510|    304|                mask = LRE_FLAG_UNICODE;
43511|    304|                break;
43512|     37|            case 'y':
43513|     37|                mask = LRE_FLAG_STICKY;
43514|     37|                break;
43515|     75|            default:
43516|     75|                goto bad_flags;
43517|  3.65k|            }
43518|  3.57k|            if ((re_flags & mask) != 0) {
43519|     90|            bad_flags:
43520|     90|                JS_FreeCString(ctx, str);
43521|     90|                return JS_ThrowSyntaxError(ctx, "invalid regular expression flags");
43522|     15|            }
43523|  3.56k|            re_flags |= mask;
43524|  3.56k|        }
43525|  39.2k|        JS_FreeCString(ctx, str);
43526|  39.2k|    }
43527|       |
43528|  39.2k|    str = JS_ToCStringLen2(ctx, &len, pattern, !(re_flags & LRE_FLAG_UNICODE));
43529|  39.2k|    if (!str)
43530|      0|        return JS_EXCEPTION;
43531|  39.2k|    re_bytecode_buf = lre_compile(&re_bytecode_len, error_msg,
43532|  39.2k|                                  sizeof(error_msg), str, len, re_flags, ctx);
43533|  39.2k|    JS_FreeCString(ctx, str);
43534|  39.2k|    if (!re_bytecode_buf) {
43535|  1.05k|        JS_ThrowSyntaxError(ctx, "%s", error_msg);
43536|  1.05k|        return JS_EXCEPTION;
43537|  1.05k|    }
43538|       |
43539|  38.1k|    ret = js_new_string8_len(ctx, (const char *)re_bytecode_buf, re_bytecode_len);
43540|  38.1k|    js_free(ctx, re_bytecode_buf);
43541|  38.1k|    return ret;
43542|  39.2k|}
43543|       |
43544|       |/* create a RegExp object from a string containing the RegExp bytecode
43545|       |   and the source pattern */
43546|       |static JSValue js_regexp_constructor_internal(JSContext *ctx, JSValueConst ctor,
43547|       |                                              JSValue pattern, JSValue bc)
43548|   849k|{
43549|   849k|    JSValue obj;
43550|   849k|    JSObject *p;
43551|   849k|    JSRegExp *re;
43552|       |
43553|       |    /* sanity check */
43554|   849k|    if (JS_VALUE_GET_TAG(bc) != JS_TAG_STRING ||
43555|   849k|        JS_VALUE_GET_TAG(pattern) != JS_TAG_STRING) {
43556|      0|        JS_ThrowTypeError(ctx, "string expected");
43557|      0|    fail:
43558|      0|        JS_FreeValue(ctx, bc);
43559|      0|        JS_FreeValue(ctx, pattern);
43560|      0|        return JS_EXCEPTION;
43561|      0|    }
43562|       |
43563|   849k|    obj = js_create_from_ctor(ctx, ctor, JS_CLASS_REGEXP);
43564|   849k|    if (JS_IsException(obj))
43565|      0|        goto fail;
43566|   849k|    p = JS_VALUE_GET_OBJ(obj);
43567|   849k|    re = &p->u.regexp;
43568|   849k|    re->pattern = JS_VALUE_GET_STRING(pattern);
43569|   849k|    re->bytecode = JS_VALUE_GET_STRING(bc);
43570|   849k|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0),
43571|   849k|                           JS_PROP_WRITABLE);
43572|   849k|    return obj;
43573|   849k|}
43574|       |
43575|       |static JSRegExp *js_get_regexp(JSContext *ctx, JSValueConst obj, BOOL throw_error)
43576|  6.24M|{
43577|  6.24M|    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
43578|  6.24M|        JSObject *p = JS_VALUE_GET_OBJ(obj);
43579|  6.24M|        if (p->class_id == JS_CLASS_REGEXP)
43580|  6.24M|            return &p->u.regexp;
43581|  6.24M|    }
43582|      0|    if (throw_error) {
43583|      0|        JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);
43584|      0|    }
43585|      0|    return NULL;
43586|  6.24M|}
43587|       |
43588|       |/* return < 0 if exception or TRUE/FALSE */
43589|       |static int js_is_regexp(JSContext *ctx, JSValueConst obj)
43590|      0|{
43591|      0|    JSValue m;
43592|       |
43593|      0|    if (!JS_IsObject(obj))
43594|      0|        return FALSE;
43595|      0|    m = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_match);
43596|      0|    if (JS_IsException(m))
43597|      0|        return -1;
43598|      0|    if (!JS_IsUndefined(m))
43599|      0|        return JS_ToBoolFree(ctx, m);
43600|      0|    return js_get_regexp(ctx, obj, FALSE) != NULL;
43601|      0|}
43602|       |
43603|       |static JSValue js_regexp_constructor(JSContext *ctx, JSValueConst new_target,
43604|       |                                     int argc, JSValueConst *argv)
43605|      0|{
43606|      0|    JSValue pattern, flags, bc, val;
43607|      0|    JSValueConst pat, flags1;
43608|      0|    JSRegExp *re;
43609|      0|    int pat_is_regexp;
43610|       |
43611|      0|    pat = argv[0];
43612|      0|    flags1 = argv[1];
43613|      0|    pat_is_regexp = js_is_regexp(ctx, pat);
43614|      0|    if (pat_is_regexp < 0)
43615|      0|        return JS_EXCEPTION;
43616|      0|    if (JS_IsUndefined(new_target)) {
43617|       |        /* called as a function */
43618|      0|        new_target = JS_GetActiveFunction(ctx);
43619|      0|        if (pat_is_regexp && JS_IsUndefined(flags1)) {
43620|      0|            JSValue ctor;
43621|      0|            BOOL res;
43622|      0|            ctor = JS_GetProperty(ctx, pat, JS_ATOM_constructor);
43623|      0|            if (JS_IsException(ctor))
43624|      0|                return ctor;
43625|      0|            res = js_same_value(ctx, ctor, new_target);
43626|      0|            JS_FreeValue(ctx, ctor);
43627|      0|            if (res)
43628|      0|                return JS_DupValue(ctx, pat);
43629|      0|        }
43630|      0|    }
43631|      0|    re = js_get_regexp(ctx, pat, FALSE);
43632|      0|    if (re) {
43633|      0|        pattern = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re->pattern));
43634|      0|        if (JS_IsUndefined(flags1)) {
43635|      0|            bc = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re->bytecode));
43636|      0|            goto no_compilation;
43637|      0|        } else {
43638|      0|            flags = JS_ToString(ctx, flags1);
43639|      0|            if (JS_IsException(flags))
43640|      0|                goto fail;
43641|      0|        }
43642|      0|    } else {
43643|      0|        flags = JS_UNDEFINED;
43644|      0|        if (pat_is_regexp) {
43645|      0|            pattern = JS_GetProperty(ctx, pat, JS_ATOM_source);
43646|      0|            if (JS_IsException(pattern))
43647|      0|                goto fail;
43648|      0|            if (JS_IsUndefined(flags1)) {
43649|      0|                flags = JS_GetProperty(ctx, pat, JS_ATOM_flags);
43650|      0|                if (JS_IsException(flags))
43651|      0|                    goto fail;
43652|      0|            } else {
43653|      0|                flags = JS_DupValue(ctx, flags1);
43654|      0|            }
43655|      0|        } else {
43656|      0|            pattern = JS_DupValue(ctx, pat);
43657|      0|            flags = JS_DupValue(ctx, flags1);
43658|      0|        }
43659|      0|        if (JS_IsUndefined(pattern)) {
43660|      0|            pattern = JS_AtomToString(ctx, JS_ATOM_empty_string);
43661|      0|        } else {
43662|      0|            val = pattern;
43663|      0|            pattern = JS_ToString(ctx, val);
43664|      0|            JS_FreeValue(ctx, val);
43665|      0|            if (JS_IsException(pattern))
43666|      0|                goto fail;
43667|      0|        }
43668|      0|    }
43669|      0|    bc = js_compile_regexp(ctx, pattern, flags);
43670|      0|    if (JS_IsException(bc))
43671|      0|        goto fail;
43672|      0|    JS_FreeValue(ctx, flags);
43673|      0| no_compilation:
43674|      0|    return js_regexp_constructor_internal(ctx, new_target, pattern, bc);
43675|      0| fail:
43676|      0|    JS_FreeValue(ctx, pattern);
43677|      0|    JS_FreeValue(ctx, flags);
43678|      0|    return JS_EXCEPTION;
43679|      0|}
43680|       |
43681|       |static JSValue js_regexp_compile(JSContext *ctx, JSValueConst this_val,
43682|       |                                 int argc, JSValueConst *argv)
43683|      0|{
43684|      0|    JSRegExp *re1, *re;
43685|      0|    JSValueConst pattern1, flags1;
43686|      0|    JSValue bc, pattern;
43687|       |
43688|      0|    re = js_get_regexp(ctx, this_val, TRUE);
43689|      0|    if (!re)
43690|      0|        return JS_EXCEPTION;
43691|      0|    pattern1 = argv[0];
43692|      0|    flags1 = argv[1];
43693|      0|    re1 = js_get_regexp(ctx, pattern1, FALSE);
43694|      0|    if (re1) {
43695|      0|        if (!JS_IsUndefined(flags1))
43696|      0|            return JS_ThrowTypeError(ctx, "flags must be undefined");
43697|      0|        pattern = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re1->pattern));
43698|      0|        bc = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re1->bytecode));
43699|      0|    } else {
43700|      0|        bc = JS_UNDEFINED;
43701|      0|        if (JS_IsUndefined(pattern1))
43702|      0|            pattern = JS_AtomToString(ctx, JS_ATOM_empty_string);
43703|      0|        else
43704|      0|            pattern = JS_ToString(ctx, pattern1);
43705|      0|        if (JS_IsException(pattern))
43706|      0|            goto fail;
43707|      0|        bc = js_compile_regexp(ctx, pattern, flags1);
43708|      0|        if (JS_IsException(bc))
43709|      0|            goto fail;
43710|      0|    }
43711|      0|    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, re->pattern));
43712|      0|    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, re->bytecode));
43713|      0|    re->pattern = JS_VALUE_GET_STRING(pattern);
43714|      0|    re->bytecode = JS_VALUE_GET_STRING(bc);
43715|      0|    if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,
43716|      0|                       JS_NewInt32(ctx, 0)) < 0)
43717|      0|        return JS_EXCEPTION;
43718|      0|    return JS_DupValue(ctx, this_val);
43719|      0| fail:
43720|      0|    JS_FreeValue(ctx, pattern);
43721|      0|    JS_FreeValue(ctx, bc);
43722|      0|    return JS_EXCEPTION;
43723|      0|}
43724|       |
43725|       |#if 0
43726|       |static JSValue js_regexp_get___source(JSContext *ctx, JSValueConst this_val)
43727|       |{
43728|       |    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
43729|       |    if (!re)
43730|       |        return JS_EXCEPTION;
43731|       |    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re->pattern));
43732|       |}
43733|       |
43734|       |static JSValue js_regexp_get___flags(JSContext *ctx, JSValueConst this_val)
43735|       |{
43736|       |    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
43737|       |    int flags;
43738|       |
43739|       |    if (!re)
43740|       |        return JS_EXCEPTION;
43741|       |    flags = lre_get_flags(re->bytecode->u.str8);
43742|       |    return JS_NewInt32(ctx, flags);
43743|       |}
43744|       |#endif
43745|       |
43746|       |static JSValue js_regexp_get_source(JSContext *ctx, JSValueConst this_val)
43747|   780k|{
43748|   780k|    JSRegExp *re;
43749|   780k|    JSString *p;
43750|   780k|    StringBuffer b_s, *b = &b_s;
43751|   780k|    int i, n, c, c2, bra;
43752|       |
43753|   780k|    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
43754|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
43755|       |
43756|   780k|    if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))
43757|      0|        goto empty_regex;
43758|       |
43759|   780k|    re = js_get_regexp(ctx, this_val, TRUE);
43760|   780k|    if (!re)
43761|      0|        return JS_EXCEPTION;
43762|       |
43763|   780k|    p = re->pattern;
43764|       |
43765|   780k|    if (p->len == 0) {
43766|      0|    empty_regex:
43767|      0|        return js_new_string8(ctx, "(?:)");
43768|      0|    }
43769|   780k|    string_buffer_init2(ctx, b, p->len, p->is_wide_char);
43770|       |
43771|       |    /* Escape '/' and newline sequences as needed */
43772|   780k|    bra = 0;
43773|  16.4M|    for (i = 0, n = p->len; i < n;) {
43774|  15.6M|        c2 = -1;
43775|  15.6M|        switch (c = string_get(p, i++)) {
43776|  14.5k|        case '\\':
43777|  14.5k|            if (i < n)
43778|  14.5k|                c2 = string_get(p, i++);
43779|  14.5k|            break;
43780|  47.5k|        case ']':
43781|  47.5k|            bra = 0;
43782|  47.5k|            break;
43783|  41.3k|        case '[':
43784|  41.3k|            if (!bra) {
43785|  27.8k|                if (i < n && string_get(p, i) == ']')
43786|    926|                    c2 = string_get(p, i++);
43787|  27.8k|                bra = 1;
43788|  27.8k|            }
43789|  41.3k|            break;
43790|      0|        case '\n':
43791|      0|            c = '\\';
43792|      0|            c2 = 'n';
43793|      0|            break;
43794|      0|        case '\r':
43795|      0|            c = '\\';
43796|      0|            c2 = 'r';
43797|      0|            break;
43798|  10.8k|        case '/':
43799|  10.8k|            if (!bra) {
43800|      0|                c = '\\';
43801|      0|                c2 = '/';
43802|      0|            }
43803|  10.8k|            break;
43804|  15.6M|        }
43805|  15.6M|        string_buffer_putc16(b, c);
43806|  15.6M|        if (c2 >= 0)
43807|  15.4k|            string_buffer_putc16(b, c2);
43808|  15.6M|    }
43809|   780k|    return string_buffer_end(b);
43810|   780k|}
43811|       |
43812|       |static JSValue js_regexp_get_flag(JSContext *ctx, JSValueConst this_val, int mask)
43813|  5.46M|{
43814|  5.46M|    JSRegExp *re;
43815|  5.46M|    int flags;
43816|       |
43817|  5.46M|    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
43818|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
43819|       |
43820|  5.46M|    re = js_get_regexp(ctx, this_val, FALSE);
43821|  5.46M|    if (!re) {
43822|      0|        if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))
43823|      0|            return JS_UNDEFINED;
43824|      0|        else
43825|      0|            return JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);
43826|      0|    }
43827|       |
43828|  5.46M|    flags = lre_get_flags(re->bytecode->u.str8);
43829|  5.46M|    return JS_NewBool(ctx, flags & mask);
43830|  5.46M|}
43831|       |
43832|       |static JSValue js_regexp_get_flags(JSContext *ctx, JSValueConst this_val)
43833|   780k|{
43834|   780k|    char str[8], *p = str;
43835|   780k|    int res;
43836|       |
43837|   780k|    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
43838|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
43839|       |
43840|   780k|    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, "hasIndices"));
43841|   780k|    if (res < 0)
43842|      8|        goto exception;
43843|   780k|    if (res)
43844|  1.24k|        *p++ = 'd';
43845|   780k|    res = JS_ToBoolFree(ctx, JS_GetProperty(ctx, this_val, JS_ATOM_global));
43846|   780k|    if (res < 0)
43847|      0|        goto exception;
43848|   780k|    if (res)
43849|  7.55k|        *p++ = 'g';
43850|   780k|    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, "ignoreCase"));
43851|   780k|    if (res < 0)
43852|      0|        goto exception;
43853|   780k|    if (res)
43854|  2.65k|        *p++ = 'i';
43855|   780k|    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, "multiline"));
43856|   780k|    if (res < 0)
43857|      0|        goto exception;
43858|   780k|    if (res)
43859|  2.66k|        *p++ = 'm';
43860|   780k|    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, "dotAll"));
43861|   780k|    if (res < 0)
43862|      0|        goto exception;
43863|   780k|    if (res)
43864|  3.63k|        *p++ = 's';
43865|   780k|    res = JS_ToBoolFree(ctx, JS_GetProperty(ctx, this_val, JS_ATOM_unicode));
43866|   780k|    if (res < 0)
43867|      0|        goto exception;
43868|   780k|    if (res)
43869|  2.08k|        *p++ = 'u';
43870|   780k|    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, "sticky"));
43871|   780k|    if (res < 0)
43872|      0|        goto exception;
43873|   780k|    if (res)
43874|    530|        *p++ = 'y';
43875|   780k|    return JS_NewStringLen(ctx, str, p - str);
43876|       |
43877|      8|exception:
43878|      8|    return JS_EXCEPTION;
43879|   780k|}
43880|       |
43881|       |static JSValue js_regexp_toString(JSContext *ctx, JSValueConst this_val,
43882|       |                                  int argc, JSValueConst *argv)
43883|   780k|{
43884|   780k|    JSValue pattern, flags;
43885|   780k|    StringBuffer b_s, *b = &b_s;
43886|       |
43887|   780k|    if (!JS_IsObject(this_val))
43888|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
43889|       |
43890|   780k|    string_buffer_init(ctx, b, 0);
43891|   780k|    string_buffer_putc8(b, '/');
43892|   780k|    pattern = JS_GetProperty(ctx, this_val, JS_ATOM_source);
43893|   780k|    if (string_buffer_concat_value_free(b, pattern))
43894|      0|        goto fail;
43895|   780k|    string_buffer_putc8(b, '/');
43896|   780k|    flags = JS_GetProperty(ctx, this_val, JS_ATOM_flags);
43897|   780k|    if (string_buffer_concat_value_free(b, flags))
43898|      8|        goto fail;
43899|   780k|    return string_buffer_end(b);
43900|       |
43901|      8|fail:
43902|      8|    string_buffer_free(b);
43903|      8|    return JS_EXCEPTION;
43904|   780k|}
43905|       |
43906|       |int lre_check_stack_overflow(void *opaque, size_t alloca_size)
43907|  78.1k|{
43908|  78.1k|    JSContext *ctx = opaque;
43909|  78.1k|    return js_check_stack_overflow(ctx->rt, alloca_size);
43910|  78.1k|}
43911|       |
43912|       |int lre_check_timeout(void *opaque)
43913|      0|{
43914|      0|    JSContext *ctx = opaque;
43915|      0|    JSRuntime *rt = ctx->rt;
43916|      0|    return (rt->interrupt_handler && 
43917|      0|            rt->interrupt_handler(rt, rt->interrupt_opaque));
43918|      0|}
43919|       |
43920|       |void *lre_realloc(void *opaque, void *ptr, size_t size)
43921|  5.93M|{
43922|  5.93M|    JSContext *ctx = opaque;
43923|       |    /* No JS exception is raised here */
43924|  5.93M|    return js_realloc_rt(ctx->rt, ptr, size);
43925|  5.93M|}
43926|       |
43927|       |static JSValue js_regexp_exec(JSContext *ctx, JSValueConst this_val,
43928|       |                              int argc, JSValueConst *argv)
43929|      0|{
43930|      0|    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
43931|      0|    JSString *str;
43932|      0|    JSValue t, ret, str_val, obj, val, groups;
43933|      0|    JSValue indices, indices_groups;
43934|      0|    uint8_t *re_bytecode;
43935|      0|    uint8_t **capture, *str_buf;
43936|      0|    int rc, capture_count, shift, i, re_flags;
43937|      0|    int64_t last_index;
43938|      0|    const char *group_name_ptr;
43939|       |
43940|      0|    if (!re)
43941|      0|        return JS_EXCEPTION;
43942|       |
43943|      0|    str_val = JS_ToString(ctx, argv[0]);
43944|      0|    if (JS_IsException(str_val))
43945|      0|        return JS_EXCEPTION;
43946|       |
43947|      0|    ret = JS_EXCEPTION;
43948|      0|    obj = JS_NULL;
43949|      0|    groups = JS_UNDEFINED;
43950|      0|    indices = JS_UNDEFINED;
43951|      0|    indices_groups = JS_UNDEFINED;
43952|      0|    capture = NULL;
43953|       |
43954|      0|    val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex);
43955|      0|    if (JS_IsException(val) || JS_ToLengthFree(ctx, &last_index, val))
43956|      0|        goto fail;
43957|       |
43958|      0|    re_bytecode = re->bytecode->u.str8;
43959|      0|    re_flags = lre_get_flags(re_bytecode);
43960|      0|    if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
43961|      0|        last_index = 0;
43962|      0|    }
43963|      0|    str = JS_VALUE_GET_STRING(str_val);
43964|      0|    capture_count = lre_get_capture_count(re_bytecode);
43965|      0|    if (capture_count > 0) {
43966|      0|        capture = js_malloc(ctx, sizeof(capture[0]) * capture_count * 2);
43967|      0|        if (!capture)
43968|      0|            goto fail;
43969|      0|    }
43970|      0|    shift = str->is_wide_char;
43971|      0|    str_buf = str->u.str8;
43972|      0|    if (last_index > str->len) {
43973|      0|        rc = 2;
43974|      0|    } else {
43975|      0|        rc = lre_exec(capture, re_bytecode,
43976|      0|                      str_buf, last_index, str->len,
43977|      0|                      shift, ctx);
43978|      0|    }
43979|      0|    if (rc != 1) {
43980|      0|        if (rc >= 0) {
43981|      0|            if (rc == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
43982|      0|                if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,
43983|      0|                                   JS_NewInt32(ctx, 0)) < 0)
43984|      0|                    goto fail;
43985|      0|            }
43986|      0|        } else {
43987|      0|            if (rc == LRE_RET_TIMEOUT) {
43988|      0|                JS_ThrowInterrupted(ctx);
43989|      0|            } else {
43990|      0|                JS_ThrowInternalError(ctx, "out of memory in regexp execution");
43991|      0|            }
43992|      0|            goto fail;
43993|      0|        }
43994|      0|    } else {
43995|      0|        int prop_flags;
43996|      0|        if (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) {
43997|      0|            if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,
43998|      0|                               JS_NewInt32(ctx, (capture[1] - str_buf) >> shift)) < 0)
43999|      0|                goto fail;
44000|      0|        }
44001|      0|        obj = JS_NewArray(ctx);
44002|      0|        if (JS_IsException(obj))
44003|      0|            goto fail;
44004|      0|        prop_flags = JS_PROP_C_W_E | JS_PROP_THROW;
44005|      0|        group_name_ptr = lre_get_groupnames(re_bytecode);
44006|      0|        if (group_name_ptr) {
44007|      0|            groups = JS_NewObjectProto(ctx, JS_NULL);
44008|      0|            if (JS_IsException(groups))
44009|      0|                goto fail;
44010|      0|        }
44011|      0|        if (re_flags & LRE_FLAG_INDICES) {
44012|      0|            indices = JS_NewArray(ctx);
44013|      0|            if (JS_IsException(indices))
44014|      0|                goto fail;
44015|      0|            if (group_name_ptr) {
44016|      0|                indices_groups = JS_NewObjectProto(ctx, JS_NULL);
44017|      0|                if (JS_IsException(indices_groups))
44018|      0|                    goto fail;
44019|      0|            }
44020|      0|        }
44021|       |
44022|      0|        for(i = 0; i < capture_count; i++) {
44023|      0|            const char *name = NULL;
44024|      0|            uint8_t **match = &capture[2 * i];
44025|      0|            int start = -1;
44026|      0|            int end = -1;
44027|      0|            JSValue val;
44028|       |
44029|      0|            if (group_name_ptr && i > 0) {
44030|      0|                if (*group_name_ptr) name = group_name_ptr;
44031|      0|                group_name_ptr += strlen(group_name_ptr) + 1;
44032|      0|            }
44033|       |
44034|      0|            if (match[0] && match[1]) {
44035|      0|                start = (match[0] - str_buf) >> shift;
44036|      0|                end = (match[1] - str_buf) >> shift;
44037|      0|            }
44038|       |
44039|      0|            if (!JS_IsUndefined(indices)) {
44040|      0|                val = JS_UNDEFINED;
44041|      0|                if (start != -1) {
44042|      0|                    val = JS_NewArray(ctx);
44043|      0|                    if (JS_IsException(val))
44044|      0|                        goto fail;
44045|      0|                    if (JS_DefinePropertyValueUint32(ctx, val, 0,
44046|      0|                                                     JS_NewInt32(ctx, start),
44047|      0|                                                     prop_flags) < 0) {
44048|      0|                        JS_FreeValue(ctx, val);
44049|      0|                        goto fail;
44050|      0|                    }
44051|      0|                    if (JS_DefinePropertyValueUint32(ctx, val, 1,
44052|      0|                                                     JS_NewInt32(ctx, end),
44053|      0|                                                     prop_flags) < 0) {
44054|      0|                        JS_FreeValue(ctx, val);
44055|      0|                        goto fail;
44056|      0|                    }
44057|      0|                }
44058|      0|                if (name && !JS_IsUndefined(indices_groups)) {
44059|      0|                    val = JS_DupValue(ctx, val);
44060|      0|                    if (JS_DefinePropertyValueStr(ctx, indices_groups,
44061|      0|                                                  name, val, prop_flags) < 0) {
44062|      0|                        JS_FreeValue(ctx, val);
44063|      0|                        goto fail;
44064|      0|                    }
44065|      0|                }
44066|      0|                if (JS_DefinePropertyValueUint32(ctx, indices, i, val,
44067|      0|                                                 prop_flags) < 0) {
44068|      0|                    goto fail;
44069|      0|                }
44070|      0|            }
44071|       |
44072|      0|            val = JS_UNDEFINED;
44073|      0|            if (start != -1) {
44074|      0|                val = js_sub_string(ctx, str, start, end);
44075|      0|                if (JS_IsException(val))
44076|      0|                    goto fail;
44077|      0|            }
44078|       |
44079|      0|            if (name) {
44080|      0|                if (JS_DefinePropertyValueStr(ctx, groups, name,
44081|      0|                                              JS_DupValue(ctx, val),
44082|      0|                                              prop_flags) < 0) {
44083|      0|                    JS_FreeValue(ctx, val);
44084|      0|                    goto fail;
44085|      0|                }
44086|      0|            }
44087|       |
44088|      0|            if (JS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags) < 0)
44089|      0|                goto fail;
44090|      0|        }
44091|       |
44092|      0|        t = groups, groups = JS_UNDEFINED;
44093|      0|        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_groups,
44094|      0|                                   t, prop_flags) < 0) {
44095|      0|            goto fail;
44096|      0|        }
44097|       |
44098|      0|        t = JS_NewInt32(ctx, (capture[0] - str_buf) >> shift);
44099|      0|        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_index, t, prop_flags) < 0)
44100|      0|            goto fail;
44101|       |
44102|      0|        t = str_val, str_val = JS_UNDEFINED;
44103|      0|        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_input, t, prop_flags) < 0)
44104|      0|            goto fail;
44105|       |
44106|      0|        if (!JS_IsUndefined(indices)) {
44107|      0|            t = indices_groups, indices_groups = JS_UNDEFINED;
44108|      0|            if (JS_DefinePropertyValue(ctx, indices, JS_ATOM_groups,
44109|      0|                                       t, prop_flags) < 0) {
44110|      0|                goto fail;
44111|      0|            }
44112|      0|            t = indices, indices = JS_UNDEFINED;
44113|      0|            if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_indices,
44114|      0|                                       t, prop_flags) < 0) {
44115|      0|                goto fail;
44116|      0|            }
44117|      0|        }
44118|      0|    }
44119|      0|    ret = obj;
44120|      0|    obj = JS_UNDEFINED;
44121|      0|fail:
44122|      0|    JS_FreeValue(ctx, indices_groups);
44123|      0|    JS_FreeValue(ctx, indices);
44124|      0|    JS_FreeValue(ctx, str_val);
44125|      0|    JS_FreeValue(ctx, groups);
44126|      0|    JS_FreeValue(ctx, obj);
44127|      0|    js_free(ctx, capture);
44128|      0|    return ret;
44129|      0|}
44130|       |
44131|       |/* delete portions of a string that match a given regex */
44132|       |static JSValue JS_RegExpDelete(JSContext *ctx, JSValueConst this_val, JSValueConst arg)
44133|      0|{
44134|      0|    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
44135|      0|    JSString *str;
44136|      0|    JSValue str_val, val;
44137|      0|    uint8_t *re_bytecode;
44138|      0|    int ret;
44139|      0|    uint8_t **capture, *str_buf;
44140|      0|    int capture_count, shift, re_flags;
44141|      0|    int next_src_pos, start, end;
44142|      0|    int64_t last_index;
44143|      0|    StringBuffer b_s, *b = &b_s;
44144|       |
44145|      0|    if (!re)
44146|      0|        return JS_EXCEPTION;
44147|       |
44148|      0|    string_buffer_init(ctx, b, 0);
44149|       |
44150|      0|    capture = NULL;
44151|      0|    str_val = JS_ToString(ctx, arg);
44152|      0|    if (JS_IsException(str_val))
44153|      0|        goto fail;
44154|      0|    str = JS_VALUE_GET_STRING(str_val);
44155|      0|    re_bytecode = re->bytecode->u.str8;
44156|      0|    re_flags = lre_get_flags(re_bytecode);
44157|      0|    if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
44158|      0|        last_index = 0;
44159|      0|    } else {
44160|      0|        val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex);
44161|      0|        if (JS_IsException(val) || JS_ToLengthFree(ctx, &last_index, val))
44162|      0|            goto fail;
44163|      0|    }
44164|      0|    capture_count = lre_get_capture_count(re_bytecode);
44165|      0|    if (capture_count > 0) {
44166|      0|        capture = js_malloc(ctx, sizeof(capture[0]) * capture_count * 2);
44167|      0|        if (!capture)
44168|      0|            goto fail;
44169|      0|    }
44170|      0|    shift = str->is_wide_char;
44171|      0|    str_buf = str->u.str8;
44172|      0|    next_src_pos = 0;
44173|      0|    for (;;) {
44174|      0|        if (last_index > str->len)
44175|      0|            break;
44176|       |
44177|      0|        ret = lre_exec(capture, re_bytecode,
44178|      0|                       str_buf, last_index, str->len, shift, ctx);
44179|      0|        if (ret != 1) {
44180|      0|            if (ret >= 0) {
44181|      0|                if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
44182|      0|                    if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,
44183|      0|                                       JS_NewInt32(ctx, 0)) < 0)
44184|      0|                        goto fail;
44185|      0|                }
44186|      0|            } else {
44187|      0|                if (ret == LRE_RET_TIMEOUT) {
44188|      0|                    JS_ThrowInterrupted(ctx);
44189|      0|                } else {
44190|      0|                    JS_ThrowInternalError(ctx, "out of memory in regexp execution");
44191|      0|                }
44192|      0|                goto fail;
44193|      0|            }
44194|      0|            break;
44195|      0|        }
44196|      0|        start = (capture[0] - str_buf) >> shift;
44197|      0|        end = (capture[1] - str_buf) >> shift;
44198|      0|        last_index = end;
44199|      0|        if (next_src_pos < start) {
44200|      0|            if (string_buffer_concat(b, str, next_src_pos, start))
44201|      0|                goto fail;
44202|      0|        }
44203|      0|        next_src_pos = end;
44204|      0|        if (!(re_flags & LRE_FLAG_GLOBAL)) {
44205|      0|            if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,
44206|      0|                               JS_NewInt32(ctx, end)) < 0)
44207|      0|                goto fail;
44208|      0|            break;
44209|      0|        }
44210|      0|        if (end == start) {
44211|      0|            if (!(re_flags & LRE_FLAG_UNICODE) || (unsigned)end >= str->len || !str->is_wide_char) {
44212|      0|                end++;
44213|      0|            } else {
44214|      0|                string_getc(str, &end);
44215|      0|            }
44216|      0|        }
44217|      0|        last_index = end;
44218|      0|    }
44219|      0|    if (string_buffer_concat(b, str, next_src_pos, str->len))
44220|      0|        goto fail;
44221|      0|    JS_FreeValue(ctx, str_val);
44222|      0|    js_free(ctx, capture);
44223|      0|    return string_buffer_end(b);
44224|      0|fail:
44225|      0|    JS_FreeValue(ctx, str_val);
44226|      0|    js_free(ctx, capture);
44227|      0|    string_buffer_free(b);
44228|      0|    return JS_EXCEPTION;
44229|      0|}
44230|       |
44231|       |static JSValue JS_RegExpExec(JSContext *ctx, JSValueConst r, JSValueConst s)
44232|      0|{
44233|      0|    JSValue method, ret;
44234|       |
44235|      0|    method = JS_GetProperty(ctx, r, JS_ATOM_exec);
44236|      0|    if (JS_IsException(method))
44237|      0|        return method;
44238|      0|    if (JS_IsFunction(ctx, method)) {
44239|      0|        ret = JS_CallFree(ctx, method, r, 1, &s);
44240|      0|        if (JS_IsException(ret))
44241|      0|            return ret;
44242|      0|        if (!JS_IsObject(ret) && !JS_IsNull(ret)) {
44243|      0|            JS_FreeValue(ctx, ret);
44244|      0|            return JS_ThrowTypeError(ctx, "RegExp exec method must return an object or null");
44245|      0|        }
44246|      0|        return ret;
44247|      0|    }
44248|      0|    JS_FreeValue(ctx, method);
44249|      0|    return js_regexp_exec(ctx, r, 1, &s);
44250|      0|}
44251|       |
44252|       |#if 0
44253|       |static JSValue js_regexp___RegExpExec(JSContext *ctx, JSValueConst this_val,
44254|       |                                      int argc, JSValueConst *argv)
44255|       |{
44256|       |    return JS_RegExpExec(ctx, argv[0], argv[1]);
44257|       |}
44258|       |static JSValue js_regexp___RegExpDelete(JSContext *ctx, JSValueConst this_val,
44259|       |                                        int argc, JSValueConst *argv)
44260|       |{
44261|       |    return JS_RegExpDelete(ctx, argv[0], argv[1]);
44262|       |}
44263|       |#endif
44264|       |
44265|       |static JSValue js_regexp_test(JSContext *ctx, JSValueConst this_val,
44266|       |                              int argc, JSValueConst *argv)
44267|      0|{
44268|      0|    JSValue val;
44269|      0|    BOOL ret;
44270|       |
44271|      0|    val = JS_RegExpExec(ctx, this_val, argv[0]);
44272|      0|    if (JS_IsException(val))
44273|      0|        return JS_EXCEPTION;
44274|      0|    ret = !JS_IsNull(val);
44275|      0|    JS_FreeValue(ctx, val);
44276|      0|    return JS_NewBool(ctx, ret);
44277|      0|}
44278|       |
44279|       |static JSValue js_regexp_Symbol_match(JSContext *ctx, JSValueConst this_val,
44280|       |                                      int argc, JSValueConst *argv)
44281|      0|{
44282|       |    // [Symbol.match](str)
44283|      0|    JSValueConst rx = this_val;
44284|      0|    JSValue A, S, flags, result, matchStr;
44285|      0|    int global, n, fullUnicode, isEmpty;
44286|      0|    JSString *p;
44287|       |
44288|      0|    if (!JS_IsObject(rx))
44289|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
44290|       |
44291|      0|    A = JS_UNDEFINED;
44292|      0|    flags = JS_UNDEFINED;
44293|      0|    result = JS_UNDEFINED;
44294|      0|    matchStr = JS_UNDEFINED;
44295|      0|    S = JS_ToString(ctx, argv[0]);
44296|      0|    if (JS_IsException(S))
44297|      0|        goto exception;
44298|       |
44299|      0|    flags = JS_GetProperty(ctx, rx, JS_ATOM_flags);
44300|      0|    if (JS_IsException(flags))
44301|      0|        goto exception;
44302|      0|    flags = JS_ToStringFree(ctx, flags);
44303|      0|    if (JS_IsException(flags))
44304|      0|        goto exception;
44305|      0|    p = JS_VALUE_GET_STRING(flags);
44306|       |
44307|       |    // TODO(bnoordhuis) query 'u' flag the same way?
44308|      0|    global = (-1 != string_indexof_char(p, 'g', 0));
44309|      0|    if (!global) {
44310|      0|        A = JS_RegExpExec(ctx, rx, S);
44311|      0|    } else {
44312|      0|        fullUnicode = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_unicode));
44313|      0|        if (fullUnicode < 0)
44314|      0|            goto exception;
44315|       |
44316|      0|        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0)) < 0)
44317|      0|            goto exception;
44318|      0|        A = JS_NewArray(ctx);
44319|      0|        if (JS_IsException(A))
44320|      0|            goto exception;
44321|      0|        n = 0;
44322|      0|        for(;;) {
44323|      0|            JS_FreeValue(ctx, result);
44324|      0|            result = JS_RegExpExec(ctx, rx, S);
44325|      0|            if (JS_IsException(result))
44326|      0|                goto exception;
44327|      0|            if (JS_IsNull(result))
44328|      0|                break;
44329|      0|            matchStr = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));
44330|      0|            if (JS_IsException(matchStr))
44331|      0|                goto exception;
44332|      0|            isEmpty = JS_IsEmptyString(matchStr);
44333|      0|            if (JS_SetPropertyInt64(ctx, A, n++, matchStr) < 0)
44334|      0|                goto exception;
44335|      0|            if (isEmpty) {
44336|      0|                int64_t thisIndex, nextIndex;
44337|      0|                if (JS_ToLengthFree(ctx, &thisIndex,
44338|      0|                                    JS_GetProperty(ctx, rx, JS_ATOM_lastIndex)) < 0)
44339|      0|                    goto exception;
44340|      0|                p = JS_VALUE_GET_STRING(S);
44341|      0|                nextIndex = string_advance_index(p, thisIndex, fullUnicode);
44342|      0|                if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt64(ctx, nextIndex)) < 0)
44343|      0|                    goto exception;
44344|      0|            }
44345|      0|        }
44346|      0|        if (n == 0) {
44347|      0|            JS_FreeValue(ctx, A);
44348|      0|            A = JS_NULL;
44349|      0|        }
44350|      0|    }
44351|      0|    JS_FreeValue(ctx, result);
44352|      0|    JS_FreeValue(ctx, flags);
44353|      0|    JS_FreeValue(ctx, S);
44354|      0|    return A;
44355|       |
44356|      0|exception:
44357|      0|    JS_FreeValue(ctx, A);
44358|      0|    JS_FreeValue(ctx, result);
44359|      0|    JS_FreeValue(ctx, flags);
44360|      0|    JS_FreeValue(ctx, S);
44361|      0|    return JS_EXCEPTION;
44362|      0|}
44363|       |
44364|       |typedef struct JSRegExpStringIteratorData {
44365|       |    JSValue iterating_regexp;
44366|       |    JSValue iterated_string;
44367|       |    BOOL global;
44368|       |    BOOL unicode;
44369|       |    BOOL done;
44370|       |} JSRegExpStringIteratorData;
44371|       |
44372|       |static void js_regexp_string_iterator_finalizer(JSRuntime *rt, JSValue val)
44373|      0|{
44374|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
44375|      0|    JSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;
44376|      0|    if (it) {
44377|      0|        JS_FreeValueRT(rt, it->iterating_regexp);
44378|      0|        JS_FreeValueRT(rt, it->iterated_string);
44379|      0|        js_free_rt(rt, it);
44380|      0|    }
44381|      0|}
44382|       |
44383|       |static void js_regexp_string_iterator_mark(JSRuntime *rt, JSValueConst val,
44384|       |                                           JS_MarkFunc *mark_func)
44385|      0|{
44386|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
44387|      0|    JSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;
44388|      0|    if (it) {
44389|      0|        JS_MarkValue(rt, it->iterating_regexp, mark_func);
44390|      0|        JS_MarkValue(rt, it->iterated_string, mark_func);
44391|      0|    }
44392|      0|}
44393|       |
44394|       |static JSValue js_regexp_string_iterator_next(JSContext *ctx,
44395|       |                                              JSValueConst this_val,
44396|       |                                              int argc, JSValueConst *argv,
44397|       |                                              BOOL *pdone, int magic)
44398|      0|{
44399|      0|    JSRegExpStringIteratorData *it;
44400|      0|    JSValueConst R, S;
44401|      0|    JSValue matchStr = JS_UNDEFINED, match = JS_UNDEFINED;
44402|      0|    JSString *sp;
44403|       |
44404|      0|    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_REGEXP_STRING_ITERATOR);
44405|      0|    if (!it)
44406|      0|        goto exception;
44407|      0|    if (it->done) {
44408|      0|        *pdone = TRUE;
44409|      0|        return JS_UNDEFINED;
44410|      0|    }
44411|      0|    R = it->iterating_regexp;
44412|      0|    S = it->iterated_string;
44413|      0|    match = JS_RegExpExec(ctx, R, S);
44414|      0|    if (JS_IsException(match))
44415|      0|        goto exception;
44416|      0|    if (JS_IsNull(match)) {
44417|      0|        it->done = TRUE;
44418|      0|        *pdone = TRUE;
44419|      0|        return JS_UNDEFINED;
44420|      0|    } else if (it->global) {
44421|      0|        matchStr = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, match, 0));
44422|      0|        if (JS_IsException(matchStr))
44423|      0|            goto exception;
44424|      0|        if (JS_IsEmptyString(matchStr)) {
44425|      0|            int64_t thisIndex, nextIndex;
44426|      0|            if (JS_ToLengthFree(ctx, &thisIndex,
44427|      0|                                JS_GetProperty(ctx, R, JS_ATOM_lastIndex)) < 0)
44428|      0|                goto exception;
44429|      0|            sp = JS_VALUE_GET_STRING(S);
44430|      0|            nextIndex = string_advance_index(sp, thisIndex, it->unicode);
44431|      0|            if (JS_SetProperty(ctx, R, JS_ATOM_lastIndex,
44432|      0|                               JS_NewInt64(ctx, nextIndex)) < 0)
44433|      0|                goto exception;
44434|      0|        }
44435|      0|        JS_FreeValue(ctx, matchStr);
44436|      0|    } else {
44437|      0|        it->done = TRUE;
44438|      0|    }
44439|      0|    *pdone = FALSE;
44440|      0|    return match;
44441|      0| exception:
44442|      0|    JS_FreeValue(ctx, match);
44443|      0|    JS_FreeValue(ctx, matchStr);
44444|      0|    *pdone = FALSE;
44445|      0|    return JS_EXCEPTION;
44446|      0|}
44447|       |
44448|       |static JSValue js_regexp_Symbol_matchAll(JSContext *ctx, JSValueConst this_val,
44449|       |                                         int argc, JSValueConst *argv)
44450|      0|{
44451|       |    // [Symbol.matchAll](str)
44452|      0|    JSValueConst R = this_val;
44453|      0|    JSValue S, C, flags, matcher, iter;
44454|      0|    JSValueConst args[2];
44455|      0|    JSString *strp;
44456|      0|    int64_t lastIndex;
44457|      0|    JSRegExpStringIteratorData *it;
44458|       |
44459|      0|    if (!JS_IsObject(R))
44460|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
44461|       |
44462|      0|    C = JS_UNDEFINED;
44463|      0|    flags = JS_UNDEFINED;
44464|      0|    matcher = JS_UNDEFINED;
44465|      0|    iter = JS_UNDEFINED;
44466|       |
44467|      0|    S = JS_ToString(ctx, argv[0]);
44468|      0|    if (JS_IsException(S))
44469|      0|        goto exception;
44470|      0|    C = JS_SpeciesConstructor(ctx, R, ctx->regexp_ctor);
44471|      0|    if (JS_IsException(C))
44472|      0|        goto exception;
44473|      0|    flags = JS_ToStringFree(ctx, JS_GetProperty(ctx, R, JS_ATOM_flags));
44474|      0|    if (JS_IsException(flags))
44475|      0|        goto exception;
44476|      0|    args[0] = R;
44477|      0|    args[1] = flags;
44478|      0|    matcher = JS_CallConstructor(ctx, C, 2, args);
44479|      0|    if (JS_IsException(matcher))
44480|      0|        goto exception;
44481|      0|    if (JS_ToLengthFree(ctx, &lastIndex,
44482|      0|                        JS_GetProperty(ctx, R, JS_ATOM_lastIndex)))
44483|      0|        goto exception;
44484|      0|    if (JS_SetProperty(ctx, matcher, JS_ATOM_lastIndex,
44485|      0|                       JS_NewInt64(ctx, lastIndex)) < 0)
44486|      0|        goto exception;
44487|       |
44488|      0|    iter = JS_NewObjectClass(ctx, JS_CLASS_REGEXP_STRING_ITERATOR);
44489|      0|    if (JS_IsException(iter))
44490|      0|        goto exception;
44491|      0|    it = js_malloc(ctx, sizeof(*it));
44492|      0|    if (!it)
44493|      0|        goto exception;
44494|      0|    it->iterating_regexp = matcher;
44495|      0|    it->iterated_string = S;
44496|      0|    strp = JS_VALUE_GET_STRING(flags);
44497|      0|    it->global = string_indexof_char(strp, 'g', 0) >= 0;
44498|      0|    it->unicode = string_indexof_char(strp, 'u', 0) >= 0;
44499|      0|    it->done = FALSE;
44500|      0|    JS_SetOpaque(iter, it);
44501|       |
44502|      0|    JS_FreeValue(ctx, C);
44503|      0|    JS_FreeValue(ctx, flags);
44504|      0|    return iter;
44505|      0| exception:
44506|      0|    JS_FreeValue(ctx, S);
44507|      0|    JS_FreeValue(ctx, C);
44508|      0|    JS_FreeValue(ctx, flags);
44509|      0|    JS_FreeValue(ctx, matcher);
44510|      0|    JS_FreeValue(ctx, iter);
44511|      0|    return JS_EXCEPTION;
44512|      0|}
44513|       |
44514|       |typedef struct ValueBuffer {
44515|       |    JSContext *ctx;
44516|       |    JSValue *arr;
44517|       |    JSValue def[4];
44518|       |    int len;
44519|       |    int size;
44520|       |    int error_status;
44521|       |} ValueBuffer;
44522|       |
44523|       |static int value_buffer_init(JSContext *ctx, ValueBuffer *b)
44524|      0|{
44525|      0|    b->ctx = ctx;
44526|      0|    b->len = 0;
44527|      0|    b->size = 4;
44528|      0|    b->error_status = 0;
44529|      0|    b->arr = b->def;
44530|      0|    return 0;
44531|      0|}
44532|       |
44533|       |static void value_buffer_free(ValueBuffer *b)
44534|      0|{
44535|      0|    while (b->len > 0)
44536|      0|        JS_FreeValue(b->ctx, b->arr[--b->len]);
44537|      0|    if (b->arr != b->def)
44538|      0|        js_free(b->ctx, b->arr);
44539|      0|    b->arr = b->def;
44540|      0|    b->size = 4;
44541|      0|}
44542|       |
44543|       |static int value_buffer_append(ValueBuffer *b, JSValue val)
44544|      0|{
44545|      0|    if (b->error_status)
44546|      0|        return -1;
44547|       |
44548|      0|    if (b->len >= b->size) {
44549|      0|        int new_size = (b->len + (b->len >> 1) + 31) & ~16;
44550|      0|        size_t slack;
44551|      0|        JSValue *new_arr;
44552|       |
44553|      0|        if (b->arr == b->def) {
44554|      0|            new_arr = js_realloc2(b->ctx, NULL, sizeof(*b->arr) * new_size, &slack);
44555|      0|            if (new_arr)
44556|      0|                memcpy(new_arr, b->def, sizeof b->def);
44557|      0|        } else {
44558|      0|            new_arr = js_realloc2(b->ctx, b->arr, sizeof(*b->arr) * new_size, &slack);
44559|      0|        }
44560|      0|        if (!new_arr) {
44561|      0|            value_buffer_free(b);
44562|      0|            JS_FreeValue(b->ctx, val);
44563|      0|            b->error_status = -1;
44564|      0|            return -1;
44565|      0|        }
44566|      0|        new_size += slack / sizeof(*new_arr);
44567|      0|        b->arr = new_arr;
44568|      0|        b->size = new_size;
44569|      0|    }
44570|      0|    b->arr[b->len++] = val;
44571|      0|    return 0;
44572|      0|}
44573|       |
44574|       |static int js_is_standard_regexp(JSContext *ctx, JSValueConst rx)
44575|      0|{
44576|      0|    JSValue val;
44577|      0|    int res;
44578|       |
44579|      0|    val = JS_GetProperty(ctx, rx, JS_ATOM_constructor);
44580|      0|    if (JS_IsException(val))
44581|      0|        return -1;
44582|       |    // rx.constructor === RegExp
44583|      0|    res = js_same_value(ctx, val, ctx->regexp_ctor);
44584|      0|    JS_FreeValue(ctx, val);
44585|      0|    if (res) {
44586|      0|        val = JS_GetProperty(ctx, rx, JS_ATOM_exec);
44587|      0|        if (JS_IsException(val))
44588|      0|            return -1;
44589|       |        // rx.exec === RE_exec
44590|      0|        res = JS_IsCFunction(ctx, val, js_regexp_exec, 0);
44591|      0|        JS_FreeValue(ctx, val);
44592|      0|    }
44593|      0|    return res;
44594|      0|}
44595|       |
44596|       |static JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,
44597|       |                                        int argc, JSValueConst *argv)
44598|      0|{
44599|       |    // [Symbol.replace](str, rep)
44600|      0|    JSValueConst rx = this_val, rep = argv[1];
44601|      0|    JSValueConst args[6];
44602|      0|    JSValue flags, str, rep_val, matched, tab, rep_str, namedCaptures, res;
44603|      0|    JSString *p, *sp, *rp;
44604|      0|    StringBuffer b_s, *b = &b_s;
44605|      0|    ValueBuffer v_b, *results = &v_b;
44606|      0|    int nextSourcePosition, n, j, functionalReplace, is_global, fullUnicode;
44607|      0|    uint32_t nCaptures;
44608|      0|    int64_t position;
44609|       |
44610|      0|    if (!JS_IsObject(rx))
44611|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
44612|       |
44613|      0|    string_buffer_init(ctx, b, 0);
44614|      0|    value_buffer_init(ctx, results);
44615|       |
44616|      0|    rep_val = JS_UNDEFINED;
44617|      0|    matched = JS_UNDEFINED;
44618|      0|    tab = JS_UNDEFINED;
44619|      0|    flags = JS_UNDEFINED;
44620|      0|    rep_str = JS_UNDEFINED;
44621|      0|    namedCaptures = JS_UNDEFINED;
44622|       |
44623|      0|    str = JS_ToString(ctx, argv[0]);
44624|      0|    if (JS_IsException(str))
44625|      0|        goto exception;
44626|       |
44627|      0|    sp = JS_VALUE_GET_STRING(str);
44628|      0|    rp = NULL;
44629|      0|    functionalReplace = JS_IsFunction(ctx, rep);
44630|      0|    if (!functionalReplace) {
44631|      0|        rep_val = JS_ToString(ctx, rep);
44632|      0|        if (JS_IsException(rep_val))
44633|      0|            goto exception;
44634|      0|        rp = JS_VALUE_GET_STRING(rep_val);
44635|      0|    }
44636|       |
44637|      0|    flags = JS_GetProperty(ctx, rx, JS_ATOM_flags);
44638|      0|    if (JS_IsException(flags))
44639|      0|        goto exception;
44640|      0|    flags = JS_ToStringFree(ctx, flags);
44641|      0|    if (JS_IsException(flags))
44642|      0|        goto exception;
44643|      0|    p = JS_VALUE_GET_STRING(flags);
44644|       |
44645|       |    // TODO(bnoordhuis) query 'u' flag the same way?
44646|      0|    fullUnicode = 0;
44647|      0|    is_global = (-1 != string_indexof_char(p, 'g', 0));
44648|      0|    if (is_global) {
44649|      0|        fullUnicode = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_unicode));
44650|      0|        if (fullUnicode < 0)
44651|      0|            goto exception;
44652|      0|        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0)) < 0)
44653|      0|            goto exception;
44654|      0|    }
44655|       |
44656|      0|    if (rp && rp->len == 0 && is_global && js_is_standard_regexp(ctx, rx)) {
44657|       |        /* use faster version for simple cases */
44658|      0|        res = JS_RegExpDelete(ctx, rx, str);
44659|      0|        goto done;
44660|      0|    }
44661|      0|    for(;;) {
44662|      0|        JSValue result;
44663|      0|        result = JS_RegExpExec(ctx, rx, str);
44664|      0|        if (JS_IsException(result))
44665|      0|            goto exception;
44666|      0|        if (JS_IsNull(result))
44667|      0|            break;
44668|      0|        if (value_buffer_append(results, result) < 0)
44669|      0|            goto exception;
44670|      0|        if (!is_global)
44671|      0|            break;
44672|      0|        JS_FreeValue(ctx, matched);
44673|      0|        matched = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));
44674|      0|        if (JS_IsException(matched))
44675|      0|            goto exception;
44676|      0|        if (JS_IsEmptyString(matched)) {
44677|       |            /* always advance of at least one char */
44678|      0|            int64_t thisIndex, nextIndex;
44679|      0|            if (JS_ToLengthFree(ctx, &thisIndex, JS_GetProperty(ctx, rx, JS_ATOM_lastIndex)) < 0)
44680|      0|                goto exception;
44681|      0|            nextIndex = string_advance_index(sp, thisIndex, fullUnicode);
44682|      0|            if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt64(ctx, nextIndex)) < 0)
44683|      0|                goto exception;
44684|      0|        }
44685|      0|    }
44686|      0|    nextSourcePosition = 0;
44687|      0|    for(j = 0; j < results->len; j++) {
44688|      0|        JSValueConst result;
44689|      0|        result = results->arr[j];
44690|      0|        if (js_get_length32(ctx, &nCaptures, result) < 0)
44691|      0|            goto exception;
44692|      0|        JS_FreeValue(ctx, matched);
44693|      0|        matched = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));
44694|      0|        if (JS_IsException(matched))
44695|      0|            goto exception;
44696|      0|        if (JS_ToLengthFree(ctx, &position, JS_GetProperty(ctx, result, JS_ATOM_index)))
44697|      0|            goto exception;
44698|      0|        if (position > sp->len)
44699|      0|            position = sp->len;
44700|      0|        else if (position < 0)
44701|      0|            position = 0;
44702|       |        /* ignore substition if going backward (can happen
44703|       |           with custom regexp object) */
44704|      0|        JS_FreeValue(ctx, tab);
44705|      0|        tab = JS_NewArray(ctx);
44706|      0|        if (JS_IsException(tab))
44707|      0|            goto exception;
44708|      0|        if (JS_DefinePropertyValueInt64(ctx, tab, 0, JS_DupValue(ctx, matched),
44709|      0|                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44710|      0|            goto exception;
44711|      0|        for(n = 1; n < nCaptures; n++) {
44712|      0|            JSValue capN;
44713|      0|            capN = JS_GetPropertyInt64(ctx, result, n);
44714|      0|            if (JS_IsException(capN))
44715|      0|                goto exception;
44716|      0|            if (!JS_IsUndefined(capN)) {
44717|      0|                capN = JS_ToStringFree(ctx, capN);
44718|      0|                if (JS_IsException(capN))
44719|      0|                    goto exception;
44720|      0|            }
44721|      0|            if (JS_DefinePropertyValueInt64(ctx, tab, n, capN,
44722|      0|                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44723|      0|                goto exception;
44724|      0|        }
44725|      0|        JS_FreeValue(ctx, namedCaptures);
44726|      0|        namedCaptures = JS_GetProperty(ctx, result, JS_ATOM_groups);
44727|      0|        if (JS_IsException(namedCaptures))
44728|      0|            goto exception;
44729|      0|        if (functionalReplace) {
44730|      0|            if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_NewInt32(ctx, position), JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44731|      0|                goto exception;
44732|      0|            if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_DupValue(ctx, str), JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44733|      0|                goto exception;
44734|      0|            if (!JS_IsUndefined(namedCaptures)) {
44735|      0|                if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_DupValue(ctx, namedCaptures), JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44736|      0|                    goto exception;
44737|      0|            }
44738|      0|            args[0] = JS_UNDEFINED;
44739|      0|            args[1] = tab;
44740|      0|            JS_FreeValue(ctx, rep_str);
44741|      0|            rep_str = JS_ToStringFree(ctx, js_function_apply(ctx, rep, 2, args, 0));
44742|      0|        } else {
44743|      0|            JSValue namedCaptures1;
44744|      0|            if (!JS_IsUndefined(namedCaptures)) {
44745|      0|                namedCaptures1 = JS_ToObject(ctx, namedCaptures);
44746|      0|                if (JS_IsException(namedCaptures1))
44747|      0|                    goto exception;
44748|      0|            } else {
44749|      0|                namedCaptures1 = JS_UNDEFINED;
44750|      0|            }
44751|      0|            args[0] = matched;
44752|      0|            args[1] = str;
44753|      0|            args[2] = JS_NewInt32(ctx, position);
44754|      0|            args[3] = tab;
44755|      0|            args[4] = namedCaptures1;
44756|      0|            args[5] = rep_val;
44757|      0|            JS_FreeValue(ctx, rep_str);
44758|      0|            rep_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);
44759|      0|            JS_FreeValue(ctx, namedCaptures1);
44760|      0|        }
44761|      0|        if (JS_IsException(rep_str))
44762|      0|            goto exception;
44763|      0|        if (position >= nextSourcePosition) {
44764|      0|            string_buffer_concat(b, sp, nextSourcePosition, position);
44765|      0|            string_buffer_concat_value(b, rep_str);
44766|      0|            nextSourcePosition = position + JS_VALUE_GET_STRING(matched)->len;
44767|      0|        }
44768|      0|    }
44769|      0|    string_buffer_concat(b, sp, nextSourcePosition, sp->len);
44770|      0|    res = string_buffer_end(b);
44771|      0|    goto done1;
44772|       |
44773|      0|exception:
44774|      0|    res = JS_EXCEPTION;
44775|      0|done:
44776|      0|    string_buffer_free(b);
44777|      0|done1:
44778|      0|    value_buffer_free(results);
44779|      0|    JS_FreeValue(ctx, rep_val);
44780|      0|    JS_FreeValue(ctx, matched);
44781|      0|    JS_FreeValue(ctx, flags);
44782|      0|    JS_FreeValue(ctx, tab);
44783|      0|    JS_FreeValue(ctx, rep_str);
44784|      0|    JS_FreeValue(ctx, namedCaptures);
44785|      0|    JS_FreeValue(ctx, str);
44786|      0|    return res;
44787|      0|}
44788|       |
44789|       |static JSValue js_regexp_Symbol_search(JSContext *ctx, JSValueConst this_val,
44790|       |                                       int argc, JSValueConst *argv)
44791|      0|{
44792|      0|    JSValueConst rx = this_val;
44793|      0|    JSValue str, previousLastIndex, currentLastIndex, result, index;
44794|       |
44795|      0|    if (!JS_IsObject(rx))
44796|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
44797|       |
44798|      0|    result = JS_UNDEFINED;
44799|      0|    currentLastIndex = JS_UNDEFINED;
44800|      0|    previousLastIndex = JS_UNDEFINED;
44801|      0|    str = JS_ToString(ctx, argv[0]);
44802|      0|    if (JS_IsException(str))
44803|      0|        goto exception;
44804|       |
44805|      0|    previousLastIndex = JS_GetProperty(ctx, rx, JS_ATOM_lastIndex);
44806|      0|    if (JS_IsException(previousLastIndex))
44807|      0|        goto exception;
44808|       |
44809|      0|    if (!js_same_value(ctx, previousLastIndex, JS_NewInt32(ctx, 0))) {
44810|      0|        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0)) < 0) {
44811|      0|            goto exception;
44812|      0|        }
44813|      0|    }
44814|      0|    result = JS_RegExpExec(ctx, rx, str);
44815|      0|    if (JS_IsException(result))
44816|      0|        goto exception;
44817|      0|    currentLastIndex = JS_GetProperty(ctx, rx, JS_ATOM_lastIndex);
44818|      0|    if (JS_IsException(currentLastIndex))
44819|      0|        goto exception;
44820|      0|    if (js_same_value(ctx, currentLastIndex, previousLastIndex)) {
44821|      0|        JS_FreeValue(ctx, previousLastIndex);
44822|      0|    } else {
44823|      0|        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, previousLastIndex) < 0) {
44824|      0|            previousLastIndex = JS_UNDEFINED;
44825|      0|            goto exception;
44826|      0|        }
44827|      0|    }
44828|      0|    JS_FreeValue(ctx, str);
44829|      0|    JS_FreeValue(ctx, currentLastIndex);
44830|       |
44831|      0|    if (JS_IsNull(result)) {
44832|      0|        return JS_NewInt32(ctx, -1);
44833|      0|    } else {
44834|      0|        index = JS_GetProperty(ctx, result, JS_ATOM_index);
44835|      0|        JS_FreeValue(ctx, result);
44836|      0|        return index;
44837|      0|    }
44838|       |
44839|      0|exception:
44840|      0|    JS_FreeValue(ctx, result);
44841|      0|    JS_FreeValue(ctx, str);
44842|      0|    JS_FreeValue(ctx, currentLastIndex);
44843|      0|    JS_FreeValue(ctx, previousLastIndex);
44844|      0|    return JS_EXCEPTION;
44845|      0|}
44846|       |
44847|       |static JSValue js_regexp_Symbol_split(JSContext *ctx, JSValueConst this_val,
44848|       |                                       int argc, JSValueConst *argv)
44849|      0|{
44850|       |    // [Symbol.split](str, limit)
44851|      0|    JSValueConst rx = this_val;
44852|      0|    JSValueConst args[2];
44853|      0|    JSValue str, ctor, splitter, A, flags, z, sub;
44854|      0|    JSString *strp;
44855|      0|    uint32_t lim, size, p, q;
44856|      0|    int unicodeMatching;
44857|      0|    int64_t lengthA, e, numberOfCaptures, i;
44858|       |
44859|      0|    if (!JS_IsObject(rx))
44860|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
44861|       |
44862|      0|    ctor = JS_UNDEFINED;
44863|      0|    splitter = JS_UNDEFINED;
44864|      0|    A = JS_UNDEFINED;
44865|      0|    flags = JS_UNDEFINED;
44866|      0|    z = JS_UNDEFINED;
44867|      0|    str = JS_ToString(ctx, argv[0]);
44868|      0|    if (JS_IsException(str))
44869|      0|        goto exception;
44870|      0|    ctor = JS_SpeciesConstructor(ctx, rx, ctx->regexp_ctor);
44871|      0|    if (JS_IsException(ctor))
44872|      0|        goto exception;
44873|      0|    flags = JS_ToStringFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_flags));
44874|      0|    if (JS_IsException(flags))
44875|      0|        goto exception;
44876|      0|    strp = JS_VALUE_GET_STRING(flags);
44877|      0|    unicodeMatching = string_indexof_char(strp, 'u', 0) >= 0;
44878|      0|    if (string_indexof_char(strp, 'y', 0) < 0) {
44879|      0|        flags = JS_ConcatString3(ctx, "", flags, "y");
44880|      0|        if (JS_IsException(flags))
44881|      0|            goto exception;
44882|      0|    }
44883|      0|    args[0] = rx;
44884|      0|    args[1] = flags;
44885|      0|    splitter = JS_CallConstructor(ctx, ctor, 2, args);
44886|      0|    if (JS_IsException(splitter))
44887|      0|        goto exception;
44888|      0|    A = JS_NewArray(ctx);
44889|      0|    if (JS_IsException(A))
44890|      0|        goto exception;
44891|      0|    lengthA = 0;
44892|      0|    if (JS_IsUndefined(argv[1])) {
44893|      0|        lim = 0xffffffff;
44894|      0|    } else {
44895|      0|        if (JS_ToUint32(ctx, &lim, argv[1]) < 0)
44896|      0|            goto exception;
44897|      0|        if (lim == 0)
44898|      0|            goto done;
44899|      0|    }
44900|      0|    strp = JS_VALUE_GET_STRING(str);
44901|      0|    p = q = 0;
44902|      0|    size = strp->len;
44903|      0|    if (size == 0) {
44904|      0|        z = JS_RegExpExec(ctx, splitter, str);
44905|      0|        if (JS_IsException(z))
44906|      0|            goto exception;
44907|      0|        if (JS_IsNull(z))
44908|      0|            goto add_tail;
44909|      0|        goto done;
44910|      0|    }
44911|      0|    while (q < size) {
44912|      0|        if (JS_SetProperty(ctx, splitter, JS_ATOM_lastIndex, JS_NewInt32(ctx, q)) < 0)
44913|      0|            goto exception;
44914|      0|        JS_FreeValue(ctx, z);
44915|      0|        z = JS_RegExpExec(ctx, splitter, str);
44916|      0|        if (JS_IsException(z))
44917|      0|            goto exception;
44918|      0|        if (JS_IsNull(z)) {
44919|      0|            q = string_advance_index(strp, q, unicodeMatching);
44920|      0|        } else {
44921|      0|            if (JS_ToLengthFree(ctx, &e, JS_GetProperty(ctx, splitter, JS_ATOM_lastIndex)))
44922|      0|                goto exception;
44923|      0|            if (e > size)
44924|      0|                e = size;
44925|      0|            if (e == p) {
44926|      0|                q = string_advance_index(strp, q, unicodeMatching);
44927|      0|            } else {
44928|      0|                sub = js_sub_string(ctx, strp, p, q);
44929|      0|                if (JS_IsException(sub))
44930|      0|                    goto exception;
44931|      0|                if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub,
44932|      0|                                                JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44933|      0|                    goto exception;
44934|      0|                if (lengthA == lim)
44935|      0|                    goto done;
44936|      0|                p = e;
44937|      0|                if (js_get_length64(ctx, &numberOfCaptures, z))
44938|      0|                    goto exception;
44939|      0|                for(i = 1; i < numberOfCaptures; i++) {
44940|      0|                    sub = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, z, i));
44941|      0|                    if (JS_IsException(sub))
44942|      0|                        goto exception;
44943|      0|                    if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub, JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44944|      0|                        goto exception;
44945|      0|                    if (lengthA == lim)
44946|      0|                        goto done;
44947|      0|                }
44948|      0|                q = p;
44949|      0|            }
44950|      0|        }
44951|      0|    }
44952|      0|add_tail:
44953|      0|    if (p > size)
44954|      0|        p = size;
44955|      0|    sub = js_sub_string(ctx, strp, p, size);
44956|      0|    if (JS_IsException(sub))
44957|      0|        goto exception;
44958|      0|    if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub, JS_PROP_C_W_E | JS_PROP_THROW) < 0)
44959|      0|        goto exception;
44960|      0|    goto done;
44961|      0|exception:
44962|      0|    JS_FreeValue(ctx, A);
44963|      0|    A = JS_EXCEPTION;
44964|      0|done:
44965|      0|    JS_FreeValue(ctx, str);
44966|      0|    JS_FreeValue(ctx, ctor);
44967|      0|    JS_FreeValue(ctx, splitter);
44968|      0|    JS_FreeValue(ctx, flags);
44969|      0|    JS_FreeValue(ctx, z);
44970|      0|    return A;
44971|      0|}
44972|       |
44973|       |static const JSCFunctionListEntry js_regexp_funcs[] = {
44974|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
44975|       |    //JS_CFUNC_DEF("__RegExpExec", 2, js_regexp___RegExpExec ),
44976|       |    //JS_CFUNC_DEF("__RegExpDelete", 2, js_regexp___RegExpDelete ),
44977|       |};
44978|       |
44979|       |static const JSCFunctionListEntry js_regexp_proto_funcs[] = {
44980|       |    JS_CGETSET_DEF("flags", js_regexp_get_flags, NULL ),
44981|       |    JS_CGETSET_DEF("source", js_regexp_get_source, NULL ),
44982|       |    JS_CGETSET_MAGIC_DEF("global", js_regexp_get_flag, NULL, LRE_FLAG_GLOBAL ),
44983|       |    JS_CGETSET_MAGIC_DEF("ignoreCase", js_regexp_get_flag, NULL, LRE_FLAG_IGNORECASE ),
44984|       |    JS_CGETSET_MAGIC_DEF("multiline", js_regexp_get_flag, NULL, LRE_FLAG_MULTILINE ),
44985|       |    JS_CGETSET_MAGIC_DEF("dotAll", js_regexp_get_flag, NULL, LRE_FLAG_DOTALL ),
44986|       |    JS_CGETSET_MAGIC_DEF("unicode", js_regexp_get_flag, NULL, LRE_FLAG_UNICODE ),
44987|       |    JS_CGETSET_MAGIC_DEF("sticky", js_regexp_get_flag, NULL, LRE_FLAG_STICKY ),
44988|       |    JS_CGETSET_MAGIC_DEF("hasIndices", js_regexp_get_flag, NULL, LRE_FLAG_INDICES ),
44989|       |    JS_CFUNC_DEF("exec", 1, js_regexp_exec ),
44990|       |    JS_CFUNC_DEF("compile", 2, js_regexp_compile ),
44991|       |    JS_CFUNC_DEF("test", 1, js_regexp_test ),
44992|       |    JS_CFUNC_DEF("toString", 0, js_regexp_toString ),
44993|       |    JS_CFUNC_DEF("[Symbol.replace]", 2, js_regexp_Symbol_replace ),
44994|       |    JS_CFUNC_DEF("[Symbol.match]", 1, js_regexp_Symbol_match ),
44995|       |    JS_CFUNC_DEF("[Symbol.matchAll]", 1, js_regexp_Symbol_matchAll ),
44996|       |    JS_CFUNC_DEF("[Symbol.search]", 1, js_regexp_Symbol_search ),
44997|       |    JS_CFUNC_DEF("[Symbol.split]", 2, js_regexp_Symbol_split ),
44998|       |    //JS_CGETSET_DEF("__source", js_regexp_get___source, NULL ),
44999|       |    //JS_CGETSET_DEF("__flags", js_regexp_get___flags, NULL ),
45000|       |};
45001|       |
45002|       |static const JSCFunctionListEntry js_regexp_string_iterator_proto_funcs[] = {
45003|       |    JS_ITERATOR_NEXT_DEF("next", 0, js_regexp_string_iterator_next, 0 ),
45004|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "RegExp String Iterator", JS_PROP_CONFIGURABLE ),
45005|       |};
45006|       |
45007|       |void JS_AddIntrinsicRegExpCompiler(JSContext *ctx)
45008|  17.7k|{
45009|  17.7k|    ctx->compile_regexp = js_compile_regexp;
45010|  17.7k|}
45011|       |
45012|       |void JS_AddIntrinsicRegExp(JSContext *ctx)
45013|  17.7k|{
45014|  17.7k|    JSValueConst obj;
45015|       |
45016|  17.7k|    JS_AddIntrinsicRegExpCompiler(ctx);
45017|       |
45018|  17.7k|    ctx->class_proto[JS_CLASS_REGEXP] = JS_NewObject(ctx);
45019|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_REGEXP], js_regexp_proto_funcs,
45020|  17.7k|                               countof(js_regexp_proto_funcs));
45021|  17.7k|    obj = JS_NewGlobalCConstructor(ctx, "RegExp", js_regexp_constructor, 2,
45022|  17.7k|                                   ctx->class_proto[JS_CLASS_REGEXP]);
45023|  17.7k|    ctx->regexp_ctor = JS_DupValue(ctx, obj);
45024|  17.7k|    JS_SetPropertyFunctionList(ctx, obj, js_regexp_funcs, countof(js_regexp_funcs));
45025|       |
45026|  17.7k|    ctx->class_proto[JS_CLASS_REGEXP_STRING_ITERATOR] =
45027|  17.7k|        JS_NewObjectProto(ctx, ctx->iterator_proto);
45028|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_REGEXP_STRING_ITERATOR],
45029|  17.7k|                               js_regexp_string_iterator_proto_funcs,
45030|  17.7k|                               countof(js_regexp_string_iterator_proto_funcs));
45031|  17.7k|}
45032|       |
45033|       |/* JSON */
45034|       |
45035|       |static int json_parse_expect(JSParseState *s, int tok)
45036|      0|{
45037|      0|    if (s->token.val != tok) {
45038|       |        /* XXX: dump token correctly in all cases */
45039|      0|        return js_parse_error(s, "expecting '%c'", tok);
45040|      0|    }
45041|      0|    return json_next_token(s);
45042|      0|}
45043|       |
45044|       |static JSValue json_parse_value(JSParseState *s)
45045|      0|{
45046|      0|    JSContext *ctx = s->ctx;
45047|      0|    JSValue val = JS_NULL;
45048|      0|    int ret;
45049|       |
45050|      0|    switch(s->token.val) {
45051|      0|    case '{':
45052|      0|        {
45053|      0|            JSValue prop_val;
45054|      0|            JSAtom prop_name;
45055|       |
45056|      0|            if (json_next_token(s))
45057|      0|                goto fail;
45058|      0|            val = JS_NewObject(ctx);
45059|      0|            if (JS_IsException(val))
45060|      0|                goto fail;
45061|      0|            if (s->token.val != '}') {
45062|      0|                for(;;) {
45063|      0|                    if (s->token.val == TOK_STRING) {
45064|      0|                        prop_name = JS_ValueToAtom(ctx, s->token.u.str.str);
45065|      0|                        if (prop_name == JS_ATOM_NULL)
45066|      0|                            goto fail;
45067|      0|                    } else if (s->ext_json && s->token.val == TOK_IDENT) {
45068|      0|                        prop_name = JS_DupAtom(ctx, s->token.u.ident.atom);
45069|      0|                    } else {
45070|      0|                        js_parse_error(s, "expecting property name");
45071|      0|                        goto fail;
45072|      0|                    }
45073|      0|                    if (json_next_token(s))
45074|      0|                        goto fail1;
45075|      0|                    if (json_parse_expect(s, ':'))
45076|      0|                        goto fail1;
45077|      0|                    prop_val = json_parse_value(s);
45078|      0|                    if (JS_IsException(prop_val)) {
45079|      0|                    fail1:
45080|      0|                        JS_FreeAtom(ctx, prop_name);
45081|      0|                        goto fail;
45082|      0|                    }
45083|      0|                    ret = JS_DefinePropertyValue(ctx, val, prop_name,
45084|      0|                                                 prop_val, JS_PROP_C_W_E);
45085|      0|                    JS_FreeAtom(ctx, prop_name);
45086|      0|                    if (ret < 0)
45087|      0|                        goto fail;
45088|       |
45089|      0|                    if (s->token.val != ',')
45090|      0|                        break;
45091|      0|                    if (json_next_token(s))
45092|      0|                        goto fail;
45093|      0|                    if (s->ext_json && s->token.val == '}')
45094|      0|                        break;
45095|      0|                }
45096|      0|            }
45097|      0|            if (json_parse_expect(s, '}'))
45098|      0|                goto fail;
45099|      0|        }
45100|      0|        break;
45101|      0|    case '[':
45102|      0|        {
45103|      0|            JSValue el;
45104|      0|            uint32_t idx;
45105|       |
45106|      0|            if (json_next_token(s))
45107|      0|                goto fail;
45108|      0|            val = JS_NewArray(ctx);
45109|      0|            if (JS_IsException(val))
45110|      0|                goto fail;
45111|      0|            if (s->token.val != ']') {
45112|      0|                idx = 0;
45113|      0|                for(;;) {
45114|      0|                    el = json_parse_value(s);
45115|      0|                    if (JS_IsException(el))
45116|      0|                        goto fail;
45117|      0|                    ret = JS_DefinePropertyValueUint32(ctx, val, idx, el, JS_PROP_C_W_E);
45118|      0|                    if (ret < 0)
45119|      0|                        goto fail;
45120|      0|                    if (s->token.val != ',')
45121|      0|                        break;
45122|      0|                    if (json_next_token(s))
45123|      0|                        goto fail;
45124|      0|                    idx++;
45125|      0|                    if (s->ext_json && s->token.val == ']')
45126|      0|                        break;
45127|      0|                }
45128|      0|            }
45129|      0|            if (json_parse_expect(s, ']'))
45130|      0|                goto fail;
45131|      0|        }
45132|      0|        break;
45133|      0|    case TOK_STRING:
45134|      0|        val = JS_DupValue(ctx, s->token.u.str.str);
45135|      0|        if (json_next_token(s))
45136|      0|            goto fail;
45137|      0|        break;
45138|      0|    case TOK_NUMBER:
45139|      0|        val = s->token.u.num.val;
45140|      0|        if (json_next_token(s))
45141|      0|            goto fail;
45142|      0|        break;
45143|      0|    case TOK_IDENT:
45144|      0|        if (s->token.u.ident.atom == JS_ATOM_false ||
45145|      0|            s->token.u.ident.atom == JS_ATOM_true) {
45146|      0|            val = JS_NewBool(ctx, s->token.u.ident.atom == JS_ATOM_true);
45147|      0|        } else if (s->token.u.ident.atom == JS_ATOM_null) {
45148|      0|            val = JS_NULL;
45149|      0|        } else {
45150|      0|            goto def_token;
45151|      0|        }
45152|      0|        if (json_next_token(s))
45153|      0|            goto fail;
45154|      0|        break;
45155|      0|    default:
45156|      0|    def_token:
45157|      0|        if (s->token.val == TOK_EOF) {
45158|      0|            js_parse_error(s, "Unexpected end of JSON input");
45159|      0|        } else {
45160|      0|            js_parse_error(s, "unexpected token: '%.*s'",
45161|      0|                           (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
45162|      0|        }
45163|      0|        goto fail;
45164|      0|    }
45165|      0|    return val;
45166|      0| fail:
45167|      0|    JS_FreeValue(ctx, val);
45168|      0|    return JS_EXCEPTION;
45169|      0|}
45170|       |
45171|       |JSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,
45172|       |                      const char *filename, int flags)
45173|      0|{
45174|      0|    JSParseState s1, *s = &s1;
45175|      0|    JSValue val = JS_UNDEFINED;
45176|       |
45177|      0|    js_parse_init(ctx, s, buf, buf_len, filename);
45178|      0|    s->ext_json = ((flags & JS_PARSE_JSON_EXT) != 0);
45179|      0|    if (json_next_token(s))
45180|      0|        goto fail;
45181|      0|    val = json_parse_value(s);
45182|      0|    if (JS_IsException(val))
45183|      0|        goto fail;
45184|      0|    if (s->token.val != TOK_EOF) {
45185|      0|        if (js_parse_error(s, "unexpected data at the end"))
45186|      0|            goto fail;
45187|      0|    }
45188|      0|    return val;
45189|      0| fail:
45190|      0|    JS_FreeValue(ctx, val);
45191|      0|    free_token(s, &s->token);
45192|      0|    return JS_EXCEPTION;
45193|      0|}
45194|       |
45195|       |JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
45196|       |                     const char *filename)
45197|      0|{
45198|      0|    return JS_ParseJSON2(ctx, buf, buf_len, filename, 0);
45199|      0|}
45200|       |
45201|       |static JSValue internalize_json_property(JSContext *ctx, JSValueConst holder,
45202|       |                                         JSAtom name, JSValueConst reviver)
45203|      0|{
45204|      0|    JSValue val, new_el, name_val, res;
45205|      0|    JSValueConst args[2];
45206|      0|    int ret, is_array;
45207|      0|    uint32_t i, len = 0;
45208|      0|    JSAtom prop;
45209|      0|    JSPropertyEnum *atoms = NULL;
45210|       |
45211|      0|    if (js_check_stack_overflow(ctx->rt, 0)) {
45212|      0|        return JS_ThrowStackOverflow(ctx);
45213|      0|    }
45214|       |
45215|      0|    val = JS_GetProperty(ctx, holder, name);
45216|      0|    if (JS_IsException(val))
45217|      0|        return val;
45218|      0|    if (JS_IsObject(val)) {
45219|      0|        is_array = JS_IsArray(ctx, val);
45220|      0|        if (is_array < 0)
45221|      0|            goto fail;
45222|      0|        if (is_array) {
45223|      0|            if (js_get_length32(ctx, &len, val))
45224|      0|                goto fail;
45225|      0|        } else {
45226|      0|            ret = JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, JS_VALUE_GET_OBJ(val), JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK);
45227|      0|            if (ret < 0)
45228|      0|                goto fail;
45229|      0|        }
45230|      0|        for(i = 0; i < len; i++) {
45231|      0|            if (is_array) {
45232|      0|                prop = JS_NewAtomUInt32(ctx, i);
45233|      0|                if (prop == JS_ATOM_NULL)
45234|      0|                    goto fail;
45235|      0|            } else {
45236|      0|                prop = JS_DupAtom(ctx, atoms[i].atom);
45237|      0|            }
45238|      0|            new_el = internalize_json_property(ctx, val, prop, reviver);
45239|      0|            if (JS_IsException(new_el)) {
45240|      0|                JS_FreeAtom(ctx, prop);
45241|      0|                goto fail;
45242|      0|            }
45243|      0|            if (JS_IsUndefined(new_el)) {
45244|      0|                ret = JS_DeleteProperty(ctx, val, prop, 0);
45245|      0|            } else {
45246|      0|                ret = JS_DefinePropertyValue(ctx, val, prop, new_el, JS_PROP_C_W_E);
45247|      0|            }
45248|      0|            JS_FreeAtom(ctx, prop);
45249|      0|            if (ret < 0)
45250|      0|                goto fail;
45251|      0|        }
45252|      0|    }
45253|      0|    js_free_prop_enum(ctx, atoms, len);
45254|      0|    atoms = NULL;
45255|      0|    name_val = JS_AtomToValue(ctx, name);
45256|      0|    if (JS_IsException(name_val))
45257|      0|        goto fail;
45258|      0|    args[0] = name_val;
45259|      0|    args[1] = val;
45260|      0|    res = JS_Call(ctx, reviver, holder, 2, args);
45261|      0|    JS_FreeValue(ctx, name_val);
45262|      0|    JS_FreeValue(ctx, val);
45263|      0|    return res;
45264|      0| fail:
45265|      0|    js_free_prop_enum(ctx, atoms, len);
45266|      0|    JS_FreeValue(ctx, val);
45267|      0|    return JS_EXCEPTION;
45268|      0|}
45269|       |
45270|       |static JSValue js_json_parse(JSContext *ctx, JSValueConst this_val,
45271|       |                             int argc, JSValueConst *argv)
45272|      0|{
45273|      0|    JSValue obj, root;
45274|      0|    JSValueConst reviver;
45275|      0|    const char *str;
45276|      0|    size_t len;
45277|       |
45278|      0|    str = JS_ToCStringLen(ctx, &len, argv[0]);
45279|      0|    if (!str)
45280|      0|        return JS_EXCEPTION;
45281|      0|    obj = JS_ParseJSON(ctx, str, len, "<input>");
45282|      0|    JS_FreeCString(ctx, str);
45283|      0|    if (JS_IsException(obj))
45284|      0|        return obj;
45285|      0|    if (argc > 1 && JS_IsFunction(ctx, argv[1])) {
45286|      0|        reviver = argv[1];
45287|      0|        root = JS_NewObject(ctx);
45288|      0|        if (JS_IsException(root)) {
45289|      0|            JS_FreeValue(ctx, obj);
45290|      0|            return JS_EXCEPTION;
45291|      0|        }
45292|      0|        if (JS_DefinePropertyValue(ctx, root, JS_ATOM_empty_string, obj,
45293|      0|                                   JS_PROP_C_W_E) < 0) {
45294|      0|            JS_FreeValue(ctx, root);
45295|      0|            return JS_EXCEPTION;
45296|      0|        }
45297|      0|        obj = internalize_json_property(ctx, root, JS_ATOM_empty_string,
45298|      0|                                        reviver);
45299|      0|        JS_FreeValue(ctx, root);
45300|      0|    }
45301|      0|    return obj;
45302|      0|}
45303|       |
45304|       |typedef struct JSONStringifyContext {
45305|       |    JSValueConst replacer_func;
45306|       |    JSValue stack;
45307|       |    JSValue property_list;
45308|       |    JSValue gap;
45309|       |    JSValue empty;
45310|       |    StringBuffer *b;
45311|       |} JSONStringifyContext;
45312|       |
45313|      0|static JSValue JS_ToQuotedStringFree(JSContext *ctx, JSValue val) {
45314|      0|    JSValue r = JS_ToQuotedString(ctx, val);
45315|      0|    JS_FreeValue(ctx, val);
45316|      0|    return r;
45317|      0|}
45318|       |
45319|       |static JSValue js_json_check(JSContext *ctx, JSONStringifyContext *jsc,
45320|       |                             JSValueConst holder, JSValue val, JSValueConst key)
45321|      0|{
45322|      0|    JSValue v;
45323|      0|    JSValueConst args[2];
45324|       |
45325|       |    /* check for object.toJSON method */
45326|       |    /* ECMA specifies this is done only for Object and BigInt */
45327|      0|    if (JS_IsObject(val) || JS_IsBigInt(ctx, val)) {
45328|      0|        JSValue f = JS_GetProperty(ctx, val, JS_ATOM_toJSON);
45329|      0|        if (JS_IsException(f))
45330|      0|            goto exception;
45331|      0|        if (JS_IsFunction(ctx, f)) {
45332|      0|            v = JS_CallFree(ctx, f, val, 1, &key);
45333|      0|            JS_FreeValue(ctx, val);
45334|      0|            val = v;
45335|      0|            if (JS_IsException(val))
45336|      0|                goto exception;
45337|      0|        } else {
45338|      0|            JS_FreeValue(ctx, f);
45339|      0|        }
45340|      0|    }
45341|       |
45342|      0|    if (!JS_IsUndefined(jsc->replacer_func)) {
45343|      0|        args[0] = key;
45344|      0|        args[1] = val;
45345|      0|        v = JS_Call(ctx, jsc->replacer_func, holder, 2, args);
45346|      0|        JS_FreeValue(ctx, val);
45347|      0|        val = v;
45348|      0|        if (JS_IsException(val))
45349|      0|            goto exception;
45350|      0|    }
45351|       |
45352|      0|    switch (JS_VALUE_GET_NORM_TAG(val)) {
45353|      0|    case JS_TAG_OBJECT:
45354|      0|        if (JS_IsFunction(ctx, val))
45355|      0|            break;
45356|      0|    case JS_TAG_STRING:
45357|      0|    case JS_TAG_STRING_ROPE:
45358|      0|    case JS_TAG_INT:
45359|      0|    case JS_TAG_FLOAT64:
45360|      0|    case JS_TAG_BOOL:
45361|      0|    case JS_TAG_NULL:
45362|      0|    case JS_TAG_SHORT_BIG_INT:
45363|      0|    case JS_TAG_BIG_INT:
45364|      0|    case JS_TAG_EXCEPTION:
45365|      0|        return val;
45366|      0|    default:
45367|      0|        break;
45368|      0|    }
45369|      0|    JS_FreeValue(ctx, val);
45370|      0|    return JS_UNDEFINED;
45371|       |
45372|      0|exception:
45373|      0|    JS_FreeValue(ctx, val);
45374|      0|    return JS_EXCEPTION;
45375|      0|}
45376|       |
45377|       |static int js_json_to_str(JSContext *ctx, JSONStringifyContext *jsc,
45378|       |                          JSValueConst holder, JSValue val,
45379|       |                          JSValueConst indent)
45380|      0|{
45381|      0|    JSValue indent1, sep, sep1, tab, v, prop;
45382|      0|    JSObject *p;
45383|      0|    int64_t i, len;
45384|      0|    int cl, ret;
45385|      0|    BOOL has_content;
45386|       |
45387|      0|    indent1 = JS_UNDEFINED;
45388|      0|    sep = JS_UNDEFINED;
45389|      0|    sep1 = JS_UNDEFINED;
45390|      0|    tab = JS_UNDEFINED;
45391|      0|    prop = JS_UNDEFINED;
45392|       |
45393|      0|    if (js_check_stack_overflow(ctx->rt, 0)) {
45394|      0|        JS_ThrowStackOverflow(ctx);
45395|      0|        goto exception;
45396|      0|    }
45397|       |
45398|      0|    if (JS_IsObject(val)) {
45399|      0|        p = JS_VALUE_GET_OBJ(val);
45400|      0|        cl = p->class_id;
45401|      0|        if (cl == JS_CLASS_STRING) {
45402|      0|            val = JS_ToStringFree(ctx, val);
45403|      0|            if (JS_IsException(val))
45404|      0|                goto exception;
45405|      0|            goto concat_primitive;
45406|      0|        } else if (cl == JS_CLASS_NUMBER) {
45407|      0|            val = JS_ToNumberFree(ctx, val);
45408|      0|            if (JS_IsException(val))
45409|      0|                goto exception;
45410|      0|            goto concat_primitive;
45411|      0|        } else if (cl == JS_CLASS_BOOLEAN || cl == JS_CLASS_BIG_INT)
45412|      0|        {
45413|       |            /* This will thow the same error as for the primitive object */
45414|      0|            set_value(ctx, &val, JS_DupValue(ctx, p->u.object_data));
45415|      0|            goto concat_primitive;
45416|      0|        }
45417|      0|        v = js_array_includes(ctx, jsc->stack, 1, (JSValueConst *)&val);
45418|      0|        if (JS_IsException(v))
45419|      0|            goto exception;
45420|      0|        if (JS_ToBoolFree(ctx, v)) {
45421|      0|            JS_ThrowTypeError(ctx, "circular reference");
45422|      0|            goto exception;
45423|      0|        }
45424|      0|        indent1 = JS_ConcatString(ctx, JS_DupValue(ctx, indent), JS_DupValue(ctx, jsc->gap));
45425|      0|        if (JS_IsException(indent1))
45426|      0|            goto exception;
45427|      0|        if (!JS_IsEmptyString(jsc->gap)) {
45428|      0|            sep = JS_ConcatString3(ctx, "\n", JS_DupValue(ctx, indent1), "");
45429|      0|            if (JS_IsException(sep))
45430|      0|                goto exception;
45431|      0|            sep1 = js_new_string8(ctx, " ");
45432|      0|            if (JS_IsException(sep1))
45433|      0|                goto exception;
45434|      0|        } else {
45435|      0|            sep = JS_DupValue(ctx, jsc->empty);
45436|      0|            sep1 = JS_DupValue(ctx, jsc->empty);
45437|      0|        }
45438|      0|        v = js_array_push(ctx, jsc->stack, 1, (JSValueConst *)&val, 0);
45439|      0|        if (check_exception_free(ctx, v))
45440|      0|            goto exception;
45441|      0|        ret = JS_IsArray(ctx, val);
45442|      0|        if (ret < 0)
45443|      0|            goto exception;
45444|      0|        if (ret) {
45445|      0|            if (js_get_length64(ctx, &len, val))
45446|      0|                goto exception;
45447|      0|            string_buffer_putc8(jsc->b, '[');
45448|      0|            for(i = 0; i < len; i++) {
45449|      0|                if (i > 0)
45450|      0|                    string_buffer_putc8(jsc->b, ',');
45451|      0|                string_buffer_concat_value(jsc->b, sep);
45452|      0|                v = JS_GetPropertyInt64(ctx, val, i);
45453|      0|                if (JS_IsException(v))
45454|      0|                    goto exception;
45455|       |                /* XXX: could do this string conversion only when needed */
45456|      0|                prop = JS_ToStringFree(ctx, JS_NewInt64(ctx, i));
45457|      0|                if (JS_IsException(prop))
45458|      0|                    goto exception;
45459|      0|                v = js_json_check(ctx, jsc, val, v, prop);
45460|      0|                JS_FreeValue(ctx, prop);
45461|      0|                prop = JS_UNDEFINED;
45462|      0|                if (JS_IsException(v))
45463|      0|                    goto exception;
45464|      0|                if (JS_IsUndefined(v))
45465|      0|                    v = JS_NULL;
45466|      0|                if (js_json_to_str(ctx, jsc, val, v, indent1))
45467|      0|                    goto exception;
45468|      0|            }
45469|      0|            if (len > 0 && !JS_IsEmptyString(jsc->gap)) {
45470|      0|                string_buffer_putc8(jsc->b, '\n');
45471|      0|                string_buffer_concat_value(jsc->b, indent);
45472|      0|            }
45473|      0|            string_buffer_putc8(jsc->b, ']');
45474|      0|        } else {
45475|      0|            if (!JS_IsUndefined(jsc->property_list))
45476|      0|                tab = JS_DupValue(ctx, jsc->property_list);
45477|      0|            else
45478|      0|                tab = js_object_keys(ctx, JS_UNDEFINED, 1, (JSValueConst *)&val, JS_ITERATOR_KIND_KEY);
45479|      0|            if (JS_IsException(tab))
45480|      0|                goto exception;
45481|      0|            if (js_get_length64(ctx, &len, tab))
45482|      0|                goto exception;
45483|      0|            string_buffer_putc8(jsc->b, '{');
45484|      0|            has_content = FALSE;
45485|      0|            for(i = 0; i < len; i++) {
45486|      0|                JS_FreeValue(ctx, prop);
45487|      0|                prop = JS_GetPropertyInt64(ctx, tab, i);
45488|      0|                if (JS_IsException(prop))
45489|      0|                    goto exception;
45490|      0|                v = JS_GetPropertyValue(ctx, val, JS_DupValue(ctx, prop));
45491|      0|                if (JS_IsException(v))
45492|      0|                    goto exception;
45493|      0|                v = js_json_check(ctx, jsc, val, v, prop);
45494|      0|                if (JS_IsException(v))
45495|      0|                    goto exception;
45496|      0|                if (!JS_IsUndefined(v)) {
45497|      0|                    if (has_content)
45498|      0|                        string_buffer_putc8(jsc->b, ',');
45499|      0|                    prop = JS_ToQuotedStringFree(ctx, prop);
45500|      0|                    if (JS_IsException(prop)) {
45501|      0|                        JS_FreeValue(ctx, v);
45502|      0|                        goto exception;
45503|      0|                    }
45504|      0|                    string_buffer_concat_value(jsc->b, sep);
45505|      0|                    string_buffer_concat_value(jsc->b, prop);
45506|      0|                    string_buffer_putc8(jsc->b, ':');
45507|      0|                    string_buffer_concat_value(jsc->b, sep1);
45508|      0|                    if (js_json_to_str(ctx, jsc, val, v, indent1))
45509|      0|                        goto exception;
45510|      0|                    has_content = TRUE;
45511|      0|                }
45512|      0|            }
45513|      0|            if (has_content && !JS_IsEmptyString(jsc->gap)) {
45514|      0|                string_buffer_putc8(jsc->b, '\n');
45515|      0|                string_buffer_concat_value(jsc->b, indent);
45516|      0|            }
45517|      0|            string_buffer_putc8(jsc->b, '}');
45518|      0|        }
45519|      0|        if (check_exception_free(ctx, js_array_pop(ctx, jsc->stack, 0, NULL, 0)))
45520|      0|            goto exception;
45521|      0|        JS_FreeValue(ctx, val);
45522|      0|        JS_FreeValue(ctx, tab);
45523|      0|        JS_FreeValue(ctx, sep);
45524|      0|        JS_FreeValue(ctx, sep1);
45525|      0|        JS_FreeValue(ctx, indent1);
45526|      0|        JS_FreeValue(ctx, prop);
45527|      0|        return 0;
45528|      0|    }
45529|      0| concat_primitive:
45530|      0|    switch (JS_VALUE_GET_NORM_TAG(val)) {
45531|      0|    case JS_TAG_STRING:
45532|      0|    case JS_TAG_STRING_ROPE:
45533|      0|        val = JS_ToQuotedStringFree(ctx, val);
45534|      0|        if (JS_IsException(val))
45535|      0|            goto exception;
45536|      0|        goto concat_value;
45537|      0|    case JS_TAG_FLOAT64:
45538|      0|        if (!isfinite(JS_VALUE_GET_FLOAT64(val))) {
45539|      0|            val = JS_NULL;
45540|      0|        }
45541|      0|        goto concat_value;
45542|      0|    case JS_TAG_INT:
45543|      0|    case JS_TAG_BOOL:
45544|      0|    case JS_TAG_NULL:
45545|      0|    concat_value:
45546|      0|        return string_buffer_concat_value_free(jsc->b, val);
45547|      0|    case JS_TAG_SHORT_BIG_INT:
45548|      0|    case JS_TAG_BIG_INT:
45549|       |        /* reject big numbers: use toJSON method to override */
45550|      0|        JS_ThrowTypeError(ctx, "Do not know how to serialize a BigInt");
45551|      0|        goto exception;
45552|      0|    default:
45553|      0|        JS_FreeValue(ctx, val);
45554|      0|        return 0;
45555|      0|    }
45556|       |
45557|      0|exception:
45558|      0|    JS_FreeValue(ctx, val);
45559|      0|    JS_FreeValue(ctx, tab);
45560|      0|    JS_FreeValue(ctx, sep);
45561|      0|    JS_FreeValue(ctx, sep1);
45562|      0|    JS_FreeValue(ctx, indent1);
45563|      0|    JS_FreeValue(ctx, prop);
45564|      0|    return -1;
45565|      0|}
45566|       |
45567|       |JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
45568|       |                         JSValueConst replacer, JSValueConst space0)
45569|      0|{
45570|      0|    StringBuffer b_s;
45571|      0|    JSONStringifyContext jsc_s, *jsc = &jsc_s;
45572|      0|    JSValue val, v, space, ret, wrapper;
45573|      0|    int res;
45574|      0|    int64_t i, j, n;
45575|       |
45576|      0|    jsc->replacer_func = JS_UNDEFINED;
45577|      0|    jsc->stack = JS_UNDEFINED;
45578|      0|    jsc->property_list = JS_UNDEFINED;
45579|      0|    jsc->gap = JS_UNDEFINED;
45580|      0|    jsc->b = &b_s;
45581|      0|    jsc->empty = JS_AtomToString(ctx, JS_ATOM_empty_string);
45582|      0|    ret = JS_UNDEFINED;
45583|      0|    wrapper = JS_UNDEFINED;
45584|       |
45585|      0|    string_buffer_init(ctx, jsc->b, 0);
45586|      0|    jsc->stack = JS_NewArray(ctx);
45587|      0|    if (JS_IsException(jsc->stack))
45588|      0|        goto exception;
45589|      0|    if (JS_IsFunction(ctx, replacer)) {
45590|      0|        jsc->replacer_func = replacer;
45591|      0|    } else {
45592|      0|        res = JS_IsArray(ctx, replacer);
45593|      0|        if (res < 0)
45594|      0|            goto exception;
45595|      0|        if (res) {
45596|       |            /* XXX: enumeration is not fully correct */
45597|      0|            jsc->property_list = JS_NewArray(ctx);
45598|      0|            if (JS_IsException(jsc->property_list))
45599|      0|                goto exception;
45600|      0|            if (js_get_length64(ctx, &n, replacer))
45601|      0|                goto exception;
45602|      0|            for (i = j = 0; i < n; i++) {
45603|      0|                JSValue present;
45604|      0|                v = JS_GetPropertyInt64(ctx, replacer, i);
45605|      0|                if (JS_IsException(v))
45606|      0|                    goto exception;
45607|      0|                if (JS_IsObject(v)) {
45608|      0|                    JSObject *p = JS_VALUE_GET_OBJ(v);
45609|      0|                    if (p->class_id == JS_CLASS_STRING ||
45610|      0|                        p->class_id == JS_CLASS_NUMBER) {
45611|      0|                        v = JS_ToStringFree(ctx, v);
45612|      0|                        if (JS_IsException(v))
45613|      0|                            goto exception;
45614|      0|                    } else {
45615|      0|                        JS_FreeValue(ctx, v);
45616|      0|                        continue;
45617|      0|                    }
45618|      0|                } else if (JS_IsNumber(v)) {
45619|      0|                    v = JS_ToStringFree(ctx, v);
45620|      0|                    if (JS_IsException(v))
45621|      0|                        goto exception;
45622|      0|                } else if (!JS_IsString(v)) {
45623|      0|                    JS_FreeValue(ctx, v);
45624|      0|                    continue;
45625|      0|                }
45626|      0|                present = js_array_includes(ctx, jsc->property_list,
45627|      0|                                            1, (JSValueConst *)&v);
45628|      0|                if (JS_IsException(present)) {
45629|      0|                    JS_FreeValue(ctx, v);
45630|      0|                    goto exception;
45631|      0|                }
45632|      0|                if (!JS_ToBoolFree(ctx, present)) {
45633|      0|                    JS_SetPropertyInt64(ctx, jsc->property_list, j++, v);
45634|      0|                } else {
45635|      0|                    JS_FreeValue(ctx, v);
45636|      0|                }
45637|      0|            }
45638|      0|        }
45639|      0|    }
45640|      0|    space = JS_DupValue(ctx, space0);
45641|      0|    if (JS_IsObject(space)) {
45642|      0|        JSObject *p = JS_VALUE_GET_OBJ(space);
45643|      0|        if (p->class_id == JS_CLASS_NUMBER) {
45644|      0|            space = JS_ToNumberFree(ctx, space);
45645|      0|        } else if (p->class_id == JS_CLASS_STRING) {
45646|      0|            space = JS_ToStringFree(ctx, space);
45647|      0|        }
45648|      0|        if (JS_IsException(space)) {
45649|      0|            JS_FreeValue(ctx, space);
45650|      0|            goto exception;
45651|      0|        }
45652|      0|    }
45653|      0|    if (JS_IsNumber(space)) {
45654|      0|        int n;
45655|      0|        if (JS_ToInt32Clamp(ctx, &n, space, 0, 10, 0))
45656|      0|            goto exception;
45657|      0|        jsc->gap = js_new_string8_len(ctx, "          ", n);
45658|      0|    } else if (JS_IsString(space)) {
45659|      0|        JSString *p = JS_VALUE_GET_STRING(space);
45660|      0|        jsc->gap = js_sub_string(ctx, p, 0, min_int(p->len, 10));
45661|      0|    } else {
45662|      0|        jsc->gap = JS_DupValue(ctx, jsc->empty);
45663|      0|    }
45664|      0|    JS_FreeValue(ctx, space);
45665|      0|    if (JS_IsException(jsc->gap))
45666|      0|        goto exception;
45667|      0|    wrapper = JS_NewObject(ctx);
45668|      0|    if (JS_IsException(wrapper))
45669|      0|        goto exception;
45670|      0|    if (JS_DefinePropertyValue(ctx, wrapper, JS_ATOM_empty_string,
45671|      0|                               JS_DupValue(ctx, obj), JS_PROP_C_W_E) < 0)
45672|      0|        goto exception;
45673|      0|    val = JS_DupValue(ctx, obj);
45674|       |
45675|      0|    val = js_json_check(ctx, jsc, wrapper, val, jsc->empty);
45676|      0|    if (JS_IsException(val))
45677|      0|        goto exception;
45678|      0|    if (JS_IsUndefined(val)) {
45679|      0|        ret = JS_UNDEFINED;
45680|      0|        goto done1;
45681|      0|    }
45682|      0|    if (js_json_to_str(ctx, jsc, wrapper, val, jsc->empty))
45683|      0|        goto exception;
45684|       |
45685|      0|    ret = string_buffer_end(jsc->b);
45686|      0|    goto done;
45687|       |
45688|      0|exception:
45689|      0|    ret = JS_EXCEPTION;
45690|      0|done1:
45691|      0|    string_buffer_free(jsc->b);
45692|      0|done:
45693|      0|    JS_FreeValue(ctx, wrapper);
45694|      0|    JS_FreeValue(ctx, jsc->empty);
45695|      0|    JS_FreeValue(ctx, jsc->gap);
45696|      0|    JS_FreeValue(ctx, jsc->property_list);
45697|      0|    JS_FreeValue(ctx, jsc->stack);
45698|      0|    return ret;
45699|      0|}
45700|       |
45701|       |static JSValue js_json_stringify(JSContext *ctx, JSValueConst this_val,
45702|       |                                 int argc, JSValueConst *argv)
45703|      0|{
45704|       |    // stringify(val, replacer, space)
45705|      0|    return JS_JSONStringify(ctx, argv[0], argv[1], argv[2]);
45706|      0|}
45707|       |
45708|       |static const JSCFunctionListEntry js_json_funcs[] = {
45709|       |    JS_CFUNC_DEF("parse", 2, js_json_parse ),
45710|       |    JS_CFUNC_DEF("stringify", 3, js_json_stringify ),
45711|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "JSON", JS_PROP_CONFIGURABLE ),
45712|       |};
45713|       |
45714|       |static const JSCFunctionListEntry js_json_obj[] = {
45715|       |    JS_OBJECT_DEF("JSON", js_json_funcs, countof(js_json_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
45716|       |};
45717|       |
45718|       |void JS_AddIntrinsicJSON(JSContext *ctx)
45719|  17.7k|{
45720|       |    /* add JSON as autoinit object */
45721|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_json_obj, countof(js_json_obj));
45722|  17.7k|}
45723|       |
45724|       |/* Reflect */
45725|       |
45726|       |static JSValue js_reflect_apply(JSContext *ctx, JSValueConst this_val,
45727|       |                                int argc, JSValueConst *argv)
45728|      0|{
45729|      0|    return js_function_apply(ctx, argv[0], max_int(0, argc - 1), argv + 1, 2);
45730|      0|}
45731|       |
45732|       |static JSValue js_reflect_construct(JSContext *ctx, JSValueConst this_val,
45733|       |                                    int argc, JSValueConst *argv)
45734|      0|{
45735|      0|    JSValueConst func, array_arg, new_target;
45736|      0|    JSValue *tab, ret;
45737|      0|    uint32_t len;
45738|       |
45739|      0|    func = argv[0];
45740|      0|    array_arg = argv[1];
45741|      0|    if (argc > 2) {
45742|      0|        new_target = argv[2];
45743|      0|        if (!JS_IsConstructor(ctx, new_target))
45744|      0|            return JS_ThrowTypeError(ctx, "not a constructor");
45745|      0|    } else {
45746|      0|        new_target = func;
45747|      0|    }
45748|      0|    tab = build_arg_list(ctx, &len, array_arg);
45749|      0|    if (!tab)
45750|      0|        return JS_EXCEPTION;
45751|      0|    ret = JS_CallConstructor2(ctx, func, new_target, len, (JSValueConst *)tab);
45752|      0|    free_arg_list(ctx, tab, len);
45753|      0|    return ret;
45754|      0|}
45755|       |
45756|       |static JSValue js_reflect_deleteProperty(JSContext *ctx, JSValueConst this_val,
45757|       |                                         int argc, JSValueConst *argv)
45758|      0|{
45759|      0|    JSValueConst obj;
45760|      0|    JSAtom atom;
45761|      0|    int ret;
45762|       |
45763|      0|    obj = argv[0];
45764|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
45765|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
45766|      0|    atom = JS_ValueToAtom(ctx, argv[1]);
45767|      0|    if (unlikely(atom == JS_ATOM_NULL))
45768|      0|        return JS_EXCEPTION;
45769|      0|    ret = JS_DeleteProperty(ctx, obj, atom, 0);
45770|      0|    JS_FreeAtom(ctx, atom);
45771|      0|    if (ret < 0)
45772|      0|        return JS_EXCEPTION;
45773|      0|    else
45774|      0|        return JS_NewBool(ctx, ret);
45775|      0|}
45776|       |
45777|       |static JSValue js_reflect_get(JSContext *ctx, JSValueConst this_val,
45778|       |                              int argc, JSValueConst *argv)
45779|      0|{
45780|      0|    JSValueConst obj, prop, receiver;
45781|      0|    JSAtom atom;
45782|      0|    JSValue ret;
45783|       |
45784|      0|    obj = argv[0];
45785|      0|    prop = argv[1];
45786|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
45787|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
45788|      0|    if (argc > 2)
45789|      0|        receiver = argv[2];
45790|      0|    else
45791|      0|        receiver = obj;
45792|      0|    atom = JS_ValueToAtom(ctx, prop);
45793|      0|    if (unlikely(atom == JS_ATOM_NULL))
45794|      0|        return JS_EXCEPTION;
45795|      0|    ret = JS_GetPropertyInternal(ctx, obj, atom, receiver, FALSE);
45796|      0|    JS_FreeAtom(ctx, atom);
45797|      0|    return ret;
45798|      0|}
45799|       |
45800|       |static JSValue js_reflect_has(JSContext *ctx, JSValueConst this_val,
45801|       |                              int argc, JSValueConst *argv)
45802|      0|{
45803|      0|    JSValueConst obj, prop;
45804|      0|    JSAtom atom;
45805|      0|    int ret;
45806|       |
45807|      0|    obj = argv[0];
45808|      0|    prop = argv[1];
45809|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
45810|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
45811|      0|    atom = JS_ValueToAtom(ctx, prop);
45812|      0|    if (unlikely(atom == JS_ATOM_NULL))
45813|      0|        return JS_EXCEPTION;
45814|      0|    ret = JS_HasProperty(ctx, obj, atom);
45815|      0|    JS_FreeAtom(ctx, atom);
45816|      0|    if (ret < 0)
45817|      0|        return JS_EXCEPTION;
45818|      0|    else
45819|      0|        return JS_NewBool(ctx, ret);
45820|      0|}
45821|       |
45822|       |static JSValue js_reflect_set(JSContext *ctx, JSValueConst this_val,
45823|       |                              int argc, JSValueConst *argv)
45824|      0|{
45825|      0|    JSValueConst obj, prop, val, receiver;
45826|      0|    int ret;
45827|      0|    JSAtom atom;
45828|       |
45829|      0|    obj = argv[0];
45830|      0|    prop = argv[1];
45831|      0|    val = argv[2];
45832|      0|    if (argc > 3)
45833|      0|        receiver = argv[3];
45834|      0|    else
45835|      0|        receiver = obj;
45836|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
45837|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
45838|      0|    atom = JS_ValueToAtom(ctx, prop);
45839|      0|    if (unlikely(atom == JS_ATOM_NULL))
45840|      0|        return JS_EXCEPTION;
45841|      0|    ret = JS_SetPropertyInternal(ctx, obj, atom,
45842|      0|                                 JS_DupValue(ctx, val), receiver, 0);
45843|      0|    JS_FreeAtom(ctx, atom);
45844|      0|    if (ret < 0)
45845|      0|        return JS_EXCEPTION;
45846|      0|    else
45847|      0|        return JS_NewBool(ctx, ret);
45848|      0|}
45849|       |
45850|       |static JSValue js_reflect_setPrototypeOf(JSContext *ctx, JSValueConst this_val,
45851|       |                                         int argc, JSValueConst *argv)
45852|      0|{
45853|      0|    int ret;
45854|      0|    ret = JS_SetPrototypeInternal(ctx, argv[0], argv[1], FALSE);
45855|      0|    if (ret < 0)
45856|      0|        return JS_EXCEPTION;
45857|      0|    else
45858|      0|        return JS_NewBool(ctx, ret);
45859|      0|}
45860|       |
45861|       |static JSValue js_reflect_ownKeys(JSContext *ctx, JSValueConst this_val,
45862|       |                                  int argc, JSValueConst *argv)
45863|      0|{
45864|      0|    if (JS_VALUE_GET_TAG(argv[0]) != JS_TAG_OBJECT)
45865|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
45866|      0|    return JS_GetOwnPropertyNames2(ctx, argv[0],
45867|      0|                                   JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK,
45868|      0|                                   JS_ITERATOR_KIND_KEY);
45869|      0|}
45870|       |
45871|       |static const JSCFunctionListEntry js_reflect_funcs[] = {
45872|       |    JS_CFUNC_DEF("apply", 3, js_reflect_apply ),
45873|       |    JS_CFUNC_DEF("construct", 2, js_reflect_construct ),
45874|       |    JS_CFUNC_MAGIC_DEF("defineProperty", 3, js_object_defineProperty, 1 ),
45875|       |    JS_CFUNC_DEF("deleteProperty", 2, js_reflect_deleteProperty ),
45876|       |    JS_CFUNC_DEF("get", 2, js_reflect_get ),
45877|       |    JS_CFUNC_MAGIC_DEF("getOwnPropertyDescriptor", 2, js_object_getOwnPropertyDescriptor, 1 ),
45878|       |    JS_CFUNC_MAGIC_DEF("getPrototypeOf", 1, js_object_getPrototypeOf, 1 ),
45879|       |    JS_CFUNC_DEF("has", 2, js_reflect_has ),
45880|       |    JS_CFUNC_MAGIC_DEF("isExtensible", 1, js_object_isExtensible, 1 ),
45881|       |    JS_CFUNC_DEF("ownKeys", 1, js_reflect_ownKeys ),
45882|       |    JS_CFUNC_MAGIC_DEF("preventExtensions", 1, js_object_preventExtensions, 1 ),
45883|       |    JS_CFUNC_DEF("set", 3, js_reflect_set ),
45884|       |    JS_CFUNC_DEF("setPrototypeOf", 2, js_reflect_setPrototypeOf ),
45885|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Reflect", JS_PROP_CONFIGURABLE ),
45886|       |};
45887|       |
45888|       |static const JSCFunctionListEntry js_reflect_obj[] = {
45889|       |    JS_OBJECT_DEF("Reflect", js_reflect_funcs, countof(js_reflect_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
45890|       |};
45891|       |
45892|       |/* Proxy */
45893|       |
45894|       |static void js_proxy_finalizer(JSRuntime *rt, JSValue val)
45895|      0|{
45896|      0|    JSProxyData *s = JS_GetOpaque(val, JS_CLASS_PROXY);
45897|      0|    if (s) {
45898|      0|        JS_FreeValueRT(rt, s->target);
45899|      0|        JS_FreeValueRT(rt, s->handler);
45900|      0|        js_free_rt(rt, s);
45901|      0|    }
45902|      0|}
45903|       |
45904|       |static void js_proxy_mark(JSRuntime *rt, JSValueConst val,
45905|       |                          JS_MarkFunc *mark_func)
45906|      0|{
45907|      0|    JSProxyData *s = JS_GetOpaque(val, JS_CLASS_PROXY);
45908|      0|    if (s) {
45909|      0|        JS_MarkValue(rt, s->target, mark_func);
45910|      0|        JS_MarkValue(rt, s->handler, mark_func);
45911|      0|    }
45912|      0|}
45913|       |
45914|       |static JSValue JS_ThrowTypeErrorRevokedProxy(JSContext *ctx)
45915|      0|{
45916|      0|    return JS_ThrowTypeError(ctx, "revoked proxy");
45917|      0|}
45918|       |
45919|       |static JSProxyData *get_proxy_method(JSContext *ctx, JSValue *pmethod,
45920|       |                                     JSValueConst obj, JSAtom name)
45921|      0|{
45922|      0|    JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);
45923|      0|    JSValue method;
45924|       |
45925|       |    /* safer to test recursion in all proxy methods */
45926|      0|    if (js_check_stack_overflow(ctx->rt, 0)) {
45927|      0|        JS_ThrowStackOverflow(ctx);
45928|      0|        return NULL;
45929|      0|    }
45930|       |
45931|       |    /* 's' should never be NULL */
45932|      0|    if (s->is_revoked) {
45933|      0|        JS_ThrowTypeErrorRevokedProxy(ctx);
45934|      0|        return NULL;
45935|      0|    }
45936|      0|    method = JS_GetProperty(ctx, s->handler, name);
45937|      0|    if (JS_IsException(method))
45938|      0|        return NULL;
45939|      0|    if (JS_IsNull(method))
45940|      0|        method = JS_UNDEFINED;
45941|      0|    *pmethod = method;
45942|      0|    return s;
45943|      0|}
45944|       |
45945|       |static JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj)
45946|      0|{
45947|      0|    JSProxyData *s;
45948|      0|    JSValue method, ret, proto1;
45949|      0|    int res;
45950|       |
45951|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_getPrototypeOf);
45952|      0|    if (!s)
45953|      0|        return JS_EXCEPTION;
45954|      0|    if (JS_IsUndefined(method))
45955|      0|        return JS_GetPrototype(ctx, s->target);
45956|      0|    ret = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);
45957|      0|    if (JS_IsException(ret))
45958|      0|        return ret;
45959|      0|    if (JS_VALUE_GET_TAG(ret) != JS_TAG_NULL &&
45960|      0|        JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {
45961|      0|        goto fail;
45962|      0|    }
45963|      0|    res = JS_IsExtensible(ctx, s->target);
45964|      0|    if (res < 0) {
45965|      0|        JS_FreeValue(ctx, ret);
45966|      0|        return JS_EXCEPTION;
45967|      0|    }
45968|      0|    if (!res) {
45969|       |        /* check invariant */
45970|      0|        proto1 = JS_GetPrototype(ctx, s->target);
45971|      0|        if (JS_IsException(proto1)) {
45972|      0|            JS_FreeValue(ctx, ret);
45973|      0|            return JS_EXCEPTION;
45974|      0|        }
45975|      0|        if (JS_VALUE_GET_OBJ(proto1) != JS_VALUE_GET_OBJ(ret)) {
45976|      0|            JS_FreeValue(ctx, proto1);
45977|      0|        fail:
45978|      0|            JS_FreeValue(ctx, ret);
45979|      0|            return JS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
45980|      0|        }
45981|      0|        JS_FreeValue(ctx, proto1);
45982|      0|    }
45983|      0|    return ret;
45984|      0|}
45985|       |
45986|       |static int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,
45987|       |                                   JSValueConst proto_val, BOOL throw_flag)
45988|      0|{
45989|      0|    JSProxyData *s;
45990|      0|    JSValue method, ret, proto1;
45991|      0|    JSValueConst args[2];
45992|      0|    BOOL res;
45993|      0|    int res2;
45994|       |
45995|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_setPrototypeOf);
45996|      0|    if (!s)
45997|      0|        return -1;
45998|      0|    if (JS_IsUndefined(method))
45999|      0|        return JS_SetPrototypeInternal(ctx, s->target, proto_val, throw_flag);
46000|      0|    args[0] = s->target;
46001|      0|    args[1] = proto_val;
46002|      0|    ret = JS_CallFree(ctx, method, s->handler, 2, args);
46003|      0|    if (JS_IsException(ret))
46004|      0|        return -1;
46005|      0|    res = JS_ToBoolFree(ctx, ret);
46006|      0|    if (!res) {
46007|      0|        if (throw_flag) {
46008|      0|            JS_ThrowTypeError(ctx, "proxy: bad prototype");
46009|      0|            return -1;
46010|      0|        } else {
46011|      0|            return FALSE;
46012|      0|        }
46013|      0|    }
46014|      0|    res2 = JS_IsExtensible(ctx, s->target);
46015|      0|    if (res2 < 0)
46016|      0|        return -1;
46017|      0|    if (!res2) {
46018|      0|        proto1 = JS_GetPrototype(ctx, s->target);
46019|      0|        if (JS_IsException(proto1))
46020|      0|            return -1;
46021|      0|        if (JS_VALUE_GET_OBJ(proto_val) != JS_VALUE_GET_OBJ(proto1)) {
46022|      0|            JS_FreeValue(ctx, proto1);
46023|      0|            JS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
46024|      0|            return -1;
46025|      0|        }
46026|      0|        JS_FreeValue(ctx, proto1);
46027|      0|    }
46028|      0|    return TRUE;
46029|      0|}
46030|       |
46031|       |static int js_proxy_isExtensible(JSContext *ctx, JSValueConst obj)
46032|      0|{
46033|      0|    JSProxyData *s;
46034|      0|    JSValue method, ret;
46035|      0|    BOOL res;
46036|      0|    int res2;
46037|       |
46038|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_isExtensible);
46039|      0|    if (!s)
46040|      0|        return -1;
46041|      0|    if (JS_IsUndefined(method))
46042|      0|        return JS_IsExtensible(ctx, s->target);
46043|      0|    ret = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);
46044|      0|    if (JS_IsException(ret))
46045|      0|        return -1;
46046|      0|    res = JS_ToBoolFree(ctx, ret);
46047|      0|    res2 = JS_IsExtensible(ctx, s->target);
46048|      0|    if (res2 < 0)
46049|      0|        return res2;
46050|      0|    if (res != res2) {
46051|      0|        JS_ThrowTypeError(ctx, "proxy: inconsistent isExtensible");
46052|      0|        return -1;
46053|      0|    }
46054|      0|    return res;
46055|      0|}
46056|       |
46057|       |static int js_proxy_preventExtensions(JSContext *ctx, JSValueConst obj)
46058|      0|{
46059|      0|    JSProxyData *s;
46060|      0|    JSValue method, ret;
46061|      0|    BOOL res;
46062|      0|    int res2;
46063|       |
46064|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_preventExtensions);
46065|      0|    if (!s)
46066|      0|        return -1;
46067|      0|    if (JS_IsUndefined(method))
46068|      0|        return JS_PreventExtensions(ctx, s->target);
46069|      0|    ret = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);
46070|      0|    if (JS_IsException(ret))
46071|      0|        return -1;
46072|      0|    res = JS_ToBoolFree(ctx, ret);
46073|      0|    if (res) {
46074|      0|        res2 = JS_IsExtensible(ctx, s->target);
46075|      0|        if (res2 < 0)
46076|      0|            return res2;
46077|      0|        if (res2) {
46078|      0|            JS_ThrowTypeError(ctx, "proxy: inconsistent preventExtensions");
46079|      0|            return -1;
46080|      0|        }
46081|      0|    }
46082|      0|    return res;
46083|      0|}
46084|       |
46085|       |static int js_proxy_has(JSContext *ctx, JSValueConst obj, JSAtom atom)
46086|      0|{
46087|      0|    JSProxyData *s;
46088|      0|    JSValue method, ret1, atom_val;
46089|      0|    int ret, res;
46090|      0|    JSObject *p;
46091|      0|    JSValueConst args[2];
46092|      0|    BOOL res2;
46093|       |
46094|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_has);
46095|      0|    if (!s)
46096|      0|        return -1;
46097|      0|    if (JS_IsUndefined(method))
46098|      0|        return JS_HasProperty(ctx, s->target, atom);
46099|      0|    atom_val = JS_AtomToValue(ctx, atom);
46100|      0|    if (JS_IsException(atom_val)) {
46101|      0|        JS_FreeValue(ctx, method);
46102|      0|        return -1;
46103|      0|    }
46104|      0|    args[0] = s->target;
46105|      0|    args[1] = atom_val;
46106|      0|    ret1 = JS_CallFree(ctx, method, s->handler, 2, args);
46107|      0|    JS_FreeValue(ctx, atom_val);
46108|      0|    if (JS_IsException(ret1))
46109|      0|        return -1;
46110|      0|    ret = JS_ToBoolFree(ctx, ret1);
46111|      0|    if (!ret) {
46112|      0|        JSPropertyDescriptor desc;
46113|      0|        p = JS_VALUE_GET_OBJ(s->target);
46114|      0|        res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);
46115|      0|        if (res < 0)
46116|      0|            return -1;
46117|      0|        if (res) {
46118|      0|            res2 = !(desc.flags & JS_PROP_CONFIGURABLE);
46119|      0|            js_free_desc(ctx, &desc);
46120|      0|            if (res2 || !p->extensible) {
46121|      0|                JS_ThrowTypeError(ctx, "proxy: inconsistent has");
46122|      0|                return -1;
46123|      0|            }
46124|      0|        }
46125|      0|    }
46126|      0|    return ret;
46127|      0|}
46128|       |
46129|       |static JSValue js_proxy_get(JSContext *ctx, JSValueConst obj, JSAtom atom,
46130|       |                            JSValueConst receiver)
46131|      0|{
46132|      0|    JSProxyData *s;
46133|      0|    JSValue method, ret, atom_val;
46134|      0|    int res;
46135|      0|    JSValueConst args[3];
46136|      0|    JSPropertyDescriptor desc;
46137|       |
46138|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_get);
46139|      0|    if (!s)
46140|      0|        return JS_EXCEPTION;
46141|       |    /* Note: recursion is possible thru the prototype of s->target */
46142|      0|    if (JS_IsUndefined(method))
46143|      0|        return JS_GetPropertyInternal(ctx, s->target, atom, receiver, FALSE);
46144|      0|    atom_val = JS_AtomToValue(ctx, atom);
46145|      0|    if (JS_IsException(atom_val)) {
46146|      0|        JS_FreeValue(ctx, method);
46147|      0|        return JS_EXCEPTION;
46148|      0|    }
46149|      0|    args[0] = s->target;
46150|      0|    args[1] = atom_val;
46151|      0|    args[2] = receiver;
46152|      0|    ret = JS_CallFree(ctx, method, s->handler, 3, args);
46153|      0|    JS_FreeValue(ctx, atom_val);
46154|      0|    if (JS_IsException(ret))
46155|      0|        return JS_EXCEPTION;
46156|      0|    res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target), atom);
46157|      0|    if (res < 0) {
46158|      0|        JS_FreeValue(ctx, ret);
46159|      0|        return JS_EXCEPTION;
46160|      0|    }
46161|      0|    if (res) {
46162|      0|        if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0) {
46163|      0|            if (!js_same_value(ctx, desc.value, ret)) {
46164|      0|                goto fail;
46165|      0|            }
46166|      0|        } else if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE)) == JS_PROP_GETSET) {
46167|      0|            if (JS_IsUndefined(desc.getter) && !JS_IsUndefined(ret)) {
46168|      0|            fail:
46169|      0|                js_free_desc(ctx, &desc);
46170|      0|                JS_FreeValue(ctx, ret);
46171|      0|                return JS_ThrowTypeError(ctx, "proxy: inconsistent get");
46172|      0|            }
46173|      0|        }
46174|      0|        js_free_desc(ctx, &desc);
46175|      0|    }
46176|      0|    return ret;
46177|      0|}
46178|       |
46179|       |static int js_proxy_set(JSContext *ctx, JSValueConst obj, JSAtom atom,
46180|       |                        JSValueConst value, JSValueConst receiver, int flags)
46181|      0|{
46182|      0|    JSProxyData *s;
46183|      0|    JSValue method, ret1, atom_val;
46184|      0|    int ret, res;
46185|      0|    JSValueConst args[4];
46186|       |
46187|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_set);
46188|      0|    if (!s)
46189|      0|        return -1;
46190|      0|    if (JS_IsUndefined(method)) {
46191|      0|        return JS_SetPropertyInternal(ctx, s->target, atom,
46192|      0|                                      JS_DupValue(ctx, value), receiver,
46193|      0|                                      flags);
46194|      0|    }
46195|      0|    atom_val = JS_AtomToValue(ctx, atom);
46196|      0|    if (JS_IsException(atom_val)) {
46197|      0|        JS_FreeValue(ctx, method);
46198|      0|        return -1;
46199|      0|    }
46200|      0|    args[0] = s->target;
46201|      0|    args[1] = atom_val;
46202|      0|    args[2] = value;
46203|      0|    args[3] = receiver;
46204|      0|    ret1 = JS_CallFree(ctx, method, s->handler, 4, args);
46205|      0|    JS_FreeValue(ctx, atom_val);
46206|      0|    if (JS_IsException(ret1))
46207|      0|        return -1;
46208|      0|    ret = JS_ToBoolFree(ctx, ret1);
46209|      0|    if (ret) {
46210|      0|        JSPropertyDescriptor desc;
46211|      0|        res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target), atom);
46212|      0|        if (res < 0)
46213|      0|            return -1;
46214|      0|        if (res) {
46215|      0|            if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0) {
46216|      0|                if (!js_same_value(ctx, desc.value, value)) {
46217|      0|                    goto fail;
46218|      0|                }
46219|      0|            } else if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE)) == JS_PROP_GETSET && JS_IsUndefined(desc.setter)) {
46220|      0|                fail:
46221|      0|                    js_free_desc(ctx, &desc);
46222|      0|                    JS_ThrowTypeError(ctx, "proxy: inconsistent set");
46223|      0|                    return -1;
46224|      0|            }
46225|      0|            js_free_desc(ctx, &desc);
46226|      0|        }
46227|      0|    } else {
46228|      0|        if ((flags & JS_PROP_THROW) ||
46229|      0|            ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
46230|      0|            JS_ThrowTypeError(ctx, "proxy: cannot set property");
46231|      0|            return -1;
46232|      0|        }
46233|      0|    }
46234|      0|    return ret;
46235|      0|}
46236|       |
46237|       |static JSValue js_create_desc(JSContext *ctx, JSValueConst val,
46238|       |                              JSValueConst getter, JSValueConst setter,
46239|       |                              int flags)
46240|      0|{
46241|      0|    JSValue ret;
46242|      0|    ret = JS_NewObject(ctx);
46243|      0|    if (JS_IsException(ret))
46244|      0|        return ret;
46245|      0|    if (flags & JS_PROP_HAS_GET) {
46246|      0|        JS_DefinePropertyValue(ctx, ret, JS_ATOM_get, JS_DupValue(ctx, getter),
46247|      0|                               JS_PROP_C_W_E);
46248|      0|    }
46249|      0|    if (flags & JS_PROP_HAS_SET) {
46250|      0|        JS_DefinePropertyValue(ctx, ret, JS_ATOM_set, JS_DupValue(ctx, setter),
46251|      0|                               JS_PROP_C_W_E);
46252|      0|    }
46253|      0|    if (flags & JS_PROP_HAS_VALUE) {
46254|      0|        JS_DefinePropertyValue(ctx, ret, JS_ATOM_value, JS_DupValue(ctx, val),
46255|      0|                               JS_PROP_C_W_E);
46256|      0|    }
46257|      0|    if (flags & JS_PROP_HAS_WRITABLE) {
46258|      0|        JS_DefinePropertyValue(ctx, ret, JS_ATOM_writable,
46259|      0|                               JS_NewBool(ctx, flags & JS_PROP_WRITABLE),
46260|      0|                               JS_PROP_C_W_E);
46261|      0|    }
46262|      0|    if (flags & JS_PROP_HAS_ENUMERABLE) {
46263|      0|        JS_DefinePropertyValue(ctx, ret, JS_ATOM_enumerable,
46264|      0|                               JS_NewBool(ctx, flags & JS_PROP_ENUMERABLE),
46265|      0|                               JS_PROP_C_W_E);
46266|      0|    }
46267|      0|    if (flags & JS_PROP_HAS_CONFIGURABLE) {
46268|      0|        JS_DefinePropertyValue(ctx, ret, JS_ATOM_configurable,
46269|      0|                               JS_NewBool(ctx, flags & JS_PROP_CONFIGURABLE),
46270|      0|                               JS_PROP_C_W_E);
46271|      0|    }
46272|      0|    return ret;
46273|      0|}
46274|       |
46275|       |static int js_proxy_get_own_property(JSContext *ctx, JSPropertyDescriptor *pdesc,
46276|       |                                     JSValueConst obj, JSAtom prop)
46277|      0|{
46278|      0|    JSProxyData *s;
46279|      0|    JSValue method, trap_result_obj, prop_val;
46280|      0|    int res, target_desc_ret, ret;
46281|      0|    JSObject *p;
46282|      0|    JSValueConst args[2];
46283|      0|    JSPropertyDescriptor result_desc, target_desc;
46284|       |
46285|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_getOwnPropertyDescriptor);
46286|      0|    if (!s)
46287|      0|        return -1;
46288|      0|    p = JS_VALUE_GET_OBJ(s->target);
46289|      0|    if (JS_IsUndefined(method)) {
46290|      0|        return JS_GetOwnPropertyInternal(ctx, pdesc, p, prop);
46291|      0|    }
46292|      0|    prop_val = JS_AtomToValue(ctx, prop);
46293|      0|    if (JS_IsException(prop_val)) {
46294|      0|        JS_FreeValue(ctx, method);
46295|      0|        return -1;
46296|      0|    }
46297|      0|    args[0] = s->target;
46298|      0|    args[1] = prop_val;
46299|      0|    trap_result_obj = JS_CallFree(ctx, method, s->handler, 2, args);
46300|      0|    JS_FreeValue(ctx, prop_val);
46301|      0|    if (JS_IsException(trap_result_obj))
46302|      0|        return -1;
46303|      0|    if (!JS_IsObject(trap_result_obj) && !JS_IsUndefined(trap_result_obj)) {
46304|      0|        JS_FreeValue(ctx, trap_result_obj);
46305|      0|        goto fail;
46306|      0|    }
46307|      0|    target_desc_ret = JS_GetOwnPropertyInternal(ctx, &target_desc, p, prop);
46308|      0|    if (target_desc_ret < 0) {
46309|      0|        JS_FreeValue(ctx, trap_result_obj);
46310|      0|        return -1;
46311|      0|    }
46312|      0|    if (target_desc_ret)
46313|      0|        js_free_desc(ctx, &target_desc);
46314|      0|    if (JS_IsUndefined(trap_result_obj)) {
46315|      0|        if (target_desc_ret) {
46316|      0|            if (!(target_desc.flags & JS_PROP_CONFIGURABLE) || !p->extensible)
46317|      0|                goto fail;
46318|      0|        }
46319|      0|        ret = FALSE;
46320|      0|    } else {
46321|      0|        int flags1, extensible_target;
46322|      0|        extensible_target = JS_IsExtensible(ctx, s->target);
46323|      0|        if (extensible_target < 0) {
46324|      0|            JS_FreeValue(ctx, trap_result_obj);
46325|      0|            return -1;
46326|      0|        }
46327|      0|        res = js_obj_to_desc(ctx, &result_desc, trap_result_obj);
46328|      0|        JS_FreeValue(ctx, trap_result_obj);
46329|      0|        if (res < 0)
46330|      0|            return -1;
46331|       |
46332|       |        /* convert the result_desc.flags to property flags */
46333|      0|        if (result_desc.flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
46334|      0|            result_desc.flags |= JS_PROP_GETSET;
46335|      0|        } else {
46336|      0|            result_desc.flags |= JS_PROP_NORMAL;
46337|      0|        }
46338|      0|        result_desc.flags &= (JS_PROP_C_W_E | JS_PROP_TMASK);
46339|       |        
46340|      0|        if (target_desc_ret) {
46341|       |            /* convert result_desc.flags to defineProperty flags */
46342|      0|            flags1 = result_desc.flags | JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_ENUMERABLE;
46343|      0|            if (result_desc.flags & JS_PROP_GETSET)
46344|      0|                flags1 |= JS_PROP_HAS_GET | JS_PROP_HAS_SET;
46345|      0|            else
46346|      0|                flags1 |= JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE;
46347|       |            /* XXX: not complete check: need to compare value &
46348|       |               getter/setter as in defineproperty */
46349|      0|            if (!check_define_prop_flags(target_desc.flags, flags1))
46350|      0|                goto fail1;
46351|      0|        } else {
46352|      0|            if (!extensible_target)
46353|      0|                goto fail1;
46354|      0|        }
46355|      0|        if (!(result_desc.flags & JS_PROP_CONFIGURABLE)) {
46356|      0|            if (!target_desc_ret || (target_desc.flags & JS_PROP_CONFIGURABLE))
46357|      0|                goto fail1;
46358|      0|            if ((result_desc.flags &
46359|      0|                 (JS_PROP_GETSET | JS_PROP_WRITABLE)) == 0 &&
46360|      0|                target_desc_ret &&
46361|      0|                (target_desc.flags & JS_PROP_WRITABLE) != 0) {
46362|       |                /* proxy-missing-checks */
46363|      0|            fail1:
46364|      0|                js_free_desc(ctx, &result_desc);
46365|      0|            fail:
46366|      0|                JS_ThrowTypeError(ctx, "proxy: inconsistent getOwnPropertyDescriptor");
46367|      0|                return -1;
46368|      0|            }
46369|      0|        }
46370|      0|        ret = TRUE;
46371|      0|        if (pdesc) {
46372|      0|            *pdesc = result_desc;
46373|      0|        } else {
46374|      0|            js_free_desc(ctx, &result_desc);
46375|      0|        }
46376|      0|    }
46377|      0|    return ret;
46378|      0|}
46379|       |
46380|       |static int js_proxy_define_own_property(JSContext *ctx, JSValueConst obj,
46381|       |                                        JSAtom prop, JSValueConst val,
46382|       |                                        JSValueConst getter, JSValueConst setter,
46383|       |                                        int flags)
46384|      0|{
46385|      0|    JSProxyData *s;
46386|      0|    JSValue method, ret1, prop_val, desc_val;
46387|      0|    int res, ret;
46388|      0|    JSObject *p;
46389|      0|    JSValueConst args[3];
46390|      0|    JSPropertyDescriptor desc;
46391|      0|    BOOL setting_not_configurable;
46392|       |
46393|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_defineProperty);
46394|      0|    if (!s)
46395|      0|        return -1;
46396|      0|    if (JS_IsUndefined(method)) {
46397|      0|        return JS_DefineProperty(ctx, s->target, prop, val, getter, setter, flags);
46398|      0|    }
46399|      0|    prop_val = JS_AtomToValue(ctx, prop);
46400|      0|    if (JS_IsException(prop_val)) {
46401|      0|        JS_FreeValue(ctx, method);
46402|      0|        return -1;
46403|      0|    }
46404|      0|    desc_val = js_create_desc(ctx, val, getter, setter, flags);
46405|      0|    if (JS_IsException(desc_val)) {
46406|      0|        JS_FreeValue(ctx, prop_val);
46407|      0|        JS_FreeValue(ctx, method);
46408|      0|        return -1;
46409|      0|    }
46410|      0|    args[0] = s->target;
46411|      0|    args[1] = prop_val;
46412|      0|    args[2] = desc_val;
46413|      0|    ret1 = JS_CallFree(ctx, method, s->handler, 3, args);
46414|      0|    JS_FreeValue(ctx, prop_val);
46415|      0|    JS_FreeValue(ctx, desc_val);
46416|      0|    if (JS_IsException(ret1))
46417|      0|        return -1;
46418|      0|    ret = JS_ToBoolFree(ctx, ret1);
46419|      0|    if (!ret) {
46420|      0|        if (flags & JS_PROP_THROW) {
46421|      0|            JS_ThrowTypeError(ctx, "proxy: defineProperty exception");
46422|      0|            return -1;
46423|      0|        } else {
46424|      0|            return 0;
46425|      0|        }
46426|      0|    }
46427|      0|    p = JS_VALUE_GET_OBJ(s->target);
46428|      0|    res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
46429|      0|    if (res < 0)
46430|      0|        return -1;
46431|      0|    setting_not_configurable = ((flags & (JS_PROP_HAS_CONFIGURABLE |
46432|      0|                                          JS_PROP_CONFIGURABLE)) ==
46433|      0|                                JS_PROP_HAS_CONFIGURABLE);
46434|      0|    if (!res) {
46435|      0|        if (!p->extensible || setting_not_configurable)
46436|      0|            goto fail;
46437|      0|    } else {
46438|      0|        if (!check_define_prop_flags(desc.flags, flags) ||
46439|      0|            ((desc.flags & JS_PROP_CONFIGURABLE) && setting_not_configurable)) {
46440|      0|            goto fail1;
46441|      0|        }
46442|      0|        if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
46443|      0|            if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE)) ==
46444|      0|                JS_PROP_GETSET) {
46445|      0|                if ((flags & JS_PROP_HAS_GET) &&
46446|      0|                    !js_same_value(ctx, getter, desc.getter)) {
46447|      0|                    goto fail1;
46448|      0|                }
46449|      0|                if ((flags & JS_PROP_HAS_SET) &&
46450|      0|                    !js_same_value(ctx, setter, desc.setter)) {
46451|      0|                    goto fail1;
46452|      0|                }
46453|      0|            }
46454|      0|        } else if (flags & JS_PROP_HAS_VALUE) {
46455|      0|            if ((desc.flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) ==
46456|      0|                JS_PROP_WRITABLE && !(flags & JS_PROP_WRITABLE)) {
46457|       |                /* missing-proxy-check feature */
46458|      0|                goto fail1;
46459|      0|            } else if ((desc.flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0 &&
46460|      0|                !js_same_value(ctx, val, desc.value)) {
46461|      0|                goto fail1;
46462|      0|            }
46463|      0|        }
46464|      0|        if (flags & JS_PROP_HAS_WRITABLE) {
46465|      0|            if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE |
46466|      0|                               JS_PROP_WRITABLE)) == JS_PROP_WRITABLE) {
46467|       |                /* proxy-missing-checks */
46468|      0|            fail1:
46469|      0|                js_free_desc(ctx, &desc);
46470|      0|            fail:
46471|      0|                JS_ThrowTypeError(ctx, "proxy: inconsistent defineProperty");
46472|      0|                return -1;
46473|      0|            }
46474|      0|        }
46475|      0|        js_free_desc(ctx, &desc);
46476|      0|    }
46477|      0|    return 1;
46478|      0|}
46479|       |
46480|       |static int js_proxy_delete_property(JSContext *ctx, JSValueConst obj,
46481|       |                                    JSAtom atom)
46482|      0|{
46483|      0|    JSProxyData *s;
46484|      0|    JSValue method, ret, atom_val;
46485|      0|    int res, res2, is_extensible;
46486|      0|    JSValueConst args[2];
46487|       |
46488|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_deleteProperty);
46489|      0|    if (!s)
46490|      0|        return -1;
46491|      0|    if (JS_IsUndefined(method)) {
46492|      0|        return JS_DeleteProperty(ctx, s->target, atom, 0);
46493|      0|    }
46494|      0|    atom_val = JS_AtomToValue(ctx, atom);;
46495|      0|    if (JS_IsException(atom_val)) {
46496|      0|        JS_FreeValue(ctx, method);
46497|      0|        return -1;
46498|      0|    }
46499|      0|    args[0] = s->target;
46500|      0|    args[1] = atom_val;
46501|      0|    ret = JS_CallFree(ctx, method, s->handler, 2, args);
46502|      0|    JS_FreeValue(ctx, atom_val);
46503|      0|    if (JS_IsException(ret))
46504|      0|        return -1;
46505|      0|    res = JS_ToBoolFree(ctx, ret);
46506|      0|    if (res) {
46507|      0|        JSPropertyDescriptor desc;
46508|      0|        res2 = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target), atom);
46509|      0|        if (res2 < 0)
46510|      0|            return -1;
46511|      0|        if (res2) {
46512|      0|            if (!(desc.flags & JS_PROP_CONFIGURABLE))
46513|      0|                goto fail;
46514|      0|            is_extensible = JS_IsExtensible(ctx, s->target);
46515|      0|            if (is_extensible < 0)
46516|      0|                goto fail1;
46517|      0|            if (!is_extensible) {
46518|       |                /* proxy-missing-checks */
46519|      0|            fail:
46520|      0|                JS_ThrowTypeError(ctx, "proxy: inconsistent deleteProperty");
46521|      0|            fail1:
46522|      0|                js_free_desc(ctx, &desc);
46523|      0|                return -1;
46524|      0|            }
46525|      0|            js_free_desc(ctx, &desc);
46526|      0|        }
46527|      0|    }
46528|      0|    return res;
46529|      0|}
46530|       |
46531|       |/* return the index of the property or -1 if not found */
46532|       |static int find_prop_key(const JSPropertyEnum *tab, int n, JSAtom atom)
46533|      0|{
46534|      0|    int i;
46535|      0|    for(i = 0; i < n; i++) {
46536|      0|        if (tab[i].atom == atom)
46537|      0|            return i;
46538|      0|    }
46539|      0|    return -1;
46540|      0|}
46541|       |
46542|       |static int js_proxy_get_own_property_names(JSContext *ctx,
46543|       |                                           JSPropertyEnum **ptab,
46544|       |                                           uint32_t *plen,
46545|       |                                           JSValueConst obj)
46546|      0|{
46547|      0|    JSProxyData *s;
46548|      0|    JSValue method, prop_array, val;
46549|      0|    uint32_t len, i, len2;
46550|      0|    JSPropertyEnum *tab, *tab2;
46551|      0|    JSAtom atom;
46552|      0|    JSPropertyDescriptor desc;
46553|      0|    int res, is_extensible, idx;
46554|       |
46555|      0|    s = get_proxy_method(ctx, &method, obj, JS_ATOM_ownKeys);
46556|      0|    if (!s)
46557|      0|        return -1;
46558|      0|    if (JS_IsUndefined(method)) {
46559|      0|        return JS_GetOwnPropertyNamesInternal(ctx, ptab, plen,
46560|      0|                                      JS_VALUE_GET_OBJ(s->target),
46561|      0|                                      JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK);
46562|      0|    }
46563|      0|    prop_array = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);
46564|      0|    if (JS_IsException(prop_array))
46565|      0|        return -1;
46566|      0|    tab = NULL;
46567|      0|    len = 0;
46568|      0|    tab2 = NULL;
46569|      0|    len2 = 0;
46570|      0|    if (js_get_length32(ctx, &len, prop_array))
46571|      0|        goto fail;
46572|      0|    if (len > 0) {
46573|      0|        tab = js_mallocz(ctx, sizeof(tab[0]) * len);
46574|      0|        if (!tab)
46575|      0|            goto fail;
46576|      0|    }
46577|      0|    for(i = 0; i < len; i++) {
46578|      0|        val = JS_GetPropertyUint32(ctx, prop_array, i);
46579|      0|        if (JS_IsException(val))
46580|      0|            goto fail;
46581|      0|        if (!JS_IsString(val) && !JS_IsSymbol(val)) {
46582|      0|            JS_FreeValue(ctx, val);
46583|      0|            JS_ThrowTypeError(ctx, "proxy: properties must be strings or symbols");
46584|      0|            goto fail;
46585|      0|        }
46586|      0|        atom = JS_ValueToAtom(ctx, val);
46587|      0|        JS_FreeValue(ctx, val);
46588|      0|        if (atom == JS_ATOM_NULL)
46589|      0|            goto fail;
46590|      0|        tab[i].atom = atom;
46591|      0|        tab[i].is_enumerable = FALSE; /* XXX: redundant? */
46592|      0|    }
46593|       |
46594|       |    /* check duplicate properties (XXX: inefficient, could store the
46595|       |     * properties an a temporary object to use the hash) */
46596|      0|    for(i = 1; i < len; i++) {
46597|      0|        if (find_prop_key(tab, i, tab[i].atom) >= 0) {
46598|      0|            JS_ThrowTypeError(ctx, "proxy: duplicate property");
46599|      0|            goto fail;
46600|      0|        }
46601|      0|    }
46602|       |
46603|      0|    is_extensible = JS_IsExtensible(ctx, s->target);
46604|      0|    if (is_extensible < 0)
46605|      0|        goto fail;
46606|       |
46607|       |    /* check if there are non configurable properties */
46608|      0|    if (s->is_revoked) {
46609|      0|        JS_ThrowTypeErrorRevokedProxy(ctx);
46610|      0|        goto fail;
46611|      0|    }
46612|      0|    if (JS_GetOwnPropertyNamesInternal(ctx, &tab2, &len2, JS_VALUE_GET_OBJ(s->target),
46613|      0|                               JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK))
46614|      0|        goto fail;
46615|      0|    for(i = 0; i < len2; i++) {
46616|      0|        if (s->is_revoked) {
46617|      0|            JS_ThrowTypeErrorRevokedProxy(ctx);
46618|      0|            goto fail;
46619|      0|        }
46620|      0|        res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target),
46621|      0|                                tab2[i].atom);
46622|      0|        if (res < 0)
46623|      0|            goto fail;
46624|      0|        if (res) {  /* safety, property should be found */
46625|      0|            js_free_desc(ctx, &desc);
46626|      0|            if (!(desc.flags & JS_PROP_CONFIGURABLE) || !is_extensible) {
46627|      0|                idx = find_prop_key(tab, len, tab2[i].atom);
46628|      0|                if (idx < 0) {
46629|      0|                    JS_ThrowTypeError(ctx, "proxy: target property must be present in proxy ownKeys");
46630|      0|                    goto fail;
46631|      0|                }
46632|       |                /* mark the property as found */
46633|      0|                if (!is_extensible)
46634|      0|                    tab[idx].is_enumerable = TRUE;
46635|      0|            }
46636|      0|        }
46637|      0|    }
46638|      0|    if (!is_extensible) {
46639|       |        /* check that all property in 'tab' were checked */
46640|      0|        for(i = 0; i < len; i++) {
46641|      0|            if (!tab[i].is_enumerable) {
46642|      0|                JS_ThrowTypeError(ctx, "proxy: property not present in target were returned by non extensible proxy");
46643|      0|                goto fail;
46644|      0|            }
46645|      0|        }
46646|      0|    }
46647|       |
46648|      0|    js_free_prop_enum(ctx, tab2, len2);
46649|      0|    JS_FreeValue(ctx, prop_array);
46650|      0|    *ptab = tab;
46651|      0|    *plen = len;
46652|      0|    return 0;
46653|      0| fail:
46654|      0|    js_free_prop_enum(ctx, tab2, len2);
46655|      0|    js_free_prop_enum(ctx, tab, len);
46656|      0|    JS_FreeValue(ctx, prop_array);
46657|      0|    return -1;
46658|      0|}
46659|       |
46660|       |static JSValue js_proxy_call_constructor(JSContext *ctx, JSValueConst func_obj,
46661|       |                                         JSValueConst new_target,
46662|       |                                         int argc, JSValueConst *argv)
46663|      0|{
46664|      0|    JSProxyData *s;
46665|      0|    JSValue method, arg_array, ret;
46666|      0|    JSValueConst args[3];
46667|       |
46668|      0|    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_construct);
46669|      0|    if (!s)
46670|      0|        return JS_EXCEPTION;
46671|      0|    if (!JS_IsConstructor(ctx, s->target))
46672|      0|        return JS_ThrowTypeError(ctx, "not a constructor");
46673|      0|    if (JS_IsUndefined(method))
46674|      0|        return JS_CallConstructor2(ctx, s->target, new_target, argc, argv);
46675|      0|    arg_array = js_create_array(ctx, argc, argv);
46676|      0|    if (JS_IsException(arg_array)) {
46677|      0|        ret = JS_EXCEPTION;
46678|      0|        goto fail;
46679|      0|    }
46680|      0|    args[0] = s->target;
46681|      0|    args[1] = arg_array;
46682|      0|    args[2] = new_target;
46683|      0|    ret = JS_Call(ctx, method, s->handler, 3, args);
46684|      0|    if (!JS_IsException(ret) && JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {
46685|      0|        JS_FreeValue(ctx, ret);
46686|      0|        ret = JS_ThrowTypeErrorNotAnObject(ctx);
46687|      0|    }
46688|      0| fail:
46689|      0|    JS_FreeValue(ctx, method);
46690|      0|    JS_FreeValue(ctx, arg_array);
46691|      0|    return ret;
46692|      0|}
46693|       |
46694|       |static JSValue js_proxy_call(JSContext *ctx, JSValueConst func_obj,
46695|       |                             JSValueConst this_obj,
46696|       |                             int argc, JSValueConst *argv, int flags)
46697|      0|{
46698|      0|    JSProxyData *s;
46699|      0|    JSValue method, arg_array, ret;
46700|      0|    JSValueConst args[3];
46701|       |
46702|      0|    if (flags & JS_CALL_FLAG_CONSTRUCTOR)
46703|      0|        return js_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);
46704|       |
46705|      0|    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_apply);
46706|      0|    if (!s)
46707|      0|        return JS_EXCEPTION;
46708|      0|    if (!s->is_func) {
46709|      0|        JS_FreeValue(ctx, method);
46710|      0|        return JS_ThrowTypeError(ctx, "not a function");
46711|      0|    }
46712|      0|    if (JS_IsUndefined(method))
46713|      0|        return JS_Call(ctx, s->target, this_obj, argc, argv);
46714|      0|    arg_array = js_create_array(ctx, argc, argv);
46715|      0|    if (JS_IsException(arg_array)) {
46716|      0|        ret = JS_EXCEPTION;
46717|      0|        goto fail;
46718|      0|    }
46719|      0|    args[0] = s->target;
46720|      0|    args[1] = this_obj;
46721|      0|    args[2] = arg_array;
46722|      0|    ret = JS_Call(ctx, method, s->handler, 3, args);
46723|      0| fail:
46724|      0|    JS_FreeValue(ctx, method);
46725|      0|    JS_FreeValue(ctx, arg_array);
46726|      0|    return ret;
46727|      0|}
46728|       |
46729|       |/* `js_resolve_proxy`: resolve the proxy chain
46730|       |   `*pval` is updated with to ultimate proxy target
46731|       |   `throw_exception` controls whether exceptions are thown or not
46732|       |   - return -1 in case of error
46733|       |   - otherwise return 0
46734|       | */
46735|    619|static int js_resolve_proxy(JSContext *ctx, JSValueConst *pval, BOOL throw_exception) {
46736|    619|    int depth = 0;
46737|    619|    JSObject *p;
46738|    619|    JSProxyData *s;
46739|       |
46740|    619|    while (JS_VALUE_GET_TAG(*pval) == JS_TAG_OBJECT) {
46741|    619|        p = JS_VALUE_GET_OBJ(*pval);
46742|    619|        if (p->class_id != JS_CLASS_PROXY)
46743|    619|            break;
46744|      0|        if (depth++ > 1000) {
46745|      0|            if (throw_exception)
46746|      0|                JS_ThrowStackOverflow(ctx);
46747|      0|            return -1;
46748|      0|        }
46749|      0|        s = p->u.opaque;
46750|      0|        if (s->is_revoked) {
46751|      0|            if (throw_exception)
46752|      0|                JS_ThrowTypeErrorRevokedProxy(ctx);
46753|      0|            return -1;
46754|      0|        }
46755|      0|        *pval = s->target;
46756|      0|    }
46757|    619|    return 0;
46758|    619|}
46759|       |
46760|       |static const JSClassExoticMethods js_proxy_exotic_methods = {
46761|       |    .get_own_property = js_proxy_get_own_property,
46762|       |    .define_own_property = js_proxy_define_own_property,
46763|       |    .delete_property = js_proxy_delete_property,
46764|       |    .get_own_property_names = js_proxy_get_own_property_names,
46765|       |    .has_property = js_proxy_has,
46766|       |    .get_property = js_proxy_get,
46767|       |    .set_property = js_proxy_set,
46768|       |};
46769|       |
46770|       |static JSValue js_proxy_constructor(JSContext *ctx, JSValueConst this_val,
46771|       |                                    int argc, JSValueConst *argv)
46772|      0|{
46773|      0|    JSValueConst target, handler;
46774|      0|    JSValue obj;
46775|      0|    JSProxyData *s;
46776|       |
46777|      0|    target = argv[0];
46778|      0|    handler = argv[1];
46779|      0|    if (JS_VALUE_GET_TAG(target) != JS_TAG_OBJECT ||
46780|      0|        JS_VALUE_GET_TAG(handler) != JS_TAG_OBJECT)
46781|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
46782|       |
46783|      0|    obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_PROXY);
46784|      0|    if (JS_IsException(obj))
46785|      0|        return obj;
46786|      0|    s = js_malloc(ctx, sizeof(JSProxyData));
46787|      0|    if (!s) {
46788|      0|        JS_FreeValue(ctx, obj);
46789|      0|        return JS_EXCEPTION;
46790|      0|    }
46791|      0|    s->target = JS_DupValue(ctx, target);
46792|      0|    s->handler = JS_DupValue(ctx, handler);
46793|      0|    s->is_func = JS_IsFunction(ctx, target);
46794|      0|    s->is_revoked = FALSE;
46795|      0|    JS_SetOpaque(obj, s);
46796|      0|    JS_SetConstructorBit(ctx, obj, JS_IsConstructor(ctx, target));
46797|      0|    return obj;
46798|      0|}
46799|       |
46800|       |static JSValue js_proxy_revoke(JSContext *ctx, JSValueConst this_val,
46801|       |                               int argc, JSValueConst *argv, int magic,
46802|       |                               JSValue *func_data)
46803|      0|{
46804|      0|    JSProxyData *s = JS_GetOpaque(func_data[0], JS_CLASS_PROXY);
46805|      0|    if (s) {
46806|       |        /* We do not free the handler and target in case they are
46807|       |           referenced as constants in the C call stack */
46808|      0|        s->is_revoked = TRUE;
46809|      0|        JS_FreeValue(ctx, func_data[0]);
46810|      0|        func_data[0] = JS_NULL;
46811|      0|    }
46812|      0|    return JS_UNDEFINED;
46813|      0|}
46814|       |
46815|       |static JSValue js_proxy_revoke_constructor(JSContext *ctx,
46816|       |                                           JSValueConst proxy_obj)
46817|      0|{
46818|      0|    return JS_NewCFunctionData(ctx, js_proxy_revoke, 0, 0, 1, &proxy_obj);
46819|      0|}
46820|       |
46821|       |static JSValue js_proxy_revocable(JSContext *ctx, JSValueConst this_val,
46822|       |                                 int argc, JSValueConst *argv)
46823|      0|{
46824|      0|    JSValue proxy_obj, revoke_obj = JS_UNDEFINED, obj;
46825|       |
46826|      0|    proxy_obj = js_proxy_constructor(ctx, JS_UNDEFINED, argc, argv);
46827|      0|    if (JS_IsException(proxy_obj))
46828|      0|        goto fail;
46829|      0|    revoke_obj = js_proxy_revoke_constructor(ctx, proxy_obj);
46830|      0|    if (JS_IsException(revoke_obj))
46831|      0|        goto fail;
46832|      0|    obj = JS_NewObject(ctx);
46833|      0|    if (JS_IsException(obj))
46834|      0|        goto fail;
46835|       |    // XXX: exceptions?
46836|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_proxy, proxy_obj, JS_PROP_C_W_E);
46837|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_revoke, revoke_obj, JS_PROP_C_W_E);
46838|      0|    return obj;
46839|      0| fail:
46840|      0|    JS_FreeValue(ctx, proxy_obj);
46841|      0|    JS_FreeValue(ctx, revoke_obj);
46842|      0|    return JS_EXCEPTION;
46843|      0|}
46844|       |
46845|       |static const JSCFunctionListEntry js_proxy_funcs[] = {
46846|       |    JS_CFUNC_DEF("revocable", 2, js_proxy_revocable ),
46847|       |};
46848|       |
46849|       |static const JSClassShortDef js_proxy_class_def[] = {
46850|       |    { JS_ATOM_Object, js_proxy_finalizer, js_proxy_mark }, /* JS_CLASS_PROXY */
46851|       |};
46852|       |
46853|       |void JS_AddIntrinsicProxy(JSContext *ctx)
46854|  17.7k|{
46855|  17.7k|    JSRuntime *rt = ctx->rt;
46856|  17.7k|    JSValue obj1;
46857|       |
46858|  17.7k|    if (!JS_IsRegisteredClass(rt, JS_CLASS_PROXY)) {
46859|  17.7k|        init_class_range(rt, js_proxy_class_def, JS_CLASS_PROXY,
46860|  17.7k|                         countof(js_proxy_class_def));
46861|  17.7k|        rt->class_array[JS_CLASS_PROXY].exotic = &js_proxy_exotic_methods;
46862|  17.7k|        rt->class_array[JS_CLASS_PROXY].call = js_proxy_call;
46863|  17.7k|    }
46864|       |
46865|  17.7k|    obj1 = JS_NewCFunction2(ctx, js_proxy_constructor, "Proxy", 2,
46866|  17.7k|                            JS_CFUNC_constructor, 0);
46867|  17.7k|    JS_SetConstructorBit(ctx, obj1, TRUE);
46868|  17.7k|    JS_SetPropertyFunctionList(ctx, obj1, js_proxy_funcs,
46869|  17.7k|                               countof(js_proxy_funcs));
46870|  17.7k|    JS_DefinePropertyValueStr(ctx, ctx->global_obj, "Proxy",
46871|  17.7k|                              obj1, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
46872|  17.7k|}
46873|       |
46874|       |/* Symbol */
46875|       |
46876|       |static JSValue js_symbol_constructor(JSContext *ctx, JSValueConst new_target,
46877|       |                                     int argc, JSValueConst *argv)
46878|      0|{
46879|      0|    JSValue str;
46880|      0|    JSString *p;
46881|       |
46882|      0|    if (!JS_IsUndefined(new_target))
46883|      0|        return JS_ThrowTypeError(ctx, "not a constructor");
46884|      0|    if (argc == 0 || JS_IsUndefined(argv[0])) {
46885|      0|        p = NULL;
46886|      0|    } else {
46887|      0|        str = JS_ToString(ctx, argv[0]);
46888|      0|        if (JS_IsException(str))
46889|      0|            return JS_EXCEPTION;
46890|      0|        p = JS_VALUE_GET_STRING(str);
46891|      0|    }
46892|      0|    return JS_NewSymbol(ctx, p, JS_ATOM_TYPE_SYMBOL);
46893|      0|}
46894|       |
46895|       |static JSValue js_thisSymbolValue(JSContext *ctx, JSValueConst this_val)
46896|      0|{
46897|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_SYMBOL)
46898|      0|        return JS_DupValue(ctx, this_val);
46899|       |
46900|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
46901|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
46902|      0|        if (p->class_id == JS_CLASS_SYMBOL) {
46903|      0|            if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_SYMBOL)
46904|      0|                return JS_DupValue(ctx, p->u.object_data);
46905|      0|        }
46906|      0|    }
46907|      0|    return JS_ThrowTypeError(ctx, "not a symbol");
46908|      0|}
46909|       |
46910|       |static JSValue js_symbol_toString(JSContext *ctx, JSValueConst this_val,
46911|       |                                  int argc, JSValueConst *argv)
46912|      0|{
46913|      0|    JSValue val, ret;
46914|      0|    val = js_thisSymbolValue(ctx, this_val);
46915|      0|    if (JS_IsException(val))
46916|      0|        return val;
46917|       |    /* XXX: use JS_ToStringInternal() with a flags */
46918|      0|    ret = js_string_constructor(ctx, JS_UNDEFINED, 1, (JSValueConst *)&val);
46919|      0|    JS_FreeValue(ctx, val);
46920|      0|    return ret;
46921|      0|}
46922|       |
46923|       |static JSValue js_symbol_valueOf(JSContext *ctx, JSValueConst this_val,
46924|       |                                 int argc, JSValueConst *argv)
46925|      0|{
46926|      0|    return js_thisSymbolValue(ctx, this_val);
46927|      0|}
46928|       |
46929|       |static JSValue js_symbol_get_description(JSContext *ctx, JSValueConst this_val)
46930|      0|{
46931|      0|    JSValue val, ret;
46932|      0|    JSAtomStruct *p;
46933|       |
46934|      0|    val = js_thisSymbolValue(ctx, this_val);
46935|      0|    if (JS_IsException(val))
46936|      0|        return val;
46937|      0|    p = JS_VALUE_GET_PTR(val);
46938|      0|    if (p->len == 0 && p->is_wide_char != 0) {
46939|      0|        ret = JS_UNDEFINED;
46940|      0|    } else {
46941|      0|        ret = JS_AtomToString(ctx, js_get_atom_index(ctx->rt, p));
46942|      0|    }
46943|      0|    JS_FreeValue(ctx, val);
46944|      0|    return ret;
46945|      0|}
46946|       |
46947|       |static const JSCFunctionListEntry js_symbol_proto_funcs[] = {
46948|       |    JS_CFUNC_DEF("toString", 0, js_symbol_toString ),
46949|       |    JS_CFUNC_DEF("valueOf", 0, js_symbol_valueOf ),
46950|       |    // XXX: should have writable: false
46951|       |    JS_CFUNC_DEF("[Symbol.toPrimitive]", 1, js_symbol_valueOf ),
46952|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Symbol", JS_PROP_CONFIGURABLE ),
46953|       |    JS_CGETSET_DEF("description", js_symbol_get_description, NULL ),
46954|       |};
46955|       |
46956|       |static JSValue js_symbol_for(JSContext *ctx, JSValueConst this_val,
46957|       |                             int argc, JSValueConst *argv)
46958|      0|{
46959|      0|    JSValue str;
46960|       |
46961|      0|    str = JS_ToString(ctx, argv[0]);
46962|      0|    if (JS_IsException(str))
46963|      0|        return JS_EXCEPTION;
46964|      0|    return JS_NewSymbol(ctx, JS_VALUE_GET_STRING(str), JS_ATOM_TYPE_GLOBAL_SYMBOL);
46965|      0|}
46966|       |
46967|       |static JSValue js_symbol_keyFor(JSContext *ctx, JSValueConst this_val,
46968|       |                                int argc, JSValueConst *argv)
46969|      0|{
46970|      0|    JSAtomStruct *p;
46971|       |
46972|      0|    if (!JS_IsSymbol(argv[0]))
46973|      0|        return JS_ThrowTypeError(ctx, "not a symbol");
46974|      0|    p = JS_VALUE_GET_PTR(argv[0]);
46975|      0|    if (p->atom_type != JS_ATOM_TYPE_GLOBAL_SYMBOL)
46976|      0|        return JS_UNDEFINED;
46977|      0|    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));
46978|      0|}
46979|       |
46980|       |static const JSCFunctionListEntry js_symbol_funcs[] = {
46981|       |    JS_CFUNC_DEF("for", 1, js_symbol_for ),
46982|       |    JS_CFUNC_DEF("keyFor", 1, js_symbol_keyFor ),
46983|       |};
46984|       |
46985|       |/* Set/Map/WeakSet/WeakMap */
46986|       |
46987|       |typedef struct JSMapRecord {
46988|       |    int ref_count; /* used during enumeration to avoid freeing the record */
46989|       |    BOOL empty : 8; /* TRUE if the record is deleted */
46990|       |    struct list_head link;
46991|       |    struct JSMapRecord *hash_next;
46992|       |    JSValue key;
46993|       |    JSValue value;
46994|       |} JSMapRecord;
46995|       |
46996|       |typedef struct JSMapState {
46997|       |    BOOL is_weak; /* TRUE if WeakSet/WeakMap */
46998|       |    struct list_head records; /* list of JSMapRecord.link */
46999|       |    uint32_t record_count;
47000|       |    JSMapRecord **hash_table;
47001|       |    int hash_bits;
47002|       |    uint32_t hash_size; /* = 2 ^ hash_bits */
47003|       |    uint32_t record_count_threshold; /* count at which a hash table
47004|       |                                        resize is needed */
47005|       |    JSWeakRefHeader weakref_header; /* only used if is_weak = TRUE */
47006|       |} JSMapState;
47007|       |
47008|       |static BOOL js_weakref_is_target(JSValueConst val)
47009|      0|{
47010|      0|    switch (JS_VALUE_GET_TAG(val)) {
47011|      0|    case JS_TAG_OBJECT:
47012|      0|        return TRUE;
47013|      0|    case JS_TAG_SYMBOL:
47014|      0|        {
47015|      0|            JSAtomStruct *p = JS_VALUE_GET_PTR(val);
47016|      0|            if (p->atom_type == JS_ATOM_TYPE_SYMBOL &&
47017|      0|                p->hash != JS_ATOM_HASH_PRIVATE)
47018|      0|                return TRUE;
47019|      0|        }
47020|      0|        break;
47021|      0|    default:
47022|      0|        break;
47023|      0|    }
47024|      0|    return FALSE;
47025|      0|}
47026|       |
47027|       |/* JS_UNDEFINED is considered as a live weakref */
47028|       |/* XXX: add a specific JSWeakRef value type ? */
47029|       |static BOOL js_weakref_is_live(JSValueConst val)
47030|      0|{
47031|      0|    int *pref_count;
47032|      0|    if (JS_IsUndefined(val))
47033|      0|        return TRUE;
47034|      0|    pref_count = JS_VALUE_GET_PTR(val);
47035|      0|    return (*pref_count != 0);
47036|      0|}
47037|       |
47038|       |/* 'val' can be JS_UNDEFINED */
47039|       |static void js_weakref_free(JSRuntime *rt, JSValue val)
47040|      0|{
47041|      0|    if (JS_VALUE_GET_TAG(val) == JS_TAG_OBJECT) {
47042|      0|        JSObject *p = JS_VALUE_GET_OBJ(val);
47043|      0|        assert(p->weakref_count >= 1);
47044|      0|        p->weakref_count--;
47045|       |        /* 'mark' is tested to avoid freeing the object structure when
47046|       |           it is about to be freed in a cycle or in
47047|       |           free_zero_refcount() */
47048|      0|        if (p->weakref_count == 0 && p->header.ref_count == 0 &&
47049|      0|            p->header.mark == 0) {
47050|      0|            js_free_rt(rt, p);
47051|      0|        }
47052|      0|    } else if (JS_VALUE_GET_TAG(val) == JS_TAG_SYMBOL) {
47053|      0|        JSString *p = JS_VALUE_GET_STRING(val);
47054|      0|        assert(p->hash >= 1);
47055|      0|        p->hash--;
47056|      0|        if (p->hash == 0 && p->header.ref_count == 0) {
47057|       |            /* can remove the dummy structure */
47058|      0|            js_free_rt(rt, p);
47059|      0|        }
47060|      0|    }
47061|      0|}
47062|       |
47063|       |/* val must be an object, a symbol or undefined (see
47064|       |   js_weakref_is_target). */
47065|       |static JSValue js_weakref_new(JSContext *ctx, JSValueConst val)
47066|      0|{
47067|      0|    if (JS_VALUE_GET_TAG(val) == JS_TAG_OBJECT) {
47068|      0|        JSObject *p = JS_VALUE_GET_OBJ(val);
47069|      0|        p->weakref_count++;
47070|      0|    } else if (JS_VALUE_GET_TAG(val) == JS_TAG_SYMBOL) {
47071|      0|        JSString *p = JS_VALUE_GET_STRING(val);
47072|       |        /* XXX: could return an exception if too many references */
47073|      0|        assert(p->hash < JS_ATOM_HASH_MASK - 2);
47074|      0|        p->hash++;
47075|      0|    } else {
47076|      0|        assert(JS_IsUndefined(val));
47077|      0|    }
47078|      0|    return (JSValue)val;
47079|      0|}
47080|       |
47081|      0|#define MAGIC_SET (1 << 0)
47082|      0|#define MAGIC_WEAK (1 << 1)
47083|       |
47084|       |static JSValue js_map_constructor(JSContext *ctx, JSValueConst new_target,
47085|       |                                  int argc, JSValueConst *argv, int magic)
47086|      0|{
47087|      0|    JSMapState *s;
47088|      0|    JSValue obj, adder = JS_UNDEFINED, iter = JS_UNDEFINED, next_method = JS_UNDEFINED;
47089|      0|    JSValueConst arr;
47090|      0|    BOOL is_set, is_weak;
47091|       |
47092|      0|    is_set = magic & MAGIC_SET;
47093|      0|    is_weak = ((magic & MAGIC_WEAK) != 0);
47094|      0|    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_MAP + magic);
47095|      0|    if (JS_IsException(obj))
47096|      0|        return JS_EXCEPTION;
47097|      0|    s = js_mallocz(ctx, sizeof(*s));
47098|      0|    if (!s)
47099|      0|        goto fail;
47100|      0|    init_list_head(&s->records);
47101|      0|    s->is_weak = is_weak;
47102|      0|    if (is_weak) {
47103|      0|        s->weakref_header.weakref_type = JS_WEAKREF_TYPE_MAP;
47104|      0|        list_add_tail(&s->weakref_header.link, &ctx->rt->weakref_list);
47105|      0|    }
47106|      0|    JS_SetOpaque(obj, s);
47107|      0|    s->hash_bits = 1;
47108|      0|    s->hash_size = 1U << s->hash_bits;
47109|      0|    s->hash_table = js_mallocz(ctx, sizeof(s->hash_table[0]) * s->hash_size);
47110|      0|    if (!s->hash_table)
47111|      0|        goto fail;
47112|      0|    s->record_count_threshold = 4;
47113|       |
47114|      0|    arr = JS_UNDEFINED;
47115|      0|    if (argc > 0)
47116|      0|        arr = argv[0];
47117|      0|    if (!JS_IsUndefined(arr) && !JS_IsNull(arr)) {
47118|      0|        JSValue item, ret;
47119|      0|        BOOL done;
47120|       |
47121|      0|        adder = JS_GetProperty(ctx, obj, is_set ? JS_ATOM_add : JS_ATOM_set);
47122|      0|        if (JS_IsException(adder))
47123|      0|            goto fail;
47124|      0|        if (!JS_IsFunction(ctx, adder)) {
47125|      0|            JS_ThrowTypeError(ctx, "set/add is not a function");
47126|      0|            goto fail;
47127|      0|        }
47128|       |
47129|      0|        iter = JS_GetIterator(ctx, arr, FALSE);
47130|      0|        if (JS_IsException(iter))
47131|      0|            goto fail;
47132|      0|        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
47133|      0|        if (JS_IsException(next_method))
47134|      0|            goto fail;
47135|       |
47136|      0|        for(;;) {
47137|      0|            item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
47138|      0|            if (JS_IsException(item))
47139|      0|                goto fail;
47140|      0|            if (done)
47141|      0|                break;
47142|      0|            if (is_set) {
47143|      0|                ret = JS_Call(ctx, adder, obj, 1, (JSValueConst *)&item);
47144|      0|                if (JS_IsException(ret)) {
47145|      0|                    JS_FreeValue(ctx, item);
47146|      0|                    goto fail;
47147|      0|                }
47148|      0|            } else {
47149|      0|                JSValue key, value;
47150|      0|                JSValueConst args[2];
47151|      0|                key = JS_UNDEFINED;
47152|      0|                value = JS_UNDEFINED;
47153|      0|                if (!JS_IsObject(item)) {
47154|      0|                    JS_ThrowTypeErrorNotAnObject(ctx);
47155|      0|                    goto fail1;
47156|      0|                }
47157|      0|                key = JS_GetPropertyUint32(ctx, item, 0);
47158|      0|                if (JS_IsException(key))
47159|      0|                    goto fail1;
47160|      0|                value = JS_GetPropertyUint32(ctx, item, 1);
47161|      0|                if (JS_IsException(value))
47162|      0|                    goto fail1;
47163|      0|                args[0] = key;
47164|      0|                args[1] = value;
47165|      0|                ret = JS_Call(ctx, adder, obj, 2, args);
47166|      0|                if (JS_IsException(ret)) {
47167|      0|                fail1:
47168|      0|                    JS_FreeValue(ctx, item);
47169|      0|                    JS_FreeValue(ctx, key);
47170|      0|                    JS_FreeValue(ctx, value);
47171|      0|                    goto fail;
47172|      0|                }
47173|      0|                JS_FreeValue(ctx, key);
47174|      0|                JS_FreeValue(ctx, value);
47175|      0|            }
47176|      0|            JS_FreeValue(ctx, ret);
47177|      0|            JS_FreeValue(ctx, item);
47178|      0|        }
47179|      0|        JS_FreeValue(ctx, next_method);
47180|      0|        JS_FreeValue(ctx, iter);
47181|      0|        JS_FreeValue(ctx, adder);
47182|      0|    }
47183|      0|    return obj;
47184|      0| fail:
47185|      0|    if (JS_IsObject(iter)) {
47186|       |        /* close the iterator object, preserving pending exception */
47187|      0|        JS_IteratorClose(ctx, iter, TRUE);
47188|      0|    }
47189|      0|    JS_FreeValue(ctx, next_method);
47190|      0|    JS_FreeValue(ctx, iter);
47191|      0|    JS_FreeValue(ctx, adder);
47192|      0|    JS_FreeValue(ctx, obj);
47193|      0|    return JS_EXCEPTION;
47194|      0|}
47195|       |
47196|       |/* XXX: could normalize strings to speed up comparison */
47197|       |static JSValueConst map_normalize_key(JSContext *ctx, JSValueConst key)
47198|      0|{
47199|      0|    uint32_t tag = JS_VALUE_GET_TAG(key);
47200|       |    /* convert -0.0 to +0.0 */
47201|      0|    if (JS_TAG_IS_FLOAT64(tag) && JS_VALUE_GET_FLOAT64(key) == 0.0) {
47202|      0|        key = JS_NewInt32(ctx, 0);
47203|      0|    }
47204|      0|    return key;
47205|      0|}
47206|       |
47207|       |/* hash multipliers, same as the Linux kernel (see Knuth vol 3,
47208|       |   section 6.4, exercise 9) */
47209|      0|#define HASH_MUL32 0x61C88647
47210|      0|#define HASH_MUL64 UINT64_C(0x61C8864680B583EB)
47211|       |
47212|       |static uint32_t map_hash32(uint32_t a, int hash_bits)
47213|      0|{
47214|      0|    return (a * HASH_MUL32) >> (32 - hash_bits);
47215|      0|}
47216|       |
47217|       |static uint32_t map_hash64(uint64_t a, int hash_bits)
47218|      0|{
47219|      0|    return (a * HASH_MUL64) >> (64 - hash_bits);
47220|      0|}
47221|       |
47222|       |static uint32_t map_hash_pointer(uintptr_t a, int hash_bits)
47223|      0|{
47224|      0|#ifdef JS_PTR64
47225|      0|    return map_hash64(a, hash_bits);
47226|       |#else
47227|       |    return map_hash32(a, hash_bits);
47228|       |#endif
47229|      0|}
47230|       |
47231|       |/* XXX: better hash ? */
47232|       |/* precondition: 1 <= hash_bits <= 32 */
47233|       |static uint32_t map_hash_key(JSValueConst key, int hash_bits)
47234|      0|{
47235|      0|    uint32_t tag = JS_VALUE_GET_NORM_TAG(key);
47236|      0|    uint32_t h;
47237|      0|    double d;
47238|      0|    JSBigInt *p;
47239|      0|    JSBigIntBuf buf;
47240|       |    
47241|      0|    switch(tag) {
47242|      0|    case JS_TAG_BOOL:
47243|      0|        h = map_hash32(JS_VALUE_GET_INT(key) ^ JS_TAG_BOOL, hash_bits);
47244|      0|        break;
47245|      0|    case JS_TAG_STRING:
47246|      0|        h = map_hash32(hash_string(JS_VALUE_GET_STRING(key), 0) ^ JS_TAG_STRING, hash_bits);
47247|      0|        break;
47248|      0|    case JS_TAG_STRING_ROPE:
47249|      0|        h = map_hash32(hash_string_rope(key, 0) ^ JS_TAG_STRING, hash_bits);
47250|      0|        break;
47251|      0|    case JS_TAG_OBJECT:
47252|      0|    case JS_TAG_SYMBOL:
47253|      0|        h = map_hash_pointer((uintptr_t)JS_VALUE_GET_PTR(key) ^ tag, hash_bits);
47254|      0|        break;
47255|      0|    case JS_TAG_INT:
47256|      0|        d = JS_VALUE_GET_INT(key);
47257|      0|        goto hash_float64;
47258|      0|    case JS_TAG_FLOAT64:
47259|      0|        d = JS_VALUE_GET_FLOAT64(key);
47260|       |        /* normalize the NaN */
47261|      0|        if (isnan(d))
47262|      0|            d = JS_FLOAT64_NAN;
47263|      0|    hash_float64:
47264|      0|        h = map_hash64(float64_as_uint64(d) ^ JS_TAG_FLOAT64, hash_bits);
47265|      0|        break;
47266|      0|    case JS_TAG_SHORT_BIG_INT:
47267|      0|        p = js_bigint_set_short(&buf, key);
47268|      0|        goto hash_bigint;
47269|      0|    case JS_TAG_BIG_INT:
47270|      0|        p = JS_VALUE_GET_PTR(key);
47271|      0|    hash_bigint:
47272|      0|        {
47273|      0|            int i;
47274|      0|            h = 1;
47275|      0|            for(i = p->len - 1; i >= 0; i--) {
47276|      0|                h = h * 263 + p->tab[i];
47277|      0|            }
47278|       |            /* the final step is necessary otherwise h mod n only
47279|       |               depends of p->tab[i] mod n */
47280|      0|            h = map_hash32(h ^ JS_TAG_BIG_INT, hash_bits);
47281|      0|        }
47282|      0|        break;
47283|      0|    default:
47284|      0|        h = 0;
47285|      0|        break;
47286|      0|    }
47287|      0|    return h;
47288|      0|}
47289|       |
47290|       |static JSMapRecord *map_find_record(JSContext *ctx, JSMapState *s,
47291|       |                                    JSValueConst key)
47292|      0|{
47293|      0|    JSMapRecord *mr;
47294|      0|    uint32_t h;
47295|      0|    h = map_hash_key(key, s->hash_bits);
47296|      0|    for(mr = s->hash_table[h]; mr != NULL; mr = mr->hash_next) {
47297|      0|        if (mr->empty || (s->is_weak && !js_weakref_is_live(mr->key))) {
47298|       |            /* cannot match */
47299|      0|        } else {
47300|      0|            if (js_same_value_zero(ctx, mr->key, key))
47301|      0|                return mr;
47302|      0|        }
47303|      0|    }
47304|      0|    return NULL;
47305|      0|}
47306|       |
47307|       |static void map_hash_resize(JSContext *ctx, JSMapState *s)
47308|      0|{
47309|      0|    uint32_t new_hash_size, h;
47310|      0|    int new_hash_bits;
47311|      0|    struct list_head *el;
47312|      0|    JSMapRecord *mr, **new_hash_table;
47313|       |
47314|       |    /* XXX: no reporting of memory allocation failure */
47315|      0|    new_hash_bits = min_int(s->hash_bits + 1, 31);
47316|      0|    new_hash_size = 1U << new_hash_bits;
47317|      0|    new_hash_table = js_realloc(ctx, s->hash_table,
47318|      0|                                sizeof(new_hash_table[0]) * new_hash_size);
47319|      0|    if (!new_hash_table)
47320|      0|        return;
47321|       |
47322|      0|    memset(new_hash_table, 0, sizeof(new_hash_table[0]) * new_hash_size);
47323|       |
47324|      0|    list_for_each(el, &s->records) {
47325|      0|        mr = list_entry(el, JSMapRecord, link);
47326|      0|        if (mr->empty || (s->is_weak && !js_weakref_is_live(mr->key))) {
47327|      0|        } else {
47328|      0|            h = map_hash_key(mr->key, new_hash_bits);
47329|      0|            mr->hash_next = new_hash_table[h];
47330|      0|            new_hash_table[h] = mr;
47331|      0|        }
47332|      0|    }
47333|      0|    s->hash_table = new_hash_table;
47334|      0|    s->hash_bits = new_hash_bits;
47335|      0|    s->hash_size = new_hash_size;
47336|      0|    s->record_count_threshold = new_hash_size * 2;
47337|      0|}
47338|       |
47339|       |static JSMapRecord *map_add_record(JSContext *ctx, JSMapState *s,
47340|       |                                   JSValueConst key)
47341|      0|{
47342|      0|    uint32_t h;
47343|      0|    JSMapRecord *mr;
47344|       |
47345|      0|    mr = js_malloc(ctx, sizeof(*mr));
47346|      0|    if (!mr)
47347|      0|        return NULL;
47348|      0|    mr->ref_count = 1;
47349|      0|    mr->empty = FALSE;
47350|      0|    if (s->is_weak) {
47351|      0|        mr->key = js_weakref_new(ctx, key);
47352|      0|    } else {
47353|      0|        mr->key = JS_DupValue(ctx, key);
47354|      0|    }
47355|      0|    h = map_hash_key(key, s->hash_bits);
47356|      0|    mr->hash_next = s->hash_table[h];
47357|      0|    s->hash_table[h] = mr;
47358|      0|    list_add_tail(&mr->link, &s->records);
47359|      0|    s->record_count++;
47360|      0|    if (s->record_count >= s->record_count_threshold) {
47361|      0|        map_hash_resize(ctx, s);
47362|      0|    }
47363|      0|    return mr;
47364|      0|}
47365|       |
47366|       |/* warning: the record must be removed from the hash table before */
47367|       |static void map_delete_record(JSRuntime *rt, JSMapState *s, JSMapRecord *mr)
47368|      0|{
47369|      0|    if (mr->empty)
47370|      0|        return;
47371|       |    
47372|      0|    if (s->is_weak) {
47373|      0|        js_weakref_free(rt, mr->key);
47374|      0|    } else {
47375|      0|        JS_FreeValueRT(rt, mr->key);
47376|      0|    }
47377|      0|    JS_FreeValueRT(rt, mr->value);
47378|      0|    if (--mr->ref_count == 0) {
47379|      0|        list_del(&mr->link);
47380|      0|        js_free_rt(rt, mr);
47381|      0|    } else {
47382|       |        /* keep a zombie record for iterators */
47383|      0|        mr->empty = TRUE;
47384|      0|        mr->key = JS_UNDEFINED;
47385|      0|        mr->value = JS_UNDEFINED;
47386|      0|    }
47387|      0|    s->record_count--;
47388|      0|}
47389|       |
47390|       |static void map_decref_record(JSRuntime *rt, JSMapRecord *mr)
47391|      0|{
47392|      0|    if (--mr->ref_count == 0) {
47393|       |        /* the record can be safely removed */
47394|      0|        assert(mr->empty);
47395|      0|        list_del(&mr->link);
47396|      0|        js_free_rt(rt, mr);
47397|      0|    }
47398|      0|}
47399|       |
47400|       |static void map_delete_weakrefs(JSRuntime *rt, JSWeakRefHeader *wh)
47401|      0|{
47402|      0|    JSMapState *s = container_of(wh, JSMapState, weakref_header);
47403|      0|    struct list_head *el, *el1;
47404|      0|    JSMapRecord *mr1, **pmr;
47405|      0|    uint32_t h;
47406|       |
47407|      0|    list_for_each_safe(el, el1, &s->records) {
47408|      0|        JSMapRecord *mr = list_entry(el, JSMapRecord, link);
47409|      0|        if (!js_weakref_is_live(mr->key)) {
47410|       |
47411|       |            /* even if key is not live it can be hashed as a pointer */
47412|      0|            h = map_hash_key(mr->key, s->hash_bits);
47413|      0|            pmr = &s->hash_table[h];
47414|      0|            for(;;) {
47415|      0|                mr1 = *pmr;
47416|       |                /* the entry may already be removed from the hash
47417|       |                   table if the map was resized */
47418|      0|                if (mr1 == NULL)
47419|      0|                    goto done; 
47420|      0|                if (mr1 == mr)
47421|      0|                    break;
47422|      0|                pmr = &mr1->hash_next;
47423|      0|            }
47424|       |            /* remove from the hash table */
47425|      0|            *pmr = mr1->hash_next;
47426|      0|        done:
47427|      0|            map_delete_record(rt, s, mr);
47428|      0|        }
47429|      0|    }
47430|      0|}
47431|       |
47432|       |static JSValue js_map_set(JSContext *ctx, JSValueConst this_val,
47433|       |                          int argc, JSValueConst *argv, int magic)
47434|      0|{
47435|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47436|      0|    JSMapRecord *mr;
47437|      0|    JSValueConst key, value;
47438|       |
47439|      0|    if (!s)
47440|      0|        return JS_EXCEPTION;
47441|      0|    key = map_normalize_key(ctx, argv[0]);
47442|      0|    if (s->is_weak && !js_weakref_is_target(key))
47443|      0|        return JS_ThrowTypeError(ctx, "invalid value used as %s key", (magic & MAGIC_SET) ? "WeakSet" : "WeakMap");
47444|      0|    if (magic & MAGIC_SET)
47445|      0|        value = JS_UNDEFINED;
47446|      0|    else
47447|      0|        value = argv[1];
47448|      0|    mr = map_find_record(ctx, s, key);
47449|      0|    if (mr) {
47450|      0|        JS_FreeValue(ctx, mr->value);
47451|      0|    } else {
47452|      0|        mr = map_add_record(ctx, s, key);
47453|      0|        if (!mr)
47454|      0|            return JS_EXCEPTION;
47455|      0|    }
47456|      0|    mr->value = JS_DupValue(ctx, value);
47457|      0|    return JS_DupValue(ctx, this_val);
47458|      0|}
47459|       |
47460|       |static JSValue js_map_get(JSContext *ctx, JSValueConst this_val,
47461|       |                          int argc, JSValueConst *argv, int magic)
47462|      0|{
47463|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47464|      0|    JSMapRecord *mr;
47465|      0|    JSValueConst key;
47466|       |
47467|      0|    if (!s)
47468|      0|        return JS_EXCEPTION;
47469|      0|    key = map_normalize_key(ctx, argv[0]);
47470|      0|    mr = map_find_record(ctx, s, key);
47471|      0|    if (!mr)
47472|      0|        return JS_UNDEFINED;
47473|      0|    else
47474|      0|        return JS_DupValue(ctx, mr->value);
47475|      0|}
47476|       |
47477|       |static JSValue js_map_has(JSContext *ctx, JSValueConst this_val,
47478|       |                          int argc, JSValueConst *argv, int magic)
47479|      0|{
47480|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47481|      0|    JSMapRecord *mr;
47482|      0|    JSValueConst key;
47483|       |
47484|      0|    if (!s)
47485|      0|        return JS_EXCEPTION;
47486|      0|    key = map_normalize_key(ctx, argv[0]);
47487|      0|    mr = map_find_record(ctx, s, key);
47488|      0|    return JS_NewBool(ctx, mr != NULL);
47489|      0|}
47490|       |
47491|       |static JSValue js_map_delete(JSContext *ctx, JSValueConst this_val,
47492|       |                             int argc, JSValueConst *argv, int magic)
47493|      0|{
47494|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47495|      0|    JSMapRecord *mr, **pmr;
47496|      0|    JSValueConst key;
47497|      0|    uint32_t h;
47498|       |
47499|      0|    if (!s)
47500|      0|        return JS_EXCEPTION;
47501|      0|    key = map_normalize_key(ctx, argv[0]);
47502|       |    
47503|      0|    h = map_hash_key(key, s->hash_bits);
47504|      0|    pmr = &s->hash_table[h];
47505|      0|    for(;;) {
47506|      0|        mr = *pmr;
47507|      0|        if (mr == NULL)
47508|      0|            return JS_FALSE;
47509|      0|        if (mr->empty || (s->is_weak && !js_weakref_is_live(mr->key))) {
47510|       |            /* not valid */
47511|      0|        } else {
47512|      0|            if (js_same_value_zero(ctx, mr->key, key))
47513|      0|                break;
47514|      0|        }
47515|      0|        pmr = &mr->hash_next;
47516|      0|    }
47517|       |
47518|       |    /* remove from the hash table */
47519|      0|    *pmr = mr->hash_next;
47520|       |    
47521|      0|    map_delete_record(ctx->rt, s, mr);
47522|      0|    return JS_TRUE;
47523|      0|}
47524|       |
47525|       |static JSValue js_map_clear(JSContext *ctx, JSValueConst this_val,
47526|       |                            int argc, JSValueConst *argv, int magic)
47527|      0|{
47528|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47529|      0|    struct list_head *el, *el1;
47530|      0|    JSMapRecord *mr;
47531|       |
47532|      0|    if (!s)
47533|      0|        return JS_EXCEPTION;
47534|       |
47535|       |    /* remove from the hash table */
47536|      0|    memset(s->hash_table, 0, sizeof(s->hash_table[0]) * s->hash_size);
47537|       |    
47538|      0|    list_for_each_safe(el, el1, &s->records) {
47539|      0|        mr = list_entry(el, JSMapRecord, link);
47540|      0|        map_delete_record(ctx->rt, s, mr);
47541|      0|    }
47542|      0|    return JS_UNDEFINED;
47543|      0|}
47544|       |
47545|       |static JSValue js_map_get_size(JSContext *ctx, JSValueConst this_val, int magic)
47546|      0|{
47547|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47548|      0|    if (!s)
47549|      0|        return JS_EXCEPTION;
47550|      0|    return JS_NewUint32(ctx, s->record_count);
47551|      0|}
47552|       |
47553|       |static JSValue js_map_forEach(JSContext *ctx, JSValueConst this_val,
47554|       |                              int argc, JSValueConst *argv, int magic)
47555|      0|{
47556|      0|    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47557|      0|    JSValueConst func, this_arg;
47558|      0|    JSValue ret, args[3];
47559|      0|    struct list_head *el;
47560|      0|    JSMapRecord *mr;
47561|       |
47562|      0|    if (!s)
47563|      0|        return JS_EXCEPTION;
47564|      0|    func = argv[0];
47565|      0|    if (argc > 1)
47566|      0|        this_arg = argv[1];
47567|      0|    else
47568|      0|        this_arg = JS_UNDEFINED;
47569|      0|    if (check_function(ctx, func))
47570|      0|        return JS_EXCEPTION;
47571|       |    /* Note: the list can be modified while traversing it, but the
47572|       |       current element is locked */
47573|      0|    el = s->records.next;
47574|      0|    while (el != &s->records) {
47575|      0|        mr = list_entry(el, JSMapRecord, link);
47576|      0|        if (!mr->empty) {
47577|      0|            mr->ref_count++;
47578|       |            /* must duplicate in case the record is deleted */
47579|      0|            args[1] = JS_DupValue(ctx, mr->key);
47580|      0|            if (magic)
47581|      0|                args[0] = args[1];
47582|      0|            else
47583|      0|                args[0] = JS_DupValue(ctx, mr->value);
47584|      0|            args[2] = (JSValue)this_val;
47585|      0|            ret = JS_Call(ctx, func, this_arg, 3, (JSValueConst *)args);
47586|      0|            JS_FreeValue(ctx, args[0]);
47587|      0|            if (!magic)
47588|      0|                JS_FreeValue(ctx, args[1]);
47589|      0|            el = el->next;
47590|      0|            map_decref_record(ctx->rt, mr);
47591|      0|            if (JS_IsException(ret))
47592|      0|                return ret;
47593|      0|            JS_FreeValue(ctx, ret);
47594|      0|        } else {
47595|      0|            el = el->next;
47596|      0|        }
47597|      0|    }
47598|      0|    return JS_UNDEFINED;
47599|      0|}
47600|       |
47601|       |static JSValue js_object_groupBy(JSContext *ctx, JSValueConst this_val,
47602|       |                                 int argc, JSValueConst *argv, int is_map)
47603|      0|{
47604|      0|    JSValueConst cb, args[2];
47605|      0|    JSValue res, iter, next, groups, key, v, prop;
47606|      0|    JSAtom key_atom = JS_ATOM_NULL;
47607|      0|    int64_t idx;
47608|      0|    BOOL done;
47609|       |
47610|       |    // "is function?" check must be observed before argv[0] is accessed
47611|      0|    cb = argv[1];
47612|      0|    if (check_function(ctx, cb))
47613|      0|        return JS_EXCEPTION;
47614|       |
47615|      0|    iter = JS_GetIterator(ctx, argv[0], /*is_async*/FALSE);
47616|      0|    if (JS_IsException(iter))
47617|      0|        return JS_EXCEPTION;
47618|       |
47619|      0|    key = JS_UNDEFINED;
47620|      0|    key_atom = JS_ATOM_NULL;
47621|      0|    v = JS_UNDEFINED;
47622|      0|    prop = JS_UNDEFINED;
47623|      0|    groups = JS_UNDEFINED;
47624|       |
47625|      0|    next = JS_GetProperty(ctx, iter, JS_ATOM_next);
47626|      0|    if (JS_IsException(next))
47627|      0|        goto exception;
47628|       |
47629|      0|    if (is_map) {
47630|      0|        groups = js_map_constructor(ctx, JS_UNDEFINED, 0, NULL, 0);
47631|      0|    } else {
47632|      0|        groups = JS_NewObjectProto(ctx, JS_NULL);
47633|      0|    }
47634|      0|    if (JS_IsException(groups))
47635|      0|        goto exception;
47636|       |
47637|      0|    for (idx = 0; ; idx++) {
47638|      0|        if (idx >= MAX_SAFE_INTEGER) {
47639|      0|            JS_ThrowTypeError(ctx, "too many elements");
47640|      0|            goto iterator_close_exception;
47641|      0|        }
47642|      0|        v = JS_IteratorNext(ctx, iter, next, 0, NULL, &done);
47643|      0|        if (JS_IsException(v))
47644|      0|            goto exception;
47645|      0|        if (done)
47646|      0|            break; // v is JS_UNDEFINED
47647|       |
47648|      0|        args[0] = v;
47649|      0|        args[1] = JS_NewInt64(ctx, idx);
47650|      0|        key = JS_Call(ctx, cb, ctx->global_obj, 2, args);
47651|      0|        if (JS_IsException(key))
47652|      0|            goto iterator_close_exception;
47653|       |
47654|      0|        if (is_map) {
47655|      0|            prop = js_map_get(ctx, groups, 1, (JSValueConst *)&key, 0);
47656|      0|        } else {
47657|      0|            key_atom = JS_ValueToAtom(ctx, key);
47658|      0|            JS_FreeValue(ctx, key);
47659|      0|            key = JS_UNDEFINED;
47660|      0|            if (key_atom == JS_ATOM_NULL)
47661|      0|                goto iterator_close_exception;
47662|      0|            prop = JS_GetProperty(ctx, groups, key_atom);
47663|      0|        }
47664|      0|        if (JS_IsException(prop))
47665|      0|            goto exception;
47666|       |
47667|      0|        if (JS_IsUndefined(prop)) {
47668|      0|            prop = JS_NewArray(ctx);
47669|      0|            if (JS_IsException(prop))
47670|      0|                goto exception;
47671|      0|            if (is_map) {
47672|      0|                args[0] = key;
47673|      0|                args[1] = prop;
47674|      0|                res = js_map_set(ctx, groups, 2, args, 0);
47675|      0|                if (JS_IsException(res))
47676|      0|                    goto exception;
47677|      0|                JS_FreeValue(ctx, res);
47678|      0|            } else {
47679|      0|                prop = JS_DupValue(ctx, prop);
47680|      0|                if (JS_DefinePropertyValue(ctx, groups, key_atom, prop,
47681|      0|                                           JS_PROP_C_W_E) < 0) {
47682|      0|                    goto exception;
47683|      0|                }
47684|      0|            }
47685|      0|        }
47686|      0|        res = js_array_push(ctx, prop, 1, (JSValueConst *)&v, /*unshift*/0);
47687|      0|        if (JS_IsException(res))
47688|      0|            goto exception;
47689|       |        // res is an int64
47690|       |
47691|      0|        JS_FreeValue(ctx, prop);
47692|      0|        JS_FreeValue(ctx, key);
47693|      0|        JS_FreeAtom(ctx, key_atom);
47694|      0|        JS_FreeValue(ctx, v);
47695|      0|        prop = JS_UNDEFINED;
47696|      0|        key = JS_UNDEFINED;
47697|      0|        key_atom = JS_ATOM_NULL;
47698|      0|        v = JS_UNDEFINED;
47699|      0|    }
47700|       |
47701|      0|    JS_FreeValue(ctx, iter);
47702|      0|    JS_FreeValue(ctx, next);
47703|      0|    return groups;
47704|       |
47705|      0| iterator_close_exception:
47706|      0|    JS_IteratorClose(ctx, iter, TRUE);
47707|      0| exception:
47708|      0|    JS_FreeAtom(ctx, key_atom);
47709|      0|    JS_FreeValue(ctx, prop);
47710|      0|    JS_FreeValue(ctx, key);
47711|      0|    JS_FreeValue(ctx, v);
47712|      0|    JS_FreeValue(ctx, groups);
47713|      0|    JS_FreeValue(ctx, iter);
47714|      0|    JS_FreeValue(ctx, next);
47715|      0|    return JS_EXCEPTION;
47716|      0|}
47717|       |
47718|       |static void js_map_finalizer(JSRuntime *rt, JSValue val)
47719|      0|{
47720|      0|    JSObject *p;
47721|      0|    JSMapState *s;
47722|      0|    struct list_head *el, *el1;
47723|      0|    JSMapRecord *mr;
47724|       |
47725|      0|    p = JS_VALUE_GET_OBJ(val);
47726|      0|    s = p->u.map_state;
47727|      0|    if (s) {
47728|       |        /* if the object is deleted we are sure that no iterator is
47729|       |           using it */
47730|      0|        list_for_each_safe(el, el1, &s->records) {
47731|      0|            mr = list_entry(el, JSMapRecord, link);
47732|      0|            if (!mr->empty) {
47733|      0|                if (s->is_weak)
47734|      0|                    js_weakref_free(rt, mr->key);
47735|      0|                else
47736|      0|                    JS_FreeValueRT(rt, mr->key);
47737|      0|                JS_FreeValueRT(rt, mr->value);
47738|      0|            }
47739|      0|            js_free_rt(rt, mr);
47740|      0|        }
47741|      0|        js_free_rt(rt, s->hash_table);
47742|      0|        if (s->is_weak) {
47743|      0|            list_del(&s->weakref_header.link);
47744|      0|        }
47745|      0|        js_free_rt(rt, s);
47746|      0|    }
47747|      0|}
47748|       |
47749|       |static void js_map_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)
47750|      0|{
47751|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
47752|      0|    JSMapState *s;
47753|      0|    struct list_head *el;
47754|      0|    JSMapRecord *mr;
47755|       |
47756|      0|    s = p->u.map_state;
47757|      0|    if (s) {
47758|      0|        list_for_each(el, &s->records) {
47759|      0|            mr = list_entry(el, JSMapRecord, link);
47760|      0|            if (!s->is_weak)
47761|      0|                JS_MarkValue(rt, mr->key, mark_func);
47762|      0|            JS_MarkValue(rt, mr->value, mark_func);
47763|      0|        }
47764|      0|    }
47765|      0|}
47766|       |
47767|       |/* Map Iterator */
47768|       |
47769|       |typedef struct JSMapIteratorData {
47770|       |    JSValue obj;
47771|       |    JSIteratorKindEnum kind;
47772|       |    JSMapRecord *cur_record;
47773|       |} JSMapIteratorData;
47774|       |
47775|       |static void js_map_iterator_finalizer(JSRuntime *rt, JSValue val)
47776|      0|{
47777|      0|    JSObject *p;
47778|      0|    JSMapIteratorData *it;
47779|       |
47780|      0|    p = JS_VALUE_GET_OBJ(val);
47781|      0|    it = p->u.map_iterator_data;
47782|      0|    if (it) {
47783|       |        /* During the GC sweep phase the Map finalizer may be
47784|       |           called before the Map iterator finalizer */
47785|      0|        if (JS_IsLiveObject(rt, it->obj) && it->cur_record) {
47786|      0|            map_decref_record(rt, it->cur_record);
47787|      0|        }
47788|      0|        JS_FreeValueRT(rt, it->obj);
47789|      0|        js_free_rt(rt, it);
47790|      0|    }
47791|      0|}
47792|       |
47793|       |static void js_map_iterator_mark(JSRuntime *rt, JSValueConst val,
47794|       |                                 JS_MarkFunc *mark_func)
47795|      0|{
47796|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
47797|      0|    JSMapIteratorData *it;
47798|      0|    it = p->u.map_iterator_data;
47799|      0|    if (it) {
47800|       |        /* the record is already marked by the object */
47801|      0|        JS_MarkValue(rt, it->obj, mark_func);
47802|      0|    }
47803|      0|}
47804|       |
47805|       |static JSValue js_create_map_iterator(JSContext *ctx, JSValueConst this_val,
47806|       |                                      int argc, JSValueConst *argv, int magic)
47807|      0|{
47808|      0|    JSIteratorKindEnum kind;
47809|      0|    JSMapState *s;
47810|      0|    JSMapIteratorData *it;
47811|      0|    JSValue enum_obj;
47812|       |
47813|      0|    kind = magic >> 2;
47814|      0|    magic &= 3;
47815|      0|    s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);
47816|      0|    if (!s)
47817|      0|        return JS_EXCEPTION;
47818|      0|    enum_obj = JS_NewObjectClass(ctx, JS_CLASS_MAP_ITERATOR + magic);
47819|      0|    if (JS_IsException(enum_obj))
47820|      0|        goto fail;
47821|      0|    it = js_malloc(ctx, sizeof(*it));
47822|      0|    if (!it) {
47823|      0|        JS_FreeValue(ctx, enum_obj);
47824|      0|        goto fail;
47825|      0|    }
47826|      0|    it->obj = JS_DupValue(ctx, this_val);
47827|      0|    it->kind = kind;
47828|      0|    it->cur_record = NULL;
47829|      0|    JS_SetOpaque(enum_obj, it);
47830|      0|    return enum_obj;
47831|      0| fail:
47832|      0|    return JS_EXCEPTION;
47833|      0|}
47834|       |
47835|       |static JSValue js_map_iterator_next(JSContext *ctx, JSValueConst this_val,
47836|       |                                    int argc, JSValueConst *argv,
47837|       |                                    BOOL *pdone, int magic)
47838|      0|{
47839|      0|    JSMapIteratorData *it;
47840|      0|    JSMapState *s;
47841|      0|    JSMapRecord *mr;
47842|      0|    struct list_head *el;
47843|       |
47844|      0|    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP_ITERATOR + magic);
47845|      0|    if (!it) {
47846|      0|        *pdone = FALSE;
47847|      0|        return JS_EXCEPTION;
47848|      0|    }
47849|      0|    if (JS_IsUndefined(it->obj))
47850|      0|        goto done;
47851|      0|    s = JS_GetOpaque(it->obj, JS_CLASS_MAP + magic);
47852|      0|    assert(s != NULL);
47853|      0|    if (!it->cur_record) {
47854|      0|        el = s->records.next;
47855|      0|    } else {
47856|      0|        mr = it->cur_record;
47857|      0|        el = mr->link.next;
47858|      0|        map_decref_record(ctx->rt, mr); /* the record can be freed here */
47859|      0|    }
47860|      0|    for(;;) {
47861|      0|        if (el == &s->records) {
47862|       |            /* no more record  */
47863|      0|            it->cur_record = NULL;
47864|      0|            JS_FreeValue(ctx, it->obj);
47865|      0|            it->obj = JS_UNDEFINED;
47866|      0|        done:
47867|       |            /* end of enumeration */
47868|      0|            *pdone = TRUE;
47869|      0|            return JS_UNDEFINED;
47870|      0|        }
47871|      0|        mr = list_entry(el, JSMapRecord, link);
47872|      0|        if (!mr->empty)
47873|      0|            break;
47874|       |        /* get the next record */
47875|      0|        el = mr->link.next;
47876|      0|    }
47877|       |
47878|       |    /* lock the record so that it won't be freed */
47879|      0|    mr->ref_count++;
47880|      0|    it->cur_record = mr;
47881|      0|    *pdone = FALSE;
47882|       |
47883|      0|    if (it->kind == JS_ITERATOR_KIND_KEY) {
47884|      0|        return JS_DupValue(ctx, mr->key);
47885|      0|    } else {
47886|      0|        JSValueConst args[2];
47887|      0|        args[0] = mr->key;
47888|      0|        if (magic)
47889|      0|            args[1] = mr->key;
47890|      0|        else
47891|      0|            args[1] = mr->value;
47892|      0|        if (it->kind == JS_ITERATOR_KIND_VALUE) {
47893|      0|            return JS_DupValue(ctx, args[1]);
47894|      0|        } else {
47895|      0|            return js_create_array(ctx, 2, args);
47896|      0|        }
47897|      0|    }
47898|      0|}
47899|       |
47900|       |static const JSCFunctionListEntry js_map_funcs[] = {
47901|       |    JS_CFUNC_MAGIC_DEF("groupBy", 2, js_object_groupBy, 1 ),
47902|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
47903|       |};
47904|       |
47905|       |static const JSCFunctionListEntry js_map_proto_funcs[] = {
47906|       |    JS_CFUNC_MAGIC_DEF("set", 2, js_map_set, 0 ),
47907|       |    JS_CFUNC_MAGIC_DEF("get", 1, js_map_get, 0 ),
47908|       |    JS_CFUNC_MAGIC_DEF("has", 1, js_map_has, 0 ),
47909|       |    JS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, 0 ),
47910|       |    JS_CFUNC_MAGIC_DEF("clear", 0, js_map_clear, 0 ),
47911|       |    JS_CGETSET_MAGIC_DEF("size", js_map_get_size, NULL, 0),
47912|       |    JS_CFUNC_MAGIC_DEF("forEach", 1, js_map_forEach, 0 ),
47913|       |    JS_CFUNC_MAGIC_DEF("values", 0, js_create_map_iterator, (JS_ITERATOR_KIND_VALUE << 2) | 0 ),
47914|       |    JS_CFUNC_MAGIC_DEF("keys", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY << 2) | 0 ),
47915|       |    JS_CFUNC_MAGIC_DEF("entries", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY_AND_VALUE << 2) | 0 ),
47916|       |    JS_ALIAS_DEF("[Symbol.iterator]", "entries" ),
47917|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Map", JS_PROP_CONFIGURABLE ),
47918|       |};
47919|       |
47920|       |static const JSCFunctionListEntry js_map_iterator_proto_funcs[] = {
47921|       |    JS_ITERATOR_NEXT_DEF("next", 0, js_map_iterator_next, 0 ),
47922|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Map Iterator", JS_PROP_CONFIGURABLE ),
47923|       |};
47924|       |
47925|       |static const JSCFunctionListEntry js_set_proto_funcs[] = {
47926|       |    JS_CFUNC_MAGIC_DEF("add", 1, js_map_set, MAGIC_SET ),
47927|       |    JS_CFUNC_MAGIC_DEF("has", 1, js_map_has, MAGIC_SET ),
47928|       |    JS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, MAGIC_SET ),
47929|       |    JS_CFUNC_MAGIC_DEF("clear", 0, js_map_clear, MAGIC_SET ),
47930|       |    JS_CGETSET_MAGIC_DEF("size", js_map_get_size, NULL, MAGIC_SET ),
47931|       |    JS_CFUNC_MAGIC_DEF("forEach", 1, js_map_forEach, MAGIC_SET ),
47932|       |    JS_CFUNC_MAGIC_DEF("values", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY << 2) | MAGIC_SET ),
47933|       |    JS_ALIAS_DEF("keys", "values" ),
47934|       |    JS_ALIAS_DEF("[Symbol.iterator]", "values" ),
47935|       |    JS_CFUNC_MAGIC_DEF("entries", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY_AND_VALUE << 2) | MAGIC_SET ),
47936|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Set", JS_PROP_CONFIGURABLE ),
47937|       |};
47938|       |
47939|       |static const JSCFunctionListEntry js_set_iterator_proto_funcs[] = {
47940|       |    JS_ITERATOR_NEXT_DEF("next", 0, js_map_iterator_next, MAGIC_SET ),
47941|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Set Iterator", JS_PROP_CONFIGURABLE ),
47942|       |};
47943|       |
47944|       |static const JSCFunctionListEntry js_weak_map_proto_funcs[] = {
47945|       |    JS_CFUNC_MAGIC_DEF("set", 2, js_map_set, MAGIC_WEAK ),
47946|       |    JS_CFUNC_MAGIC_DEF("get", 1, js_map_get, MAGIC_WEAK ),
47947|       |    JS_CFUNC_MAGIC_DEF("has", 1, js_map_has, MAGIC_WEAK ),
47948|       |    JS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, MAGIC_WEAK ),
47949|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakMap", JS_PROP_CONFIGURABLE ),
47950|       |};
47951|       |
47952|       |static const JSCFunctionListEntry js_weak_set_proto_funcs[] = {
47953|       |    JS_CFUNC_MAGIC_DEF("add", 1, js_map_set, MAGIC_SET | MAGIC_WEAK ),
47954|       |    JS_CFUNC_MAGIC_DEF("has", 1, js_map_has, MAGIC_SET | MAGIC_WEAK ),
47955|       |    JS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, MAGIC_SET | MAGIC_WEAK ),
47956|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakSet", JS_PROP_CONFIGURABLE ),
47957|       |};
47958|       |
47959|       |static const JSCFunctionListEntry * const js_map_proto_funcs_ptr[6] = {
47960|       |    js_map_proto_funcs,
47961|       |    js_set_proto_funcs,
47962|       |    js_weak_map_proto_funcs,
47963|       |    js_weak_set_proto_funcs,
47964|       |    js_map_iterator_proto_funcs,
47965|       |    js_set_iterator_proto_funcs,
47966|       |};
47967|       |
47968|       |static const uint8_t js_map_proto_funcs_count[6] = {
47969|       |    countof(js_map_proto_funcs),
47970|       |    countof(js_set_proto_funcs),
47971|       |    countof(js_weak_map_proto_funcs),
47972|       |    countof(js_weak_set_proto_funcs),
47973|       |    countof(js_map_iterator_proto_funcs),
47974|       |    countof(js_set_iterator_proto_funcs),
47975|       |};
47976|       |
47977|       |void JS_AddIntrinsicMapSet(JSContext *ctx)
47978|  17.7k|{
47979|  17.7k|    int i;
47980|  17.7k|    JSValue obj1;
47981|  17.7k|    char buf[ATOM_GET_STR_BUF_SIZE];
47982|       |
47983|  88.8k|    for(i = 0; i < 4; i++) {
47984|  71.0k|        const char *name = JS_AtomGetStr(ctx, buf, sizeof(buf),
47985|  71.0k|                                         JS_ATOM_Map + i);
47986|  71.0k|        ctx->class_proto[JS_CLASS_MAP + i] = JS_NewObject(ctx);
47987|  71.0k|        JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_MAP + i],
47988|  71.0k|                                   js_map_proto_funcs_ptr[i],
47989|  71.0k|                                   js_map_proto_funcs_count[i]);
47990|  71.0k|        obj1 = JS_NewCFunctionMagic(ctx, js_map_constructor, name, 0,
47991|  71.0k|                                    JS_CFUNC_constructor_magic, i);
47992|  71.0k|        if (i < 2) {
47993|  35.5k|            JS_SetPropertyFunctionList(ctx, obj1, js_map_funcs,
47994|  35.5k|                                       countof(js_map_funcs));
47995|  35.5k|        }
47996|  71.0k|        JS_NewGlobalCConstructor2(ctx, obj1, name, ctx->class_proto[JS_CLASS_MAP + i]);
47997|  71.0k|    }
47998|       |
47999|  53.3k|    for(i = 0; i < 2; i++) {
48000|  35.5k|        ctx->class_proto[JS_CLASS_MAP_ITERATOR + i] =
48001|  35.5k|            JS_NewObjectProto(ctx, ctx->iterator_proto);
48002|  35.5k|        JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_MAP_ITERATOR + i],
48003|  35.5k|                                   js_map_proto_funcs_ptr[i + 4],
48004|  35.5k|                                   js_map_proto_funcs_count[i + 4]);
48005|  35.5k|    }
48006|  17.7k|}
48007|       |
48008|       |/* Generator */
48009|       |static const JSCFunctionListEntry js_generator_function_proto_funcs[] = {
48010|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "GeneratorFunction", JS_PROP_CONFIGURABLE),
48011|       |};
48012|       |
48013|       |static const JSCFunctionListEntry js_generator_proto_funcs[] = {
48014|       |    JS_ITERATOR_NEXT_DEF("next", 1, js_generator_next, GEN_MAGIC_NEXT ),
48015|       |    JS_ITERATOR_NEXT_DEF("return", 1, js_generator_next, GEN_MAGIC_RETURN ),
48016|       |    JS_ITERATOR_NEXT_DEF("throw", 1, js_generator_next, GEN_MAGIC_THROW ),
48017|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Generator", JS_PROP_CONFIGURABLE),
48018|       |};
48019|       |
48020|       |/* Promise */
48021|       |
48022|       |typedef struct JSPromiseData {
48023|       |    JSPromiseStateEnum promise_state;
48024|       |    /* 0=fulfill, 1=reject, list of JSPromiseReactionData.link */
48025|       |    struct list_head promise_reactions[2];
48026|       |    BOOL is_handled; /* Note: only useful to debug */
48027|       |    JSValue promise_result;
48028|       |} JSPromiseData;
48029|       |
48030|       |typedef struct JSPromiseFunctionDataResolved {
48031|       |    int ref_count;
48032|       |    BOOL already_resolved;
48033|       |} JSPromiseFunctionDataResolved;
48034|       |
48035|       |typedef struct JSPromiseFunctionData {
48036|       |    JSValue promise;
48037|       |    JSPromiseFunctionDataResolved *presolved;
48038|       |} JSPromiseFunctionData;
48039|       |
48040|       |typedef struct JSPromiseReactionData {
48041|       |    struct list_head link; /* not used in promise_reaction_job */
48042|       |    JSValue resolving_funcs[2];
48043|       |    JSValue handler;
48044|       |} JSPromiseReactionData;
48045|       |
48046|       |JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise)
48047|    548|{
48048|    548|    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
48049|    548|    if (!s)
48050|    518|        return -1;
48051|     30|    return s->promise_state;
48052|    548|}
48053|       |
48054|       |JSValue JS_PromiseResult(JSContext *ctx, JSValue promise)
48055|     15|{
48056|     15|    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
48057|     15|    if (!s)
48058|      0|        return JS_UNDEFINED;
48059|     15|    return JS_DupValue(ctx, s->promise_result);
48060|     15|}
48061|       |
48062|       |static int js_create_resolving_functions(JSContext *ctx, JSValue *args,
48063|       |                                         JSValueConst promise);
48064|       |
48065|       |static void promise_reaction_data_free(JSRuntime *rt,
48066|       |                                       JSPromiseReactionData *rd)
48067|      0|{
48068|      0|    JS_FreeValueRT(rt, rd->resolving_funcs[0]);
48069|      0|    JS_FreeValueRT(rt, rd->resolving_funcs[1]);
48070|      0|    JS_FreeValueRT(rt, rd->handler);
48071|      0|    js_free_rt(rt, rd);
48072|      0|}
48073|       |
48074|       |static JSValue promise_reaction_job(JSContext *ctx, int argc,
48075|       |                                    JSValueConst *argv)
48076|      0|{
48077|      0|    JSValueConst handler, arg, func;
48078|      0|    JSValue res, res2;
48079|      0|    BOOL is_reject;
48080|       |
48081|      0|    assert(argc == 5);
48082|      0|    handler = argv[2];
48083|      0|    is_reject = JS_ToBool(ctx, argv[3]);
48084|      0|    arg = argv[4];
48085|       |#ifdef DUMP_PROMISE
48086|       |    printf("promise_reaction_job: is_reject=%d\n", is_reject);
48087|       |#endif
48088|       |
48089|      0|    if (JS_IsUndefined(handler)) {
48090|      0|        if (is_reject) {
48091|      0|            res = JS_Throw(ctx, JS_DupValue(ctx, arg));
48092|      0|        } else {
48093|      0|            res = JS_DupValue(ctx, arg);
48094|      0|        }
48095|      0|    } else {
48096|      0|        res = JS_Call(ctx, handler, JS_UNDEFINED, 1, &arg);
48097|      0|    }
48098|      0|    is_reject = JS_IsException(res);
48099|      0|    if (is_reject)
48100|      0|        res = JS_GetException(ctx);
48101|      0|    func = argv[is_reject];
48102|       |    /* as an extension, we support undefined as value to avoid
48103|       |       creating a dummy promise in the 'await' implementation of async
48104|       |       functions */
48105|      0|    if (!JS_IsUndefined(func)) {
48106|      0|        res2 = JS_Call(ctx, func, JS_UNDEFINED,
48107|      0|                       1, (JSValueConst *)&res);
48108|      0|    } else {
48109|      0|        res2 = JS_UNDEFINED;
48110|      0|    }
48111|      0|    JS_FreeValue(ctx, res);
48112|       |
48113|      0|    return res2;
48114|      0|}
48115|       |
48116|       |void JS_SetHostPromiseRejectionTracker(JSRuntime *rt,
48117|       |                                       JSHostPromiseRejectionTracker *cb,
48118|       |                                       void *opaque)
48119|  17.7k|{
48120|  17.7k|    rt->host_promise_rejection_tracker = cb;
48121|  17.7k|    rt->host_promise_rejection_tracker_opaque = opaque;
48122|  17.7k|}
48123|       |
48124|       |static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
48125|       |                                      JSValueConst value, BOOL is_reject)
48126|    382|{
48127|    382|    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
48128|    382|    struct list_head *el, *el1;
48129|    382|    JSPromiseReactionData *rd;
48130|    382|    JSValueConst args[5];
48131|       |
48132|    382|    if (!s || s->promise_state != JS_PROMISE_PENDING)
48133|      0|        return; /* should never happen */
48134|    382|    set_value(ctx, &s->promise_result, JS_DupValue(ctx, value));
48135|    382|    s->promise_state = JS_PROMISE_FULFILLED + is_reject;
48136|       |#ifdef DUMP_PROMISE
48137|       |    printf("fulfill_or_reject_promise: is_reject=%d\n", is_reject);
48138|       |#endif
48139|    382|    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
48140|    352|        JSRuntime *rt = ctx->rt;
48141|    352|        if (rt->host_promise_rejection_tracker) {
48142|    352|            rt->host_promise_rejection_tracker(ctx, promise, value, FALSE,
48143|    352|                                               rt->host_promise_rejection_tracker_opaque);
48144|    352|        }
48145|    352|    }
48146|       |
48147|    382|    list_for_each_safe(el, el1, &s->promise_reactions[is_reject]) {
48148|      0|        rd = list_entry(el, JSPromiseReactionData, link);
48149|      0|        args[0] = rd->resolving_funcs[0];
48150|      0|        args[1] = rd->resolving_funcs[1];
48151|      0|        args[2] = rd->handler;
48152|      0|        args[3] = JS_NewBool(ctx, is_reject);
48153|      0|        args[4] = value;
48154|      0|        JS_EnqueueJob(ctx, promise_reaction_job, 5, args);
48155|      0|        list_del(&rd->link);
48156|      0|        promise_reaction_data_free(ctx->rt, rd);
48157|      0|    }
48158|       |
48159|    382|    list_for_each_safe(el, el1, &s->promise_reactions[1 - is_reject]) {
48160|      0|        rd = list_entry(el, JSPromiseReactionData, link);
48161|      0|        list_del(&rd->link);
48162|      0|        promise_reaction_data_free(ctx->rt, rd);
48163|      0|    }
48164|    382|}
48165|       |
48166|       |static void reject_promise(JSContext *ctx, JSValueConst promise,
48167|       |                           JSValueConst value)
48168|      0|{
48169|      0|    fulfill_or_reject_promise(ctx, promise, value, TRUE);
48170|      0|}
48171|       |
48172|       |static JSValue js_promise_resolve_thenable_job(JSContext *ctx,
48173|       |                                               int argc, JSValueConst *argv)
48174|      0|{
48175|      0|    JSValueConst promise, thenable, then;
48176|      0|    JSValue args[2], res;
48177|       |
48178|       |#ifdef DUMP_PROMISE
48179|       |    printf("js_promise_resolve_thenable_job\n");
48180|       |#endif
48181|      0|    assert(argc == 3);
48182|      0|    promise = argv[0];
48183|      0|    thenable = argv[1];
48184|      0|    then = argv[2];
48185|      0|    if (js_create_resolving_functions(ctx, args, promise) < 0)
48186|      0|        return JS_EXCEPTION;
48187|      0|    res = JS_Call(ctx, then, thenable, 2, (JSValueConst *)args);
48188|      0|    if (JS_IsException(res)) {
48189|      0|        JSValue error = JS_GetException(ctx);
48190|      0|        res = JS_Call(ctx, args[1], JS_UNDEFINED, 1, (JSValueConst *)&error);
48191|      0|        JS_FreeValue(ctx, error);
48192|      0|    }
48193|      0|    JS_FreeValue(ctx, args[0]);
48194|      0|    JS_FreeValue(ctx, args[1]);
48195|      0|    return res;
48196|      0|}
48197|       |
48198|       |static void js_promise_resolve_function_free_resolved(JSRuntime *rt,
48199|       |                                                      JSPromiseFunctionDataResolved *sr)
48200|    794|{
48201|    794|    if (--sr->ref_count == 0) {
48202|     30|        js_free_rt(rt, sr);
48203|     30|    }
48204|    794|}
48205|       |
48206|       |static int js_create_resolving_functions(JSContext *ctx,
48207|       |                                         JSValue *resolving_funcs,
48208|       |                                         JSValueConst promise)
48209|       |
48210|    734|{
48211|    734|    JSValue obj;
48212|    734|    JSPromiseFunctionData *s;
48213|    734|    JSPromiseFunctionDataResolved *sr;
48214|    734|    int i, ret;
48215|       |
48216|    734|    sr = js_malloc(ctx, sizeof(*sr));
48217|    734|    if (!sr)
48218|      0|        return -1;
48219|    734|    sr->ref_count = 1;
48220|    734|    sr->already_resolved = FALSE; /* must be shared between the two functions */
48221|    734|    ret = 0;
48222|  2.20k|    for(i = 0; i < 2; i++) {
48223|  1.46k|        obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,
48224|  1.46k|                                     JS_CLASS_PROMISE_RESOLVE_FUNCTION + i);
48225|  1.46k|        if (JS_IsException(obj))
48226|      0|            goto fail;
48227|  1.46k|        s = js_malloc(ctx, sizeof(*s));
48228|  1.46k|        if (!s) {
48229|      0|            JS_FreeValue(ctx, obj);
48230|      0|        fail:
48231|       |
48232|      0|            if (i != 0)
48233|      0|                JS_FreeValue(ctx, resolving_funcs[0]);
48234|      0|            ret = -1;
48235|      0|            break;
48236|      0|        }
48237|  1.46k|        sr->ref_count++;
48238|  1.46k|        s->presolved = sr;
48239|  1.46k|        s->promise = JS_DupValue(ctx, promise);
48240|  1.46k|        JS_SetOpaque(obj, s);
48241|  1.46k|        js_function_set_properties(ctx, obj, JS_ATOM_empty_string, 1);
48242|  1.46k|        resolving_funcs[i] = obj;
48243|  1.46k|    }
48244|    734|    js_promise_resolve_function_free_resolved(ctx->rt, sr);
48245|    734|    return ret;
48246|    734|}
48247|       |
48248|       |static void js_promise_resolve_function_finalizer(JSRuntime *rt, JSValue val)
48249|     60|{
48250|     60|    JSPromiseFunctionData *s = JS_VALUE_GET_OBJ(val)->u.promise_function_data;
48251|     60|    if (s) {
48252|     60|        js_promise_resolve_function_free_resolved(rt, s->presolved);
48253|     60|        JS_FreeValueRT(rt, s->promise);
48254|     60|        js_free_rt(rt, s);
48255|     60|    }
48256|     60|}
48257|       |
48258|       |static void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,
48259|       |                                             JS_MarkFunc *mark_func)
48260|     84|{
48261|     84|    JSPromiseFunctionData *s = JS_VALUE_GET_OBJ(val)->u.promise_function_data;
48262|     84|    if (s) {
48263|     84|        JS_MarkValue(rt, s->promise, mark_func);
48264|     84|    }
48265|     84|}
48266|       |
48267|       |static JSValue js_promise_resolve_function_call(JSContext *ctx,
48268|       |                                                JSValueConst func_obj,
48269|       |                                                JSValueConst this_val,
48270|       |                                                int argc, JSValueConst *argv,
48271|       |                                                int flags)
48272|    382|{
48273|    382|    JSObject *p = JS_VALUE_GET_OBJ(func_obj);
48274|    382|    JSPromiseFunctionData *s;
48275|    382|    JSValueConst resolution, args[3];
48276|    382|    JSValue then;
48277|    382|    BOOL is_reject;
48278|       |
48279|    382|    s = p->u.promise_function_data;
48280|    382|    if (!s || s->presolved->already_resolved)
48281|      0|        return JS_UNDEFINED;
48282|    382|    s->presolved->already_resolved = TRUE;
48283|    382|    is_reject = p->class_id - JS_CLASS_PROMISE_RESOLVE_FUNCTION;
48284|    382|    if (argc > 0)
48285|    382|        resolution = argv[0];
48286|      0|    else
48287|      0|        resolution = JS_UNDEFINED;
48288|       |#ifdef DUMP_PROMISE
48289|       |    printf("js_promise_resolving_function_call: is_reject=%d resolution=", is_reject);
48290|       |    JS_DumpValue(ctx, resolution);
48291|       |    printf("\n");
48292|       |#endif
48293|    382|    if (is_reject || !JS_IsObject(resolution)) {
48294|    382|        goto done;
48295|    382|    } else if (js_same_value(ctx, resolution, s->promise)) {
48296|      0|        JS_ThrowTypeError(ctx, "promise self resolution");
48297|      0|        goto fail_reject;
48298|      0|    }
48299|      0|    then = JS_GetProperty(ctx, resolution, JS_ATOM_then);
48300|      0|    if (JS_IsException(then)) {
48301|      0|        JSValue error;
48302|      0|    fail_reject:
48303|      0|        error = JS_GetException(ctx);
48304|      0|        reject_promise(ctx, s->promise, error);
48305|      0|        JS_FreeValue(ctx, error);
48306|      0|    } else if (!JS_IsFunction(ctx, then)) {
48307|      0|        JS_FreeValue(ctx, then);
48308|    382|    done:
48309|    382|        fulfill_or_reject_promise(ctx, s->promise, resolution, is_reject);
48310|    382|    } else {
48311|      0|        args[0] = s->promise;
48312|      0|        args[1] = resolution;
48313|      0|        args[2] = then;
48314|      0|        JS_EnqueueJob(ctx, js_promise_resolve_thenable_job, 3, args);
48315|      0|        JS_FreeValue(ctx, then);
48316|      0|    }
48317|    382|    return JS_UNDEFINED;
48318|      0|}
48319|       |
48320|       |static void js_promise_finalizer(JSRuntime *rt, JSValue val)
48321|     30|{
48322|     30|    JSPromiseData *s = JS_GetOpaque(val, JS_CLASS_PROMISE);
48323|     30|    struct list_head *el, *el1;
48324|     30|    int i;
48325|       |
48326|     30|    if (!s)
48327|      0|        return;
48328|     90|    for(i = 0; i < 2; i++) {
48329|     60|        list_for_each_safe(el, el1, &s->promise_reactions[i]) {
48330|      0|            JSPromiseReactionData *rd =
48331|      0|                list_entry(el, JSPromiseReactionData, link);
48332|      0|            promise_reaction_data_free(rt, rd);
48333|      0|        }
48334|     60|    }
48335|     30|    JS_FreeValueRT(rt, s->promise_result);
48336|     30|    js_free_rt(rt, s);
48337|     30|}
48338|       |
48339|       |static void js_promise_mark(JSRuntime *rt, JSValueConst val,
48340|       |                            JS_MarkFunc *mark_func)
48341|     44|{
48342|     44|    JSPromiseData *s = JS_GetOpaque(val, JS_CLASS_PROMISE);
48343|     44|    struct list_head *el;
48344|     44|    int i;
48345|       |
48346|     44|    if (!s)
48347|      0|        return;
48348|    132|    for(i = 0; i < 2; i++) {
48349|     88|        list_for_each(el, &s->promise_reactions[i]) {
48350|      0|            JSPromiseReactionData *rd =
48351|      0|                list_entry(el, JSPromiseReactionData, link);
48352|      0|            JS_MarkValue(rt, rd->resolving_funcs[0], mark_func);
48353|      0|            JS_MarkValue(rt, rd->resolving_funcs[1], mark_func);
48354|      0|            JS_MarkValue(rt, rd->handler, mark_func);
48355|      0|        }
48356|     88|    }
48357|     44|    JS_MarkValue(rt, s->promise_result, mark_func);
48358|     44|}
48359|       |
48360|       |static JSValue js_promise_constructor(JSContext *ctx, JSValueConst new_target,
48361|       |                                      int argc, JSValueConst *argv)
48362|    734|{
48363|    734|    JSValueConst executor;
48364|    734|    JSValue obj;
48365|    734|    JSPromiseData *s;
48366|    734|    JSValue args[2], ret;
48367|    734|    int i;
48368|       |
48369|    734|    executor = argv[0];
48370|    734|    if (check_function(ctx, executor))
48371|      0|        return JS_EXCEPTION;
48372|    734|    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_PROMISE);
48373|    734|    if (JS_IsException(obj))
48374|      0|        return JS_EXCEPTION;
48375|    734|    s = js_mallocz(ctx, sizeof(*s));
48376|    734|    if (!s)
48377|      0|        goto fail;
48378|    734|    s->promise_state = JS_PROMISE_PENDING;
48379|    734|    s->is_handled = FALSE;
48380|  2.20k|    for(i = 0; i < 2; i++)
48381|  1.46k|        init_list_head(&s->promise_reactions[i]);
48382|    734|    s->promise_result = JS_UNDEFINED;
48383|    734|    JS_SetOpaque(obj, s);
48384|    734|    if (js_create_resolving_functions(ctx, args, obj))
48385|      0|        goto fail;
48386|    734|    ret = JS_Call(ctx, executor, JS_UNDEFINED, 2, (JSValueConst *)args);
48387|    734|    if (JS_IsException(ret)) {
48388|      0|        JSValue ret2, error;
48389|      0|        error = JS_GetException(ctx);
48390|      0|        ret2 = JS_Call(ctx, args[1], JS_UNDEFINED, 1, (JSValueConst *)&error);
48391|      0|        JS_FreeValue(ctx, error);
48392|      0|        if (JS_IsException(ret2))
48393|      0|            goto fail1;
48394|      0|        JS_FreeValue(ctx, ret2);
48395|      0|    }
48396|    734|    JS_FreeValue(ctx, ret);
48397|    734|    JS_FreeValue(ctx, args[0]);
48398|    734|    JS_FreeValue(ctx, args[1]);
48399|    734|    return obj;
48400|      0| fail1:
48401|      0|    JS_FreeValue(ctx, args[0]);
48402|      0|    JS_FreeValue(ctx, args[1]);
48403|      0| fail:
48404|      0|    JS_FreeValue(ctx, obj);
48405|      0|    return JS_EXCEPTION;
48406|      0|}
48407|       |
48408|       |static JSValue js_promise_executor(JSContext *ctx,
48409|       |                                   JSValueConst this_val,
48410|       |                                   int argc, JSValueConst *argv,
48411|       |                                   int magic, JSValue *func_data)
48412|    734|{
48413|    734|    int i;
48414|       |
48415|  2.20k|    for(i = 0; i < 2; i++) {
48416|  1.46k|        if (!JS_IsUndefined(func_data[i]))
48417|      0|            return JS_ThrowTypeError(ctx, "resolving function already set");
48418|  1.46k|        func_data[i] = JS_DupValue(ctx, argv[i]);
48419|  1.46k|    }
48420|    734|    return JS_UNDEFINED;
48421|    734|}
48422|       |
48423|       |static JSValue js_promise_executor_new(JSContext *ctx)
48424|    734|{
48425|    734|    JSValueConst func_data[2];
48426|       |
48427|    734|    func_data[0] = JS_UNDEFINED;
48428|    734|    func_data[1] = JS_UNDEFINED;
48429|    734|    return JS_NewCFunctionData(ctx, js_promise_executor, 2,
48430|    734|                               0, 2, func_data);
48431|    734|}
48432|       |
48433|       |static JSValue js_new_promise_capability(JSContext *ctx,
48434|       |                                         JSValue *resolving_funcs,
48435|       |                                         JSValueConst ctor)
48436|    734|{
48437|    734|    JSValue executor, result_promise;
48438|    734|    JSCFunctionDataRecord *s;
48439|    734|    int i;
48440|       |
48441|    734|    executor = js_promise_executor_new(ctx);
48442|    734|    if (JS_IsException(executor))
48443|      0|        return executor;
48444|       |
48445|    734|    if (JS_IsUndefined(ctor)) {
48446|    734|        result_promise = js_promise_constructor(ctx, ctor, 1,
48447|    734|                                                (JSValueConst *)&executor);
48448|    734|    } else {
48449|      0|        result_promise = JS_CallConstructor(ctx, ctor, 1,
48450|      0|                                            (JSValueConst *)&executor);
48451|      0|    }
48452|    734|    if (JS_IsException(result_promise))
48453|      0|        goto fail;
48454|    734|    s = JS_GetOpaque(executor, JS_CLASS_C_FUNCTION_DATA);
48455|  2.20k|    for(i = 0; i < 2; i++) {
48456|  1.46k|        if (check_function(ctx, s->data[i]))
48457|      0|            goto fail;
48458|  1.46k|    }
48459|  2.20k|    for(i = 0; i < 2; i++)
48460|  1.46k|        resolving_funcs[i] = JS_DupValue(ctx, s->data[i]);
48461|    734|    JS_FreeValue(ctx, executor);
48462|    734|    return result_promise;
48463|      0| fail:
48464|      0|    JS_FreeValue(ctx, executor);
48465|      0|    JS_FreeValue(ctx, result_promise);
48466|      0|    return JS_EXCEPTION;
48467|    734|}
48468|       |
48469|       |JSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs)
48470|    734|{
48471|    734|    return js_new_promise_capability(ctx, resolving_funcs, JS_UNDEFINED);
48472|    734|}
48473|       |
48474|       |static JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,
48475|       |                                  int argc, JSValueConst *argv, int magic)
48476|      0|{
48477|      0|    JSValue result_promise, resolving_funcs[2], ret;
48478|      0|    BOOL is_reject = magic;
48479|       |
48480|      0|    if (!JS_IsObject(this_val))
48481|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
48482|      0|    if (!is_reject && JS_GetOpaque(argv[0], JS_CLASS_PROMISE)) {
48483|      0|        JSValue ctor;
48484|      0|        BOOL is_same;
48485|      0|        ctor = JS_GetProperty(ctx, argv[0], JS_ATOM_constructor);
48486|      0|        if (JS_IsException(ctor))
48487|      0|            return ctor;
48488|      0|        is_same = js_same_value(ctx, ctor, this_val);
48489|      0|        JS_FreeValue(ctx, ctor);
48490|      0|        if (is_same)
48491|      0|            return JS_DupValue(ctx, argv[0]);
48492|      0|    }
48493|      0|    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
48494|      0|    if (JS_IsException(result_promise))
48495|      0|        return result_promise;
48496|      0|    ret = JS_Call(ctx, resolving_funcs[is_reject], JS_UNDEFINED, 1, argv);
48497|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
48498|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
48499|      0|    if (JS_IsException(ret)) {
48500|      0|        JS_FreeValue(ctx, result_promise);
48501|      0|        return ret;
48502|      0|    }
48503|      0|    JS_FreeValue(ctx, ret);
48504|      0|    return result_promise;
48505|      0|}
48506|       |
48507|       |static JSValue js_promise_withResolvers(JSContext *ctx,
48508|       |                                        JSValueConst this_val,
48509|       |                                        int argc, JSValueConst *argv)
48510|      0|{
48511|      0|    JSValue result_promise, resolving_funcs[2], obj;
48512|      0|    if (!JS_IsObject(this_val))
48513|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
48514|      0|    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
48515|      0|    if (JS_IsException(result_promise))
48516|      0|        return result_promise;
48517|      0|    obj = JS_NewObject(ctx);
48518|      0|    if (JS_IsException(obj)) {
48519|      0|        JS_FreeValue(ctx, resolving_funcs[0]);
48520|      0|        JS_FreeValue(ctx, resolving_funcs[1]);
48521|      0|        JS_FreeValue(ctx, result_promise);
48522|      0|        return JS_EXCEPTION;
48523|      0|    }
48524|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_promise, result_promise, JS_PROP_C_W_E);
48525|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_resolve, resolving_funcs[0], JS_PROP_C_W_E);
48526|      0|    JS_DefinePropertyValue(ctx, obj, JS_ATOM_reject, resolving_funcs[1], JS_PROP_C_W_E);
48527|      0|    return obj;
48528|      0|}
48529|       |
48530|       |static __exception int remainingElementsCount_add(JSContext *ctx,
48531|       |                                                  JSValueConst resolve_element_env,
48532|       |                                                  int addend)
48533|      0|{
48534|      0|    JSValue val;
48535|      0|    int remainingElementsCount;
48536|       |
48537|      0|    val = JS_GetPropertyUint32(ctx, resolve_element_env, 0);
48538|      0|    if (JS_IsException(val))
48539|      0|        return -1;
48540|      0|    if (JS_ToInt32Free(ctx, &remainingElementsCount, val))
48541|      0|        return -1;
48542|      0|    remainingElementsCount += addend;
48543|      0|    if (JS_SetPropertyUint32(ctx, resolve_element_env, 0,
48544|      0|                             JS_NewInt32(ctx, remainingElementsCount)) < 0)
48545|      0|        return -1;
48546|      0|    return (remainingElementsCount == 0);
48547|      0|}
48548|       |
48549|       |#define PROMISE_MAGIC_all        0
48550|      0|#define PROMISE_MAGIC_allSettled 1
48551|      0|#define PROMISE_MAGIC_any        2
48552|       |
48553|       |static JSValue js_promise_all_resolve_element(JSContext *ctx,
48554|       |                                              JSValueConst this_val,
48555|       |                                              int argc, JSValueConst *argv,
48556|       |                                              int magic,
48557|       |                                              JSValue *func_data)
48558|      0|{
48559|      0|    int resolve_type = magic & 3;
48560|      0|    int is_reject = magic & 4;
48561|      0|    BOOL alreadyCalled = JS_ToBool(ctx, func_data[0]);
48562|      0|    JSValueConst values = func_data[2];
48563|      0|    JSValueConst resolve = func_data[3];
48564|      0|    JSValueConst resolve_element_env = func_data[4];
48565|      0|    JSValue ret, obj;
48566|      0|    int is_zero, index;
48567|       |
48568|      0|    if (JS_ToInt32(ctx, &index, func_data[1]))
48569|      0|        return JS_EXCEPTION;
48570|      0|    if (alreadyCalled)
48571|      0|        return JS_UNDEFINED;
48572|      0|    func_data[0] = JS_NewBool(ctx, TRUE);
48573|       |
48574|      0|    if (resolve_type == PROMISE_MAGIC_allSettled) {
48575|      0|        JSValue str;
48576|       |
48577|      0|        obj = JS_NewObject(ctx);
48578|      0|        if (JS_IsException(obj))
48579|      0|            return JS_EXCEPTION;
48580|      0|        str = js_new_string8(ctx, is_reject ? "rejected" : "fulfilled");
48581|      0|        if (JS_IsException(str))
48582|      0|            goto fail1;
48583|      0|        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_status,
48584|      0|                                   str,
48585|      0|                                   JS_PROP_C_W_E) < 0)
48586|      0|            goto fail1;
48587|      0|        if (JS_DefinePropertyValue(ctx, obj,
48588|      0|                                   is_reject ? JS_ATOM_reason : JS_ATOM_value,
48589|      0|                                   JS_DupValue(ctx, argv[0]),
48590|      0|                                   JS_PROP_C_W_E) < 0) {
48591|      0|        fail1:
48592|      0|            JS_FreeValue(ctx, obj);
48593|      0|            return JS_EXCEPTION;
48594|      0|        }
48595|      0|    } else {
48596|      0|        obj = JS_DupValue(ctx, argv[0]);
48597|      0|    }
48598|      0|    if (JS_DefinePropertyValueUint32(ctx, values, index,
48599|      0|                                     obj, JS_PROP_C_W_E) < 0)
48600|      0|        return JS_EXCEPTION;
48601|       |
48602|      0|    is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
48603|      0|    if (is_zero < 0)
48604|      0|        return JS_EXCEPTION;
48605|      0|    if (is_zero) {
48606|      0|        if (resolve_type == PROMISE_MAGIC_any) {
48607|      0|            JSValue error;
48608|      0|            error = js_aggregate_error_constructor(ctx, values);
48609|      0|            if (JS_IsException(error))
48610|      0|                return JS_EXCEPTION;
48611|      0|            ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&error);
48612|      0|            JS_FreeValue(ctx, error);
48613|      0|        } else {
48614|      0|            ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&values);
48615|      0|        }
48616|      0|        if (JS_IsException(ret))
48617|      0|            return ret;
48618|      0|        JS_FreeValue(ctx, ret);
48619|      0|    }
48620|      0|    return JS_UNDEFINED;
48621|      0|}
48622|       |
48623|       |/* magic = 0: Promise.all 1: Promise.allSettled */
48624|       |static JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,
48625|       |                              int argc, JSValueConst *argv, int magic)
48626|      0|{
48627|      0|    JSValue result_promise, resolving_funcs[2], item, next_promise, ret;
48628|      0|    JSValue next_method = JS_UNDEFINED, values = JS_UNDEFINED;
48629|      0|    JSValue resolve_element_env = JS_UNDEFINED, resolve_element, reject_element;
48630|      0|    JSValue promise_resolve = JS_UNDEFINED, iter = JS_UNDEFINED;
48631|      0|    JSValueConst then_args[2], resolve_element_data[5];
48632|      0|    BOOL done;
48633|      0|    int index, is_zero, is_promise_any = (magic == PROMISE_MAGIC_any);
48634|       |
48635|      0|    if (!JS_IsObject(this_val))
48636|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
48637|      0|    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
48638|      0|    if (JS_IsException(result_promise))
48639|      0|        return result_promise;
48640|      0|    promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);
48641|      0|    if (JS_IsException(promise_resolve) ||
48642|      0|        check_function(ctx, promise_resolve))
48643|      0|        goto fail_reject;
48644|      0|    iter = JS_GetIterator(ctx, argv[0], FALSE);
48645|      0|    if (JS_IsException(iter)) {
48646|      0|        JSValue error;
48647|      0|    fail_reject:
48648|      0|        error = JS_GetException(ctx);
48649|      0|        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED, 1,
48650|      0|                       (JSValueConst *)&error);
48651|      0|        JS_FreeValue(ctx, error);
48652|      0|        if (JS_IsException(ret))
48653|      0|            goto fail;
48654|      0|        JS_FreeValue(ctx, ret);
48655|      0|    } else {
48656|      0|        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
48657|      0|        if (JS_IsException(next_method))
48658|      0|            goto fail_reject;
48659|      0|        values = JS_NewArray(ctx);
48660|      0|        if (JS_IsException(values))
48661|      0|            goto fail_reject;
48662|      0|        resolve_element_env = JS_NewArray(ctx);
48663|      0|        if (JS_IsException(resolve_element_env))
48664|      0|            goto fail_reject;
48665|       |        /* remainingElementsCount field */
48666|      0|        if (JS_DefinePropertyValueUint32(ctx, resolve_element_env, 0,
48667|      0|                                         JS_NewInt32(ctx, 1),
48668|      0|                                         JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)
48669|      0|            goto fail_reject;
48670|       |
48671|      0|        index = 0;
48672|      0|        for(;;) {
48673|       |            /* XXX: conformance: should close the iterator if error on 'done'
48674|       |               access, but not on 'value' access */
48675|      0|            item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
48676|      0|            if (JS_IsException(item))
48677|      0|                goto fail_reject;
48678|      0|            if (done)
48679|      0|                break;
48680|      0|            next_promise = JS_Call(ctx, promise_resolve,
48681|      0|                                   this_val, 1, (JSValueConst *)&item);
48682|      0|            JS_FreeValue(ctx, item);
48683|      0|            if (JS_IsException(next_promise)) {
48684|      0|            fail_reject1:
48685|      0|                JS_IteratorClose(ctx, iter, TRUE);
48686|      0|                goto fail_reject;
48687|      0|            }
48688|      0|            resolve_element_data[0] = JS_NewBool(ctx, FALSE);
48689|      0|            resolve_element_data[1] = (JSValueConst)JS_NewInt32(ctx, index);
48690|      0|            resolve_element_data[2] = values;
48691|      0|            resolve_element_data[3] = resolving_funcs[is_promise_any];
48692|      0|            resolve_element_data[4] = resolve_element_env;
48693|      0|            resolve_element =
48694|      0|                JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,
48695|      0|                                    magic, 5, resolve_element_data);
48696|      0|            if (JS_IsException(resolve_element)) {
48697|      0|                JS_FreeValue(ctx, next_promise);
48698|      0|                goto fail_reject1;
48699|      0|            }
48700|       |
48701|      0|            if (magic == PROMISE_MAGIC_allSettled) {
48702|      0|                reject_element =
48703|      0|                    JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,
48704|      0|                                        magic | 4, 5, resolve_element_data);
48705|      0|                if (JS_IsException(reject_element)) {
48706|      0|                    JS_FreeValue(ctx, next_promise);
48707|      0|                    goto fail_reject1;
48708|      0|                }
48709|      0|            } else if (magic == PROMISE_MAGIC_any) {
48710|      0|                if (JS_DefinePropertyValueUint32(ctx, values, index,
48711|      0|                                                 JS_UNDEFINED, JS_PROP_C_W_E) < 0)
48712|      0|                    goto fail_reject1;
48713|      0|                reject_element = resolve_element;
48714|      0|                resolve_element = JS_DupValue(ctx, resolving_funcs[0]);
48715|      0|            } else {
48716|      0|                reject_element = JS_DupValue(ctx, resolving_funcs[1]);
48717|      0|            }
48718|       |
48719|      0|            if (remainingElementsCount_add(ctx, resolve_element_env, 1) < 0) {
48720|      0|                JS_FreeValue(ctx, next_promise);
48721|      0|                JS_FreeValue(ctx, resolve_element);
48722|      0|                JS_FreeValue(ctx, reject_element);
48723|      0|                goto fail_reject1;
48724|      0|            }
48725|       |
48726|      0|            then_args[0] = resolve_element;
48727|      0|            then_args[1] = reject_element;
48728|      0|            ret = JS_InvokeFree(ctx, next_promise, JS_ATOM_then, 2, then_args);
48729|      0|            JS_FreeValue(ctx, resolve_element);
48730|      0|            JS_FreeValue(ctx, reject_element);
48731|      0|            if (check_exception_free(ctx, ret))
48732|      0|                goto fail_reject1;
48733|      0|            index++;
48734|      0|        }
48735|       |
48736|      0|        is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
48737|      0|        if (is_zero < 0)
48738|      0|            goto fail_reject;
48739|      0|        if (is_zero) {
48740|      0|            if (magic == PROMISE_MAGIC_any) {
48741|      0|                JSValue error;
48742|      0|                error = js_aggregate_error_constructor(ctx, values);
48743|      0|                if (JS_IsException(error))
48744|      0|                    goto fail_reject;
48745|      0|                JS_FreeValue(ctx, values);
48746|      0|                values = error;
48747|      0|            }
48748|      0|            ret = JS_Call(ctx, resolving_funcs[is_promise_any], JS_UNDEFINED,
48749|      0|                          1, (JSValueConst *)&values);
48750|      0|            if (check_exception_free(ctx, ret))
48751|      0|                goto fail_reject;
48752|      0|        }
48753|      0|    }
48754|      0| done:
48755|      0|    JS_FreeValue(ctx, promise_resolve);
48756|      0|    JS_FreeValue(ctx, resolve_element_env);
48757|      0|    JS_FreeValue(ctx, values);
48758|      0|    JS_FreeValue(ctx, next_method);
48759|      0|    JS_FreeValue(ctx, iter);
48760|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
48761|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
48762|      0|    return result_promise;
48763|      0| fail:
48764|      0|    JS_FreeValue(ctx, result_promise);
48765|      0|    result_promise = JS_EXCEPTION;
48766|      0|    goto done;
48767|      0|}
48768|       |
48769|       |static JSValue js_promise_race(JSContext *ctx, JSValueConst this_val,
48770|       |                               int argc, JSValueConst *argv)
48771|      0|{
48772|      0|    JSValue result_promise, resolving_funcs[2], item, next_promise, ret;
48773|      0|    JSValue next_method = JS_UNDEFINED, iter = JS_UNDEFINED;
48774|      0|    JSValue promise_resolve = JS_UNDEFINED;
48775|      0|    BOOL done;
48776|       |
48777|      0|    if (!JS_IsObject(this_val))
48778|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
48779|      0|    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
48780|      0|    if (JS_IsException(result_promise))
48781|      0|        return result_promise;
48782|      0|    promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);
48783|      0|    if (JS_IsException(promise_resolve) ||
48784|      0|        check_function(ctx, promise_resolve))
48785|      0|        goto fail_reject;
48786|      0|    iter = JS_GetIterator(ctx, argv[0], FALSE);
48787|      0|    if (JS_IsException(iter)) {
48788|      0|        JSValue error;
48789|      0|    fail_reject:
48790|      0|        error = JS_GetException(ctx);
48791|      0|        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED, 1,
48792|      0|                       (JSValueConst *)&error);
48793|      0|        JS_FreeValue(ctx, error);
48794|      0|        if (JS_IsException(ret))
48795|      0|            goto fail;
48796|      0|        JS_FreeValue(ctx, ret);
48797|      0|    } else {
48798|      0|        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
48799|      0|        if (JS_IsException(next_method))
48800|      0|            goto fail_reject;
48801|       |
48802|      0|        for(;;) {
48803|       |            /* XXX: conformance: should close the iterator if error on 'done'
48804|       |               access, but not on 'value' access */
48805|      0|            item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
48806|      0|            if (JS_IsException(item))
48807|      0|                goto fail_reject;
48808|      0|            if (done)
48809|      0|                break;
48810|      0|            next_promise = JS_Call(ctx, promise_resolve,
48811|      0|                                   this_val, 1, (JSValueConst *)&item);
48812|      0|            JS_FreeValue(ctx, item);
48813|      0|            if (JS_IsException(next_promise)) {
48814|      0|            fail_reject1:
48815|      0|                JS_IteratorClose(ctx, iter, TRUE);
48816|      0|                goto fail_reject;
48817|      0|            }
48818|      0|            ret = JS_InvokeFree(ctx, next_promise, JS_ATOM_then, 2,
48819|      0|                                (JSValueConst *)resolving_funcs);
48820|      0|            if (check_exception_free(ctx, ret))
48821|      0|                goto fail_reject1;
48822|      0|        }
48823|      0|    }
48824|      0| done:
48825|      0|    JS_FreeValue(ctx, promise_resolve);
48826|      0|    JS_FreeValue(ctx, next_method);
48827|      0|    JS_FreeValue(ctx, iter);
48828|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
48829|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
48830|      0|    return result_promise;
48831|      0| fail:
48832|       |    //JS_FreeValue(ctx, next_method); // why not???
48833|      0|    JS_FreeValue(ctx, result_promise);
48834|      0|    result_promise = JS_EXCEPTION;
48835|      0|    goto done;
48836|      0|}
48837|       |
48838|       |static __exception int perform_promise_then(JSContext *ctx,
48839|       |                                            JSValueConst promise,
48840|       |                                            JSValueConst *resolve_reject,
48841|       |                                            JSValueConst *cap_resolving_funcs)
48842|      0|{
48843|      0|    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
48844|      0|    JSPromiseReactionData *rd_array[2], *rd;
48845|      0|    int i, j;
48846|       |
48847|      0|    rd_array[0] = NULL;
48848|      0|    rd_array[1] = NULL;
48849|      0|    for(i = 0; i < 2; i++) {
48850|      0|        JSValueConst handler;
48851|      0|        rd = js_mallocz(ctx, sizeof(*rd));
48852|      0|        if (!rd) {
48853|      0|            if (i == 1)
48854|      0|                promise_reaction_data_free(ctx->rt, rd_array[0]);
48855|      0|            return -1;
48856|      0|        }
48857|      0|        for(j = 0; j < 2; j++)
48858|      0|            rd->resolving_funcs[j] = JS_DupValue(ctx, cap_resolving_funcs[j]);
48859|      0|        handler = resolve_reject[i];
48860|      0|        if (!JS_IsFunction(ctx, handler))
48861|      0|            handler = JS_UNDEFINED;
48862|      0|        rd->handler = JS_DupValue(ctx, handler);
48863|      0|        rd_array[i] = rd;
48864|      0|    }
48865|       |
48866|      0|    if (s->promise_state == JS_PROMISE_PENDING) {
48867|      0|        for(i = 0; i < 2; i++)
48868|      0|            list_add_tail(&rd_array[i]->link, &s->promise_reactions[i]);
48869|      0|    } else {
48870|      0|        JSValueConst args[5];
48871|      0|        if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
48872|      0|            JSRuntime *rt = ctx->rt;
48873|      0|            if (rt->host_promise_rejection_tracker) {
48874|      0|                rt->host_promise_rejection_tracker(ctx, promise, s->promise_result,
48875|      0|                                                   TRUE, rt->host_promise_rejection_tracker_opaque);
48876|      0|            }
48877|      0|        }
48878|      0|        i = s->promise_state - JS_PROMISE_FULFILLED;
48879|      0|        rd = rd_array[i];
48880|      0|        args[0] = rd->resolving_funcs[0];
48881|      0|        args[1] = rd->resolving_funcs[1];
48882|      0|        args[2] = rd->handler;
48883|      0|        args[3] = JS_NewBool(ctx, i);
48884|      0|        args[4] = s->promise_result;
48885|      0|        JS_EnqueueJob(ctx, promise_reaction_job, 5, args);
48886|      0|        for(i = 0; i < 2; i++)
48887|      0|            promise_reaction_data_free(ctx->rt, rd_array[i]);
48888|      0|    }
48889|      0|    s->is_handled = TRUE;
48890|      0|    return 0;
48891|      0|}
48892|       |
48893|       |static JSValue js_promise_then(JSContext *ctx, JSValueConst this_val,
48894|       |                               int argc, JSValueConst *argv)
48895|      0|{
48896|      0|    JSValue ctor, result_promise, resolving_funcs[2];
48897|      0|    JSPromiseData *s;
48898|      0|    int i, ret;
48899|       |
48900|      0|    s = JS_GetOpaque2(ctx, this_val, JS_CLASS_PROMISE);
48901|      0|    if (!s)
48902|      0|        return JS_EXCEPTION;
48903|       |
48904|      0|    ctor = JS_SpeciesConstructor(ctx, this_val, JS_UNDEFINED);
48905|      0|    if (JS_IsException(ctor))
48906|      0|        return ctor;
48907|      0|    result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);
48908|      0|    JS_FreeValue(ctx, ctor);
48909|      0|    if (JS_IsException(result_promise))
48910|      0|        return result_promise;
48911|      0|    ret = perform_promise_then(ctx, this_val, argv,
48912|      0|                               (JSValueConst *)resolving_funcs);
48913|      0|    for(i = 0; i < 2; i++)
48914|      0|        JS_FreeValue(ctx, resolving_funcs[i]);
48915|      0|    if (ret) {
48916|      0|        JS_FreeValue(ctx, result_promise);
48917|      0|        return JS_EXCEPTION;
48918|      0|    }
48919|      0|    return result_promise;
48920|      0|}
48921|       |
48922|       |static JSValue js_promise_catch(JSContext *ctx, JSValueConst this_val,
48923|       |                                int argc, JSValueConst *argv)
48924|      0|{
48925|      0|    JSValueConst args[2];
48926|      0|    args[0] = JS_UNDEFINED;
48927|      0|    args[1] = argv[0];
48928|      0|    return JS_Invoke(ctx, this_val, JS_ATOM_then, 2, args);
48929|      0|}
48930|       |
48931|       |static JSValue js_promise_finally_value_thunk(JSContext *ctx, JSValueConst this_val,
48932|       |                                              int argc, JSValueConst *argv,
48933|       |                                              int magic, JSValue *func_data)
48934|      0|{
48935|      0|    return JS_DupValue(ctx, func_data[0]);
48936|      0|}
48937|       |
48938|       |static JSValue js_promise_finally_thrower(JSContext *ctx, JSValueConst this_val,
48939|       |                                          int argc, JSValueConst *argv,
48940|       |                                          int magic, JSValue *func_data)
48941|      0|{
48942|      0|    return JS_Throw(ctx, JS_DupValue(ctx, func_data[0]));
48943|      0|}
48944|       |
48945|       |static JSValue js_promise_then_finally_func(JSContext *ctx, JSValueConst this_val,
48946|       |                                            int argc, JSValueConst *argv,
48947|       |                                            int magic, JSValue *func_data)
48948|      0|{
48949|      0|    JSValueConst ctor = func_data[0];
48950|      0|    JSValueConst onFinally = func_data[1];
48951|      0|    JSValue res, promise, ret, then_func;
48952|       |
48953|      0|    res = JS_Call(ctx, onFinally, JS_UNDEFINED, 0, NULL);
48954|      0|    if (JS_IsException(res))
48955|      0|        return res;
48956|      0|    promise = js_promise_resolve(ctx, ctor, 1, (JSValueConst *)&res, 0);
48957|      0|    JS_FreeValue(ctx, res);
48958|      0|    if (JS_IsException(promise))
48959|      0|        return promise;
48960|      0|    if (magic == 0) {
48961|      0|        then_func = JS_NewCFunctionData(ctx, js_promise_finally_value_thunk, 0,
48962|      0|                                        0, 1, argv);
48963|      0|    } else {
48964|      0|        then_func = JS_NewCFunctionData(ctx, js_promise_finally_thrower, 0,
48965|      0|                                        0, 1, argv);
48966|      0|    }
48967|      0|    if (JS_IsException(then_func)) {
48968|      0|        JS_FreeValue(ctx, promise);
48969|      0|        return then_func;
48970|      0|    }
48971|      0|    ret = JS_InvokeFree(ctx, promise, JS_ATOM_then, 1, (JSValueConst *)&then_func);
48972|      0|    JS_FreeValue(ctx, then_func);
48973|      0|    return ret;
48974|      0|}
48975|       |
48976|       |static JSValue js_promise_finally(JSContext *ctx, JSValueConst this_val,
48977|       |                                  int argc, JSValueConst *argv)
48978|      0|{
48979|      0|    JSValueConst onFinally = argv[0];
48980|      0|    JSValue ctor, ret;
48981|      0|    JSValue then_funcs[2];
48982|      0|    JSValueConst func_data[2];
48983|      0|    int i;
48984|       |
48985|      0|    ctor = JS_SpeciesConstructor(ctx, this_val, JS_UNDEFINED);
48986|      0|    if (JS_IsException(ctor))
48987|      0|        return ctor;
48988|      0|    if (!JS_IsFunction(ctx, onFinally)) {
48989|      0|        then_funcs[0] = JS_DupValue(ctx, onFinally);
48990|      0|        then_funcs[1] = JS_DupValue(ctx, onFinally);
48991|      0|    } else {
48992|      0|        func_data[0] = ctor;
48993|      0|        func_data[1] = onFinally;
48994|      0|        for(i = 0; i < 2; i++) {
48995|      0|            then_funcs[i] = JS_NewCFunctionData(ctx, js_promise_then_finally_func, 1, i, 2, func_data);
48996|      0|            if (JS_IsException(then_funcs[i])) {
48997|      0|                if (i == 1)
48998|      0|                    JS_FreeValue(ctx, then_funcs[0]);
48999|      0|                JS_FreeValue(ctx, ctor);
49000|      0|                return JS_EXCEPTION;
49001|      0|            }
49002|      0|        }
49003|      0|    }
49004|      0|    JS_FreeValue(ctx, ctor);
49005|      0|    ret = JS_Invoke(ctx, this_val, JS_ATOM_then, 2, (JSValueConst *)then_funcs);
49006|      0|    JS_FreeValue(ctx, then_funcs[0]);
49007|      0|    JS_FreeValue(ctx, then_funcs[1]);
49008|      0|    return ret;
49009|      0|}
49010|       |
49011|       |static const JSCFunctionListEntry js_promise_funcs[] = {
49012|       |    JS_CFUNC_MAGIC_DEF("resolve", 1, js_promise_resolve, 0 ),
49013|       |    JS_CFUNC_MAGIC_DEF("reject", 1, js_promise_resolve, 1 ),
49014|       |    JS_CFUNC_MAGIC_DEF("all", 1, js_promise_all, PROMISE_MAGIC_all ),
49015|       |    JS_CFUNC_MAGIC_DEF("allSettled", 1, js_promise_all, PROMISE_MAGIC_allSettled ),
49016|       |    JS_CFUNC_MAGIC_DEF("any", 1, js_promise_all, PROMISE_MAGIC_any ),
49017|       |    JS_CFUNC_DEF("race", 1, js_promise_race ),
49018|       |    JS_CFUNC_DEF("withResolvers", 0, js_promise_withResolvers ),
49019|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
49020|       |};
49021|       |
49022|       |static const JSCFunctionListEntry js_promise_proto_funcs[] = {
49023|       |    JS_CFUNC_DEF("then", 2, js_promise_then ),
49024|       |    JS_CFUNC_DEF("catch", 1, js_promise_catch ),
49025|       |    JS_CFUNC_DEF("finally", 1, js_promise_finally ),
49026|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Promise", JS_PROP_CONFIGURABLE ),
49027|       |};
49028|       |
49029|       |/* AsyncFunction */
49030|       |static const JSCFunctionListEntry js_async_function_proto_funcs[] = {
49031|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncFunction", JS_PROP_CONFIGURABLE ),
49032|       |};
49033|       |
49034|       |/* AsyncIteratorPrototype */
49035|       |
49036|       |static const JSCFunctionListEntry js_async_iterator_proto_funcs[] = {
49037|       |    JS_CFUNC_DEF("[Symbol.asyncIterator]", 0, js_iterator_proto_iterator ),
49038|       |};
49039|       |
49040|       |/* AsyncFromSyncIteratorPrototype */
49041|       |
49042|       |typedef struct JSAsyncFromSyncIteratorData {
49043|       |    JSValue sync_iter;
49044|       |    JSValue next_method;
49045|       |} JSAsyncFromSyncIteratorData;
49046|       |
49047|       |static void js_async_from_sync_iterator_finalizer(JSRuntime *rt, JSValue val)
49048|      0|{
49049|      0|    JSAsyncFromSyncIteratorData *s =
49050|      0|        JS_GetOpaque(val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);
49051|      0|    if (s) {
49052|      0|        JS_FreeValueRT(rt, s->sync_iter);
49053|      0|        JS_FreeValueRT(rt, s->next_method);
49054|      0|        js_free_rt(rt, s);
49055|      0|    }
49056|      0|}
49057|       |
49058|       |static void js_async_from_sync_iterator_mark(JSRuntime *rt, JSValueConst val,
49059|       |                                             JS_MarkFunc *mark_func)
49060|      0|{
49061|      0|    JSAsyncFromSyncIteratorData *s =
49062|      0|        JS_GetOpaque(val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);
49063|      0|    if (s) {
49064|      0|        JS_MarkValue(rt, s->sync_iter, mark_func);
49065|      0|        JS_MarkValue(rt, s->next_method, mark_func);
49066|      0|    }
49067|      0|}
49068|       |
49069|       |static JSValue JS_CreateAsyncFromSyncIterator(JSContext *ctx,
49070|       |                                              JSValueConst sync_iter)
49071|      0|{
49072|      0|    JSValue async_iter, next_method;
49073|      0|    JSAsyncFromSyncIteratorData *s;
49074|       |
49075|      0|    next_method = JS_GetProperty(ctx, sync_iter, JS_ATOM_next);
49076|      0|    if (JS_IsException(next_method))
49077|      0|        return JS_EXCEPTION;
49078|      0|    async_iter = JS_NewObjectClass(ctx, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);
49079|      0|    if (JS_IsException(async_iter)) {
49080|      0|        JS_FreeValue(ctx, next_method);
49081|      0|        return async_iter;
49082|      0|    }
49083|      0|    s = js_mallocz(ctx, sizeof(*s));
49084|      0|    if (!s) {
49085|      0|        JS_FreeValue(ctx, async_iter);
49086|      0|        JS_FreeValue(ctx, next_method);
49087|      0|        return JS_EXCEPTION;
49088|      0|    }
49089|      0|    s->sync_iter = JS_DupValue(ctx, sync_iter);
49090|      0|    s->next_method = next_method;
49091|      0|    JS_SetOpaque(async_iter, s);
49092|      0|    return async_iter;
49093|      0|}
49094|       |
49095|       |static JSValue js_async_from_sync_iterator_unwrap(JSContext *ctx,
49096|       |                                                  JSValueConst this_val,
49097|       |                                                  int argc, JSValueConst *argv,
49098|       |                                                  int magic, JSValue *func_data)
49099|      0|{
49100|      0|    return js_create_iterator_result(ctx, JS_DupValue(ctx, argv[0]),
49101|      0|                                     JS_ToBool(ctx, func_data[0]));
49102|      0|}
49103|       |
49104|       |static JSValue js_async_from_sync_iterator_unwrap_func_create(JSContext *ctx,
49105|       |                                                              BOOL done)
49106|      0|{
49107|      0|    JSValueConst func_data[1];
49108|       |
49109|      0|    func_data[0] = (JSValueConst)JS_NewBool(ctx, done);
49110|      0|    return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_unwrap,
49111|      0|                               1, 0, 1, func_data);
49112|      0|}
49113|       |
49114|       |static JSValue js_async_from_sync_iterator_close_wrap(JSContext *ctx,
49115|       |                                                      JSValueConst this_val,
49116|       |                                                      int argc, JSValueConst *argv,
49117|       |                                                      int magic, JSValue *func_data)
49118|      0|{
49119|      0|    JS_Throw(ctx, JS_DupValue(ctx, argv[0]));
49120|      0|    JS_IteratorClose(ctx, func_data[0], TRUE);
49121|      0|    return JS_EXCEPTION;
49122|      0|}
49123|       |
49124|       |static JSValue js_async_from_sync_iterator_close_wrap_func_create(JSContext *ctx, JSValueConst sync_iter)
49125|      0|{
49126|      0|    return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_close_wrap,
49127|      0|                               1, 0, 1, &sync_iter);
49128|      0|}
49129|       |
49130|       |static JSValue js_async_from_sync_iterator_next(JSContext *ctx, JSValueConst this_val,
49131|       |                                                int argc, JSValueConst *argv,
49132|       |                                                int magic)
49133|      0|{
49134|      0|    JSValue promise, resolving_funcs[2], value, err, method;
49135|      0|    JSAsyncFromSyncIteratorData *s;
49136|      0|    int done;
49137|      0|    int is_reject;
49138|       |
49139|      0|    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
49140|      0|    if (JS_IsException(promise))
49141|      0|        return JS_EXCEPTION;
49142|      0|    s = JS_GetOpaque(this_val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);
49143|      0|    if (!s) {
49144|      0|        JS_ThrowTypeError(ctx, "not an Async-from-Sync Iterator");
49145|      0|        goto reject;
49146|      0|    }
49147|       |
49148|      0|    if (magic == GEN_MAGIC_NEXT) {
49149|      0|        method = JS_DupValue(ctx, s->next_method);
49150|      0|    } else {
49151|      0|        method = JS_GetProperty(ctx, s->sync_iter,
49152|      0|                                magic == GEN_MAGIC_RETURN ? JS_ATOM_return :
49153|      0|                                JS_ATOM_throw);
49154|      0|        if (JS_IsException(method))
49155|      0|            goto reject;
49156|      0|        if (JS_IsUndefined(method) || JS_IsNull(method)) {
49157|      0|            if (magic == GEN_MAGIC_RETURN) {
49158|      0|                err = js_create_iterator_result(ctx, JS_DupValue(ctx, argv[0]), TRUE);
49159|      0|                is_reject = 0;
49160|      0|                goto done_resolve;
49161|      0|            } else {
49162|      0|                if (JS_IteratorClose(ctx, s->sync_iter, FALSE))
49163|      0|                    goto reject;
49164|      0|                JS_ThrowTypeError(ctx, "throw is not a method");
49165|      0|                goto reject;
49166|      0|            }
49167|      0|        }
49168|      0|    }
49169|      0|    value = JS_IteratorNext2(ctx, s->sync_iter, method,
49170|      0|                             argc >= 1 ? 1 : 0, argv, &done);
49171|      0|    JS_FreeValue(ctx, method);
49172|      0|    if (JS_IsException(value))
49173|      0|        goto reject;
49174|      0|    if (done == 2) {
49175|      0|        JSValue obj = value;
49176|      0|        value = JS_IteratorGetCompleteValue(ctx, obj, &done);
49177|      0|        JS_FreeValue(ctx, obj);
49178|      0|        if (JS_IsException(value))
49179|      0|            goto reject;
49180|      0|    }
49181|       |    
49182|      0|    if (JS_IsException(value))
49183|      0|        goto reject;
49184|      0|    {
49185|      0|        JSValue value_wrapper_promise, resolve_reject[2];
49186|      0|        int res;
49187|       |
49188|      0|        value_wrapper_promise = js_promise_resolve(ctx, ctx->promise_ctor,
49189|      0|                                                   1, (JSValueConst *)&value, 0);
49190|      0|        if (JS_IsException(value_wrapper_promise)) {
49191|      0|            JSValue res2;
49192|      0|            JS_FreeValue(ctx, value);
49193|      0|            if (magic != GEN_MAGIC_RETURN && !done) {
49194|      0|                JS_IteratorClose(ctx, s->sync_iter, TRUE);
49195|      0|            }
49196|      0|        reject:
49197|      0|            err = JS_GetException(ctx);
49198|      0|            is_reject = 1;
49199|      0|        done_resolve:
49200|      0|            res2 = JS_Call(ctx, resolving_funcs[is_reject], JS_UNDEFINED,
49201|      0|                           1, (JSValueConst *)&err);
49202|      0|            JS_FreeValue(ctx, err);
49203|      0|            JS_FreeValue(ctx, res2);
49204|      0|            JS_FreeValue(ctx, resolving_funcs[0]);
49205|      0|            JS_FreeValue(ctx, resolving_funcs[1]);
49206|      0|            return promise;
49207|      0|        }
49208|       |
49209|      0|        resolve_reject[0] =
49210|      0|            js_async_from_sync_iterator_unwrap_func_create(ctx, done);
49211|      0|        if (JS_IsException(resolve_reject[0])) {
49212|      0|            JS_FreeValue(ctx, value_wrapper_promise);
49213|      0|            goto fail;
49214|      0|        }
49215|      0|        if (done || magic == GEN_MAGIC_RETURN) {
49216|      0|            resolve_reject[1] = JS_UNDEFINED;
49217|      0|        } else {
49218|      0|            resolve_reject[1] =
49219|      0|                js_async_from_sync_iterator_close_wrap_func_create(ctx, s->sync_iter);
49220|      0|            if (JS_IsException(resolve_reject[1])) {
49221|      0|                JS_FreeValue(ctx, value_wrapper_promise);
49222|      0|                JS_FreeValue(ctx, resolve_reject[0]);
49223|      0|                goto fail;
49224|      0|            }
49225|      0|        }
49226|      0|        JS_FreeValue(ctx, value);
49227|      0|        res = perform_promise_then(ctx, value_wrapper_promise,
49228|      0|                                   (JSValueConst *)resolve_reject,
49229|      0|                                   (JSValueConst *)resolving_funcs);
49230|      0|        JS_FreeValue(ctx, resolve_reject[0]);
49231|      0|        JS_FreeValue(ctx, resolve_reject[1]);
49232|      0|        JS_FreeValue(ctx, value_wrapper_promise);
49233|      0|        JS_FreeValue(ctx, resolving_funcs[0]);
49234|      0|        JS_FreeValue(ctx, resolving_funcs[1]);
49235|      0|        if (res) {
49236|      0|            JS_FreeValue(ctx, promise);
49237|      0|            return JS_EXCEPTION;
49238|      0|        }
49239|      0|    }
49240|      0|    return promise;
49241|      0| fail:
49242|      0|    JS_FreeValue(ctx, value);
49243|      0|    JS_FreeValue(ctx, resolving_funcs[0]);
49244|      0|    JS_FreeValue(ctx, resolving_funcs[1]);
49245|      0|    JS_FreeValue(ctx, promise);
49246|      0|    return JS_EXCEPTION;
49247|      0|}
49248|       |
49249|       |static const JSCFunctionListEntry js_async_from_sync_iterator_proto_funcs[] = {
49250|       |    JS_CFUNC_MAGIC_DEF("next", 1, js_async_from_sync_iterator_next, GEN_MAGIC_NEXT ),
49251|       |    JS_CFUNC_MAGIC_DEF("return", 1, js_async_from_sync_iterator_next, GEN_MAGIC_RETURN ),
49252|       |    JS_CFUNC_MAGIC_DEF("throw", 1, js_async_from_sync_iterator_next, GEN_MAGIC_THROW ),
49253|       |};
49254|       |
49255|       |/* AsyncGeneratorFunction */
49256|       |
49257|       |static const JSCFunctionListEntry js_async_generator_function_proto_funcs[] = {
49258|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncGeneratorFunction", JS_PROP_CONFIGURABLE ),
49259|       |};
49260|       |
49261|       |/* AsyncGenerator prototype */
49262|       |
49263|       |static const JSCFunctionListEntry js_async_generator_proto_funcs[] = {
49264|       |    JS_CFUNC_MAGIC_DEF("next", 1, js_async_generator_next, GEN_MAGIC_NEXT ),
49265|       |    JS_CFUNC_MAGIC_DEF("return", 1, js_async_generator_next, GEN_MAGIC_RETURN ),
49266|       |    JS_CFUNC_MAGIC_DEF("throw", 1, js_async_generator_next, GEN_MAGIC_THROW ),
49267|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncGenerator", JS_PROP_CONFIGURABLE ),
49268|       |};
49269|       |
49270|       |static JSClassShortDef const js_async_class_def[] = {
49271|       |    { JS_ATOM_Promise, js_promise_finalizer, js_promise_mark },                      /* JS_CLASS_PROMISE */
49272|       |    { JS_ATOM_PromiseResolveFunction, js_promise_resolve_function_finalizer, js_promise_resolve_function_mark }, /* JS_CLASS_PROMISE_RESOLVE_FUNCTION */
49273|       |    { JS_ATOM_PromiseRejectFunction, js_promise_resolve_function_finalizer, js_promise_resolve_function_mark }, /* JS_CLASS_PROMISE_REJECT_FUNCTION */
49274|       |    { JS_ATOM_AsyncFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_ASYNC_FUNCTION */
49275|       |    { JS_ATOM_AsyncFunctionResolve, js_async_function_resolve_finalizer, js_async_function_resolve_mark }, /* JS_CLASS_ASYNC_FUNCTION_RESOLVE */
49276|       |    { JS_ATOM_AsyncFunctionReject, js_async_function_resolve_finalizer, js_async_function_resolve_mark }, /* JS_CLASS_ASYNC_FUNCTION_REJECT */
49277|       |    { JS_ATOM_empty_string, js_async_from_sync_iterator_finalizer, js_async_from_sync_iterator_mark }, /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */
49278|       |    { JS_ATOM_AsyncGeneratorFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_ASYNC_GENERATOR_FUNCTION */
49279|       |    { JS_ATOM_AsyncGenerator, js_async_generator_finalizer, js_async_generator_mark },  /* JS_CLASS_ASYNC_GENERATOR */
49280|       |};
49281|       |
49282|       |void JS_AddIntrinsicPromise(JSContext *ctx)
49283|  17.7k|{
49284|  17.7k|    JSRuntime *rt = ctx->rt;
49285|  17.7k|    JSValue obj1;
49286|       |
49287|  17.7k|    if (!JS_IsRegisteredClass(rt, JS_CLASS_PROMISE)) {
49288|  17.7k|        init_class_range(rt, js_async_class_def, JS_CLASS_PROMISE,
49289|  17.7k|                         countof(js_async_class_def));
49290|  17.7k|        rt->class_array[JS_CLASS_PROMISE_RESOLVE_FUNCTION].call = js_promise_resolve_function_call;
49291|  17.7k|        rt->class_array[JS_CLASS_PROMISE_REJECT_FUNCTION].call = js_promise_resolve_function_call;
49292|  17.7k|        rt->class_array[JS_CLASS_ASYNC_FUNCTION].call = js_async_function_call;
49293|  17.7k|        rt->class_array[JS_CLASS_ASYNC_FUNCTION_RESOLVE].call = js_async_function_resolve_call;
49294|  17.7k|        rt->class_array[JS_CLASS_ASYNC_FUNCTION_REJECT].call = js_async_function_resolve_call;
49295|  17.7k|        rt->class_array[JS_CLASS_ASYNC_GENERATOR_FUNCTION].call = js_async_generator_function_call;
49296|  17.7k|    }
49297|       |
49298|       |    /* Promise */
49299|  17.7k|    ctx->class_proto[JS_CLASS_PROMISE] = JS_NewObject(ctx);
49300|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_PROMISE],
49301|  17.7k|                               js_promise_proto_funcs,
49302|  17.7k|                               countof(js_promise_proto_funcs));
49303|  17.7k|    obj1 = JS_NewCFunction2(ctx, js_promise_constructor, "Promise", 1,
49304|  17.7k|                            JS_CFUNC_constructor, 0);
49305|  17.7k|    ctx->promise_ctor = JS_DupValue(ctx, obj1);
49306|  17.7k|    JS_SetPropertyFunctionList(ctx, obj1,
49307|  17.7k|                               js_promise_funcs,
49308|  17.7k|                               countof(js_promise_funcs));
49309|  17.7k|    JS_NewGlobalCConstructor2(ctx, obj1, "Promise",
49310|  17.7k|                              ctx->class_proto[JS_CLASS_PROMISE]);
49311|       |
49312|       |    /* AsyncFunction */
49313|  17.7k|    ctx->class_proto[JS_CLASS_ASYNC_FUNCTION] = JS_NewObjectProto(ctx, ctx->function_proto);
49314|  17.7k|    obj1 = JS_NewCFunction3(ctx, (JSCFunction *)js_function_constructor,
49315|  17.7k|                            "AsyncFunction", 1,
49316|  17.7k|                            JS_CFUNC_constructor_or_func_magic, JS_FUNC_ASYNC,
49317|  17.7k|                            ctx->function_ctor);
49318|  17.7k|    JS_SetPropertyFunctionList(ctx,
49319|  17.7k|                               ctx->class_proto[JS_CLASS_ASYNC_FUNCTION],
49320|  17.7k|                               js_async_function_proto_funcs,
49321|  17.7k|                               countof(js_async_function_proto_funcs));
49322|  17.7k|    JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_ASYNC_FUNCTION],
49323|  17.7k|                       0, JS_PROP_CONFIGURABLE);
49324|  17.7k|    JS_FreeValue(ctx, obj1);
49325|       |
49326|       |    /* AsyncIteratorPrototype */
49327|  17.7k|    ctx->async_iterator_proto = JS_NewObject(ctx);
49328|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->async_iterator_proto,
49329|  17.7k|                               js_async_iterator_proto_funcs,
49330|  17.7k|                               countof(js_async_iterator_proto_funcs));
49331|       |
49332|       |    /* AsyncFromSyncIteratorPrototype */
49333|  17.7k|    ctx->class_proto[JS_CLASS_ASYNC_FROM_SYNC_ITERATOR] =
49334|  17.7k|        JS_NewObjectProto(ctx, ctx->async_iterator_proto);
49335|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ASYNC_FROM_SYNC_ITERATOR],
49336|  17.7k|                               js_async_from_sync_iterator_proto_funcs,
49337|  17.7k|                               countof(js_async_from_sync_iterator_proto_funcs));
49338|       |
49339|       |    /* AsyncGeneratorPrototype */
49340|  17.7k|    ctx->class_proto[JS_CLASS_ASYNC_GENERATOR] =
49341|  17.7k|        JS_NewObjectProto(ctx, ctx->async_iterator_proto);
49342|  17.7k|    JS_SetPropertyFunctionList(ctx,
49343|  17.7k|                               ctx->class_proto[JS_CLASS_ASYNC_GENERATOR],
49344|  17.7k|                               js_async_generator_proto_funcs,
49345|  17.7k|                               countof(js_async_generator_proto_funcs));
49346|       |
49347|       |    /* AsyncGeneratorFunction */
49348|  17.7k|    ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION] =
49349|  17.7k|        JS_NewObjectProto(ctx, ctx->function_proto);
49350|  17.7k|    obj1 = JS_NewCFunction3(ctx, (JSCFunction *)js_function_constructor,
49351|  17.7k|                            "AsyncGeneratorFunction", 1,
49352|  17.7k|                            JS_CFUNC_constructor_or_func_magic,
49353|  17.7k|                            JS_FUNC_ASYNC_GENERATOR,
49354|  17.7k|                            ctx->function_ctor);
49355|  17.7k|    JS_SetPropertyFunctionList(ctx,
49356|  17.7k|                               ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],
49357|  17.7k|                               js_async_generator_function_proto_funcs,
49358|  17.7k|                               countof(js_async_generator_function_proto_funcs));
49359|  17.7k|    JS_SetConstructor2(ctx, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],
49360|  17.7k|                       ctx->class_proto[JS_CLASS_ASYNC_GENERATOR],
49361|  17.7k|                       JS_PROP_CONFIGURABLE, JS_PROP_CONFIGURABLE);
49362|  17.7k|    JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],
49363|  17.7k|                       0, JS_PROP_CONFIGURABLE);
49364|  17.7k|    JS_FreeValue(ctx, obj1);
49365|  17.7k|}
49366|       |
49367|       |/* URI handling */
49368|       |
49369|      0|static int string_get_hex(JSString *p, int k, int n) {
49370|      0|    int c = 0, h;
49371|      0|    while (n-- > 0) {
49372|      0|        if ((h = from_hex(string_get(p, k++))) < 0)
49373|      0|            return -1;
49374|      0|        c = (c << 4) | h;
49375|      0|    }
49376|      0|    return c;
49377|      0|}
49378|       |
49379|      0|static int isURIReserved(int c) {
49380|      0|    return c < 0x100 && memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
49381|      0|}
49382|       |
49383|       |static int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
49384|      0|{
49385|      0|    va_list ap;
49386|       |
49387|      0|    va_start(ap, fmt);
49388|      0|    JS_ThrowError(ctx, JS_URI_ERROR, fmt, ap);
49389|      0|    va_end(ap);
49390|      0|    return -1;
49391|      0|}
49392|       |
49393|      0|static int hex_decode(JSContext *ctx, JSString *p, int k) {
49394|      0|    int c;
49395|       |
49396|      0|    if (k >= p->len || string_get(p, k) != '%')
49397|      0|        return js_throw_URIError(ctx, "expecting %%");
49398|      0|    if (k + 2 >= p->len || (c = string_get_hex(p, k + 1, 2)) < 0)
49399|      0|        return js_throw_URIError(ctx, "expecting hex digit");
49400|       |
49401|      0|    return c;
49402|      0|}
49403|       |
49404|       |static JSValue js_global_decodeURI(JSContext *ctx, JSValueConst this_val,
49405|       |                                   int argc, JSValueConst *argv, int isComponent)
49406|      0|{
49407|      0|    JSValue str;
49408|      0|    StringBuffer b_s, *b = &b_s;
49409|      0|    JSString *p;
49410|      0|    int k, c, c1, n, c_min;
49411|       |
49412|      0|    str = JS_ToString(ctx, argv[0]);
49413|      0|    if (JS_IsException(str))
49414|      0|        return str;
49415|       |
49416|      0|    string_buffer_init(ctx, b, 0);
49417|       |
49418|      0|    p = JS_VALUE_GET_STRING(str);
49419|      0|    for (k = 0; k < p->len;) {
49420|      0|        c = string_get(p, k);
49421|      0|        if (c == '%') {
49422|      0|            c = hex_decode(ctx, p, k);
49423|      0|            if (c < 0)
49424|      0|                goto fail;
49425|      0|            k += 3;
49426|      0|            if (c < 0x80) {
49427|      0|                if (!isComponent && isURIReserved(c)) {
49428|      0|                    c = '%';
49429|      0|                    k -= 2;
49430|      0|                }
49431|      0|            } else {
49432|       |                /* Decode URI-encoded UTF-8 sequence */
49433|      0|                if (c >= 0xc0 && c <= 0xdf) {
49434|      0|                    n = 1;
49435|      0|                    c_min = 0x80;
49436|      0|                    c &= 0x1f;
49437|      0|                } else if (c >= 0xe0 && c <= 0xef) {
49438|      0|                    n = 2;
49439|      0|                    c_min = 0x800;
49440|      0|                    c &= 0xf;
49441|      0|                } else if (c >= 0xf0 && c <= 0xf7) {
49442|      0|                    n = 3;
49443|      0|                    c_min = 0x10000;
49444|      0|                    c &= 0x7;
49445|      0|                } else {
49446|      0|                    n = 0;
49447|      0|                    c_min = 1;
49448|      0|                    c = 0;
49449|      0|                }
49450|      0|                while (n-- > 0) {
49451|      0|                    c1 = hex_decode(ctx, p, k);
49452|      0|                    if (c1 < 0)
49453|      0|                        goto fail;
49454|      0|                    k += 3;
49455|      0|                    if ((c1 & 0xc0) != 0x80) {
49456|      0|                        c = 0;
49457|      0|                        break;
49458|      0|                    }
49459|      0|                    c = (c << 6) | (c1 & 0x3f);
49460|      0|                }
49461|      0|                if (c < c_min || c > 0x10FFFF || is_surrogate(c)) {
49462|      0|                    js_throw_URIError(ctx, "malformed UTF-8");
49463|      0|                    goto fail;
49464|      0|                }
49465|      0|            }
49466|      0|        } else {
49467|      0|            k++;
49468|      0|        }
49469|      0|        string_buffer_putc(b, c);
49470|      0|    }
49471|      0|    JS_FreeValue(ctx, str);
49472|      0|    return string_buffer_end(b);
49473|       |
49474|      0|fail:
49475|      0|    JS_FreeValue(ctx, str);
49476|      0|    string_buffer_free(b);
49477|      0|    return JS_EXCEPTION;
49478|      0|}
49479|       |
49480|      0|static int isUnescaped(int c) {
49481|      0|    static char const unescaped_chars[] =
49482|      0|        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
49483|      0|        "abcdefghijklmnopqrstuvwxyz"
49484|      0|        "0123456789"
49485|      0|        "@*_+-./";
49486|      0|    return c < 0x100 &&
49487|      0|        memchr(unescaped_chars, c, sizeof(unescaped_chars) - 1);
49488|      0|}
49489|       |
49490|      0|static int isURIUnescaped(int c, int isComponent) {
49491|      0|    return c < 0x100 &&
49492|      0|        ((c >= 0x61 && c <= 0x7a) ||
49493|      0|         (c >= 0x41 && c <= 0x5a) ||
49494|      0|         (c >= 0x30 && c <= 0x39) ||
49495|      0|         memchr("-_.!~*'()", c, sizeof("-_.!~*'()") - 1) != NULL ||
49496|      0|         (!isComponent && isURIReserved(c)));
49497|      0|}
49498|       |
49499|      0|static int encodeURI_hex(StringBuffer *b, int c) {
49500|      0|    uint8_t buf[6];
49501|      0|    int n = 0;
49502|      0|    const char *hex = "0123456789ABCDEF";
49503|       |
49504|      0|    buf[n++] = '%';
49505|      0|    if (c >= 256) {
49506|      0|        buf[n++] = 'u';
49507|      0|        buf[n++] = hex[(c >> 12) & 15];
49508|      0|        buf[n++] = hex[(c >>  8) & 15];
49509|      0|    }
49510|      0|    buf[n++] = hex[(c >> 4) & 15];
49511|      0|    buf[n++] = hex[(c >> 0) & 15];
49512|      0|    return string_buffer_write8(b, buf, n);
49513|      0|}
49514|       |
49515|       |static JSValue js_global_encodeURI(JSContext *ctx, JSValueConst this_val,
49516|       |                                   int argc, JSValueConst *argv,
49517|       |                                   int isComponent)
49518|      0|{
49519|      0|    JSValue str;
49520|      0|    StringBuffer b_s, *b = &b_s;
49521|      0|    JSString *p;
49522|      0|    int k, c, c1;
49523|       |
49524|      0|    str = JS_ToString(ctx, argv[0]);
49525|      0|    if (JS_IsException(str))
49526|      0|        return str;
49527|       |
49528|      0|    p = JS_VALUE_GET_STRING(str);
49529|      0|    string_buffer_init(ctx, b, p->len);
49530|      0|    for (k = 0; k < p->len;) {
49531|      0|        c = string_get(p, k);
49532|      0|        k++;
49533|      0|        if (isURIUnescaped(c, isComponent)) {
49534|      0|            string_buffer_putc16(b, c);
49535|      0|        } else {
49536|      0|            if (is_lo_surrogate(c)) {
49537|      0|                js_throw_URIError(ctx, "invalid character");
49538|      0|                goto fail;
49539|      0|            } else if (is_hi_surrogate(c)) {
49540|      0|                if (k >= p->len) {
49541|      0|                    js_throw_URIError(ctx, "expecting surrogate pair");
49542|      0|                    goto fail;
49543|      0|                }
49544|      0|                c1 = string_get(p, k);
49545|      0|                k++;
49546|      0|                if (!is_lo_surrogate(c1)) {
49547|      0|                    js_throw_URIError(ctx, "expecting surrogate pair");
49548|      0|                    goto fail;
49549|      0|                }
49550|      0|                c = from_surrogate(c, c1);
49551|      0|            }
49552|      0|            if (c < 0x80) {
49553|      0|                encodeURI_hex(b, c);
49554|      0|            } else {
49555|       |                /* XXX: use C UTF-8 conversion ? */
49556|      0|                if (c < 0x800) {
49557|      0|                    encodeURI_hex(b, (c >> 6) | 0xc0);
49558|      0|                } else {
49559|      0|                    if (c < 0x10000) {
49560|      0|                        encodeURI_hex(b, (c >> 12) | 0xe0);
49561|      0|                    } else {
49562|      0|                        encodeURI_hex(b, (c >> 18) | 0xf0);
49563|      0|                        encodeURI_hex(b, ((c >> 12) & 0x3f) | 0x80);
49564|      0|                    }
49565|      0|                    encodeURI_hex(b, ((c >> 6) & 0x3f) | 0x80);
49566|      0|                }
49567|      0|                encodeURI_hex(b, (c & 0x3f) | 0x80);
49568|      0|            }
49569|      0|        }
49570|      0|    }
49571|      0|    JS_FreeValue(ctx, str);
49572|      0|    return string_buffer_end(b);
49573|       |
49574|      0|fail:
49575|      0|    JS_FreeValue(ctx, str);
49576|      0|    string_buffer_free(b);
49577|      0|    return JS_EXCEPTION;
49578|      0|}
49579|       |
49580|       |static JSValue js_global_escape(JSContext *ctx, JSValueConst this_val,
49581|       |                                int argc, JSValueConst *argv)
49582|      0|{
49583|      0|    JSValue str;
49584|      0|    StringBuffer b_s, *b = &b_s;
49585|      0|    JSString *p;
49586|      0|    int i, len, c;
49587|       |
49588|      0|    str = JS_ToString(ctx, argv[0]);
49589|      0|    if (JS_IsException(str))
49590|      0|        return str;
49591|       |
49592|      0|    p = JS_VALUE_GET_STRING(str);
49593|      0|    string_buffer_init(ctx, b, p->len);
49594|      0|    for (i = 0, len = p->len; i < len; i++) {
49595|      0|        c = string_get(p, i);
49596|      0|        if (isUnescaped(c)) {
49597|      0|            string_buffer_putc16(b, c);
49598|      0|        } else {
49599|      0|            encodeURI_hex(b, c);
49600|      0|        }
49601|      0|    }
49602|      0|    JS_FreeValue(ctx, str);
49603|      0|    return string_buffer_end(b);
49604|      0|}
49605|       |
49606|       |static JSValue js_global_unescape(JSContext *ctx, JSValueConst this_val,
49607|       |                                  int argc, JSValueConst *argv)
49608|      0|{
49609|      0|    JSValue str;
49610|      0|    StringBuffer b_s, *b = &b_s;
49611|      0|    JSString *p;
49612|      0|    int i, len, c, n;
49613|       |
49614|      0|    str = JS_ToString(ctx, argv[0]);
49615|      0|    if (JS_IsException(str))
49616|      0|        return str;
49617|       |
49618|      0|    string_buffer_init(ctx, b, 0);
49619|      0|    p = JS_VALUE_GET_STRING(str);
49620|      0|    for (i = 0, len = p->len; i < len; i++) {
49621|      0|        c = string_get(p, i);
49622|      0|        if (c == '%') {
49623|      0|            if (i + 6 <= len
49624|      0|            &&  string_get(p, i + 1) == 'u'
49625|      0|            &&  (n = string_get_hex(p, i + 2, 4)) >= 0) {
49626|      0|                c = n;
49627|      0|                i += 6 - 1;
49628|      0|            } else
49629|      0|            if (i + 3 <= len
49630|      0|            &&  (n = string_get_hex(p, i + 1, 2)) >= 0) {
49631|      0|                c = n;
49632|      0|                i += 3 - 1;
49633|      0|            }
49634|      0|        }
49635|      0|        string_buffer_putc16(b, c);
49636|      0|    }
49637|      0|    JS_FreeValue(ctx, str);
49638|      0|    return string_buffer_end(b);
49639|      0|}
49640|       |
49641|       |/* global object */
49642|       |
49643|       |static const JSCFunctionListEntry js_global_funcs[] = {
49644|       |    JS_CFUNC_DEF("parseInt", 2, js_parseInt ),
49645|       |    JS_CFUNC_DEF("parseFloat", 1, js_parseFloat ),
49646|       |    JS_CFUNC_DEF("isNaN", 1, js_global_isNaN ),
49647|       |    JS_CFUNC_DEF("isFinite", 1, js_global_isFinite ),
49648|       |
49649|       |    JS_CFUNC_MAGIC_DEF("decodeURI", 1, js_global_decodeURI, 0 ),
49650|       |    JS_CFUNC_MAGIC_DEF("decodeURIComponent", 1, js_global_decodeURI, 1 ),
49651|       |    JS_CFUNC_MAGIC_DEF("encodeURI", 1, js_global_encodeURI, 0 ),
49652|       |    JS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, js_global_encodeURI, 1 ),
49653|       |    JS_CFUNC_DEF("escape", 1, js_global_escape ),
49654|       |    JS_CFUNC_DEF("unescape", 1, js_global_unescape ),
49655|       |    JS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0 ),
49656|       |    JS_PROP_DOUBLE_DEF("NaN", NAN, 0 ),
49657|       |    JS_PROP_UNDEFINED_DEF("undefined", 0 ),
49658|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "global", JS_PROP_CONFIGURABLE ),
49659|       |};
49660|       |
49661|       |/* Date */
49662|       |
49663|      0|static int64_t math_mod(int64_t a, int64_t b) {
49664|       |    /* return positive modulo */
49665|      0|    int64_t m = a % b;
49666|      0|    return m + (m < 0) * b;
49667|      0|}
49668|       |
49669|      0|static int64_t floor_div(int64_t a, int64_t b) {
49670|       |    /* integer division rounding toward -Infinity */
49671|      0|    int64_t m = a % b;
49672|      0|    return (a - (m + (m < 0) * b)) / b;
49673|      0|}
49674|       |
49675|       |static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
49676|       |                             int argc, JSValueConst *argv);
49677|       |
49678|       |static __exception int JS_ThisTimeValue(JSContext *ctx, double *valp, JSValueConst this_val)
49679|      0|{
49680|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
49681|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
49682|      0|        if (p->class_id == JS_CLASS_DATE && JS_IsNumber(p->u.object_data))
49683|      0|            return JS_ToFloat64(ctx, valp, p->u.object_data);
49684|      0|    }
49685|      0|    JS_ThrowTypeError(ctx, "not a Date object");
49686|      0|    return -1;
49687|      0|}
49688|       |
49689|       |static JSValue JS_SetThisTimeValue(JSContext *ctx, JSValueConst this_val, double v)
49690|      0|{
49691|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
49692|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
49693|      0|        if (p->class_id == JS_CLASS_DATE) {
49694|      0|            JS_FreeValue(ctx, p->u.object_data);
49695|      0|            p->u.object_data = JS_NewFloat64(ctx, v);
49696|      0|            return JS_DupValue(ctx, p->u.object_data);
49697|      0|        }
49698|      0|    }
49699|      0|    return JS_ThrowTypeError(ctx, "not a Date object");
49700|      0|}
49701|       |
49702|      0|static int64_t days_from_year(int64_t y) {
49703|      0|    return 365 * (y - 1970) + floor_div(y - 1969, 4) -
49704|      0|        floor_div(y - 1901, 100) + floor_div(y - 1601, 400);
49705|      0|}
49706|       |
49707|      0|static int64_t days_in_year(int64_t y) {
49708|      0|    return 365 + !(y % 4) - !(y % 100) + !(y % 400);
49709|      0|}
49710|       |
49711|       |/* return the year, update days */
49712|      0|static int64_t year_from_days(int64_t *days) {
49713|      0|    int64_t y, d1, nd, d = *days;
49714|      0|    y = floor_div(d * 10000, 3652425) + 1970;
49715|       |    /* the initial approximation is very good, so only a few
49716|       |       iterations are necessary */
49717|      0|    for(;;) {
49718|      0|        d1 = d - days_from_year(y);
49719|      0|        if (d1 < 0) {
49720|      0|            y--;
49721|      0|            d1 += days_in_year(y);
49722|      0|        } else {
49723|      0|            nd = days_in_year(y);
49724|      0|            if (d1 < nd)
49725|      0|                break;
49726|      0|            d1 -= nd;
49727|      0|            y++;
49728|      0|        }
49729|      0|    }
49730|      0|    *days = d1;
49731|      0|    return y;
49732|      0|}
49733|       |
49734|       |static int const month_days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
49735|       |static char const month_names[] = "JanFebMarAprMayJunJulAugSepOctNovDec";
49736|       |static char const day_names[] = "SunMonTueWedThuFriSat";
49737|       |
49738|       |static __exception int get_date_fields(JSContext *ctx, JSValueConst obj,
49739|       |                                       double fields[minimum_length(9)], int is_local, int force)
49740|      0|{
49741|      0|    double dval;
49742|      0|    int64_t d, days, wd, y, i, md, h, m, s, ms, tz = 0;
49743|       |
49744|      0|    if (JS_ThisTimeValue(ctx, &dval, obj))
49745|      0|        return -1;
49746|       |
49747|      0|    if (isnan(dval)) {
49748|      0|        if (!force)
49749|      0|            return FALSE; /* NaN */
49750|      0|        d = 0;        /* initialize all fields to 0 */
49751|      0|    } else {
49752|      0|        d = dval;     /* assuming -8.64e15 <= dval <= -8.64e15 */
49753|      0|        if (is_local) {
49754|      0|            tz = -getTimezoneOffset(d);
49755|      0|            d += tz * 60000;
49756|      0|        }
49757|      0|    }
49758|       |
49759|       |    /* result is >= 0, we can use % */
49760|      0|    h = math_mod(d, 86400000);
49761|      0|    days = (d - h) / 86400000;
49762|      0|    ms = h % 1000;
49763|      0|    h = (h - ms) / 1000;
49764|      0|    s = h % 60;
49765|      0|    h = (h - s) / 60;
49766|      0|    m = h % 60;
49767|      0|    h = (h - m) / 60;
49768|      0|    wd = math_mod(days + 4, 7); /* week day */
49769|      0|    y = year_from_days(&days);
49770|       |
49771|      0|    for(i = 0; i < 11; i++) {
49772|      0|        md = month_days[i];
49773|      0|        if (i == 1)
49774|      0|            md += days_in_year(y) - 365;
49775|      0|        if (days < md)
49776|      0|            break;
49777|      0|        days -= md;
49778|      0|    }
49779|      0|    fields[0] = y;
49780|      0|    fields[1] = i;
49781|      0|    fields[2] = days + 1;
49782|      0|    fields[3] = h;
49783|      0|    fields[4] = m;
49784|      0|    fields[5] = s;
49785|      0|    fields[6] = ms;
49786|      0|    fields[7] = wd;
49787|      0|    fields[8] = tz;
49788|      0|    return TRUE;
49789|      0|}
49790|       |
49791|      0|static double time_clip(double t) {
49792|      0|    if (t >= -8.64e15 && t <= 8.64e15)
49793|      0|        return trunc(t) + 0.0;  /* convert -0 to +0 */
49794|      0|    else
49795|      0|        return NAN;
49796|      0|}
49797|       |
49798|       |/* The spec mandates the use of 'double' and it specifies the order
49799|       |   of the operations */
49800|      0|static double set_date_fields(double fields[minimum_length(7)], int is_local) {
49801|      0|    double y, m, dt, ym, mn, day, h, s, milli, time, tv;
49802|      0|    int yi, mi, i;
49803|      0|    int64_t days;
49804|      0|    volatile double temp;  /* enforce evaluation order */
49805|       |
49806|       |    /* emulate 21.4.1.15 MakeDay ( year, month, date ) */
49807|      0|    y = fields[0];
49808|      0|    m = fields[1];
49809|      0|    dt = fields[2];
49810|      0|    ym = y + floor(m / 12);
49811|      0|    mn = fmod(m, 12);
49812|      0|    if (mn < 0)
49813|      0|        mn += 12;
49814|      0|    if (ym < -271821 || ym > 275760)
49815|      0|        return NAN;
49816|       |
49817|      0|    yi = ym;
49818|      0|    mi = mn;
49819|      0|    days = days_from_year(yi);
49820|      0|    for(i = 0; i < mi; i++) {
49821|      0|        days += month_days[i];
49822|      0|        if (i == 1)
49823|      0|            days += days_in_year(yi) - 365;
49824|      0|    }
49825|      0|    day = days + dt - 1;
49826|       |
49827|       |    /* emulate 21.4.1.14 MakeTime ( hour, min, sec, ms ) */
49828|      0|    h = fields[3];
49829|      0|    m = fields[4];
49830|      0|    s = fields[5];
49831|      0|    milli = fields[6];
49832|       |    /* Use a volatile intermediary variable to ensure order of evaluation
49833|       |     * as specified in ECMA. This fixes a test262 error on
49834|       |     * test262/test/built-ins/Date/UTC/fp-evaluation-order.js.
49835|       |     * Without the volatile qualifier, the compile can generate code
49836|       |     * that performs the computation in a different order or with instructions
49837|       |     * that produce a different result such as FMA (float multiply and add).
49838|       |     */
49839|      0|    time = h * 3600000;
49840|      0|    time += (temp = m * 60000);
49841|      0|    time += (temp = s * 1000);
49842|      0|    time += milli;
49843|       |
49844|       |    /* emulate 21.4.1.16 MakeDate ( day, time ) */
49845|      0|    tv = (temp = day * 86400000) + time;   /* prevent generation of FMA */
49846|      0|    if (!isfinite(tv))
49847|      0|        return NAN;
49848|       |
49849|       |    /* adjust for local time and clip */
49850|      0|    if (is_local) {
49851|      0|        int64_t ti = tv < INT64_MIN ? INT64_MIN : tv >= 0x1p63 ? INT64_MAX : (int64_t)tv;
49852|      0|        tv += getTimezoneOffset(ti) * 60000;
49853|      0|    }
49854|      0|    return time_clip(tv);
49855|      0|}
49856|       |
49857|       |static JSValue get_date_field(JSContext *ctx, JSValueConst this_val,
49858|       |                              int argc, JSValueConst *argv, int magic)
49859|      0|{
49860|       |    // get_date_field(obj, n, is_local)
49861|      0|    double fields[9];
49862|      0|    int res, n, is_local;
49863|       |
49864|      0|    is_local = magic & 0x0F;
49865|      0|    n = (magic >> 4) & 0x0F;
49866|      0|    res = get_date_fields(ctx, this_val, fields, is_local, 0);
49867|      0|    if (res < 0)
49868|      0|        return JS_EXCEPTION;
49869|      0|    if (!res)
49870|      0|        return JS_NAN;
49871|       |
49872|      0|    if (magic & 0x100) {    // getYear
49873|      0|        fields[0] -= 1900;
49874|      0|    }
49875|      0|    return JS_NewFloat64(ctx, fields[n]);
49876|      0|}
49877|       |
49878|       |static JSValue set_date_field(JSContext *ctx, JSValueConst this_val,
49879|       |                              int argc, JSValueConst *argv, int magic)
49880|      0|{
49881|       |    // _field(obj, first_field, end_field, args, is_local)
49882|      0|    double fields[9];
49883|      0|    int res, first_field, end_field, is_local, i, n, res1;
49884|      0|    double d, a;
49885|       |
49886|      0|    d = NAN;
49887|      0|    first_field = (magic >> 8) & 0x0F;
49888|      0|    end_field = (magic >> 4) & 0x0F;
49889|      0|    is_local = magic & 0x0F;
49890|       |
49891|      0|    res = get_date_fields(ctx, this_val, fields, is_local, first_field == 0);
49892|      0|    if (res < 0)
49893|      0|        return JS_EXCEPTION;
49894|      0|    res1 = res;
49895|       |    
49896|       |    // Argument coercion is observable and must be done unconditionally.
49897|      0|    n = min_int(argc, end_field - first_field);
49898|      0|    for(i = 0; i < n; i++) {
49899|      0|        if (JS_ToFloat64(ctx, &a, argv[i]))
49900|      0|            return JS_EXCEPTION;
49901|      0|        if (!isfinite(a))
49902|      0|            res = FALSE;
49903|      0|        fields[first_field + i] = trunc(a);
49904|      0|    }
49905|       |
49906|      0|    if (!res1)
49907|      0|        return JS_NAN; /* thisTimeValue is NaN */
49908|       |
49909|      0|    if (res && argc > 0)
49910|      0|        d = set_date_fields(fields, is_local);
49911|       |
49912|      0|    return JS_SetThisTimeValue(ctx, this_val, d);
49913|      0|}
49914|       |
49915|       |/* fmt:
49916|       |   0: toUTCString: "Tue, 02 Jan 2018 23:04:46 GMT"
49917|       |   1: toString: "Wed Jan 03 2018 00:05:22 GMT+0100 (CET)"
49918|       |   2: toISOString: "2018-01-02T23:02:56.927Z"
49919|       |   3: toLocaleString: "1/2/2018, 11:40:40 PM"
49920|       |   part: 1=date, 2=time 3=all
49921|       |   XXX: should use a variant of strftime().
49922|       | */
49923|       |static JSValue get_date_string(JSContext *ctx, JSValueConst this_val,
49924|       |                               int argc, JSValueConst *argv, int magic)
49925|      0|{
49926|       |    // _string(obj, fmt, part)
49927|      0|    char buf[64];
49928|      0|    double fields[9];
49929|      0|    int res, fmt, part, pos;
49930|      0|    int y, mon, d, h, m, s, ms, wd, tz;
49931|       |
49932|      0|    fmt = (magic >> 4) & 0x0F;
49933|      0|    part = magic & 0x0F;
49934|       |
49935|      0|    res = get_date_fields(ctx, this_val, fields, fmt & 1, 0);
49936|      0|    if (res < 0)
49937|      0|        return JS_EXCEPTION;
49938|      0|    if (!res) {
49939|      0|        if (fmt == 2)
49940|      0|            return JS_ThrowRangeError(ctx, "Date value is NaN");
49941|      0|        else
49942|      0|            return js_new_string8(ctx, "Invalid Date");
49943|      0|    }
49944|       |
49945|      0|    y = fields[0];
49946|      0|    mon = fields[1];
49947|      0|    d = fields[2];
49948|      0|    h = fields[3];
49949|      0|    m = fields[4];
49950|      0|    s = fields[5];
49951|      0|    ms = fields[6];
49952|      0|    wd = fields[7];
49953|      0|    tz = fields[8];
49954|       |
49955|      0|    pos = 0;
49956|       |
49957|      0|    if (part & 1) { /* date part */
49958|      0|        switch(fmt) {
49959|      0|        case 0:
49960|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
49961|      0|                            "%.3s, %02d %.3s %0*d ",
49962|      0|                            day_names + wd * 3, d,
49963|      0|                            month_names + mon * 3, 4 + (y < 0), y);
49964|      0|            break;
49965|      0|        case 1:
49966|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
49967|      0|                            "%.3s %.3s %02d %0*d",
49968|      0|                            day_names + wd * 3,
49969|      0|                            month_names + mon * 3, d, 4 + (y < 0), y);
49970|      0|            if (part == 3) {
49971|      0|                buf[pos++] = ' ';
49972|      0|            }
49973|      0|            break;
49974|      0|        case 2:
49975|      0|            if (y >= 0 && y <= 9999) {
49976|      0|                pos += snprintf(buf + pos, sizeof(buf) - pos,
49977|      0|                                "%04d", y);
49978|      0|            } else {
49979|      0|                pos += snprintf(buf + pos, sizeof(buf) - pos,
49980|      0|                                "%+07d", y);
49981|      0|            }
49982|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
49983|      0|                            "-%02d-%02dT", mon + 1, d);
49984|      0|            break;
49985|      0|        case 3:
49986|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
49987|      0|                            "%02d/%02d/%0*d", mon + 1, d, 4 + (y < 0), y);
49988|      0|            if (part == 3) {
49989|      0|                buf[pos++] = ',';
49990|      0|                buf[pos++] = ' ';
49991|      0|            }
49992|      0|            break;
49993|      0|        }
49994|      0|    }
49995|      0|    if (part & 2) { /* time part */
49996|      0|        switch(fmt) {
49997|      0|        case 0:
49998|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
49999|      0|                            "%02d:%02d:%02d GMT", h, m, s);
50000|      0|            break;
50001|      0|        case 1:
50002|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
50003|      0|                            "%02d:%02d:%02d GMT", h, m, s);
50004|      0|            if (tz < 0) {
50005|      0|                buf[pos++] = '-';
50006|      0|                tz = -tz;
50007|      0|            } else {
50008|      0|                buf[pos++] = '+';
50009|      0|            }
50010|       |            /* tz is >= 0, can use % */
50011|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
50012|      0|                            "%02d%02d", tz / 60, tz % 60);
50013|       |            /* XXX: tack the time zone code? */
50014|      0|            break;
50015|      0|        case 2:
50016|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
50017|      0|                            "%02d:%02d:%02d.%03dZ", h, m, s, ms);
50018|      0|            break;
50019|      0|        case 3:
50020|      0|            pos += snprintf(buf + pos, sizeof(buf) - pos,
50021|      0|                            "%02d:%02d:%02d %cM", (h + 11) % 12 + 1, m, s,
50022|      0|                            (h < 12) ? 'A' : 'P');
50023|      0|            break;
50024|      0|        }
50025|      0|    }
50026|      0|    return JS_NewStringLen(ctx, buf, pos);
50027|      0|}
50028|       |
50029|       |/* OS dependent: return the UTC time in ms since 1970. */
50030|      0|static int64_t date_now(void) {
50031|      0|    struct timeval tv;
50032|      0|    gettimeofday(&tv, NULL);
50033|      0|    return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
50034|      0|}
50035|       |
50036|       |static JSValue js_date_constructor(JSContext *ctx, JSValueConst new_target,
50037|       |                                   int argc, JSValueConst *argv)
50038|      0|{
50039|       |    // Date(y, mon, d, h, m, s, ms)
50040|      0|    JSValue rv;
50041|      0|    int i, n;
50042|      0|    double a, val;
50043|       |
50044|      0|    if (JS_IsUndefined(new_target)) {
50045|       |        /* invoked as function */
50046|      0|        argc = 0;
50047|      0|    }
50048|      0|    n = argc;
50049|      0|    if (n == 0) {
50050|      0|        val = date_now();
50051|      0|    } else if (n == 1) {
50052|      0|        JSValue v, dv;
50053|      0|        if (JS_VALUE_GET_TAG(argv[0]) == JS_TAG_OBJECT) {
50054|      0|            JSObject *p = JS_VALUE_GET_OBJ(argv[0]);
50055|      0|            if (p->class_id == JS_CLASS_DATE && JS_IsNumber(p->u.object_data)) {
50056|      0|                if (JS_ToFloat64(ctx, &val, p->u.object_data))
50057|      0|                    return JS_EXCEPTION;
50058|      0|                val = time_clip(val);
50059|      0|                goto has_val;
50060|      0|            }
50061|      0|        }
50062|      0|        v = JS_ToPrimitive(ctx, argv[0], HINT_NONE);
50063|      0|        if (JS_IsString(v)) {
50064|      0|            dv = js_Date_parse(ctx, JS_UNDEFINED, 1, (JSValueConst *)&v);
50065|      0|            JS_FreeValue(ctx, v);
50066|      0|            if (JS_IsException(dv))
50067|      0|                return JS_EXCEPTION;
50068|      0|            if (JS_ToFloat64Free(ctx, &val, dv))
50069|      0|                return JS_EXCEPTION;
50070|      0|        } else {
50071|      0|            if (JS_ToFloat64Free(ctx, &val, v))
50072|      0|                return JS_EXCEPTION;
50073|      0|        }
50074|      0|        val = time_clip(val);
50075|      0|    } else {
50076|      0|        double fields[] = { 0, 0, 1, 0, 0, 0, 0 };
50077|      0|        if (n > 7)
50078|      0|            n = 7;
50079|      0|        for(i = 0; i < n; i++) {
50080|      0|            if (JS_ToFloat64(ctx, &a, argv[i]))
50081|      0|                return JS_EXCEPTION;
50082|      0|            if (!isfinite(a))
50083|      0|                break;
50084|      0|            fields[i] = trunc(a);
50085|      0|            if (i == 0 && fields[0] >= 0 && fields[0] < 100)
50086|      0|                fields[0] += 1900;
50087|      0|        }
50088|      0|        val = (i == n) ? set_date_fields(fields, 1) : NAN;
50089|      0|    }
50090|      0|has_val:
50091|       |#if 0
50092|       |    JSValueConst args[3];
50093|       |    args[0] = new_target;
50094|       |    args[1] = ctx->class_proto[JS_CLASS_DATE];
50095|       |    args[2] = JS_NewFloat64(ctx, val);
50096|       |    rv = js___date_create(ctx, JS_UNDEFINED, 3, args);
50097|       |#else
50098|      0|    rv = js_create_from_ctor(ctx, new_target, JS_CLASS_DATE);
50099|      0|    if (!JS_IsException(rv))
50100|      0|        JS_SetObjectData(ctx, rv, JS_NewFloat64(ctx, val));
50101|      0|#endif
50102|      0|    if (!JS_IsException(rv) && JS_IsUndefined(new_target)) {
50103|       |        /* invoked as a function, return (new Date()).toString(); */
50104|      0|        JSValue s;
50105|      0|        s = get_date_string(ctx, rv, 0, NULL, 0x13);
50106|      0|        JS_FreeValue(ctx, rv);
50107|      0|        rv = s;
50108|      0|    }
50109|      0|    return rv;
50110|      0|}
50111|       |
50112|       |static JSValue js_Date_UTC(JSContext *ctx, JSValueConst this_val,
50113|       |                           int argc, JSValueConst *argv)
50114|      0|{
50115|       |    // UTC(y, mon, d, h, m, s, ms)
50116|      0|    double fields[] = { 0, 0, 1, 0, 0, 0, 0 };
50117|      0|    int i, n;
50118|      0|    double a;
50119|       |
50120|      0|    n = argc;
50121|      0|    if (n == 0)
50122|      0|        return JS_NAN;
50123|      0|    if (n > 7)
50124|      0|        n = 7;
50125|      0|    for(i = 0; i < n; i++) {
50126|      0|        if (JS_ToFloat64(ctx, &a, argv[i]))
50127|      0|            return JS_EXCEPTION;
50128|      0|        if (!isfinite(a))
50129|      0|            return JS_NAN;
50130|      0|        fields[i] = trunc(a);
50131|      0|        if (i == 0 && fields[0] >= 0 && fields[0] < 100)
50132|      0|            fields[0] += 1900;
50133|      0|    }
50134|      0|    return JS_NewFloat64(ctx, set_date_fields(fields, 0));
50135|      0|}
50136|       |
50137|       |/* Date string parsing */
50138|       |
50139|      0|static BOOL string_skip_char(const uint8_t *sp, int *pp, int c) {
50140|      0|    if (sp[*pp] == c) {
50141|      0|        *pp += 1;
50142|      0|        return TRUE;
50143|      0|    } else {
50144|      0|        return FALSE;
50145|      0|    }
50146|      0|}
50147|       |
50148|       |/* skip spaces, update offset, return next char */
50149|      0|static int string_skip_spaces(const uint8_t *sp, int *pp) {
50150|      0|    int c;
50151|      0|    while ((c = sp[*pp]) == ' ')
50152|      0|        *pp += 1;
50153|      0|    return c;
50154|      0|}
50155|       |
50156|       |/* skip dashes dots and commas */
50157|      0|static int string_skip_separators(const uint8_t *sp, int *pp) {
50158|      0|    int c;
50159|      0|    while ((c = sp[*pp]) == '-' || c == '/' || c == '.' || c == ',')
50160|      0|        *pp += 1;
50161|      0|    return c;
50162|      0|}
50163|       |
50164|       |/* skip a word, stop on spaces, digits and separators, update offset */
50165|      0|static int string_skip_until(const uint8_t *sp, int *pp, const char *stoplist) {
50166|      0|    int c;
50167|      0|    while (!strchr(stoplist, c = sp[*pp]))
50168|      0|        *pp += 1;
50169|      0|    return c;
50170|      0|}
50171|       |
50172|       |/* parse a numeric field (max_digits = 0 -> no maximum) */
50173|       |static BOOL string_get_digits(const uint8_t *sp, int *pp, int *pval,
50174|       |                              int min_digits, int max_digits)
50175|      0|{
50176|      0|    int v = 0;
50177|      0|    int c, p = *pp, p_start;
50178|       |
50179|      0|    p_start = p;
50180|      0|    while ((c = sp[p]) >= '0' && c <= '9') {
50181|       |        /* arbitrary limit to 9 digits */
50182|      0|        if (v >= 100000000)
50183|      0|            return FALSE;
50184|      0|        v = v * 10 + c - '0';
50185|      0|        p++;
50186|      0|        if (p - p_start == max_digits)
50187|      0|            break;
50188|      0|    }
50189|      0|    if (p - p_start < min_digits)
50190|      0|        return FALSE;
50191|      0|    *pval = v;
50192|      0|    *pp = p;
50193|      0|    return TRUE;
50194|      0|}
50195|       |
50196|      0|static BOOL string_get_milliseconds(const uint8_t *sp, int *pp, int *pval) {
50197|       |    /* parse optional fractional part as milliseconds and truncate. */
50198|       |    /* spec does not indicate which rounding should be used */
50199|      0|    int mul = 100, ms = 0, c, p_start, p = *pp;
50200|       |
50201|      0|    c = sp[p];
50202|      0|    if (c == '.' || c == ',') {
50203|      0|        p++;
50204|      0|        p_start = p;
50205|      0|        while ((c = sp[p]) >= '0' && c <= '9') {
50206|      0|            ms += (c - '0') * mul;
50207|      0|            mul /= 10;
50208|      0|            p++;
50209|      0|            if (p - p_start == 9)
50210|      0|                break;
50211|      0|        }
50212|      0|        if (p > p_start) {
50213|       |            /* only consume the separator if digits are present */
50214|      0|            *pval = ms;
50215|      0|            *pp = p;
50216|      0|        }
50217|      0|    }
50218|      0|    return TRUE;
50219|      0|}
50220|       |
50221|      0|static uint8_t upper_ascii(uint8_t c) {
50222|      0|    return c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c;
50223|      0|}
50224|       |
50225|      0|static BOOL string_get_tzoffset(const uint8_t *sp, int *pp, int *tzp, BOOL strict) {
50226|      0|    int tz = 0, sgn, hh, mm, p = *pp;
50227|       |
50228|      0|    sgn = sp[p++];
50229|      0|    if (sgn == '+' || sgn == '-') {
50230|      0|        int n = p;
50231|      0|        if (!string_get_digits(sp, &p, &hh, 1, 0))
50232|      0|            return FALSE;
50233|      0|        n = p - n;
50234|      0|        if (strict && n != 2 && n != 4)
50235|      0|            return FALSE;
50236|      0|        while (n > 4) {
50237|      0|            n -= 2;
50238|      0|            hh /= 100;
50239|      0|        }
50240|      0|        if (n > 2) {
50241|      0|            mm = hh % 100;
50242|      0|            hh = hh / 100;
50243|      0|        } else {
50244|      0|            mm = 0;
50245|      0|            if (string_skip_char(sp, &p, ':')  /* optional separator */
50246|      0|            &&  !string_get_digits(sp, &p, &mm, 2, 2))
50247|      0|                return FALSE;
50248|      0|        }
50249|      0|        if (hh > 23 || mm > 59)
50250|      0|            return FALSE;
50251|      0|        tz = hh * 60 + mm;
50252|      0|        if (sgn != '+')
50253|      0|            tz = -tz;
50254|      0|    } else
50255|      0|    if (sgn != 'Z') {
50256|      0|        return FALSE;
50257|      0|    }
50258|      0|    *pp = p;
50259|      0|    *tzp = tz;
50260|      0|    return TRUE;
50261|      0|}
50262|       |
50263|      0|static BOOL string_match(const uint8_t *sp, int *pp, const char *s) {
50264|      0|    int p = *pp;
50265|      0|    while (*s != '\0') {
50266|      0|        if (upper_ascii(sp[p]) != upper_ascii(*s++))
50267|      0|            return FALSE;
50268|      0|        p++;
50269|      0|    }
50270|      0|    *pp = p;
50271|      0|    return TRUE;
50272|      0|}
50273|       |
50274|      0|static int find_abbrev(const uint8_t *sp, int p, const char *list, int count) {
50275|      0|    int n, i;
50276|       |
50277|      0|    for (n = 0; n < count; n++) {
50278|      0|        for (i = 0;; i++) {
50279|      0|            if (upper_ascii(sp[p + i]) != upper_ascii(list[n * 3 + i]))
50280|      0|                break;
50281|      0|            if (i == 2)
50282|      0|                return n;
50283|      0|        }
50284|      0|    }
50285|      0|    return -1;
50286|      0|}
50287|       |
50288|      0|static BOOL string_get_month(const uint8_t *sp, int *pp, int *pval) {
50289|      0|    int n;
50290|       |
50291|      0|    n = find_abbrev(sp, *pp, month_names, 12);
50292|      0|    if (n < 0)
50293|      0|        return FALSE;
50294|       |
50295|      0|    *pval = n + 1;
50296|      0|    *pp += 3;
50297|      0|    return TRUE;
50298|      0|}
50299|       |
50300|       |/* parse toISOString format */
50301|      0|static BOOL js_date_parse_isostring(const uint8_t *sp, int fields[9], BOOL *is_local) {
50302|      0|    int sgn, i, p = 0;
50303|       |
50304|       |    /* initialize fields to the beginning of the Epoch */
50305|      0|    for (i = 0; i < 9; i++) {
50306|      0|        fields[i] = (i == 2);
50307|      0|    }
50308|      0|    *is_local = FALSE;
50309|       |
50310|       |    /* year is either yyyy digits or [+-]yyyyyy */
50311|      0|    sgn = sp[p];
50312|      0|    if (sgn == '-' || sgn == '+') {
50313|      0|        p++;
50314|      0|        if (!string_get_digits(sp, &p, &fields[0], 6, 6))
50315|      0|            return FALSE;
50316|      0|        if (sgn == '-') {
50317|      0|            if (fields[0] == 0)
50318|      0|                return FALSE; // reject -000000
50319|      0|            fields[0] = -fields[0];
50320|      0|        }
50321|      0|    } else {
50322|      0|        if (!string_get_digits(sp, &p, &fields[0], 4, 4))
50323|      0|            return FALSE;
50324|      0|    }
50325|      0|    if (string_skip_char(sp, &p, '-')) {
50326|      0|        if (!string_get_digits(sp, &p, &fields[1], 2, 2))  /* month */
50327|      0|            return FALSE;
50328|      0|        if (fields[1] < 1)
50329|      0|            return FALSE;
50330|      0|        fields[1] -= 1;
50331|      0|        if (string_skip_char(sp, &p, '-')) {
50332|      0|            if (!string_get_digits(sp, &p, &fields[2], 2, 2))  /* day */
50333|      0|                return FALSE;
50334|      0|            if (fields[2] < 1)
50335|      0|                return FALSE;
50336|      0|        }
50337|      0|    }
50338|      0|    if (string_skip_char(sp, &p, 'T')) {
50339|      0|        *is_local = TRUE;
50340|      0|        if (!string_get_digits(sp, &p, &fields[3], 2, 2)  /* hour */
50341|      0|        ||  !string_skip_char(sp, &p, ':')
50342|      0|        ||  !string_get_digits(sp, &p, &fields[4], 2, 2)) {  /* minute */
50343|      0|            fields[3] = 100;  // reject unconditionally
50344|      0|            return TRUE;
50345|      0|        }
50346|      0|        if (string_skip_char(sp, &p, ':')) {
50347|      0|            if (!string_get_digits(sp, &p, &fields[5], 2, 2))  /* second */
50348|      0|                return FALSE;
50349|      0|            string_get_milliseconds(sp, &p, &fields[6]);
50350|      0|        }
50351|      0|    }
50352|       |    /* parse the time zone offset if present: [+-]HH:mm or [+-]HHmm */
50353|      0|    if (sp[p]) {
50354|      0|        *is_local = FALSE;
50355|      0|        if (!string_get_tzoffset(sp, &p, &fields[8], TRUE))
50356|      0|            return FALSE;
50357|      0|    }
50358|       |    /* error if extraneous characters */
50359|      0|    return sp[p] == '\0';
50360|      0|}
50361|       |
50362|       |static struct {
50363|       |    char name[6];
50364|       |    int16_t offset;
50365|       |} const js_tzabbr[] = {
50366|       |    { "GMT",   0 },         // Greenwich Mean Time
50367|       |    { "UTC",   0 },         // Coordinated Universal Time
50368|       |    { "UT",    0 },         // Universal Time
50369|       |    { "Z",     0 },         // Zulu Time
50370|       |    { "EDT",  -4 * 60 },    // Eastern Daylight Time
50371|       |    { "EST",  -5 * 60 },    // Eastern Standard Time
50372|       |    { "CDT",  -5 * 60 },    // Central Daylight Time
50373|       |    { "CST",  -6 * 60 },    // Central Standard Time
50374|       |    { "MDT",  -6 * 60 },    // Mountain Daylight Time
50375|       |    { "MST",  -7 * 60 },    // Mountain Standard Time
50376|       |    { "PDT",  -7 * 60 },    // Pacific Daylight Time
50377|       |    { "PST",  -8 * 60 },    // Pacific Standard Time
50378|       |    { "WET",  +0 * 60 },    // Western European Time
50379|       |    { "WEST", +1 * 60 },    // Western European Summer Time
50380|       |    { "CET",  +1 * 60 },    // Central European Time
50381|       |    { "CEST", +2 * 60 },    // Central European Summer Time
50382|       |    { "EET",  +2 * 60 },    // Eastern European Time
50383|       |    { "EEST", +3 * 60 },    // Eastern European Summer Time
50384|       |};
50385|       |
50386|      0|static BOOL string_get_tzabbr(const uint8_t *sp, int *pp, int *offset) {
50387|      0|    for (size_t i = 0; i < countof(js_tzabbr); i++) {
50388|      0|        if (string_match(sp, pp, js_tzabbr[i].name)) {
50389|      0|            *offset = js_tzabbr[i].offset;
50390|      0|            return TRUE;
50391|      0|        }
50392|      0|    }
50393|      0|    return FALSE;
50394|      0|}
50395|       |
50396|       |/* parse toString, toUTCString and other formats */
50397|       |static BOOL js_date_parse_otherstring(const uint8_t *sp,
50398|       |                                      int fields[minimum_length(9)],
50399|      0|                                      BOOL *is_local) {
50400|      0|    int c, i, val, p = 0, p_start;
50401|      0|    int num[3];
50402|      0|    BOOL has_year = FALSE;
50403|      0|    BOOL has_mon = FALSE;
50404|      0|    BOOL has_time = FALSE;
50405|      0|    int num_index = 0;
50406|       |
50407|       |    /* initialize fields to the beginning of 2001-01-01 */
50408|      0|    fields[0] = 2001;
50409|      0|    fields[1] = 1;
50410|      0|    fields[2] = 1;
50411|      0|    for (i = 3; i < 9; i++) {
50412|      0|        fields[i] = 0;
50413|      0|    }
50414|      0|    *is_local = TRUE;
50415|       |
50416|      0|    while (string_skip_spaces(sp, &p)) {
50417|      0|        p_start = p;
50418|      0|        if ((c = sp[p]) == '+' || c == '-') {
50419|      0|            if (has_time && string_get_tzoffset(sp, &p, &fields[8], FALSE)) {
50420|      0|                *is_local = FALSE;
50421|      0|            } else {
50422|      0|                p++;
50423|      0|                if (string_get_digits(sp, &p, &val, 1, 0)) {
50424|      0|                    if (c == '-') {
50425|      0|                        if (val == 0)
50426|      0|                            return FALSE;
50427|      0|                        val = -val;
50428|      0|                    }
50429|      0|                    fields[0] = val;
50430|      0|                    has_year = TRUE;
50431|      0|                }
50432|      0|            }
50433|      0|        } else
50434|      0|        if (string_get_digits(sp, &p, &val, 1, 0)) {
50435|      0|            if (string_skip_char(sp, &p, ':')) {
50436|       |                /* time part */
50437|      0|                fields[3] = val;
50438|      0|                if (!string_get_digits(sp, &p, &fields[4], 1, 2))
50439|      0|                    return FALSE;
50440|      0|                if (string_skip_char(sp, &p, ':')) {
50441|      0|                    if (!string_get_digits(sp, &p, &fields[5], 1, 2))
50442|      0|                        return FALSE;
50443|      0|                    string_get_milliseconds(sp, &p, &fields[6]);
50444|      0|                }
50445|      0|                has_time = TRUE;
50446|      0|            } else {
50447|      0|                if (p - p_start > 2) {
50448|      0|                    fields[0] = val;
50449|      0|                    has_year = TRUE;
50450|      0|                } else
50451|      0|                if (val < 1 || val > 31) {
50452|      0|                    fields[0] = val + (val < 100) * 1900 + (val < 50) * 100;
50453|      0|                    has_year = TRUE;
50454|      0|                } else {
50455|      0|                    if (num_index == 3)
50456|      0|                        return FALSE;
50457|      0|                    num[num_index++] = val;
50458|      0|                }
50459|      0|            }
50460|      0|        } else
50461|      0|        if (string_get_month(sp, &p, &fields[1])) {
50462|      0|            has_mon = TRUE;
50463|      0|            string_skip_until(sp, &p, "0123456789 -/(");
50464|      0|        } else
50465|      0|        if (has_time && string_match(sp, &p, "PM")) {
50466|      0|            if (fields[3] < 12)
50467|      0|                fields[3] += 12;
50468|      0|            continue;
50469|      0|        } else
50470|      0|        if (has_time && string_match(sp, &p, "AM")) {
50471|      0|            if (fields[3] == 12)
50472|      0|                fields[3] -= 12;
50473|      0|            continue;
50474|      0|        } else
50475|      0|        if (string_get_tzabbr(sp, &p, &fields[8])) {
50476|      0|            *is_local = FALSE;
50477|      0|            continue;
50478|      0|        } else
50479|      0|        if (c == '(') {  /* skip parenthesized phrase */
50480|      0|            int level = 0;
50481|      0|            while ((c = sp[p]) != '\0') {
50482|      0|                p++;
50483|      0|                level += (c == '(');
50484|      0|                level -= (c == ')');
50485|      0|                if (!level)
50486|      0|                    break;
50487|      0|            }
50488|      0|            if (level > 0)
50489|      0|                return FALSE;
50490|      0|        } else
50491|      0|        if (c == ')') {
50492|      0|            return FALSE;
50493|      0|        } else {
50494|      0|            if (has_year + has_mon + has_time + num_index)
50495|      0|                return FALSE;
50496|       |            /* skip a word */
50497|      0|            string_skip_until(sp, &p, " -/(");
50498|      0|        }
50499|      0|        string_skip_separators(sp, &p);
50500|      0|    }
50501|      0|    if (num_index + has_year + has_mon > 3)
50502|      0|        return FALSE;
50503|       |
50504|      0|    switch (num_index) {
50505|      0|    case 0:
50506|      0|        if (!has_year)
50507|      0|            return FALSE;
50508|      0|        break;
50509|      0|    case 1:
50510|      0|        if (has_mon)
50511|      0|            fields[2] = num[0];
50512|      0|        else
50513|      0|            fields[1] = num[0];
50514|      0|        break;
50515|      0|    case 2:
50516|      0|        if (has_year) {
50517|      0|            fields[1] = num[0];
50518|      0|            fields[2] = num[1];
50519|      0|        } else
50520|      0|        if (has_mon) {
50521|      0|            fields[0] = num[1] + (num[1] < 100) * 1900 + (num[1] < 50) * 100;
50522|      0|            fields[2] = num[0];
50523|      0|        } else {
50524|      0|            fields[1] = num[0];
50525|      0|            fields[2] = num[1];
50526|      0|        }
50527|      0|        break;
50528|      0|    case 3:
50529|      0|        fields[0] = num[2] + (num[2] < 100) * 1900 + (num[2] < 50) * 100;
50530|      0|        fields[1] = num[0];
50531|      0|        fields[2] = num[1];
50532|      0|        break;
50533|      0|    default:
50534|      0|        return FALSE;
50535|      0|    }
50536|      0|    if (fields[1] < 1 || fields[2] < 1)
50537|      0|        return FALSE;
50538|      0|    fields[1] -= 1;
50539|      0|    return TRUE;
50540|      0|}
50541|       |
50542|       |static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
50543|       |                             int argc, JSValueConst *argv)
50544|      0|{
50545|      0|    JSValue s, rv;
50546|      0|    int fields[9];
50547|      0|    double fields1[9];
50548|      0|    double d;
50549|      0|    int i, c;
50550|      0|    JSString *sp;
50551|      0|    uint8_t buf[128];
50552|      0|    BOOL is_local;
50553|       |
50554|      0|    rv = JS_NAN;
50555|       |
50556|      0|    s = JS_ToString(ctx, argv[0]);
50557|      0|    if (JS_IsException(s))
50558|      0|        return JS_EXCEPTION;
50559|       |
50560|      0|    sp = JS_VALUE_GET_STRING(s);
50561|       |    /* convert the string as a byte array */
50562|      0|    for (i = 0; i < sp->len && i < (int)countof(buf) - 1; i++) {
50563|      0|        c = string_get(sp, i);
50564|      0|        if (c > 255)
50565|      0|            c = (c == 0x2212) ? '-' : 'x';
50566|      0|        buf[i] = c;
50567|      0|    }
50568|      0|    buf[i] = '\0';
50569|      0|    if (js_date_parse_isostring(buf, fields, &is_local)
50570|      0|    ||  js_date_parse_otherstring(buf, fields, &is_local)) {
50571|      0|        static int const field_max[6] = { 0, 11, 31, 24, 59, 59 };
50572|      0|        BOOL valid = TRUE;
50573|       |        /* check field maximum values */
50574|      0|        for (i = 1; i < 6; i++) {
50575|      0|            if (fields[i] > field_max[i])
50576|      0|                valid = FALSE;
50577|      0|        }
50578|       |        /* special case 24:00:00.000 */
50579|      0|        if (fields[3] == 24 && (fields[4] | fields[5] | fields[6]))
50580|      0|            valid = FALSE;
50581|      0|        if (valid) {
50582|      0|            for(i = 0; i < 7; i++)
50583|      0|                fields1[i] = fields[i];
50584|      0|            d = set_date_fields(fields1, is_local) - fields[8] * 60000;
50585|      0|            rv = JS_NewFloat64(ctx, d);
50586|      0|        }
50587|      0|    }
50588|      0|    JS_FreeValue(ctx, s);
50589|      0|    return rv;
50590|      0|}
50591|       |
50592|       |static JSValue js_Date_now(JSContext *ctx, JSValueConst this_val,
50593|       |                           int argc, JSValueConst *argv)
50594|      0|{
50595|       |    // now()
50596|      0|    return JS_NewInt64(ctx, date_now());
50597|      0|}
50598|       |
50599|       |static JSValue js_date_Symbol_toPrimitive(JSContext *ctx, JSValueConst this_val,
50600|       |                                          int argc, JSValueConst *argv)
50601|      0|{
50602|       |    // Symbol_toPrimitive(hint)
50603|      0|    JSValueConst obj = this_val;
50604|      0|    JSAtom hint = JS_ATOM_NULL;
50605|      0|    int hint_num;
50606|       |
50607|      0|    if (!JS_IsObject(obj))
50608|      0|        return JS_ThrowTypeErrorNotAnObject(ctx);
50609|       |
50610|      0|    if (JS_IsString(argv[0])) {
50611|      0|        hint = JS_ValueToAtom(ctx, argv[0]);
50612|      0|        if (hint == JS_ATOM_NULL)
50613|      0|            return JS_EXCEPTION;
50614|      0|        JS_FreeAtom(ctx, hint);
50615|      0|    }
50616|      0|    switch (hint) {
50617|      0|    case JS_ATOM_number:
50618|      0|    case JS_ATOM_integer:
50619|      0|        hint_num = HINT_NUMBER;
50620|      0|        break;
50621|      0|    case JS_ATOM_string:
50622|      0|    case JS_ATOM_default:
50623|      0|        hint_num = HINT_STRING;
50624|      0|        break;
50625|      0|    default:
50626|      0|        return JS_ThrowTypeError(ctx, "invalid hint");
50627|      0|    }
50628|      0|    return JS_ToPrimitive(ctx, obj, hint_num | HINT_FORCE_ORDINARY);
50629|      0|}
50630|       |
50631|       |static JSValue js_date_getTimezoneOffset(JSContext *ctx, JSValueConst this_val,
50632|       |                                         int argc, JSValueConst *argv)
50633|      0|{
50634|       |    // getTimezoneOffset()
50635|      0|    double v;
50636|       |
50637|      0|    if (JS_ThisTimeValue(ctx, &v, this_val))
50638|      0|        return JS_EXCEPTION;
50639|      0|    if (isnan(v))
50640|      0|        return JS_NAN;
50641|      0|    else
50642|       |        /* assuming -8.64e15 <= v <= -8.64e15 */
50643|      0|        return JS_NewInt64(ctx, getTimezoneOffset((int64_t)trunc(v)));
50644|      0|}
50645|       |
50646|       |static JSValue js_date_getTime(JSContext *ctx, JSValueConst this_val,
50647|       |                               int argc, JSValueConst *argv)
50648|      0|{
50649|       |    // getTime()
50650|      0|    double v;
50651|       |
50652|      0|    if (JS_ThisTimeValue(ctx, &v, this_val))
50653|      0|        return JS_EXCEPTION;
50654|      0|    return JS_NewFloat64(ctx, v);
50655|      0|}
50656|       |
50657|       |static JSValue js_date_setTime(JSContext *ctx, JSValueConst this_val,
50658|       |                               int argc, JSValueConst *argv)
50659|      0|{
50660|       |    // setTime(v)
50661|      0|    double v;
50662|       |
50663|      0|    if (JS_ThisTimeValue(ctx, &v, this_val) || JS_ToFloat64(ctx, &v, argv[0]))
50664|      0|        return JS_EXCEPTION;
50665|      0|    return JS_SetThisTimeValue(ctx, this_val, time_clip(v));
50666|      0|}
50667|       |
50668|       |static JSValue js_date_setYear(JSContext *ctx, JSValueConst this_val,
50669|       |                               int argc, JSValueConst *argv)
50670|      0|{
50671|       |    // setYear(y)
50672|      0|    double y;
50673|      0|    JSValueConst args[1];
50674|       |
50675|      0|    if (JS_ThisTimeValue(ctx, &y, this_val) || JS_ToFloat64(ctx, &y, argv[0]))
50676|      0|        return JS_EXCEPTION;
50677|      0|    y = +y;
50678|      0|    if (isfinite(y)) {
50679|      0|        y = trunc(y);
50680|      0|        if (y >= 0 && y < 100)
50681|      0|            y += 1900;
50682|      0|    }
50683|      0|    args[0] = JS_NewFloat64(ctx, y);
50684|      0|    return set_date_field(ctx, this_val, 1, args, 0x011);
50685|      0|}
50686|       |
50687|       |static JSValue js_date_toJSON(JSContext *ctx, JSValueConst this_val,
50688|       |                              int argc, JSValueConst *argv)
50689|      0|{
50690|       |    // toJSON(key)
50691|      0|    JSValue obj, tv, method, rv;
50692|      0|    double d;
50693|       |
50694|      0|    rv = JS_EXCEPTION;
50695|      0|    tv = JS_UNDEFINED;
50696|       |
50697|      0|    obj = JS_ToObject(ctx, this_val);
50698|      0|    tv = JS_ToPrimitive(ctx, obj, HINT_NUMBER);
50699|      0|    if (JS_IsException(tv))
50700|      0|        goto exception;
50701|      0|    if (JS_IsNumber(tv)) {
50702|      0|        if (JS_ToFloat64(ctx, &d, tv) < 0)
50703|      0|            goto exception;
50704|      0|        if (!isfinite(d)) {
50705|      0|            rv = JS_NULL;
50706|      0|            goto done;
50707|      0|        }
50708|      0|    }
50709|      0|    method = JS_GetPropertyStr(ctx, obj, "toISOString");
50710|      0|    if (JS_IsException(method))
50711|      0|        goto exception;
50712|      0|    if (!JS_IsFunction(ctx, method)) {
50713|      0|        JS_ThrowTypeError(ctx, "object needs toISOString method");
50714|      0|        JS_FreeValue(ctx, method);
50715|      0|        goto exception;
50716|      0|    }
50717|      0|    rv = JS_CallFree(ctx, method, obj, 0, NULL);
50718|      0|exception:
50719|      0|done:
50720|      0|    JS_FreeValue(ctx, obj);
50721|      0|    JS_FreeValue(ctx, tv);
50722|      0|    return rv;
50723|      0|}
50724|       |
50725|       |static const JSCFunctionListEntry js_date_funcs[] = {
50726|       |    JS_CFUNC_DEF("now", 0, js_Date_now ),
50727|       |    JS_CFUNC_DEF("parse", 1, js_Date_parse ),
50728|       |    JS_CFUNC_DEF("UTC", 7, js_Date_UTC ),
50729|       |};
50730|       |
50731|       |static const JSCFunctionListEntry js_date_proto_funcs[] = {
50732|       |    JS_CFUNC_DEF("valueOf", 0, js_date_getTime ),
50733|       |    JS_CFUNC_MAGIC_DEF("toString", 0, get_date_string, 0x13 ),
50734|       |    JS_CFUNC_DEF("[Symbol.toPrimitive]", 1, js_date_Symbol_toPrimitive ),
50735|       |    JS_CFUNC_MAGIC_DEF("toUTCString", 0, get_date_string, 0x03 ),
50736|       |    JS_ALIAS_DEF("toGMTString", "toUTCString" ),
50737|       |    JS_CFUNC_MAGIC_DEF("toISOString", 0, get_date_string, 0x23 ),
50738|       |    JS_CFUNC_MAGIC_DEF("toDateString", 0, get_date_string, 0x11 ),
50739|       |    JS_CFUNC_MAGIC_DEF("toTimeString", 0, get_date_string, 0x12 ),
50740|       |    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, get_date_string, 0x33 ),
50741|       |    JS_CFUNC_MAGIC_DEF("toLocaleDateString", 0, get_date_string, 0x31 ),
50742|       |    JS_CFUNC_MAGIC_DEF("toLocaleTimeString", 0, get_date_string, 0x32 ),
50743|       |    JS_CFUNC_DEF("getTimezoneOffset", 0, js_date_getTimezoneOffset ),
50744|       |    JS_CFUNC_DEF("getTime", 0, js_date_getTime ),
50745|       |    JS_CFUNC_MAGIC_DEF("getYear", 0, get_date_field, 0x101 ),
50746|       |    JS_CFUNC_MAGIC_DEF("getFullYear", 0, get_date_field, 0x01 ),
50747|       |    JS_CFUNC_MAGIC_DEF("getUTCFullYear", 0, get_date_field, 0x00 ),
50748|       |    JS_CFUNC_MAGIC_DEF("getMonth", 0, get_date_field, 0x11 ),
50749|       |    JS_CFUNC_MAGIC_DEF("getUTCMonth", 0, get_date_field, 0x10 ),
50750|       |    JS_CFUNC_MAGIC_DEF("getDate", 0, get_date_field, 0x21 ),
50751|       |    JS_CFUNC_MAGIC_DEF("getUTCDate", 0, get_date_field, 0x20 ),
50752|       |    JS_CFUNC_MAGIC_DEF("getHours", 0, get_date_field, 0x31 ),
50753|       |    JS_CFUNC_MAGIC_DEF("getUTCHours", 0, get_date_field, 0x30 ),
50754|       |    JS_CFUNC_MAGIC_DEF("getMinutes", 0, get_date_field, 0x41 ),
50755|       |    JS_CFUNC_MAGIC_DEF("getUTCMinutes", 0, get_date_field, 0x40 ),
50756|       |    JS_CFUNC_MAGIC_DEF("getSeconds", 0, get_date_field, 0x51 ),
50757|       |    JS_CFUNC_MAGIC_DEF("getUTCSeconds", 0, get_date_field, 0x50 ),
50758|       |    JS_CFUNC_MAGIC_DEF("getMilliseconds", 0, get_date_field, 0x61 ),
50759|       |    JS_CFUNC_MAGIC_DEF("getUTCMilliseconds", 0, get_date_field, 0x60 ),
50760|       |    JS_CFUNC_MAGIC_DEF("getDay", 0, get_date_field, 0x71 ),
50761|       |    JS_CFUNC_MAGIC_DEF("getUTCDay", 0, get_date_field, 0x70 ),
50762|       |    JS_CFUNC_DEF("setTime", 1, js_date_setTime ),
50763|       |    JS_CFUNC_MAGIC_DEF("setMilliseconds", 1, set_date_field, 0x671 ),
50764|       |    JS_CFUNC_MAGIC_DEF("setUTCMilliseconds", 1, set_date_field, 0x670 ),
50765|       |    JS_CFUNC_MAGIC_DEF("setSeconds", 2, set_date_field, 0x571 ),
50766|       |    JS_CFUNC_MAGIC_DEF("setUTCSeconds", 2, set_date_field, 0x570 ),
50767|       |    JS_CFUNC_MAGIC_DEF("setMinutes", 3, set_date_field, 0x471 ),
50768|       |    JS_CFUNC_MAGIC_DEF("setUTCMinutes", 3, set_date_field, 0x470 ),
50769|       |    JS_CFUNC_MAGIC_DEF("setHours", 4, set_date_field, 0x371 ),
50770|       |    JS_CFUNC_MAGIC_DEF("setUTCHours", 4, set_date_field, 0x370 ),
50771|       |    JS_CFUNC_MAGIC_DEF("setDate", 1, set_date_field, 0x231 ),
50772|       |    JS_CFUNC_MAGIC_DEF("setUTCDate", 1, set_date_field, 0x230 ),
50773|       |    JS_CFUNC_MAGIC_DEF("setMonth", 2, set_date_field, 0x131 ),
50774|       |    JS_CFUNC_MAGIC_DEF("setUTCMonth", 2, set_date_field, 0x130 ),
50775|       |    JS_CFUNC_DEF("setYear", 1, js_date_setYear ),
50776|       |    JS_CFUNC_MAGIC_DEF("setFullYear", 3, set_date_field, 0x031 ),
50777|       |    JS_CFUNC_MAGIC_DEF("setUTCFullYear", 3, set_date_field, 0x030 ),
50778|       |    JS_CFUNC_DEF("toJSON", 1, js_date_toJSON ),
50779|       |};
50780|       |
50781|       |JSValue JS_NewDate(JSContext *ctx, double epoch_ms)
50782|      0|{
50783|      0|    JSValue obj = js_create_from_ctor(ctx, JS_UNDEFINED, JS_CLASS_DATE);
50784|      0|    if (JS_IsException(obj))
50785|      0|        return JS_EXCEPTION;
50786|      0|    JS_SetObjectData(ctx, obj, __JS_NewFloat64(ctx, time_clip(epoch_ms)));
50787|      0|    return obj;
50788|      0|}
50789|       |
50790|       |void JS_AddIntrinsicDate(JSContext *ctx)
50791|  17.7k|{
50792|  17.7k|    JSValueConst obj;
50793|       |
50794|       |    /* Date */
50795|  17.7k|    ctx->class_proto[JS_CLASS_DATE] = JS_NewObject(ctx);
50796|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATE], js_date_proto_funcs,
50797|  17.7k|                               countof(js_date_proto_funcs));
50798|  17.7k|    obj = JS_NewGlobalCConstructor(ctx, "Date", js_date_constructor, 7,
50799|  17.7k|                                   ctx->class_proto[JS_CLASS_DATE]);
50800|  17.7k|    JS_SetPropertyFunctionList(ctx, obj, js_date_funcs, countof(js_date_funcs));
50801|  17.7k|}
50802|       |
50803|       |/* eval */
50804|       |
50805|       |void JS_AddIntrinsicEval(JSContext *ctx)
50806|  17.7k|{
50807|  17.7k|    ctx->eval_internal = __JS_EvalInternal;
50808|  17.7k|}
50809|       |
50810|       |/* BigInt */
50811|       |
50812|       |static JSValue JS_ToBigIntCtorFree(JSContext *ctx, JSValue val)
50813|      0|{
50814|      0|    uint32_t tag;
50815|       |
50816|      0| redo:
50817|      0|    tag = JS_VALUE_GET_NORM_TAG(val);
50818|      0|    switch(tag) {
50819|      0|    case JS_TAG_INT:
50820|      0|    case JS_TAG_BOOL:
50821|      0|        val = JS_NewBigInt64(ctx, JS_VALUE_GET_INT(val));
50822|      0|        break;
50823|      0|    case JS_TAG_SHORT_BIG_INT:
50824|      0|    case JS_TAG_BIG_INT:
50825|      0|        break;
50826|      0|    case JS_TAG_FLOAT64:
50827|      0|        {
50828|      0|            double d = JS_VALUE_GET_FLOAT64(val);
50829|      0|            JSBigInt *r;
50830|      0|            int res;
50831|      0|            r = js_bigint_from_float64(ctx, &res, d);
50832|      0|            if (!r) {
50833|      0|                if (res == 0) {
50834|      0|                    val = JS_EXCEPTION;
50835|      0|                } else if (res == 1) {
50836|      0|                    val = JS_ThrowRangeError(ctx, "cannot convert to BigInt: not an integer");
50837|      0|                } else {
50838|      0|                    val = JS_ThrowRangeError(ctx, "cannot convert NaN or Infinity to BigInt");                }
50839|      0|            } else {
50840|      0|                val = JS_CompactBigInt(ctx, r);
50841|      0|            }
50842|      0|        }
50843|      0|        break;
50844|      0|    case JS_TAG_STRING:
50845|      0|    case JS_TAG_STRING_ROPE:
50846|      0|        val = JS_StringToBigIntErr(ctx, val);
50847|      0|        break;
50848|      0|    case JS_TAG_OBJECT:
50849|      0|        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
50850|      0|        if (JS_IsException(val))
50851|      0|            break;
50852|      0|        goto redo;
50853|      0|    case JS_TAG_NULL:
50854|      0|    case JS_TAG_UNDEFINED:
50855|      0|    default:
50856|      0|        JS_FreeValue(ctx, val);
50857|      0|        return JS_ThrowTypeError(ctx, "cannot convert to BigInt");
50858|      0|    }
50859|      0|    return val;
50860|      0|}
50861|       |
50862|       |static JSValue js_bigint_constructor(JSContext *ctx,
50863|       |                                     JSValueConst new_target,
50864|       |                                     int argc, JSValueConst *argv)
50865|      0|{
50866|      0|    if (!JS_IsUndefined(new_target))
50867|      0|        return JS_ThrowTypeError(ctx, "not a constructor");
50868|      0|    return JS_ToBigIntCtorFree(ctx, JS_DupValue(ctx, argv[0]));
50869|      0|}
50870|       |
50871|       |static JSValue js_thisBigIntValue(JSContext *ctx, JSValueConst this_val)
50872|      0|{
50873|      0|    if (JS_IsBigInt(ctx, this_val))
50874|      0|        return JS_DupValue(ctx, this_val);
50875|       |
50876|      0|    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
50877|      0|        JSObject *p = JS_VALUE_GET_OBJ(this_val);
50878|      0|        if (p->class_id == JS_CLASS_BIG_INT) {
50879|      0|            if (JS_IsBigInt(ctx, p->u.object_data))
50880|      0|                return JS_DupValue(ctx, p->u.object_data);
50881|      0|        }
50882|      0|    }
50883|      0|    return JS_ThrowTypeError(ctx, "not a BigInt");
50884|      0|}
50885|       |
50886|       |static JSValue js_bigint_toString(JSContext *ctx, JSValueConst this_val,
50887|       |                                  int argc, JSValueConst *argv)
50888|      0|{
50889|      0|    JSValue val;
50890|      0|    int base;
50891|      0|    JSValue ret;
50892|       |
50893|      0|    val = js_thisBigIntValue(ctx, this_val);
50894|      0|    if (JS_IsException(val))
50895|      0|        return val;
50896|      0|    if (argc == 0 || JS_IsUndefined(argv[0])) {
50897|      0|        base = 10;
50898|      0|    } else {
50899|      0|        base = js_get_radix(ctx, argv[0]);
50900|      0|        if (base < 0)
50901|      0|            goto fail;
50902|      0|    }
50903|      0|    ret = js_bigint_to_string1(ctx, val, base);
50904|      0|    JS_FreeValue(ctx, val);
50905|      0|    return ret;
50906|      0| fail:
50907|      0|    JS_FreeValue(ctx, val);
50908|      0|    return JS_EXCEPTION;
50909|      0|}
50910|       |
50911|       |static JSValue js_bigint_valueOf(JSContext *ctx, JSValueConst this_val,
50912|       |                                 int argc, JSValueConst *argv)
50913|      0|{
50914|      0|    return js_thisBigIntValue(ctx, this_val);
50915|      0|}
50916|       |
50917|       |static JSValue js_bigint_asUintN(JSContext *ctx,
50918|       |                                  JSValueConst this_val,
50919|       |                                  int argc, JSValueConst *argv, int asIntN)
50920|      0|{
50921|      0|    uint64_t bits;
50922|      0|    JSValue res, a;
50923|       |    
50924|      0|    if (JS_ToIndex(ctx, &bits, argv[0]))
50925|      0|        return JS_EXCEPTION;
50926|      0|    a = JS_ToBigInt(ctx, argv[1]);
50927|      0|    if (JS_IsException(a))
50928|      0|        return JS_EXCEPTION;
50929|      0|    if (bits == 0) {
50930|      0|        JS_FreeValue(ctx, a);
50931|      0|        res = __JS_NewShortBigInt(ctx, 0);
50932|      0|    } else if (JS_VALUE_GET_TAG(a) == JS_TAG_SHORT_BIG_INT) {
50933|       |        /* fast case */
50934|      0|        if (bits >= JS_SHORT_BIG_INT_BITS) {
50935|      0|            res = a;
50936|      0|        } else {
50937|      0|            uint64_t v;
50938|      0|            int shift;
50939|      0|            shift = 64 - bits;
50940|      0|            v = JS_VALUE_GET_SHORT_BIG_INT(a);
50941|      0|            v = v << shift;
50942|      0|            if (asIntN)
50943|      0|                v = (int64_t)v >> shift;
50944|      0|            else
50945|      0|                v = v >> shift;
50946|      0|            res = __JS_NewShortBigInt(ctx, v);
50947|      0|        }
50948|      0|    } else {
50949|      0|        JSBigInt *r, *p = JS_VALUE_GET_PTR(a);
50950|      0|        if (bits >= p->len * JS_LIMB_BITS) {
50951|      0|            res = a;
50952|      0|        } else {
50953|      0|            int len, shift, i;
50954|      0|            js_limb_t v;
50955|      0|            len = (bits + JS_LIMB_BITS - 1) / JS_LIMB_BITS;
50956|      0|            r = js_bigint_new(ctx, len);
50957|      0|            if (!r) {
50958|      0|                JS_FreeValue(ctx, a);
50959|      0|                return JS_EXCEPTION;
50960|      0|            }
50961|      0|            r->len = len;
50962|      0|            for(i = 0; i < len - 1; i++)
50963|      0|                r->tab[i] = p->tab[i];
50964|      0|            shift = (-bits) & (JS_LIMB_BITS - 1);
50965|       |            /* 0 <= shift <= JS_LIMB_BITS - 1 */
50966|      0|            v = p->tab[len - 1] << shift;
50967|      0|            if (asIntN)
50968|      0|                v = (js_slimb_t)v >> shift;
50969|      0|            else
50970|      0|                v = v >> shift;
50971|      0|            r->tab[len - 1] = v;
50972|      0|            r = js_bigint_normalize(ctx, r);
50973|      0|            JS_FreeValue(ctx, a);
50974|      0|            res = JS_CompactBigInt(ctx, r);
50975|      0|        }
50976|      0|    }
50977|      0|    return res;
50978|      0|}
50979|       |
50980|       |static const JSCFunctionListEntry js_bigint_funcs[] = {
50981|       |    JS_CFUNC_MAGIC_DEF("asUintN", 2, js_bigint_asUintN, 0 ),
50982|       |    JS_CFUNC_MAGIC_DEF("asIntN", 2, js_bigint_asUintN, 1 ),
50983|       |};
50984|       |
50985|       |static const JSCFunctionListEntry js_bigint_proto_funcs[] = {
50986|       |    JS_CFUNC_DEF("toString", 0, js_bigint_toString ),
50987|       |    JS_CFUNC_DEF("valueOf", 0, js_bigint_valueOf ),
50988|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "BigInt", JS_PROP_CONFIGURABLE ),
50989|       |};
50990|       |
50991|       |static void JS_AddIntrinsicBigInt(JSContext *ctx)
50992|  17.7k|{
50993|  17.7k|    JSValueConst obj1;
50994|       |
50995|  17.7k|    ctx->class_proto[JS_CLASS_BIG_INT] = JS_NewObject(ctx);
50996|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
50997|  17.7k|                               js_bigint_proto_funcs,
50998|  17.7k|                               countof(js_bigint_proto_funcs));
50999|  17.7k|    obj1 = JS_NewGlobalCConstructor(ctx, "BigInt", js_bigint_constructor, 1,
51000|  17.7k|                                    ctx->class_proto[JS_CLASS_BIG_INT]);
51001|  17.7k|    JS_SetPropertyFunctionList(ctx, obj1, js_bigint_funcs,
51002|  17.7k|                               countof(js_bigint_funcs));
51003|  17.7k|}
51004|       |
51005|       |static const char * const native_error_name[JS_NATIVE_ERROR_COUNT] = {
51006|       |    "EvalError", "RangeError", "ReferenceError",
51007|       |    "SyntaxError", "TypeError", "URIError",
51008|       |    "InternalError", "AggregateError",
51009|       |};
51010|       |
51011|       |/* Minimum amount of objects to be able to compile code and display
51012|       |   error messages. No JSAtom should be allocated by this function. */
51013|       |static void JS_AddIntrinsicBasicObjects(JSContext *ctx)
51014|  17.7k|{
51015|  17.7k|    JSValue proto;
51016|  17.7k|    int i;
51017|       |
51018|  17.7k|    ctx->class_proto[JS_CLASS_OBJECT] = JS_NewObjectProto(ctx, JS_NULL);
51019|  17.7k|    ctx->function_proto = JS_NewCFunction3(ctx, js_function_proto, "", 0,
51020|  17.7k|                                           JS_CFUNC_generic, 0,
51021|  17.7k|                                           ctx->class_proto[JS_CLASS_OBJECT]);
51022|  17.7k|    ctx->class_proto[JS_CLASS_BYTECODE_FUNCTION] = JS_DupValue(ctx, ctx->function_proto);
51023|  17.7k|    ctx->class_proto[JS_CLASS_ERROR] = JS_NewObject(ctx);
51024|       |#if 0
51025|       |    /* these are auto-initialized from js_error_proto_funcs,
51026|       |       but delaying might be a problem */
51027|       |    JS_DefinePropertyValue(ctx, ctx->class_proto[JS_CLASS_ERROR], JS_ATOM_name,
51028|       |                           JS_AtomToString(ctx, JS_ATOM_Error),
51029|       |                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
51030|       |    JS_DefinePropertyValue(ctx, ctx->class_proto[JS_CLASS_ERROR], JS_ATOM_message,
51031|       |                           JS_AtomToString(ctx, JS_ATOM_empty_string),
51032|       |                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
51033|       |#endif
51034|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ERROR],
51035|  17.7k|                               js_error_proto_funcs,
51036|  17.7k|                               countof(js_error_proto_funcs));
51037|       |
51038|   159k|    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
51039|   142k|        proto = JS_NewObjectProto(ctx, ctx->class_proto[JS_CLASS_ERROR]);
51040|   142k|        JS_DefinePropertyValue(ctx, proto, JS_ATOM_name,
51041|   142k|                               JS_NewAtomString(ctx, native_error_name[i]),
51042|   142k|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
51043|   142k|        JS_DefinePropertyValue(ctx, proto, JS_ATOM_message,
51044|   142k|                               JS_AtomToString(ctx, JS_ATOM_empty_string),
51045|   142k|                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
51046|   142k|        ctx->native_error_proto[i] = proto;
51047|   142k|    }
51048|       |
51049|       |    /* the array prototype is an array */
51050|  17.7k|    ctx->class_proto[JS_CLASS_ARRAY] =
51051|  17.7k|        JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
51052|  17.7k|                               JS_CLASS_ARRAY);
51053|       |
51054|  17.7k|    ctx->array_shape = js_new_shape2(ctx, get_proto_obj(ctx->class_proto[JS_CLASS_ARRAY]),
51055|  17.7k|                                     JS_PROP_INITIAL_HASH_SIZE, 1);
51056|  17.7k|    add_shape_property(ctx, &ctx->array_shape, NULL,
51057|  17.7k|                       JS_ATOM_length, JS_PROP_WRITABLE | JS_PROP_LENGTH);
51058|       |
51059|       |    /* XXX: could test it on first context creation to ensure that no
51060|       |       new atoms are created in JS_AddIntrinsicBasicObjects(). It is
51061|       |       necessary to avoid useless renumbering of atoms after
51062|       |       JS_EvalBinary() if it is done just after
51063|       |       JS_AddIntrinsicBasicObjects(). */
51064|       |    //    assert(ctx->rt->atom_count == JS_ATOM_END);
51065|  17.7k|}
51066|       |
51067|       |void JS_AddIntrinsicBaseObjects(JSContext *ctx)
51068|  17.7k|{
51069|  17.7k|    int i;
51070|  17.7k|    JSValueConst obj, number_obj;
51071|  17.7k|    JSValue obj1;
51072|       |
51073|  17.7k|    ctx->throw_type_error = JS_NewCFunction(ctx, js_throw_type_error, NULL, 0);
51074|       |
51075|       |    /* add caller and arguments properties to throw a TypeError */
51076|  17.7k|    JS_DefineProperty(ctx, ctx->function_proto, JS_ATOM_caller, JS_UNDEFINED,
51077|  17.7k|                      ctx->throw_type_error, ctx->throw_type_error,
51078|  17.7k|                      JS_PROP_HAS_GET | JS_PROP_HAS_SET |
51079|  17.7k|                      JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE);
51080|  17.7k|    JS_DefineProperty(ctx, ctx->function_proto, JS_ATOM_arguments, JS_UNDEFINED,
51081|  17.7k|                      ctx->throw_type_error, ctx->throw_type_error,
51082|  17.7k|                      JS_PROP_HAS_GET | JS_PROP_HAS_SET |
51083|  17.7k|                      JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE);
51084|  17.7k|    JS_FreeValue(ctx, js_object_seal(ctx, JS_UNDEFINED, 1, (JSValueConst *)&ctx->throw_type_error, 1));
51085|       |
51086|  17.7k|    ctx->global_obj = JS_NewObject(ctx);
51087|  17.7k|    ctx->global_var_obj = JS_NewObjectProto(ctx, JS_NULL);
51088|       |
51089|       |    /* Object */
51090|  17.7k|    obj = JS_NewGlobalCConstructor(ctx, "Object", js_object_constructor, 1,
51091|  17.7k|                                   ctx->class_proto[JS_CLASS_OBJECT]);
51092|  17.7k|    JS_SetPropertyFunctionList(ctx, obj, js_object_funcs, countof(js_object_funcs));
51093|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_OBJECT],
51094|  17.7k|                               js_object_proto_funcs, countof(js_object_proto_funcs));
51095|       |
51096|       |    /* Function */
51097|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->function_proto, js_function_proto_funcs, countof(js_function_proto_funcs));
51098|  17.7k|    ctx->function_ctor = JS_NewCFunctionMagic(ctx, js_function_constructor,
51099|  17.7k|                                              "Function", 1, JS_CFUNC_constructor_or_func_magic,
51100|  17.7k|                                              JS_FUNC_NORMAL);
51101|  17.7k|    JS_NewGlobalCConstructor2(ctx, JS_DupValue(ctx, ctx->function_ctor), "Function",
51102|  17.7k|                              ctx->function_proto);
51103|       |
51104|       |    /* Error */
51105|  17.7k|    obj1 = JS_NewCFunctionMagic(ctx, js_error_constructor,
51106|  17.7k|                                "Error", 1, JS_CFUNC_constructor_or_func_magic, -1);
51107|  17.7k|    JS_NewGlobalCConstructor2(ctx, obj1,
51108|  17.7k|                              "Error", ctx->class_proto[JS_CLASS_ERROR]);
51109|       |
51110|       |    /* Used to squelch a -Wcast-function-type warning. */
51111|  17.7k|    JSCFunctionType ft = { .generic_magic = js_error_constructor };
51112|   159k|    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
51113|   142k|        JSValue func_obj;
51114|   142k|        int n_args;
51115|   142k|        n_args = 1 + (i == JS_AGGREGATE_ERROR);
51116|   142k|        func_obj = JS_NewCFunction3(ctx, ft.generic,
51117|   142k|                                    native_error_name[i], n_args,
51118|   142k|                                    JS_CFUNC_constructor_or_func_magic, i, obj1);
51119|   142k|        JS_NewGlobalCConstructor2(ctx, func_obj, native_error_name[i],
51120|   142k|                                  ctx->native_error_proto[i]);
51121|   142k|    }
51122|       |
51123|       |    /* Iterator prototype */
51124|  17.7k|    ctx->iterator_proto = JS_NewObject(ctx);
51125|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->iterator_proto,
51126|  17.7k|                               js_iterator_proto_funcs,
51127|  17.7k|                               countof(js_iterator_proto_funcs));
51128|       |
51129|       |    /* Array */
51130|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY],
51131|  17.7k|                               js_array_proto_funcs,
51132|  17.7k|                               countof(js_array_proto_funcs));
51133|       |
51134|  17.7k|    obj = JS_NewGlobalCConstructor(ctx, "Array", js_array_constructor, 1,
51135|  17.7k|                                   ctx->class_proto[JS_CLASS_ARRAY]);
51136|  17.7k|    ctx->array_ctor = JS_DupValue(ctx, obj);
51137|  17.7k|    JS_SetPropertyFunctionList(ctx, obj, js_array_funcs,
51138|  17.7k|                               countof(js_array_funcs));
51139|       |
51140|       |    /* XXX: create auto_initializer */
51141|  17.7k|    {
51142|       |        /* initialize Array.prototype[Symbol.unscopables] */
51143|  17.7k|        static const char unscopables[] =
51144|  17.7k|            "at" "\0"
51145|  17.7k|            "copyWithin" "\0"
51146|  17.7k|            "entries" "\0"
51147|  17.7k|            "fill" "\0"
51148|  17.7k|            "find" "\0"
51149|  17.7k|            "findIndex" "\0"
51150|  17.7k|            "findLast" "\0"
51151|  17.7k|            "findLastIndex" "\0"
51152|  17.7k|            "flat" "\0"
51153|  17.7k|            "flatMap" "\0"
51154|  17.7k|            "includes" "\0"
51155|  17.7k|            "keys" "\0"
51156|  17.7k|            "toReversed" "\0"
51157|  17.7k|            "toSorted" "\0"
51158|  17.7k|            "toSpliced" "\0"
51159|  17.7k|            "values" "\0";
51160|  17.7k|        const char *p = unscopables;
51161|  17.7k|        obj1 = JS_NewObjectProto(ctx, JS_NULL);
51162|   302k|        for(p = unscopables; *p; p += strlen(p) + 1) {
51163|   284k|            JS_DefinePropertyValueStr(ctx, obj1, p, JS_TRUE, JS_PROP_C_W_E);
51164|   284k|        }
51165|  17.7k|        JS_DefinePropertyValue(ctx, ctx->class_proto[JS_CLASS_ARRAY],
51166|  17.7k|                               JS_ATOM_Symbol_unscopables, obj1,
51167|  17.7k|                               JS_PROP_CONFIGURABLE);
51168|  17.7k|    }
51169|       |
51170|       |    /* needed to initialize arguments[Symbol.iterator] */
51171|  17.7k|    ctx->array_proto_values =
51172|  17.7k|        JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_ARRAY], JS_ATOM_values);
51173|       |
51174|  17.7k|    ctx->class_proto[JS_CLASS_ARRAY_ITERATOR] = JS_NewObjectProto(ctx, ctx->iterator_proto);
51175|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY_ITERATOR],
51176|  17.7k|                               js_array_iterator_proto_funcs,
51177|  17.7k|                               countof(js_array_iterator_proto_funcs));
51178|       |
51179|       |    /* parseFloat and parseInteger must be defined before Number
51180|       |       because of the Number.parseFloat and Number.parseInteger
51181|       |       aliases */
51182|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_global_funcs,
51183|  17.7k|                               countof(js_global_funcs));
51184|       |
51185|       |    /* Number */
51186|  17.7k|    ctx->class_proto[JS_CLASS_NUMBER] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
51187|  17.7k|                                                               JS_CLASS_NUMBER);
51188|  17.7k|    JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_NUMBER], JS_NewInt32(ctx, 0));
51189|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_NUMBER],
51190|  17.7k|                               js_number_proto_funcs,
51191|  17.7k|                               countof(js_number_proto_funcs));
51192|  17.7k|    number_obj = JS_NewGlobalCConstructor(ctx, "Number", js_number_constructor, 1,
51193|  17.7k|                                          ctx->class_proto[JS_CLASS_NUMBER]);
51194|  17.7k|    JS_SetPropertyFunctionList(ctx, number_obj, js_number_funcs, countof(js_number_funcs));
51195|       |
51196|       |    /* Boolean */
51197|  17.7k|    ctx->class_proto[JS_CLASS_BOOLEAN] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
51198|  17.7k|                                                                JS_CLASS_BOOLEAN);
51199|  17.7k|    JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_BOOLEAN], JS_NewBool(ctx, FALSE));
51200|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BOOLEAN], js_boolean_proto_funcs,
51201|  17.7k|                               countof(js_boolean_proto_funcs));
51202|  17.7k|    JS_NewGlobalCConstructor(ctx, "Boolean", js_boolean_constructor, 1,
51203|  17.7k|                             ctx->class_proto[JS_CLASS_BOOLEAN]);
51204|       |
51205|       |    /* String */
51206|  17.7k|    ctx->class_proto[JS_CLASS_STRING] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
51207|  17.7k|                                                               JS_CLASS_STRING);
51208|  17.7k|    JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_STRING], JS_AtomToString(ctx, JS_ATOM_empty_string));
51209|  17.7k|    obj = JS_NewGlobalCConstructor(ctx, "String", js_string_constructor, 1,
51210|  17.7k|                                   ctx->class_proto[JS_CLASS_STRING]);
51211|  17.7k|    JS_SetPropertyFunctionList(ctx, obj, js_string_funcs,
51212|  17.7k|                               countof(js_string_funcs));
51213|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING], js_string_proto_funcs,
51214|  17.7k|                               countof(js_string_proto_funcs));
51215|       |
51216|  17.7k|    ctx->class_proto[JS_CLASS_STRING_ITERATOR] = JS_NewObjectProto(ctx, ctx->iterator_proto);
51217|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING_ITERATOR],
51218|  17.7k|                               js_string_iterator_proto_funcs,
51219|  17.7k|                               countof(js_string_iterator_proto_funcs));
51220|       |
51221|       |    /* Math: create as autoinit object */
51222|  17.7k|    js_random_init(ctx);
51223|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_math_obj, countof(js_math_obj));
51224|       |
51225|       |    /* ES6 Reflect: create as autoinit object */
51226|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_reflect_obj, countof(js_reflect_obj));
51227|       |
51228|       |    /* ES6 Symbol */
51229|  17.7k|    ctx->class_proto[JS_CLASS_SYMBOL] = JS_NewObject(ctx);
51230|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_SYMBOL], js_symbol_proto_funcs,
51231|  17.7k|                               countof(js_symbol_proto_funcs));
51232|  17.7k|    obj = JS_NewGlobalCConstructor(ctx, "Symbol", js_symbol_constructor, 0,
51233|  17.7k|                                   ctx->class_proto[JS_CLASS_SYMBOL]);
51234|  17.7k|    JS_SetPropertyFunctionList(ctx, obj, js_symbol_funcs,
51235|  17.7k|                               countof(js_symbol_funcs));
51236|   248k|    for(i = JS_ATOM_Symbol_toPrimitive; i < JS_ATOM_END; i++) {
51237|   230k|        char buf[ATOM_GET_STR_BUF_SIZE];
51238|   230k|        const char *str, *p;
51239|   230k|        str = JS_AtomGetStr(ctx, buf, sizeof(buf), i);
51240|       |        /* skip "Symbol." */
51241|   230k|        p = strchr(str, '.');
51242|   230k|        if (p)
51243|   230k|            str = p + 1;
51244|   230k|        JS_DefinePropertyValueStr(ctx, obj, str, JS_AtomToValue(ctx, i), 0);
51245|   230k|    }
51246|       |
51247|       |    /* ES6 Generator */
51248|  17.7k|    ctx->class_proto[JS_CLASS_GENERATOR] = JS_NewObjectProto(ctx, ctx->iterator_proto);
51249|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_GENERATOR],
51250|  17.7k|                               js_generator_proto_funcs,
51251|  17.7k|                               countof(js_generator_proto_funcs));
51252|       |
51253|  17.7k|    ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION] = JS_NewObjectProto(ctx, ctx->function_proto);
51254|  17.7k|    obj1 = JS_NewCFunctionMagic(ctx, js_function_constructor,
51255|  17.7k|                                "GeneratorFunction", 1,
51256|  17.7k|                                JS_CFUNC_constructor_or_func_magic, JS_FUNC_GENERATOR);
51257|  17.7k|    JS_SetPropertyFunctionList(ctx,
51258|  17.7k|                               ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],
51259|  17.7k|                               js_generator_function_proto_funcs,
51260|  17.7k|                               countof(js_generator_function_proto_funcs));
51261|  17.7k|    JS_SetConstructor2(ctx, ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],
51262|  17.7k|                       ctx->class_proto[JS_CLASS_GENERATOR],
51263|  17.7k|                       JS_PROP_CONFIGURABLE, JS_PROP_CONFIGURABLE);
51264|  17.7k|    JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],
51265|  17.7k|                       0, JS_PROP_CONFIGURABLE);
51266|  17.7k|    JS_FreeValue(ctx, obj1);
51267|       |
51268|       |    /* global properties */
51269|  17.7k|    ctx->eval_obj = JS_NewCFunction(ctx, js_global_eval, "eval", 1);
51270|  17.7k|    JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_eval,
51271|  17.7k|                           JS_DupValue(ctx, ctx->eval_obj),
51272|  17.7k|                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
51273|       |
51274|  17.7k|    JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_globalThis,
51275|  17.7k|                           JS_DupValue(ctx, ctx->global_obj),
51276|  17.7k|                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
51277|       |
51278|       |    /* BigInt */
51279|  17.7k|    JS_AddIntrinsicBigInt(ctx);
51280|  17.7k|}
51281|       |
51282|       |/* Typed Arrays */
51283|       |
51284|       |static uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT] = {
51285|       |    0, 0, 0, 1, 1, 2, 2,
51286|       |    3, 3, /* BigInt64Array, BigUint64Array */
51287|       |    2, 3
51288|       |};
51289|       |
51290|       |static JSValue js_array_buffer_constructor3(JSContext *ctx,
51291|       |                                            JSValueConst new_target,
51292|       |                                            uint64_t len, JSClassID class_id,
51293|       |                                            uint8_t *buf,
51294|       |                                            JSFreeArrayBufferDataFunc *free_func,
51295|       |                                            void *opaque, BOOL alloc_flag)
51296|      0|{
51297|      0|    JSRuntime *rt = ctx->rt;
51298|      0|    JSValue obj;
51299|      0|    JSArrayBuffer *abuf = NULL;
51300|       |
51301|      0|    obj = js_create_from_ctor(ctx, new_target, class_id);
51302|      0|    if (JS_IsException(obj))
51303|      0|        return obj;
51304|       |    /* XXX: we are currently limited to 2 GB */
51305|      0|    if (len > INT32_MAX) {
51306|      0|        JS_ThrowRangeError(ctx, "invalid array buffer length");
51307|      0|        goto fail;
51308|      0|    }
51309|      0|    abuf = js_malloc(ctx, sizeof(*abuf));
51310|      0|    if (!abuf)
51311|      0|        goto fail;
51312|      0|    abuf->byte_length = len;
51313|      0|    if (alloc_flag) {
51314|      0|        if (class_id == JS_CLASS_SHARED_ARRAY_BUFFER &&
51315|      0|            rt->sab_funcs.sab_alloc) {
51316|      0|            abuf->data = rt->sab_funcs.sab_alloc(rt->sab_funcs.sab_opaque,
51317|      0|                                                 max_int(len, 1));
51318|      0|            if (!abuf->data)
51319|      0|                goto fail;
51320|      0|            memset(abuf->data, 0, len);
51321|      0|        } else {
51322|       |            /* the allocation must be done after the object creation */
51323|      0|            abuf->data = js_mallocz(ctx, max_int(len, 1));
51324|      0|            if (!abuf->data)
51325|      0|                goto fail;
51326|      0|        }
51327|      0|    } else {
51328|      0|        if (class_id == JS_CLASS_SHARED_ARRAY_BUFFER &&
51329|      0|            rt->sab_funcs.sab_dup) {
51330|      0|            rt->sab_funcs.sab_dup(rt->sab_funcs.sab_opaque, buf);
51331|      0|        }
51332|      0|        abuf->data = buf;
51333|      0|    }
51334|      0|    init_list_head(&abuf->array_list);
51335|      0|    abuf->detached = FALSE;
51336|      0|    abuf->shared = (class_id == JS_CLASS_SHARED_ARRAY_BUFFER);
51337|      0|    abuf->opaque = opaque;
51338|      0|    abuf->free_func = free_func;
51339|      0|    if (alloc_flag && buf)
51340|      0|        memcpy(abuf->data, buf, len);
51341|      0|    JS_SetOpaque(obj, abuf);
51342|      0|    return obj;
51343|      0| fail:
51344|      0|    JS_FreeValue(ctx, obj);
51345|      0|    js_free(ctx, abuf);
51346|      0|    return JS_EXCEPTION;
51347|      0|}
51348|       |
51349|       |static void js_array_buffer_free(JSRuntime *rt, void *opaque, void *ptr)
51350|      0|{
51351|      0|    js_free_rt(rt, ptr);
51352|      0|}
51353|       |
51354|       |static JSValue js_array_buffer_constructor2(JSContext *ctx,
51355|       |                                            JSValueConst new_target,
51356|       |                                            uint64_t len, JSClassID class_id)
51357|      0|{
51358|      0|    return js_array_buffer_constructor3(ctx, new_target, len, class_id,
51359|      0|                                        NULL, js_array_buffer_free, NULL,
51360|      0|                                        TRUE);
51361|      0|}
51362|       |
51363|       |static JSValue js_array_buffer_constructor1(JSContext *ctx,
51364|       |                                            JSValueConst new_target,
51365|       |                                            uint64_t len)
51366|      0|{
51367|      0|    return js_array_buffer_constructor2(ctx, new_target, len,
51368|      0|                                        JS_CLASS_ARRAY_BUFFER);
51369|      0|}
51370|       |
51371|       |JSValue JS_NewArrayBuffer(JSContext *ctx, uint8_t *buf, size_t len,
51372|       |                          JSFreeArrayBufferDataFunc *free_func, void *opaque,
51373|       |                          BOOL is_shared)
51374|      0|{
51375|      0|    return js_array_buffer_constructor3(ctx, JS_UNDEFINED, len,
51376|      0|                                        is_shared ? JS_CLASS_SHARED_ARRAY_BUFFER : JS_CLASS_ARRAY_BUFFER,
51377|      0|                                        buf, free_func, opaque, FALSE);
51378|      0|}
51379|       |
51380|       |/* create a new ArrayBuffer of length 'len' and copy 'buf' to it */
51381|       |JSValue JS_NewArrayBufferCopy(JSContext *ctx, const uint8_t *buf, size_t len)
51382|      0|{
51383|      0|    return js_array_buffer_constructor3(ctx, JS_UNDEFINED, len,
51384|      0|                                        JS_CLASS_ARRAY_BUFFER,
51385|      0|                                        (uint8_t *)buf,
51386|      0|                                        js_array_buffer_free, NULL,
51387|      0|                                        TRUE);
51388|      0|}
51389|       |
51390|       |static JSValue js_array_buffer_constructor(JSContext *ctx,
51391|       |                                           JSValueConst new_target,
51392|       |                                           int argc, JSValueConst *argv)
51393|      0|{
51394|      0|    uint64_t len;
51395|      0|    if (JS_ToIndex(ctx, &len, argv[0]))
51396|      0|        return JS_EXCEPTION;
51397|      0|    return js_array_buffer_constructor1(ctx, new_target, len);
51398|      0|}
51399|       |
51400|       |static JSValue js_shared_array_buffer_constructor(JSContext *ctx,
51401|       |                                                  JSValueConst new_target,
51402|       |                                                  int argc, JSValueConst *argv)
51403|      0|{
51404|      0|    uint64_t len;
51405|      0|    if (JS_ToIndex(ctx, &len, argv[0]))
51406|      0|        return JS_EXCEPTION;
51407|      0|    return js_array_buffer_constructor2(ctx, new_target, len,
51408|      0|                                        JS_CLASS_SHARED_ARRAY_BUFFER);
51409|      0|}
51410|       |
51411|       |/* also used for SharedArrayBuffer */
51412|       |static void js_array_buffer_finalizer(JSRuntime *rt, JSValue val)
51413|      0|{
51414|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
51415|      0|    JSArrayBuffer *abuf = p->u.array_buffer;
51416|      0|    struct list_head *el, *el1;
51417|       |
51418|      0|    if (abuf) {
51419|       |        /* The ArrayBuffer finalizer may be called before the typed
51420|       |           array finalizers using it, so abuf->array_list is not
51421|       |           necessarily empty. */
51422|      0|        list_for_each_safe(el, el1, &abuf->array_list) {
51423|      0|            JSTypedArray *ta;
51424|      0|            JSObject *p1;
51425|       |
51426|      0|            ta = list_entry(el, JSTypedArray, link);
51427|      0|            ta->link.prev = NULL;
51428|      0|            ta->link.next = NULL;
51429|      0|            p1 = ta->obj;
51430|       |            /* Note: the typed array length and offset fields are not modified */
51431|      0|            if (p1->class_id != JS_CLASS_DATAVIEW) {
51432|      0|                p1->u.array.count = 0;
51433|      0|                p1->u.array.u.ptr = NULL;
51434|      0|            }
51435|      0|        }
51436|      0|        if (abuf->shared && rt->sab_funcs.sab_free) {
51437|      0|            rt->sab_funcs.sab_free(rt->sab_funcs.sab_opaque, abuf->data);
51438|      0|        } else {
51439|      0|            if (abuf->free_func)
51440|      0|                abuf->free_func(rt, abuf->opaque, abuf->data);
51441|      0|        }
51442|      0|        js_free_rt(rt, abuf);
51443|      0|    }
51444|      0|}
51445|       |
51446|       |static JSValue js_array_buffer_isView(JSContext *ctx,
51447|       |                                      JSValueConst this_val,
51448|       |                                      int argc, JSValueConst *argv)
51449|      0|{
51450|      0|    JSObject *p;
51451|      0|    BOOL res;
51452|      0|    res = FALSE;
51453|      0|    if (JS_VALUE_GET_TAG(argv[0]) == JS_TAG_OBJECT) {
51454|      0|        p = JS_VALUE_GET_OBJ(argv[0]);
51455|      0|        if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
51456|      0|            p->class_id <= JS_CLASS_DATAVIEW) {
51457|      0|            res = TRUE;
51458|      0|        }
51459|      0|    }
51460|      0|    return JS_NewBool(ctx, res);
51461|      0|}
51462|       |
51463|       |static const JSCFunctionListEntry js_array_buffer_funcs[] = {
51464|       |    JS_CFUNC_DEF("isView", 1, js_array_buffer_isView ),
51465|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
51466|       |};
51467|       |
51468|       |static JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx)
51469|      0|{
51470|      0|    return JS_ThrowTypeError(ctx, "ArrayBuffer is detached");
51471|      0|}
51472|       |
51473|       |static JSValue js_array_buffer_get_byteLength(JSContext *ctx,
51474|       |                                              JSValueConst this_val,
51475|       |                                              int class_id)
51476|      0|{
51477|      0|    JSArrayBuffer *abuf = JS_GetOpaque2(ctx, this_val, class_id);
51478|      0|    if (!abuf)
51479|      0|        return JS_EXCEPTION;
51480|       |    /* return 0 if detached */
51481|      0|    return JS_NewUint32(ctx, abuf->byte_length);
51482|      0|}
51483|       |
51484|       |void JS_DetachArrayBuffer(JSContext *ctx, JSValueConst obj)
51485|      0|{
51486|      0|    JSArrayBuffer *abuf = JS_GetOpaque(obj, JS_CLASS_ARRAY_BUFFER);
51487|      0|    struct list_head *el;
51488|       |
51489|      0|    if (!abuf || abuf->detached)
51490|      0|        return;
51491|      0|    if (abuf->free_func)
51492|      0|        abuf->free_func(ctx->rt, abuf->opaque, abuf->data);
51493|      0|    abuf->data = NULL;
51494|      0|    abuf->byte_length = 0;
51495|      0|    abuf->detached = TRUE;
51496|       |
51497|      0|    list_for_each(el, &abuf->array_list) {
51498|      0|        JSTypedArray *ta;
51499|      0|        JSObject *p;
51500|       |
51501|      0|        ta = list_entry(el, JSTypedArray, link);
51502|      0|        p = ta->obj;
51503|       |        /* Note: the typed array length and offset fields are not modified */
51504|      0|        if (p->class_id != JS_CLASS_DATAVIEW) {
51505|      0|            p->u.array.count = 0;
51506|      0|            p->u.array.u.ptr = NULL;
51507|      0|        }
51508|      0|    }
51509|      0|}
51510|       |
51511|       |/* get an ArrayBuffer or SharedArrayBuffer */
51512|       |static JSArrayBuffer *js_get_array_buffer(JSContext *ctx, JSValueConst obj)
51513|      0|{
51514|      0|    JSObject *p;
51515|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
51516|      0|        goto fail;
51517|      0|    p = JS_VALUE_GET_OBJ(obj);
51518|      0|    if (p->class_id != JS_CLASS_ARRAY_BUFFER &&
51519|      0|        p->class_id != JS_CLASS_SHARED_ARRAY_BUFFER) {
51520|      0|    fail:
51521|      0|        JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_ARRAY_BUFFER);
51522|      0|        return NULL;
51523|      0|    }
51524|      0|    return p->u.array_buffer;
51525|      0|}
51526|       |
51527|       |/* return NULL if exception. WARNING: any JS call can detach the
51528|       |   buffer and render the returned pointer invalid */
51529|       |uint8_t *JS_GetArrayBuffer(JSContext *ctx, size_t *psize, JSValueConst obj)
51530|      0|{
51531|      0|    JSArrayBuffer *abuf = js_get_array_buffer(ctx, obj);
51532|      0|    if (!abuf)
51533|      0|        goto fail;
51534|      0|    if (abuf->detached) {
51535|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51536|      0|        goto fail;
51537|      0|    }
51538|      0|    *psize = abuf->byte_length;
51539|      0|    return abuf->data;
51540|      0| fail:
51541|      0|    *psize = 0;
51542|      0|    return NULL;
51543|      0|}
51544|       |
51545|       |static JSValue js_array_buffer_slice(JSContext *ctx,
51546|       |                                     JSValueConst this_val,
51547|       |                                     int argc, JSValueConst *argv, int class_id)
51548|      0|{
51549|      0|    JSArrayBuffer *abuf, *new_abuf;
51550|      0|    int64_t len, start, end, new_len;
51551|      0|    JSValue ctor, new_obj;
51552|       |
51553|      0|    abuf = JS_GetOpaque2(ctx, this_val, class_id);
51554|      0|    if (!abuf)
51555|      0|        return JS_EXCEPTION;
51556|      0|    if (abuf->detached)
51557|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51558|      0|    len = abuf->byte_length;
51559|       |
51560|      0|    if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))
51561|      0|        return JS_EXCEPTION;
51562|       |
51563|      0|    end = len;
51564|      0|    if (!JS_IsUndefined(argv[1])) {
51565|      0|        if (JS_ToInt64Clamp(ctx, &end, argv[1], 0, len, len))
51566|      0|            return JS_EXCEPTION;
51567|      0|    }
51568|      0|    new_len = max_int64(end - start, 0);
51569|      0|    ctor = JS_SpeciesConstructor(ctx, this_val, JS_UNDEFINED);
51570|      0|    if (JS_IsException(ctor))
51571|      0|        return ctor;
51572|      0|    if (JS_IsUndefined(ctor)) {
51573|      0|        new_obj = js_array_buffer_constructor2(ctx, JS_UNDEFINED, new_len,
51574|      0|                                               class_id);
51575|      0|    } else {
51576|      0|        JSValue args[1];
51577|      0|        args[0] = JS_NewInt64(ctx, new_len);
51578|      0|        new_obj = JS_CallConstructor(ctx, ctor, 1, (JSValueConst *)args);
51579|      0|        JS_FreeValue(ctx, ctor);
51580|      0|        JS_FreeValue(ctx, args[0]);
51581|      0|    }
51582|      0|    if (JS_IsException(new_obj))
51583|      0|        return new_obj;
51584|      0|    new_abuf = JS_GetOpaque2(ctx, new_obj, class_id);
51585|      0|    if (!new_abuf)
51586|      0|        goto fail;
51587|      0|    if (js_same_value(ctx, new_obj, this_val)) {
51588|      0|        JS_ThrowTypeError(ctx, "cannot use identical ArrayBuffer");
51589|      0|        goto fail;
51590|      0|    }
51591|      0|    if (new_abuf->detached) {
51592|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51593|      0|        goto fail;
51594|      0|    }
51595|      0|    if (new_abuf->byte_length < new_len) {
51596|      0|        JS_ThrowTypeError(ctx, "new ArrayBuffer is too small");
51597|      0|        goto fail;
51598|      0|    }
51599|       |    /* must test again because of side effects */
51600|      0|    if (abuf->detached) {
51601|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51602|      0|        goto fail;
51603|      0|    }
51604|      0|    memcpy(new_abuf->data, abuf->data + start, new_len);
51605|      0|    return new_obj;
51606|      0| fail:
51607|      0|    JS_FreeValue(ctx, new_obj);
51608|      0|    return JS_EXCEPTION;
51609|      0|}
51610|       |
51611|       |static const JSCFunctionListEntry js_array_buffer_proto_funcs[] = {
51612|       |    JS_CGETSET_MAGIC_DEF("byteLength", js_array_buffer_get_byteLength, NULL, JS_CLASS_ARRAY_BUFFER ),
51613|       |    JS_CFUNC_MAGIC_DEF("slice", 2, js_array_buffer_slice, JS_CLASS_ARRAY_BUFFER ),
51614|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "ArrayBuffer", JS_PROP_CONFIGURABLE ),
51615|       |};
51616|       |
51617|       |/* SharedArrayBuffer */
51618|       |
51619|       |static const JSCFunctionListEntry js_shared_array_buffer_funcs[] = {
51620|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
51621|       |};
51622|       |
51623|       |static const JSCFunctionListEntry js_shared_array_buffer_proto_funcs[] = {
51624|       |    JS_CGETSET_MAGIC_DEF("byteLength", js_array_buffer_get_byteLength, NULL, JS_CLASS_SHARED_ARRAY_BUFFER ),
51625|       |    JS_CFUNC_MAGIC_DEF("slice", 2, js_array_buffer_slice, JS_CLASS_SHARED_ARRAY_BUFFER ),
51626|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "SharedArrayBuffer", JS_PROP_CONFIGURABLE ),
51627|       |};
51628|       |
51629|       |static JSObject *get_typed_array(JSContext *ctx,
51630|       |                                 JSValueConst this_val,
51631|       |                                 int is_dataview)
51632|      0|{
51633|      0|    JSObject *p;
51634|      0|    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
51635|      0|        goto fail;
51636|      0|    p = JS_VALUE_GET_OBJ(this_val);
51637|      0|    if (is_dataview) {
51638|      0|        if (p->class_id != JS_CLASS_DATAVIEW)
51639|      0|            goto fail;
51640|      0|    } else {
51641|      0|        if (!(p->class_id >= JS_CLASS_UINT8C_ARRAY &&
51642|      0|              p->class_id <= JS_CLASS_FLOAT64_ARRAY)) {
51643|      0|        fail:
51644|      0|            JS_ThrowTypeError(ctx, "not a %s", is_dataview ? "DataView" : "TypedArray");
51645|      0|            return NULL;
51646|      0|        }
51647|      0|    }
51648|      0|    return p;
51649|      0|}
51650|       |
51651|       |/* WARNING: 'p' must be a typed array */
51652|       |static BOOL typed_array_is_detached(JSContext *ctx, JSObject *p)
51653|      0|{
51654|      0|    JSTypedArray *ta = p->u.typed_array;
51655|      0|    JSArrayBuffer *abuf = ta->buffer->u.array_buffer;
51656|       |    /* XXX: could simplify test by ensuring that
51657|       |       p->u.array.u.ptr is NULL iff it is detached */
51658|      0|    return abuf->detached;
51659|      0|}
51660|       |
51661|       |/* WARNING: 'p' must be a typed array. Works even if the array buffer
51662|       |   is detached */
51663|       |static uint32_t typed_array_get_length(JSContext *ctx, JSObject *p)
51664|      0|{
51665|      0|    JSTypedArray *ta = p->u.typed_array;
51666|      0|    int size_log2 = typed_array_size_log2(p->class_id);
51667|      0|    return ta->length >> size_log2;
51668|      0|}
51669|       |
51670|       |static int validate_typed_array(JSContext *ctx, JSValueConst this_val)
51671|      0|{
51672|      0|    JSObject *p;
51673|      0|    p = get_typed_array(ctx, this_val, 0);
51674|      0|    if (!p)
51675|      0|        return -1;
51676|      0|    if (typed_array_is_detached(ctx, p)) {
51677|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51678|      0|        return -1;
51679|      0|    }
51680|      0|    return 0;
51681|      0|}
51682|       |
51683|       |static JSValue js_typed_array_get_length(JSContext *ctx,
51684|       |                                         JSValueConst this_val)
51685|      0|{
51686|      0|    JSObject *p;
51687|      0|    p = get_typed_array(ctx, this_val, 0);
51688|      0|    if (!p)
51689|      0|        return JS_EXCEPTION;
51690|      0|    return JS_NewInt32(ctx, p->u.array.count);
51691|      0|}
51692|       |
51693|       |static JSValue js_typed_array_get_buffer(JSContext *ctx,
51694|       |                                         JSValueConst this_val, int is_dataview)
51695|      0|{
51696|      0|    JSObject *p;
51697|      0|    JSTypedArray *ta;
51698|      0|    p = get_typed_array(ctx, this_val, is_dataview);
51699|      0|    if (!p)
51700|      0|        return JS_EXCEPTION;
51701|      0|    ta = p->u.typed_array;
51702|      0|    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));
51703|      0|}
51704|       |
51705|       |static JSValue js_typed_array_get_byteLength(JSContext *ctx,
51706|       |                                             JSValueConst this_val,
51707|       |                                             int is_dataview)
51708|      0|{
51709|      0|    JSObject *p;
51710|      0|    JSTypedArray *ta;
51711|      0|    p = get_typed_array(ctx, this_val, is_dataview);
51712|      0|    if (!p)
51713|      0|        return JS_EXCEPTION;
51714|      0|    if (typed_array_is_detached(ctx, p)) {
51715|      0|        if (is_dataview) {
51716|      0|            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51717|      0|        } else {
51718|      0|            return JS_NewInt32(ctx, 0);
51719|      0|        }
51720|      0|    }
51721|      0|    ta = p->u.typed_array;
51722|      0|    return JS_NewInt32(ctx, ta->length);
51723|      0|}
51724|       |
51725|       |static JSValue js_typed_array_get_byteOffset(JSContext *ctx,
51726|       |                                             JSValueConst this_val,
51727|       |                                             int is_dataview)
51728|      0|{
51729|      0|    JSObject *p;
51730|      0|    JSTypedArray *ta;
51731|      0|    p = get_typed_array(ctx, this_val, is_dataview);
51732|      0|    if (!p)
51733|      0|        return JS_EXCEPTION;
51734|      0|    if (typed_array_is_detached(ctx, p)) {
51735|      0|        if (is_dataview) {
51736|      0|            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51737|      0|        } else {
51738|      0|            return JS_NewInt32(ctx, 0);
51739|      0|        }
51740|      0|    }
51741|      0|    ta = p->u.typed_array;
51742|      0|    return JS_NewInt32(ctx, ta->offset);
51743|      0|}
51744|       |
51745|       |JSValue JS_NewTypedArray(JSContext *ctx, int argc, JSValueConst *argv,
51746|       |                         JSTypedArrayEnum type)
51747|      0|{
51748|      0|    if (type < JS_TYPED_ARRAY_UINT8C || type > JS_TYPED_ARRAY_FLOAT64)
51749|      0|        return JS_ThrowRangeError(ctx, "invalid typed array type");
51750|       |
51751|      0|    return js_typed_array_constructor(ctx, JS_UNDEFINED, argc, argv,
51752|      0|                                      JS_CLASS_UINT8C_ARRAY + type);
51753|      0|}
51754|       |
51755|       |/* Return the buffer associated to the typed array or an exception if
51756|       |   it is not a typed array or if the buffer is detached. pbyte_offset,
51757|       |   pbyte_length or pbytes_per_element can be NULL. */
51758|       |JSValue JS_GetTypedArrayBuffer(JSContext *ctx, JSValueConst obj,
51759|       |                               size_t *pbyte_offset,
51760|       |                               size_t *pbyte_length,
51761|       |                               size_t *pbytes_per_element)
51762|      0|{
51763|      0|    JSObject *p;
51764|      0|    JSTypedArray *ta;
51765|      0|    p = get_typed_array(ctx, obj, FALSE);
51766|      0|    if (!p)
51767|      0|        return JS_EXCEPTION;
51768|      0|    if (typed_array_is_detached(ctx, p))
51769|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51770|      0|    ta = p->u.typed_array;
51771|      0|    if (pbyte_offset)
51772|      0|        *pbyte_offset = ta->offset;
51773|      0|    if (pbyte_length)
51774|      0|        *pbyte_length = ta->length;
51775|      0|    if (pbytes_per_element) {
51776|      0|        *pbytes_per_element = 1 << typed_array_size_log2(p->class_id);
51777|      0|    }
51778|      0|    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));
51779|      0|}
51780|       |
51781|       |static JSValue js_typed_array_get_toStringTag(JSContext *ctx,
51782|       |                                              JSValueConst this_val)
51783|      0|{
51784|      0|    JSObject *p;
51785|      0|    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
51786|      0|        return JS_UNDEFINED;
51787|      0|    p = JS_VALUE_GET_OBJ(this_val);
51788|      0|    if (!(p->class_id >= JS_CLASS_UINT8C_ARRAY &&
51789|      0|          p->class_id <= JS_CLASS_FLOAT64_ARRAY))
51790|      0|        return JS_UNDEFINED;
51791|      0|    return JS_AtomToString(ctx, ctx->rt->class_array[p->class_id].class_name);
51792|      0|}
51793|       |
51794|       |static JSValue js_typed_array_set_internal(JSContext *ctx,
51795|       |                                           JSValueConst dst,
51796|       |                                           JSValueConst src,
51797|       |                                           JSValueConst off)
51798|      0|{
51799|      0|    JSObject *p;
51800|      0|    JSObject *src_p;
51801|      0|    uint32_t i;
51802|      0|    int64_t src_len, offset;
51803|      0|    JSValue val, src_obj = JS_UNDEFINED;
51804|       |
51805|      0|    p = get_typed_array(ctx, dst, 0);
51806|      0|    if (!p)
51807|      0|        goto fail;
51808|      0|    if (JS_ToInt64Sat(ctx, &offset, off))
51809|      0|        goto fail;
51810|      0|    if (offset < 0)
51811|      0|        goto range_error;
51812|      0|    if (typed_array_is_detached(ctx, p)) {
51813|      0|    detached:
51814|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51815|      0|        goto fail;
51816|      0|    }
51817|      0|    src_obj = JS_ToObject(ctx, src);
51818|      0|    if (JS_IsException(src_obj))
51819|      0|        goto fail;
51820|      0|    src_p = JS_VALUE_GET_OBJ(src_obj);
51821|      0|    if (src_p->class_id >= JS_CLASS_UINT8C_ARRAY &&
51822|      0|        src_p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
51823|      0|        JSTypedArray *dest_ta = p->u.typed_array;
51824|      0|        JSArrayBuffer *dest_abuf = dest_ta->buffer->u.array_buffer;
51825|      0|        JSTypedArray *src_ta = src_p->u.typed_array;
51826|      0|        JSArrayBuffer *src_abuf = src_ta->buffer->u.array_buffer;
51827|      0|        int shift = typed_array_size_log2(p->class_id);
51828|       |
51829|      0|        if (src_abuf->detached)
51830|      0|            goto detached;
51831|       |
51832|      0|        src_len = src_p->u.array.count;
51833|      0|        if (offset > (int64_t)(p->u.array.count - src_len))
51834|      0|            goto range_error;
51835|       |
51836|       |        /* copying between typed objects */
51837|      0|        if (src_p->class_id == p->class_id) {
51838|       |            /* same type, use memmove */
51839|      0|            memmove(dest_abuf->data + dest_ta->offset + (offset << shift),
51840|      0|                    src_abuf->data + src_ta->offset, src_len << shift);
51841|      0|            goto done;
51842|      0|        }
51843|      0|        if (dest_abuf->data == src_abuf->data) {
51844|       |            /* copying between the same buffer using different types of mappings
51845|       |               would require a temporary buffer */
51846|      0|        }
51847|       |        /* otherwise, default behavior is slow but correct */
51848|      0|    } else {
51849|      0|        if (js_get_length64(ctx, &src_len, src_obj))
51850|      0|            goto fail;
51851|      0|        if (offset > (int64_t)(p->u.array.count - src_len)) {
51852|      0|        range_error:
51853|      0|            JS_ThrowRangeError(ctx, "invalid array length");
51854|      0|            goto fail;
51855|      0|        }
51856|      0|    }
51857|      0|    for(i = 0; i < src_len; i++) {
51858|      0|        val = JS_GetPropertyUint32(ctx, src_obj, i);
51859|      0|        if (JS_IsException(val))
51860|      0|            goto fail;
51861|      0|        if (JS_SetPropertyUint32(ctx, dst, offset + i, val) < 0)
51862|      0|            goto fail;
51863|      0|    }
51864|      0|done:
51865|      0|    JS_FreeValue(ctx, src_obj);
51866|      0|    return JS_UNDEFINED;
51867|      0|fail:
51868|      0|    JS_FreeValue(ctx, src_obj);
51869|      0|    return JS_EXCEPTION;
51870|      0|}
51871|       |
51872|       |static JSValue js_typed_array_at(JSContext *ctx, JSValueConst this_val,
51873|       |                                 int argc, JSValueConst *argv)
51874|      0|{
51875|      0|    JSObject *p;
51876|      0|    int64_t idx, len;
51877|       |
51878|      0|    p = get_typed_array(ctx, this_val, 0);
51879|      0|    if (!p)
51880|      0|        return JS_EXCEPTION;
51881|       |
51882|      0|    if (typed_array_is_detached(ctx, p)) {
51883|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51884|      0|        return JS_EXCEPTION;
51885|      0|    }
51886|       |
51887|      0|    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
51888|      0|        return JS_EXCEPTION;
51889|       |
51890|      0|    len = p->u.array.count;
51891|      0|    if (idx < 0)
51892|      0|        idx = len + idx;
51893|      0|    if (idx < 0 || idx >= len)
51894|      0|        return JS_UNDEFINED;
51895|      0|    return JS_GetPropertyInt64(ctx, this_val, idx);
51896|      0|}
51897|       |
51898|       |static JSValue js_typed_array_with(JSContext *ctx, JSValueConst this_val,
51899|       |                                   int argc, JSValueConst *argv)
51900|      0|{
51901|      0|    JSValue arr, val;
51902|      0|    JSObject *p;
51903|      0|    int64_t idx, len;
51904|       |
51905|      0|    p = get_typed_array(ctx, this_val, /*is_dataview*/0);
51906|      0|    if (!p)
51907|      0|        return JS_EXCEPTION;
51908|       |
51909|      0|    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
51910|      0|        return JS_EXCEPTION;
51911|       |
51912|      0|    len = p->u.array.count;
51913|      0|    if (idx < 0)
51914|      0|        idx = len + idx;
51915|      0|    if (idx < 0 || idx >= len)
51916|      0|        return JS_ThrowRangeError(ctx, "invalid array index");
51917|       |
51918|      0|    val = JS_ToPrimitive(ctx, argv[1], HINT_NUMBER);
51919|      0|    if (JS_IsException(val))
51920|      0|        return JS_EXCEPTION;
51921|       |
51922|      0|    arr = js_typed_array_constructor_ta(ctx, JS_UNDEFINED, this_val,
51923|      0|                                        p->class_id);
51924|      0|    if (JS_IsException(arr)) {
51925|      0|        JS_FreeValue(ctx, val);
51926|      0|        return JS_EXCEPTION;
51927|      0|    }
51928|      0|    if (JS_SetPropertyInt64(ctx, arr, idx, val) < 0) {
51929|      0|        JS_FreeValue(ctx, arr);
51930|      0|        return JS_EXCEPTION;
51931|      0|    }
51932|      0|    return arr;
51933|      0|}
51934|       |
51935|       |static JSValue js_typed_array_set(JSContext *ctx,
51936|       |                                  JSValueConst this_val,
51937|       |                                  int argc, JSValueConst *argv)
51938|      0|{
51939|      0|    JSValueConst offset = JS_UNDEFINED;
51940|      0|    if (argc > 1) {
51941|      0|        offset = argv[1];
51942|      0|    }
51943|      0|    return js_typed_array_set_internal(ctx, this_val, argv[0], offset);
51944|      0|}
51945|       |
51946|       |static JSValue js_create_typed_array_iterator(JSContext *ctx, JSValueConst this_val,
51947|       |                                              int argc, JSValueConst *argv, int magic)
51948|      0|{
51949|      0|    if (validate_typed_array(ctx, this_val))
51950|      0|        return JS_EXCEPTION;
51951|      0|    return js_create_array_iterator(ctx, this_val, argc, argv, magic);
51952|      0|}
51953|       |
51954|       |/* return < 0 if exception */
51955|       |static int js_typed_array_get_length_internal(JSContext *ctx,
51956|       |                                              JSValueConst obj)
51957|      0|{
51958|      0|    JSObject *p;
51959|      0|    p = get_typed_array(ctx, obj, 0);
51960|      0|    if (!p)
51961|      0|        return -1;
51962|      0|    if (typed_array_is_detached(ctx, p)) {
51963|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
51964|      0|        return -1;
51965|      0|    }
51966|      0|    return p->u.array.count;
51967|      0|}
51968|       |
51969|       |#if 0
51970|       |/* validate a typed array and return its length */
51971|       |static JSValue js_typed_array___getLength(JSContext *ctx,
51972|       |                                          JSValueConst this_val,
51973|       |                                          int argc, JSValueConst *argv)
51974|       |{
51975|       |    BOOL ignore_detached = JS_ToBool(ctx, argv[1]);
51976|       |
51977|       |    if (ignore_detached) {
51978|       |        return js_typed_array_get_length(ctx, argv[0]);
51979|       |    } else {
51980|       |        int len;
51981|       |        len = js_typed_array_get_length_internal(ctx, argv[0]);
51982|       |        if (len < 0)
51983|       |            return JS_EXCEPTION;
51984|       |        return JS_NewInt32(ctx, len);
51985|       |    }
51986|       |}
51987|       |#endif
51988|       |
51989|       |static JSValue js_typed_array_create(JSContext *ctx, JSValueConst ctor,
51990|       |                                     int argc, JSValueConst *argv)
51991|      0|{
51992|      0|    JSValue ret;
51993|      0|    int new_len;
51994|      0|    int64_t len;
51995|       |
51996|      0|    ret = JS_CallConstructor(ctx, ctor, argc, argv);
51997|      0|    if (JS_IsException(ret))
51998|      0|        return ret;
51999|       |    /* validate the typed array */
52000|      0|    new_len = js_typed_array_get_length_internal(ctx, ret);
52001|      0|    if (new_len < 0)
52002|      0|        goto fail;
52003|      0|    if (argc == 1) {
52004|       |        /* ensure that it is large enough */
52005|      0|        if (JS_ToLengthFree(ctx, &len, JS_DupValue(ctx, argv[0])))
52006|      0|            goto fail;
52007|      0|        if (new_len < len) {
52008|      0|            JS_ThrowTypeError(ctx, "TypedArray length is too small");
52009|      0|        fail:
52010|      0|            JS_FreeValue(ctx, ret);
52011|      0|            return JS_EXCEPTION;
52012|      0|        }
52013|      0|    }
52014|      0|    return ret;
52015|      0|}
52016|       |
52017|       |#if 0
52018|       |static JSValue js_typed_array___create(JSContext *ctx,
52019|       |                                       JSValueConst this_val,
52020|       |                                       int argc, JSValueConst *argv)
52021|       |{
52022|       |    return js_typed_array_create(ctx, argv[0], max_int(argc - 1, 0), argv + 1);
52023|       |}
52024|       |#endif
52025|       |
52026|       |static JSValue js_typed_array___speciesCreate(JSContext *ctx,
52027|       |                                              JSValueConst this_val,
52028|       |                                              int argc, JSValueConst *argv)
52029|      0|{
52030|      0|    JSValueConst obj;
52031|      0|    JSObject *p;
52032|      0|    JSValue ctor, ret;
52033|      0|    int argc1;
52034|       |
52035|      0|    obj = argv[0];
52036|      0|    p = get_typed_array(ctx, obj, 0);
52037|      0|    if (!p)
52038|      0|        return JS_EXCEPTION;
52039|      0|    ctor = JS_SpeciesConstructor(ctx, obj, JS_UNDEFINED);
52040|      0|    if (JS_IsException(ctor))
52041|      0|        return ctor;
52042|      0|    argc1 = max_int(argc - 1, 0);
52043|      0|    if (JS_IsUndefined(ctor)) {
52044|      0|        ret = js_typed_array_constructor(ctx, JS_UNDEFINED, argc1, argv + 1,
52045|      0|                                         p->class_id);
52046|      0|    } else {
52047|      0|        ret = js_typed_array_create(ctx, ctor, argc1, argv + 1);
52048|      0|        JS_FreeValue(ctx, ctor);
52049|      0|    }
52050|      0|    return ret;
52051|      0|}
52052|       |
52053|       |static JSValue js_typed_array_from(JSContext *ctx, JSValueConst this_val,
52054|       |                                   int argc, JSValueConst *argv)
52055|      0|{
52056|       |    // from(items, mapfn = void 0, this_arg = void 0)
52057|      0|    JSValueConst items = argv[0], mapfn, this_arg;
52058|      0|    JSValueConst args[2];
52059|      0|    JSValue stack[2];
52060|      0|    JSValue iter, arr, r, v, v2;
52061|      0|    int64_t k, len;
52062|      0|    int done, mapping;
52063|       |
52064|      0|    mapping = FALSE;
52065|      0|    mapfn = JS_UNDEFINED;
52066|      0|    this_arg = JS_UNDEFINED;
52067|      0|    r = JS_UNDEFINED;
52068|      0|    arr = JS_UNDEFINED;
52069|      0|    stack[0] = JS_UNDEFINED;
52070|      0|    stack[1] = JS_UNDEFINED;
52071|       |
52072|      0|    if (argc > 1) {
52073|      0|        mapfn = argv[1];
52074|      0|        if (!JS_IsUndefined(mapfn)) {
52075|      0|            if (check_function(ctx, mapfn))
52076|      0|                goto exception;
52077|      0|            mapping = 1;
52078|      0|            if (argc > 2)
52079|      0|                this_arg = argv[2];
52080|      0|        }
52081|      0|    }
52082|      0|    iter = JS_GetProperty(ctx, items, JS_ATOM_Symbol_iterator);
52083|      0|    if (JS_IsException(iter))
52084|      0|        goto exception;
52085|      0|    if (!JS_IsUndefined(iter)) {
52086|      0|        JS_FreeValue(ctx, iter);
52087|      0|        arr = JS_NewArray(ctx);
52088|      0|        if (JS_IsException(arr))
52089|      0|            goto exception;
52090|      0|        stack[0] = JS_DupValue(ctx, items);
52091|      0|        if (js_for_of_start(ctx, &stack[1], FALSE))
52092|      0|            goto exception;
52093|      0|        for (k = 0;; k++) {
52094|      0|            v = JS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);
52095|      0|            if (JS_IsException(v))
52096|      0|                goto exception_close;
52097|      0|            if (done)
52098|      0|                break;
52099|      0|            if (JS_DefinePropertyValueInt64(ctx, arr, k, v, JS_PROP_C_W_E | JS_PROP_THROW) < 0)
52100|      0|                goto exception_close;
52101|      0|        }
52102|      0|    } else {
52103|      0|        arr = JS_ToObject(ctx, items);
52104|      0|        if (JS_IsException(arr))
52105|      0|            goto exception;
52106|      0|    }
52107|      0|    if (js_get_length64(ctx, &len, arr) < 0)
52108|      0|        goto exception;
52109|      0|    v = JS_NewInt64(ctx, len);
52110|      0|    args[0] = v;
52111|      0|    r = js_typed_array_create(ctx, this_val, 1, args);
52112|      0|    JS_FreeValue(ctx, v);
52113|      0|    if (JS_IsException(r))
52114|      0|        goto exception;
52115|      0|    for(k = 0; k < len; k++) {
52116|      0|        v = JS_GetPropertyInt64(ctx, arr, k);
52117|      0|        if (JS_IsException(v))
52118|      0|            goto exception;
52119|      0|        if (mapping) {
52120|      0|            args[0] = v;
52121|      0|            args[1] = JS_NewInt32(ctx, k);
52122|      0|            v2 = JS_Call(ctx, mapfn, this_arg, 2, args);
52123|      0|            JS_FreeValue(ctx, v);
52124|      0|            v = v2;
52125|      0|            if (JS_IsException(v))
52126|      0|                goto exception;
52127|      0|        }
52128|      0|        if (JS_SetPropertyInt64(ctx, r, k, v) < 0)
52129|      0|            goto exception;
52130|      0|    }
52131|      0|    goto done;
52132|       |
52133|      0| exception_close:
52134|      0|    if (!JS_IsUndefined(stack[0]))
52135|      0|        JS_IteratorClose(ctx, stack[0], TRUE);
52136|      0| exception:
52137|      0|    JS_FreeValue(ctx, r);
52138|      0|    r = JS_EXCEPTION;
52139|      0| done:
52140|      0|    JS_FreeValue(ctx, arr);
52141|      0|    JS_FreeValue(ctx, stack[0]);
52142|      0|    JS_FreeValue(ctx, stack[1]);
52143|      0|    return r;
52144|      0|}
52145|       |
52146|       |static JSValue js_typed_array_of(JSContext *ctx, JSValueConst this_val,
52147|       |                                 int argc, JSValueConst *argv)
52148|      0|{
52149|      0|    JSValue obj;
52150|      0|    JSValueConst args[1];
52151|      0|    int i;
52152|       |
52153|      0|    args[0] = JS_NewInt32(ctx, argc);
52154|      0|    obj = js_typed_array_create(ctx, this_val, 1, args);
52155|      0|    if (JS_IsException(obj))
52156|      0|        return obj;
52157|       |
52158|      0|    for(i = 0; i < argc; i++) {
52159|      0|        if (JS_SetPropertyUint32(ctx, obj, i, JS_DupValue(ctx, argv[i])) < 0) {
52160|      0|            JS_FreeValue(ctx, obj);
52161|      0|            return JS_EXCEPTION;
52162|      0|        }
52163|      0|    }
52164|      0|    return obj;
52165|      0|}
52166|       |
52167|       |static JSValue js_typed_array_copyWithin(JSContext *ctx, JSValueConst this_val,
52168|       |                                         int argc, JSValueConst *argv)
52169|      0|{
52170|      0|    JSObject *p;
52171|      0|    int len, to, from, final, count, shift;
52172|       |
52173|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
52174|      0|    if (len < 0)
52175|      0|        return JS_EXCEPTION;
52176|       |
52177|      0|    if (JS_ToInt32Clamp(ctx, &to, argv[0], 0, len, len))
52178|      0|        return JS_EXCEPTION;
52179|       |
52180|      0|    if (JS_ToInt32Clamp(ctx, &from, argv[1], 0, len, len))
52181|      0|        return JS_EXCEPTION;
52182|       |
52183|      0|    final = len;
52184|      0|    if (argc > 2 && !JS_IsUndefined(argv[2])) {
52185|      0|        if (JS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))
52186|      0|            return JS_EXCEPTION;
52187|      0|    }
52188|       |
52189|      0|    count = min_int(final - from, len - to);
52190|      0|    if (count > 0) {
52191|      0|        p = JS_VALUE_GET_OBJ(this_val);
52192|      0|        if (typed_array_is_detached(ctx, p))
52193|      0|            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
52194|      0|        shift = typed_array_size_log2(p->class_id);
52195|      0|        memmove(p->u.array.u.uint8_ptr + (to << shift),
52196|      0|                p->u.array.u.uint8_ptr + (from << shift),
52197|      0|                count << shift);
52198|      0|    }
52199|      0|    return JS_DupValue(ctx, this_val);
52200|      0|}
52201|       |
52202|       |static JSValue js_typed_array_fill(JSContext *ctx, JSValueConst this_val,
52203|       |                                   int argc, JSValueConst *argv)
52204|      0|{
52205|      0|    JSObject *p;
52206|      0|    int len, k, final, shift;
52207|      0|    uint64_t v64;
52208|       |
52209|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
52210|      0|    if (len < 0)
52211|      0|        return JS_EXCEPTION;
52212|      0|    p = JS_VALUE_GET_OBJ(this_val);
52213|       |
52214|      0|    if (p->class_id == JS_CLASS_UINT8C_ARRAY) {
52215|      0|        int32_t v;
52216|      0|        if (JS_ToUint8ClampFree(ctx, &v, JS_DupValue(ctx, argv[0])))
52217|      0|            return JS_EXCEPTION;
52218|      0|        v64 = v;
52219|      0|    } else if (p->class_id <= JS_CLASS_UINT32_ARRAY) {
52220|      0|        uint32_t v;
52221|      0|        if (JS_ToUint32(ctx, &v, argv[0]))
52222|      0|            return JS_EXCEPTION;
52223|      0|        v64 = v;
52224|      0|    } else if (p->class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
52225|      0|        if (JS_ToBigInt64(ctx, (int64_t *)&v64, argv[0]))
52226|      0|            return JS_EXCEPTION;
52227|      0|    } else {
52228|      0|        double d;
52229|      0|        if (JS_ToFloat64(ctx, &d, argv[0]))
52230|      0|            return JS_EXCEPTION;
52231|      0|        if (p->class_id == JS_CLASS_FLOAT32_ARRAY) {
52232|      0|            union {
52233|      0|                float f;
52234|      0|                uint32_t u32;
52235|      0|            } u;
52236|      0|            u.f = d;
52237|      0|            v64 = u.u32;
52238|      0|        } else {
52239|      0|            JSFloat64Union u;
52240|      0|            u.d = d;
52241|      0|            v64 = u.u64;
52242|      0|        }
52243|      0|    }
52244|       |
52245|      0|    k = 0;
52246|      0|    if (argc > 1) {
52247|      0|        if (JS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len))
52248|      0|            return JS_EXCEPTION;
52249|      0|    }
52250|       |
52251|      0|    final = len;
52252|      0|    if (argc > 2 && !JS_IsUndefined(argv[2])) {
52253|      0|        if (JS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))
52254|      0|            return JS_EXCEPTION;
52255|      0|    }
52256|       |
52257|      0|    if (typed_array_is_detached(ctx, p))
52258|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
52259|       |
52260|      0|    shift = typed_array_size_log2(p->class_id);
52261|      0|    switch(shift) {
52262|      0|    case 0:
52263|      0|        if (k < final) {
52264|      0|            memset(p->u.array.u.uint8_ptr + k, v64, final - k);
52265|      0|        }
52266|      0|        break;
52267|      0|    case 1:
52268|      0|        for(; k < final; k++) {
52269|      0|            p->u.array.u.uint16_ptr[k] = v64;
52270|      0|        }
52271|      0|        break;
52272|      0|    case 2:
52273|      0|        for(; k < final; k++) {
52274|      0|            p->u.array.u.uint32_ptr[k] = v64;
52275|      0|        }
52276|      0|        break;
52277|      0|    case 3:
52278|      0|        for(; k < final; k++) {
52279|      0|            p->u.array.u.uint64_ptr[k] = v64;
52280|      0|        }
52281|      0|        break;
52282|      0|    default:
52283|      0|        abort();
52284|      0|    }
52285|      0|    return JS_DupValue(ctx, this_val);
52286|      0|}
52287|       |
52288|       |static JSValue js_typed_array_find(JSContext *ctx, JSValueConst this_val,
52289|       |                                   int argc, JSValueConst *argv, int mode)
52290|      0|{
52291|      0|    JSValueConst func, this_arg;
52292|      0|    JSValueConst args[3];
52293|      0|    JSValue val, index_val, res;
52294|      0|    int len, k, end;
52295|      0|    int dir;
52296|       |
52297|      0|    val = JS_UNDEFINED;
52298|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
52299|      0|    if (len < 0)
52300|      0|        goto exception;
52301|       |
52302|      0|    func = argv[0];
52303|      0|    if (check_function(ctx, func))
52304|      0|        goto exception;
52305|       |
52306|      0|    this_arg = JS_UNDEFINED;
52307|      0|    if (argc > 1)
52308|      0|        this_arg = argv[1];
52309|       |
52310|      0|    k = 0;
52311|      0|    dir = 1;
52312|      0|    end = len;
52313|      0|    if (mode == ArrayFindLast || mode == ArrayFindLastIndex) {
52314|      0|        k = len - 1;
52315|      0|        dir = -1;
52316|      0|        end = -1;
52317|      0|    }
52318|       |
52319|      0|    for(; k != end; k += dir) {
52320|      0|        index_val = JS_NewInt32(ctx, k);
52321|      0|        val = JS_GetPropertyValue(ctx, this_val, index_val);
52322|      0|        if (JS_IsException(val))
52323|      0|            goto exception;
52324|      0|        args[0] = val;
52325|      0|        args[1] = index_val;
52326|      0|        args[2] = this_val;
52327|      0|        res = JS_Call(ctx, func, this_arg, 3, args);
52328|      0|        if (JS_IsException(res))
52329|      0|            goto exception;
52330|      0|        if (JS_ToBoolFree(ctx, res)) {
52331|      0|            if (mode == ArrayFindIndex || mode == ArrayFindLastIndex) {
52332|      0|                JS_FreeValue(ctx, val);
52333|      0|                return index_val;
52334|      0|            } else {
52335|      0|                return val;
52336|      0|            }
52337|      0|        }
52338|      0|        JS_FreeValue(ctx, val);
52339|      0|    }
52340|      0|    if (mode == ArrayFindIndex || mode == ArrayFindLastIndex)
52341|      0|        return JS_NewInt32(ctx, -1);
52342|      0|    else
52343|      0|        return JS_UNDEFINED;
52344|       |
52345|      0|exception:
52346|      0|    JS_FreeValue(ctx, val);
52347|      0|    return JS_EXCEPTION;
52348|      0|}
52349|       |
52350|       |#define special_indexOf 0
52351|      0|#define special_lastIndexOf 1
52352|      0|#define special_includes -1
52353|       |
52354|       |static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
52355|       |                                      int argc, JSValueConst *argv, int special)
52356|      0|{
52357|      0|    JSObject *p;
52358|      0|    int len, tag, is_int, is_bigint, k, stop, inc, res = -1;
52359|      0|    int64_t v64;
52360|      0|    double d;
52361|      0|    float f;
52362|       |
52363|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
52364|      0|    if (len < 0)
52365|      0|        goto exception;
52366|      0|    if (len == 0)
52367|      0|        goto done;
52368|       |
52369|      0|    if (special == special_lastIndexOf) {
52370|      0|        k = len - 1;
52371|      0|        if (argc > 1) {
52372|      0|            if (JS_ToFloat64(ctx, &d, argv[1]))
52373|      0|                goto exception;
52374|      0|            if (isnan(d)) {
52375|      0|                k = 0;
52376|      0|            } else {
52377|      0|                if (d >= 0) {
52378|      0|                    if (d < k) {
52379|      0|                        k = d;
52380|      0|                    }
52381|      0|                } else {
52382|      0|                    d += len;
52383|      0|                    if (d < 0)
52384|      0|                        goto done;
52385|      0|                    k = d;
52386|      0|                }
52387|      0|            }
52388|      0|        }
52389|      0|        stop = -1;
52390|      0|        inc = -1;
52391|      0|    } else {
52392|      0|        k = 0;
52393|      0|        if (argc > 1) {
52394|      0|            if (JS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len))
52395|      0|                goto exception;
52396|      0|        }
52397|      0|        stop = len;
52398|      0|        inc = 1;
52399|      0|    }
52400|       |
52401|      0|    p = JS_VALUE_GET_OBJ(this_val);
52402|       |    /* if the array was detached, no need to go further (but no
52403|       |       exception is raised) */
52404|      0|    if (typed_array_is_detached(ctx, p)) {
52405|       |        /* "includes" scans all the properties, so "undefined" can match */
52406|      0|        if (special == special_includes && JS_IsUndefined(argv[0]) && len > 0)
52407|      0|            res = 0;
52408|      0|        goto done;
52409|      0|    }
52410|       |
52411|      0|    is_bigint = 0;
52412|      0|    is_int = 0; /* avoid warning */
52413|      0|    v64 = 0; /* avoid warning */
52414|      0|    tag = JS_VALUE_GET_NORM_TAG(argv[0]);
52415|      0|    if (tag == JS_TAG_INT) {
52416|      0|        is_int = 1;
52417|      0|        v64 = JS_VALUE_GET_INT(argv[0]);
52418|      0|        d = v64;
52419|      0|    } else
52420|      0|    if (tag == JS_TAG_FLOAT64) {
52421|      0|        d = JS_VALUE_GET_FLOAT64(argv[0]);
52422|      0|        if (d >= INT64_MIN && d < 0x1p63) {
52423|      0|            v64 = d;
52424|      0|            is_int = (v64 == d);
52425|      0|        }
52426|      0|    } else if (tag == JS_TAG_BIG_INT || tag == JS_TAG_SHORT_BIG_INT) {
52427|      0|        JSBigIntBuf buf1;
52428|      0|        JSBigInt *p1;
52429|      0|        int sz = (64 / JS_LIMB_BITS);
52430|      0|        if (tag == JS_TAG_SHORT_BIG_INT)
52431|      0|            p1 = js_bigint_set_short(&buf1, argv[0]);
52432|      0|        else
52433|      0|            p1 = JS_VALUE_GET_PTR(argv[0]);
52434|       |        
52435|      0|        if (p->class_id == JS_CLASS_BIG_INT64_ARRAY) {
52436|      0|            if (p1->len > sz)
52437|      0|                goto done; /* does not fit an int64 : cannot be found */
52438|      0|        } else if (p->class_id == JS_CLASS_BIG_UINT64_ARRAY) {
52439|      0|            if (js_bigint_sign(p1))
52440|      0|                goto done; /* v < 0 */
52441|      0|            if (p1->len <= sz) {
52442|       |                /* OK */
52443|      0|            } else if (p1->len == sz + 1 && p1->tab[sz] == 0) {
52444|       |                /* 2^63 <= v <= 2^64-1 */
52445|      0|            } else {
52446|      0|                goto done;
52447|      0|            }
52448|      0|        } else {
52449|      0|            goto done;
52450|      0|        }
52451|      0|        if (JS_ToBigInt64(ctx, &v64, argv[0]))
52452|      0|            goto exception;
52453|      0|        d = 0;
52454|      0|        is_bigint = 1;
52455|      0|    } else {
52456|      0|        goto done;
52457|      0|    }
52458|       |
52459|      0|    switch (p->class_id) {
52460|      0|    case JS_CLASS_INT8_ARRAY:
52461|      0|        if (is_int && (int8_t)v64 == v64)
52462|      0|            goto scan8;
52463|      0|        break;
52464|      0|    case JS_CLASS_UINT8C_ARRAY:
52465|      0|    case JS_CLASS_UINT8_ARRAY:
52466|      0|        if (is_int && (uint8_t)v64 == v64) {
52467|      0|            const uint8_t *pv, *pp;
52468|      0|            uint16_t v;
52469|      0|        scan8:
52470|      0|            pv = p->u.array.u.uint8_ptr;
52471|      0|            v = v64;
52472|      0|            if (inc > 0) {
52473|      0|                pp = memchr(pv + k, v, len - k);
52474|      0|                if (pp)
52475|      0|                    res = pp - pv;
52476|      0|            } else {
52477|      0|                for (; k != stop; k += inc) {
52478|      0|                    if (pv[k] == v) {
52479|      0|                        res = k;
52480|      0|                        break;
52481|      0|                    }
52482|      0|                }
52483|      0|            }
52484|      0|        }
52485|      0|        break;
52486|      0|    case JS_CLASS_INT16_ARRAY:
52487|      0|        if (is_int && (int16_t)v64 == v64)
52488|      0|            goto scan16;
52489|      0|        break;
52490|      0|    case JS_CLASS_UINT16_ARRAY:
52491|      0|        if (is_int && (uint16_t)v64 == v64) {
52492|      0|            const uint16_t *pv;
52493|      0|            uint16_t v;
52494|      0|        scan16:
52495|      0|            pv = p->u.array.u.uint16_ptr;
52496|      0|            v = v64;
52497|      0|            for (; k != stop; k += inc) {
52498|      0|                if (pv[k] == v) {
52499|      0|                    res = k;
52500|      0|                    break;
52501|      0|                }
52502|      0|            }
52503|      0|        }
52504|      0|        break;
52505|      0|    case JS_CLASS_INT32_ARRAY:
52506|      0|        if (is_int && (int32_t)v64 == v64)
52507|      0|            goto scan32;
52508|      0|        break;
52509|      0|    case JS_CLASS_UINT32_ARRAY:
52510|      0|        if (is_int && (uint32_t)v64 == v64) {
52511|      0|            const uint32_t *pv;
52512|      0|            uint32_t v;
52513|      0|        scan32:
52514|      0|            pv = p->u.array.u.uint32_ptr;
52515|      0|            v = v64;
52516|      0|            for (; k != stop; k += inc) {
52517|      0|                if (pv[k] == v) {
52518|      0|                    res = k;
52519|      0|                    break;
52520|      0|                }
52521|      0|            }
52522|      0|        }
52523|      0|        break;
52524|      0|    case JS_CLASS_FLOAT32_ARRAY:
52525|      0|        if (is_bigint)
52526|      0|            break;
52527|      0|        if (isnan(d)) {
52528|      0|            const float *pv = p->u.array.u.float_ptr;
52529|       |            /* special case: indexOf returns -1, includes finds NaN */
52530|      0|            if (special != special_includes)
52531|      0|                goto done;
52532|      0|            for (; k != stop; k += inc) {
52533|      0|                if (isnan(pv[k])) {
52534|      0|                    res = k;
52535|      0|                    break;
52536|      0|                }
52537|      0|            }
52538|      0|        } else if ((f = (float)d) == d) {
52539|      0|            const float *pv = p->u.array.u.float_ptr;
52540|      0|            for (; k != stop; k += inc) {
52541|      0|                if (pv[k] == f) {
52542|      0|                    res = k;
52543|      0|                    break;
52544|      0|                }
52545|      0|            }
52546|      0|        }
52547|      0|        break;
52548|      0|    case JS_CLASS_FLOAT64_ARRAY:
52549|      0|        if (is_bigint)
52550|      0|            break;
52551|      0|        if (isnan(d)) {
52552|      0|            const double *pv = p->u.array.u.double_ptr;
52553|       |            /* special case: indexOf returns -1, includes finds NaN */
52554|      0|            if (special != special_includes)
52555|      0|                goto done;
52556|      0|            for (; k != stop; k += inc) {
52557|      0|                if (isnan(pv[k])) {
52558|      0|                    res = k;
52559|      0|                    break;
52560|      0|                }
52561|      0|            }
52562|      0|        } else {
52563|      0|            const double *pv = p->u.array.u.double_ptr;
52564|      0|            for (; k != stop; k += inc) {
52565|      0|                if (pv[k] == d) {
52566|      0|                    res = k;
52567|      0|                    break;
52568|      0|                }
52569|      0|            }
52570|      0|        }
52571|      0|        break;
52572|      0|    case JS_CLASS_BIG_INT64_ARRAY:
52573|      0|        if (is_bigint) {
52574|      0|            goto scan64;
52575|      0|        }
52576|      0|        break;
52577|      0|    case JS_CLASS_BIG_UINT64_ARRAY:
52578|      0|        if (is_bigint) {
52579|      0|            const uint64_t *pv;
52580|      0|            uint64_t v;
52581|      0|        scan64:
52582|      0|            pv = p->u.array.u.uint64_ptr;
52583|      0|            v = v64;
52584|      0|            for (; k != stop; k += inc) {
52585|      0|                if (pv[k] == v) {
52586|      0|                    res = k;
52587|      0|                    break;
52588|      0|                }
52589|      0|            }
52590|      0|        }
52591|      0|        break;
52592|      0|    }
52593|       |
52594|      0|done:
52595|      0|    if (special == special_includes)
52596|      0|        return JS_NewBool(ctx, res >= 0);
52597|      0|    else
52598|      0|        return JS_NewInt32(ctx, res);
52599|       |
52600|      0|exception:
52601|      0|    return JS_EXCEPTION;
52602|      0|}
52603|       |
52604|       |static JSValue js_typed_array_join(JSContext *ctx, JSValueConst this_val,
52605|       |                                   int argc, JSValueConst *argv, int toLocaleString)
52606|      0|{
52607|      0|    JSValue sep = JS_UNDEFINED, el;
52608|      0|    StringBuffer b_s, *b = &b_s;
52609|      0|    JSString *p = NULL;
52610|      0|    int i, n;
52611|      0|    int c;
52612|       |
52613|      0|    n = js_typed_array_get_length_internal(ctx, this_val);
52614|      0|    if (n < 0)
52615|      0|        goto exception;
52616|       |
52617|      0|    c = ',';    /* default separator */
52618|      0|    if (!toLocaleString && argc > 0 && !JS_IsUndefined(argv[0])) {
52619|      0|        sep = JS_ToString(ctx, argv[0]);
52620|      0|        if (JS_IsException(sep))
52621|      0|            goto exception;
52622|      0|        p = JS_VALUE_GET_STRING(sep);
52623|      0|        if (p->len == 1 && !p->is_wide_char)
52624|      0|            c = p->u.str8[0];
52625|      0|        else
52626|      0|            c = -1;
52627|      0|    }
52628|      0|    string_buffer_init(ctx, b, 0);
52629|       |
52630|       |    /* XXX: optimize with direct access */
52631|      0|    for(i = 0; i < n; i++) {
52632|      0|        if (i > 0) {
52633|      0|            if (c >= 0) {
52634|      0|                if (string_buffer_putc8(b, c))
52635|      0|                    goto fail;
52636|      0|            } else {
52637|      0|                if (string_buffer_concat(b, p, 0, p->len))
52638|      0|                    goto fail;
52639|      0|            }
52640|      0|        }
52641|      0|        el = JS_GetPropertyUint32(ctx, this_val, i);
52642|       |        /* Can return undefined for example if the typed array is detached */
52643|      0|        if (!JS_IsNull(el) && !JS_IsUndefined(el)) {
52644|      0|            if (JS_IsException(el))
52645|      0|                goto fail;
52646|      0|            if (toLocaleString) {
52647|      0|                el = JS_ToLocaleStringFree(ctx, el);
52648|      0|            }
52649|      0|            if (string_buffer_concat_value_free(b, el))
52650|      0|                goto fail;
52651|      0|        }
52652|      0|    }
52653|      0|    JS_FreeValue(ctx, sep);
52654|      0|    return string_buffer_end(b);
52655|       |
52656|      0|fail:
52657|      0|    string_buffer_free(b);
52658|      0|    JS_FreeValue(ctx, sep);
52659|      0|exception:
52660|      0|    return JS_EXCEPTION;
52661|      0|}
52662|       |
52663|       |static JSValue js_typed_array_reverse(JSContext *ctx, JSValueConst this_val,
52664|       |                                      int argc, JSValueConst *argv)
52665|      0|{
52666|      0|    JSObject *p;
52667|      0|    int len;
52668|       |
52669|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
52670|      0|    if (len < 0)
52671|      0|        return JS_EXCEPTION;
52672|      0|    if (len > 0) {
52673|      0|        p = JS_VALUE_GET_OBJ(this_val);
52674|      0|        switch (typed_array_size_log2(p->class_id)) {
52675|      0|        case 0:
52676|      0|            {
52677|      0|                uint8_t *p1 = p->u.array.u.uint8_ptr;
52678|      0|                uint8_t *p2 = p1 + len - 1;
52679|      0|                while (p1 < p2) {
52680|      0|                    uint8_t v = *p1;
52681|      0|                    *p1++ = *p2;
52682|      0|                    *p2-- = v;
52683|      0|                }
52684|      0|            }
52685|      0|            break;
52686|      0|        case 1:
52687|      0|            {
52688|      0|                uint16_t *p1 = p->u.array.u.uint16_ptr;
52689|      0|                uint16_t *p2 = p1 + len - 1;
52690|      0|                while (p1 < p2) {
52691|      0|                    uint16_t v = *p1;
52692|      0|                    *p1++ = *p2;
52693|      0|                    *p2-- = v;
52694|      0|                }
52695|      0|            }
52696|      0|            break;
52697|      0|        case 2:
52698|      0|            {
52699|      0|                uint32_t *p1 = p->u.array.u.uint32_ptr;
52700|      0|                uint32_t *p2 = p1 + len - 1;
52701|      0|                while (p1 < p2) {
52702|      0|                    uint32_t v = *p1;
52703|      0|                    *p1++ = *p2;
52704|      0|                    *p2-- = v;
52705|      0|                }
52706|      0|            }
52707|      0|            break;
52708|      0|        case 3:
52709|      0|            {
52710|      0|                uint64_t *p1 = p->u.array.u.uint64_ptr;
52711|      0|                uint64_t *p2 = p1 + len - 1;
52712|      0|                while (p1 < p2) {
52713|      0|                    uint64_t v = *p1;
52714|      0|                    *p1++ = *p2;
52715|      0|                    *p2-- = v;
52716|      0|                }
52717|      0|            }
52718|      0|            break;
52719|      0|        default:
52720|      0|            abort();
52721|      0|        }
52722|      0|    }
52723|      0|    return JS_DupValue(ctx, this_val);
52724|      0|}
52725|       |
52726|       |static JSValue js_typed_array_toReversed(JSContext *ctx, JSValueConst this_val,
52727|       |                                         int argc, JSValueConst *argv)
52728|      0|{
52729|      0|    JSValue arr, ret;
52730|      0|    JSObject *p;
52731|       |
52732|      0|    p = get_typed_array(ctx, this_val, /*is_dataview*/0);
52733|      0|    if (!p)
52734|      0|        return JS_EXCEPTION;
52735|      0|    arr = js_typed_array_constructor_ta(ctx, JS_UNDEFINED, this_val,
52736|      0|                                        p->class_id);
52737|      0|    if (JS_IsException(arr))
52738|      0|        return JS_EXCEPTION;
52739|      0|    ret = js_typed_array_reverse(ctx, arr, argc, argv);
52740|      0|    JS_FreeValue(ctx, arr);
52741|      0|    return ret;
52742|      0|}
52743|       |
52744|       |static JSValue js_typed_array_slice(JSContext *ctx, JSValueConst this_val,
52745|       |                                    int argc, JSValueConst *argv)
52746|      0|{
52747|      0|    JSValueConst args[2];
52748|      0|    JSValue arr, val;
52749|      0|    JSObject *p, *p1;
52750|      0|    int n, len, start, final, count, shift;
52751|       |
52752|      0|    arr = JS_UNDEFINED;
52753|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
52754|      0|    if (len < 0)
52755|      0|        goto exception;
52756|       |
52757|      0|    if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len))
52758|      0|        goto exception;
52759|      0|    final = len;
52760|      0|    if (!JS_IsUndefined(argv[1])) {
52761|      0|        if (JS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len))
52762|      0|            goto exception;
52763|      0|    }
52764|      0|    count = max_int(final - start, 0);
52765|       |
52766|      0|    p = get_typed_array(ctx, this_val, 0);
52767|      0|    if (p == NULL)
52768|      0|        goto exception;
52769|      0|    shift = typed_array_size_log2(p->class_id);
52770|       |
52771|      0|    args[0] = this_val;
52772|      0|    args[1] = JS_NewInt32(ctx, count);
52773|      0|    arr = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 2, args);
52774|      0|    if (JS_IsException(arr))
52775|      0|        goto exception;
52776|       |
52777|      0|    if (count > 0) {
52778|      0|        if (validate_typed_array(ctx, this_val)
52779|      0|        ||  validate_typed_array(ctx, arr))
52780|      0|            goto exception;
52781|       |
52782|      0|        p1 = get_typed_array(ctx, arr, 0);
52783|      0|        if (p1 != NULL && p->class_id == p1->class_id &&
52784|      0|            typed_array_get_length(ctx, p1) >= count &&
52785|      0|            typed_array_get_length(ctx, p) >= start + count) {
52786|      0|            memcpy(p1->u.array.u.uint8_ptr,
52787|      0|                   p->u.array.u.uint8_ptr + (start << shift),
52788|      0|                   count << shift);
52789|      0|        } else {
52790|      0|            for (n = 0; n < count; n++) {
52791|      0|                val = JS_GetPropertyValue(ctx, this_val, JS_NewInt32(ctx, start + n));
52792|      0|                if (JS_IsException(val))
52793|      0|                    goto exception;
52794|      0|                if (JS_SetPropertyValue(ctx, arr, JS_NewInt32(ctx, n), val,
52795|      0|                                        JS_PROP_THROW) < 0)
52796|      0|                    goto exception;
52797|      0|            }
52798|      0|        }
52799|      0|    }
52800|      0|    return arr;
52801|       |
52802|      0| exception:
52803|      0|    JS_FreeValue(ctx, arr);
52804|      0|    return JS_EXCEPTION;
52805|      0|}
52806|       |
52807|       |static JSValue js_typed_array_subarray(JSContext *ctx, JSValueConst this_val,
52808|       |                                       int argc, JSValueConst *argv)
52809|      0|{
52810|      0|    JSValueConst args[4];
52811|      0|    JSValue arr, byteOffset, ta_buffer;
52812|      0|    JSObject *p;
52813|      0|    int len, start, final, count, shift, offset;
52814|       |
52815|      0|    p = get_typed_array(ctx, this_val, 0);
52816|      0|    if (!p)
52817|      0|        goto exception;
52818|      0|    len = p->u.array.count;
52819|      0|    if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len))
52820|      0|        goto exception;
52821|       |
52822|      0|    final = len;
52823|      0|    if (!JS_IsUndefined(argv[1])) {
52824|      0|        if (JS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len))
52825|      0|            goto exception;
52826|      0|    }
52827|      0|    count = max_int(final - start, 0);
52828|      0|    byteOffset = js_typed_array_get_byteOffset(ctx, this_val, 0);
52829|      0|    if (JS_IsException(byteOffset))
52830|      0|        goto exception;
52831|      0|    shift = typed_array_size_log2(p->class_id);
52832|      0|    offset = JS_VALUE_GET_INT(byteOffset) + (start << shift);
52833|      0|    JS_FreeValue(ctx, byteOffset);
52834|      0|    ta_buffer = js_typed_array_get_buffer(ctx, this_val, 0);
52835|      0|    if (JS_IsException(ta_buffer))
52836|      0|        goto exception;
52837|      0|    args[0] = this_val;
52838|      0|    args[1] = ta_buffer;
52839|      0|    args[2] = JS_NewInt32(ctx, offset);
52840|      0|    args[3] = JS_NewInt32(ctx, count);
52841|      0|    arr = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 4, args);
52842|      0|    JS_FreeValue(ctx, ta_buffer);
52843|      0|    return arr;
52844|       |
52845|      0| exception:
52846|      0|    return JS_EXCEPTION;
52847|      0|}
52848|       |
52849|       |/* TypedArray.prototype.sort */
52850|       |
52851|       |static int js_cmp_doubles(double x, double y)
52852|      0|{
52853|      0|    if (isnan(x))    return isnan(y) ? 0 : +1;
52854|      0|    if (isnan(y))    return -1;
52855|      0|    if (x < y)       return -1;
52856|      0|    if (x > y)       return 1;
52857|      0|    if (x != 0)      return 0;
52858|      0|    if (signbit(x))  return signbit(y) ? 0 : -1;
52859|      0|    else             return signbit(y) ? 1 : 0;
52860|      0|}
52861|       |
52862|      0|static int js_TA_cmp_int8(const void *a, const void *b, void *opaque) {
52863|      0|    return *(const int8_t *)a - *(const int8_t *)b;
52864|      0|}
52865|       |
52866|      0|static int js_TA_cmp_uint8(const void *a, const void *b, void *opaque) {
52867|      0|    return *(const uint8_t *)a - *(const uint8_t *)b;
52868|      0|}
52869|       |
52870|      0|static int js_TA_cmp_int16(const void *a, const void *b, void *opaque) {
52871|      0|    return *(const int16_t *)a - *(const int16_t *)b;
52872|      0|}
52873|       |
52874|      0|static int js_TA_cmp_uint16(const void *a, const void *b, void *opaque) {
52875|      0|    return *(const uint16_t *)a - *(const uint16_t *)b;
52876|      0|}
52877|       |
52878|      0|static int js_TA_cmp_int32(const void *a, const void *b, void *opaque) {
52879|      0|    int32_t x = *(const int32_t *)a;
52880|      0|    int32_t y = *(const int32_t *)b;
52881|      0|    return (y < x) - (y > x);
52882|      0|}
52883|       |
52884|      0|static int js_TA_cmp_uint32(const void *a, const void *b, void *opaque) {
52885|      0|    uint32_t x = *(const uint32_t *)a;
52886|      0|    uint32_t y = *(const uint32_t *)b;
52887|      0|    return (y < x) - (y > x);
52888|      0|}
52889|       |
52890|      0|static int js_TA_cmp_int64(const void *a, const void *b, void *opaque) {
52891|      0|    int64_t x = *(const int64_t *)a;
52892|      0|    int64_t y = *(const int64_t *)b;
52893|      0|    return (y < x) - (y > x);
52894|      0|}
52895|       |
52896|      0|static int js_TA_cmp_uint64(const void *a, const void *b, void *opaque) {
52897|      0|    uint64_t x = *(const uint64_t *)a;
52898|      0|    uint64_t y = *(const uint64_t *)b;
52899|      0|    return (y < x) - (y > x);
52900|      0|}
52901|       |
52902|      0|static int js_TA_cmp_float32(const void *a, const void *b, void *opaque) {
52903|      0|    return js_cmp_doubles(*(const float *)a, *(const float *)b);
52904|      0|}
52905|       |
52906|      0|static int js_TA_cmp_float64(const void *a, const void *b, void *opaque) {
52907|      0|    return js_cmp_doubles(*(const double *)a, *(const double *)b);
52908|      0|}
52909|       |
52910|      0|static JSValue js_TA_get_int8(JSContext *ctx, const void *a) {
52911|      0|    return JS_NewInt32(ctx, *(const int8_t *)a);
52912|      0|}
52913|       |
52914|      0|static JSValue js_TA_get_uint8(JSContext *ctx, const void *a) {
52915|      0|    return JS_NewInt32(ctx, *(const uint8_t *)a);
52916|      0|}
52917|       |
52918|      0|static JSValue js_TA_get_int16(JSContext *ctx, const void *a) {
52919|      0|    return JS_NewInt32(ctx, *(const int16_t *)a);
52920|      0|}
52921|       |
52922|      0|static JSValue js_TA_get_uint16(JSContext *ctx, const void *a) {
52923|      0|    return JS_NewInt32(ctx, *(const uint16_t *)a);
52924|      0|}
52925|       |
52926|      0|static JSValue js_TA_get_int32(JSContext *ctx, const void *a) {
52927|      0|    return JS_NewInt32(ctx, *(const int32_t *)a);
52928|      0|}
52929|       |
52930|      0|static JSValue js_TA_get_uint32(JSContext *ctx, const void *a) {
52931|      0|    return JS_NewUint32(ctx, *(const uint32_t *)a);
52932|      0|}
52933|       |
52934|      0|static JSValue js_TA_get_int64(JSContext *ctx, const void *a) {
52935|      0|    return JS_NewBigInt64(ctx, *(int64_t *)a);
52936|      0|}
52937|       |
52938|      0|static JSValue js_TA_get_uint64(JSContext *ctx, const void *a) {
52939|      0|    return JS_NewBigUint64(ctx, *(uint64_t *)a);
52940|      0|}
52941|       |
52942|      0|static JSValue js_TA_get_float32(JSContext *ctx, const void *a) {
52943|      0|    return __JS_NewFloat64(ctx, *(const float *)a);
52944|      0|}
52945|       |
52946|      0|static JSValue js_TA_get_float64(JSContext *ctx, const void *a) {
52947|      0|    return __JS_NewFloat64(ctx, *(const double *)a);
52948|      0|}
52949|       |
52950|       |struct TA_sort_context {
52951|       |    JSContext *ctx;
52952|       |    int exception; /* 1 = exception, 2 = detached typed array */
52953|       |    JSValueConst arr;
52954|       |    JSValueConst cmp;
52955|       |    JSValue (*getfun)(JSContext *ctx, const void *a);
52956|       |    uint8_t *array_ptr; /* cannot change unless the array is detached */
52957|       |    int elt_size;
52958|       |};
52959|       |
52960|      0|static int js_TA_cmp_generic(const void *a, const void *b, void *opaque) {
52961|      0|    struct TA_sort_context *psc = opaque;
52962|      0|    JSContext *ctx = psc->ctx;
52963|      0|    uint32_t a_idx, b_idx;
52964|      0|    JSValueConst argv[2];
52965|      0|    JSValue res;
52966|      0|    int cmp;
52967|       |
52968|      0|    cmp = 0;
52969|      0|    if (!psc->exception) {
52970|       |        /* Note: the typed array can be detached without causing an
52971|       |           error */
52972|      0|        a_idx = *(uint32_t *)a;
52973|      0|        b_idx = *(uint32_t *)b;
52974|      0|        argv[0] = psc->getfun(ctx, psc->array_ptr +
52975|      0|                              a_idx * (size_t)psc->elt_size);
52976|      0|        argv[1] = psc->getfun(ctx, psc->array_ptr +
52977|      0|                              b_idx * (size_t)(psc->elt_size));
52978|      0|        res = JS_Call(ctx, psc->cmp, JS_UNDEFINED, 2, argv);
52979|      0|        if (JS_IsException(res)) {
52980|      0|            psc->exception = 1;
52981|      0|            goto done;
52982|      0|        }
52983|      0|        if (JS_VALUE_GET_TAG(res) == JS_TAG_INT) {
52984|      0|            int val = JS_VALUE_GET_INT(res);
52985|      0|            cmp = (val > 0) - (val < 0);
52986|      0|        } else {
52987|      0|            double val;
52988|      0|            if (JS_ToFloat64Free(ctx, &val, res) < 0) {
52989|      0|                psc->exception = 1;
52990|      0|                goto done;
52991|      0|            } else {
52992|      0|                cmp = (val > 0) - (val < 0);
52993|      0|            }
52994|      0|        }
52995|      0|        if (cmp == 0) {
52996|       |            /* make sort stable: compare array offsets */
52997|      0|            cmp = (a_idx > b_idx) - (a_idx < b_idx);
52998|      0|        }
52999|      0|        if (unlikely(typed_array_is_detached(ctx,
53000|      0|                                             JS_VALUE_GET_PTR(psc->arr)))) {
53001|      0|            psc->exception = 2;
53002|      0|        }
53003|      0|    done:
53004|      0|        JS_FreeValue(ctx, (JSValue)argv[0]);
53005|      0|        JS_FreeValue(ctx, (JSValue)argv[1]);
53006|      0|    }
53007|      0|    return cmp;
53008|      0|}
53009|       |
53010|       |static JSValue js_typed_array_sort(JSContext *ctx, JSValueConst this_val,
53011|       |                                   int argc, JSValueConst *argv)
53012|      0|{
53013|      0|    JSObject *p;
53014|      0|    int len;
53015|      0|    size_t elt_size;
53016|      0|    struct TA_sort_context tsc;
53017|      0|    void *array_ptr;
53018|      0|    int (*cmpfun)(const void *a, const void *b, void *opaque);
53019|       |
53020|      0|    tsc.ctx = ctx;
53021|      0|    tsc.exception = 0;
53022|      0|    tsc.arr = this_val;
53023|      0|    tsc.cmp = argv[0];
53024|       |
53025|      0|    if (!JS_IsUndefined(tsc.cmp) && check_function(ctx, tsc.cmp))
53026|      0|        return JS_EXCEPTION;
53027|      0|    len = js_typed_array_get_length_internal(ctx, this_val);
53028|      0|    if (len < 0)
53029|      0|        return JS_EXCEPTION;
53030|       |
53031|      0|    if (len > 1) {
53032|      0|        p = JS_VALUE_GET_OBJ(this_val);
53033|      0|        switch (p->class_id) {
53034|      0|        case JS_CLASS_INT8_ARRAY:
53035|      0|            tsc.getfun = js_TA_get_int8;
53036|      0|            cmpfun = js_TA_cmp_int8;
53037|      0|            break;
53038|      0|        case JS_CLASS_UINT8C_ARRAY:
53039|      0|        case JS_CLASS_UINT8_ARRAY:
53040|      0|            tsc.getfun = js_TA_get_uint8;
53041|      0|            cmpfun = js_TA_cmp_uint8;
53042|      0|            break;
53043|      0|        case JS_CLASS_INT16_ARRAY:
53044|      0|            tsc.getfun = js_TA_get_int16;
53045|      0|            cmpfun = js_TA_cmp_int16;
53046|      0|            break;
53047|      0|        case JS_CLASS_UINT16_ARRAY:
53048|      0|            tsc.getfun = js_TA_get_uint16;
53049|      0|            cmpfun = js_TA_cmp_uint16;
53050|      0|            break;
53051|      0|        case JS_CLASS_INT32_ARRAY:
53052|      0|            tsc.getfun = js_TA_get_int32;
53053|      0|            cmpfun = js_TA_cmp_int32;
53054|      0|            break;
53055|      0|        case JS_CLASS_UINT32_ARRAY:
53056|      0|            tsc.getfun = js_TA_get_uint32;
53057|      0|            cmpfun = js_TA_cmp_uint32;
53058|      0|            break;
53059|      0|        case JS_CLASS_BIG_INT64_ARRAY:
53060|      0|            tsc.getfun = js_TA_get_int64;
53061|      0|            cmpfun = js_TA_cmp_int64;
53062|      0|            break;
53063|      0|        case JS_CLASS_BIG_UINT64_ARRAY:
53064|      0|            tsc.getfun = js_TA_get_uint64;
53065|      0|            cmpfun = js_TA_cmp_uint64;
53066|      0|            break;
53067|      0|        case JS_CLASS_FLOAT32_ARRAY:
53068|      0|            tsc.getfun = js_TA_get_float32;
53069|      0|            cmpfun = js_TA_cmp_float32;
53070|      0|            break;
53071|      0|        case JS_CLASS_FLOAT64_ARRAY:
53072|      0|            tsc.getfun = js_TA_get_float64;
53073|      0|            cmpfun = js_TA_cmp_float64;
53074|      0|            break;
53075|      0|        default:
53076|      0|            abort();
53077|      0|        }
53078|      0|        array_ptr = p->u.array.u.ptr;
53079|      0|        elt_size = 1 << typed_array_size_log2(p->class_id);
53080|      0|        if (!JS_IsUndefined(tsc.cmp)) {
53081|      0|            uint32_t *array_idx;
53082|      0|            void *array_tmp;
53083|      0|            size_t i, j;
53084|       |
53085|       |            /* XXX: a stable sort would use less memory */
53086|      0|            array_idx = js_malloc(ctx, len * sizeof(array_idx[0]));
53087|      0|            if (!array_idx)
53088|      0|                return JS_EXCEPTION;
53089|      0|            for(i = 0; i < len; i++)
53090|      0|                array_idx[i] = i;
53091|      0|            tsc.array_ptr = array_ptr;
53092|      0|            tsc.elt_size = elt_size;
53093|      0|            rqsort(array_idx, len, sizeof(array_idx[0]),
53094|      0|                   js_TA_cmp_generic, &tsc);
53095|      0|            if (tsc.exception) {
53096|      0|                if (tsc.exception == 1)
53097|      0|                    goto fail;
53098|       |                /* detached typed array during the sort: no error */
53099|      0|            } else {
53100|      0|                array_tmp = js_malloc(ctx, len * elt_size);
53101|      0|                if (!array_tmp) {
53102|      0|                fail:
53103|      0|                    js_free(ctx, array_idx);
53104|      0|                    return JS_EXCEPTION;
53105|      0|                }
53106|      0|                memcpy(array_tmp, array_ptr, len * elt_size);
53107|      0|                switch(elt_size) {
53108|      0|                case 1:
53109|      0|                    for(i = 0; i < len; i++) {
53110|      0|                        j = array_idx[i];
53111|      0|                        ((uint8_t *)array_ptr)[i] = ((uint8_t *)array_tmp)[j];
53112|      0|                    }
53113|      0|                    break;
53114|      0|                case 2:
53115|      0|                    for(i = 0; i < len; i++) {
53116|      0|                        j = array_idx[i];
53117|      0|                        ((uint16_t *)array_ptr)[i] = ((uint16_t *)array_tmp)[j];
53118|      0|                    }
53119|      0|                    break;
53120|      0|                case 4:
53121|      0|                    for(i = 0; i < len; i++) {
53122|      0|                        j = array_idx[i];
53123|      0|                        ((uint32_t *)array_ptr)[i] = ((uint32_t *)array_tmp)[j];
53124|      0|                    }
53125|      0|                    break;
53126|      0|                case 8:
53127|      0|                    for(i = 0; i < len; i++) {
53128|      0|                        j = array_idx[i];
53129|      0|                        ((uint64_t *)array_ptr)[i] = ((uint64_t *)array_tmp)[j];
53130|      0|                    }
53131|      0|                    break;
53132|      0|                default:
53133|      0|                    abort();
53134|      0|                }
53135|      0|                js_free(ctx, array_tmp);
53136|      0|            }
53137|      0|            js_free(ctx, array_idx);
53138|      0|        } else {
53139|      0|            rqsort(array_ptr, len, elt_size, cmpfun, &tsc);
53140|      0|            if (tsc.exception)
53141|      0|                return JS_EXCEPTION;
53142|      0|        }
53143|      0|    }
53144|      0|    return JS_DupValue(ctx, this_val);
53145|      0|}
53146|       |
53147|       |static JSValue js_typed_array_toSorted(JSContext *ctx, JSValueConst this_val,
53148|       |                                       int argc, JSValueConst *argv)
53149|      0|{
53150|      0|    JSValue arr, ret;
53151|      0|    JSObject *p;
53152|       |
53153|      0|    p = get_typed_array(ctx, this_val, /*is_dataview*/0);
53154|      0|    if (!p)
53155|      0|        return JS_EXCEPTION;
53156|      0|    arr = js_typed_array_constructor_ta(ctx, JS_UNDEFINED, this_val,
53157|      0|                                        p->class_id);
53158|      0|    if (JS_IsException(arr))
53159|      0|        return JS_EXCEPTION;
53160|      0|    ret = js_typed_array_sort(ctx, arr, argc, argv);
53161|      0|    JS_FreeValue(ctx, arr);
53162|      0|    return ret;
53163|      0|}
53164|       |
53165|       |static const JSCFunctionListEntry js_typed_array_base_funcs[] = {
53166|       |    JS_CFUNC_DEF("from", 1, js_typed_array_from ),
53167|       |    JS_CFUNC_DEF("of", 0, js_typed_array_of ),
53168|       |    JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
53169|       |    //JS_CFUNC_DEF("__getLength", 2, js_typed_array___getLength ),
53170|       |    //JS_CFUNC_DEF("__create", 2, js_typed_array___create ),
53171|       |    //JS_CFUNC_DEF("__speciesCreate", 2, js_typed_array___speciesCreate ),
53172|       |};
53173|       |
53174|       |static const JSCFunctionListEntry js_typed_array_base_proto_funcs[] = {
53175|       |    JS_CGETSET_DEF("length", js_typed_array_get_length, NULL ),
53176|       |    JS_CFUNC_DEF("at", 1, js_typed_array_at ),
53177|       |    JS_CFUNC_DEF("with", 2, js_typed_array_with ),
53178|       |    JS_CGETSET_MAGIC_DEF("buffer", js_typed_array_get_buffer, NULL, 0 ),
53179|       |    JS_CGETSET_MAGIC_DEF("byteLength", js_typed_array_get_byteLength, NULL, 0 ),
53180|       |    JS_CGETSET_MAGIC_DEF("byteOffset", js_typed_array_get_byteOffset, NULL, 0 ),
53181|       |    JS_CFUNC_DEF("set", 1, js_typed_array_set ),
53182|       |    JS_CFUNC_MAGIC_DEF("values", 0, js_create_typed_array_iterator, JS_ITERATOR_KIND_VALUE ),
53183|       |    JS_ALIAS_DEF("[Symbol.iterator]", "values" ),
53184|       |    JS_CFUNC_MAGIC_DEF("keys", 0, js_create_typed_array_iterator, JS_ITERATOR_KIND_KEY ),
53185|       |    JS_CFUNC_MAGIC_DEF("entries", 0, js_create_typed_array_iterator, JS_ITERATOR_KIND_KEY_AND_VALUE ),
53186|       |    JS_CGETSET_DEF("[Symbol.toStringTag]", js_typed_array_get_toStringTag, NULL ),
53187|       |    JS_CFUNC_DEF("copyWithin", 2, js_typed_array_copyWithin ),
53188|       |    JS_CFUNC_MAGIC_DEF("every", 1, js_array_every, special_every | special_TA ),
53189|       |    JS_CFUNC_MAGIC_DEF("some", 1, js_array_every, special_some | special_TA ),
53190|       |    JS_CFUNC_MAGIC_DEF("forEach", 1, js_array_every, special_forEach | special_TA ),
53191|       |    JS_CFUNC_MAGIC_DEF("map", 1, js_array_every, special_map | special_TA ),
53192|       |    JS_CFUNC_MAGIC_DEF("filter", 1, js_array_every, special_filter | special_TA ),
53193|       |    JS_CFUNC_MAGIC_DEF("reduce", 1, js_array_reduce, special_reduce | special_TA ),
53194|       |    JS_CFUNC_MAGIC_DEF("reduceRight", 1, js_array_reduce, special_reduceRight | special_TA ),
53195|       |    JS_CFUNC_DEF("fill", 1, js_typed_array_fill ),
53196|       |    JS_CFUNC_MAGIC_DEF("find", 1, js_typed_array_find, ArrayFind ),
53197|       |    JS_CFUNC_MAGIC_DEF("findIndex", 1, js_typed_array_find, ArrayFindIndex ),
53198|       |    JS_CFUNC_MAGIC_DEF("findLast", 1, js_typed_array_find, ArrayFindLast ),
53199|       |    JS_CFUNC_MAGIC_DEF("findLastIndex", 1, js_typed_array_find, ArrayFindLastIndex ),
53200|       |    JS_CFUNC_DEF("reverse", 0, js_typed_array_reverse ),
53201|       |    JS_CFUNC_DEF("toReversed", 0, js_typed_array_toReversed ),
53202|       |    JS_CFUNC_DEF("slice", 2, js_typed_array_slice ),
53203|       |    JS_CFUNC_DEF("subarray", 2, js_typed_array_subarray ),
53204|       |    JS_CFUNC_DEF("sort", 1, js_typed_array_sort ),
53205|       |    JS_CFUNC_DEF("toSorted", 1, js_typed_array_toSorted ),
53206|       |    JS_CFUNC_MAGIC_DEF("join", 1, js_typed_array_join, 0 ),
53207|       |    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_typed_array_join, 1 ),
53208|       |    JS_CFUNC_MAGIC_DEF("indexOf", 1, js_typed_array_indexOf, special_indexOf ),
53209|       |    JS_CFUNC_MAGIC_DEF("lastIndexOf", 1, js_typed_array_indexOf, special_lastIndexOf ),
53210|       |    JS_CFUNC_MAGIC_DEF("includes", 1, js_typed_array_indexOf, special_includes ),
53211|       |    //JS_ALIAS_BASE_DEF("toString", "toString", 2 /* Array.prototype. */), @@@
53212|       |};
53213|       |
53214|       |static JSValue js_typed_array_base_constructor(JSContext *ctx,
53215|       |                                               JSValueConst this_val,
53216|       |                                               int argc, JSValueConst *argv)
53217|      0|{
53218|      0|    return JS_ThrowTypeError(ctx, "cannot be called");
53219|      0|}
53220|       |
53221|       |/* 'obj' must be an allocated typed array object */
53222|       |static int typed_array_init(JSContext *ctx, JSValueConst obj,
53223|       |                            JSValue buffer, uint64_t offset, uint64_t len)
53224|      0|{
53225|      0|    JSTypedArray *ta;
53226|      0|    JSObject *p, *pbuffer;
53227|      0|    JSArrayBuffer *abuf;
53228|      0|    int size_log2;
53229|       |
53230|      0|    p = JS_VALUE_GET_OBJ(obj);
53231|      0|    size_log2 = typed_array_size_log2(p->class_id);
53232|      0|    ta = js_malloc(ctx, sizeof(*ta));
53233|      0|    if (!ta) {
53234|      0|        JS_FreeValue(ctx, buffer);
53235|      0|        return -1;
53236|      0|    }
53237|      0|    pbuffer = JS_VALUE_GET_OBJ(buffer);
53238|      0|    abuf = pbuffer->u.array_buffer;
53239|      0|    ta->obj = p;
53240|      0|    ta->buffer = pbuffer;
53241|      0|    ta->offset = offset;
53242|      0|    ta->length = len << size_log2;
53243|      0|    list_add_tail(&ta->link, &abuf->array_list);
53244|      0|    p->u.typed_array = ta;
53245|      0|    p->u.array.count = len;
53246|      0|    p->u.array.u.ptr = abuf->data + offset;
53247|      0|    return 0;
53248|      0|}
53249|       |
53250|       |
53251|       |static JSValue js_array_from_iterator(JSContext *ctx, uint32_t *plen,
53252|       |                                      JSValueConst obj, JSValueConst method)
53253|      0|{
53254|      0|    JSValue arr, iter, next_method = JS_UNDEFINED, val;
53255|      0|    BOOL done;
53256|      0|    uint32_t k;
53257|       |
53258|      0|    *plen = 0;
53259|      0|    arr = JS_NewArray(ctx);
53260|      0|    if (JS_IsException(arr))
53261|      0|        return arr;
53262|      0|    iter = JS_GetIterator2(ctx, obj, method);
53263|      0|    if (JS_IsException(iter))
53264|      0|        goto fail;
53265|      0|    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
53266|      0|    if (JS_IsException(next_method))
53267|      0|        goto fail;
53268|      0|    k = 0;
53269|      0|    for(;;) {
53270|      0|        val = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
53271|      0|        if (JS_IsException(val))
53272|      0|            goto fail;
53273|      0|        if (done)
53274|      0|            break;
53275|      0|        if (JS_CreateDataPropertyUint32(ctx, arr, k, val, JS_PROP_THROW) < 0)
53276|      0|            goto fail;
53277|      0|        k++;
53278|      0|    }
53279|      0|    JS_FreeValue(ctx, next_method);
53280|      0|    JS_FreeValue(ctx, iter);
53281|      0|    *plen = k;
53282|      0|    return arr;
53283|      0| fail:
53284|      0|    JS_FreeValue(ctx, next_method);
53285|      0|    JS_FreeValue(ctx, iter);
53286|      0|    JS_FreeValue(ctx, arr);
53287|      0|    return JS_EXCEPTION;
53288|      0|}
53289|       |
53290|       |static JSValue js_typed_array_constructor_obj(JSContext *ctx,
53291|       |                                              JSValueConst new_target,
53292|       |                                              JSValueConst obj,
53293|       |                                              int classid)
53294|      0|{
53295|      0|    JSValue iter, ret, arr = JS_UNDEFINED, val, buffer;
53296|      0|    uint32_t i;
53297|      0|    int size_log2;
53298|      0|    int64_t len;
53299|       |
53300|      0|    size_log2 = typed_array_size_log2(classid);
53301|      0|    ret = js_create_from_ctor(ctx, new_target, classid);
53302|      0|    if (JS_IsException(ret))
53303|      0|        return JS_EXCEPTION;
53304|       |
53305|      0|    iter = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);
53306|      0|    if (JS_IsException(iter))
53307|      0|        goto fail;
53308|      0|    if (!JS_IsUndefined(iter) && !JS_IsNull(iter)) {
53309|      0|        uint32_t len1;
53310|      0|        arr = js_array_from_iterator(ctx, &len1, obj, iter);
53311|      0|        JS_FreeValue(ctx, iter);
53312|      0|        if (JS_IsException(arr))
53313|      0|            goto fail;
53314|      0|        len = len1;
53315|      0|    } else {
53316|      0|        if (js_get_length64(ctx, &len, obj))
53317|      0|            goto fail;
53318|      0|        arr = JS_DupValue(ctx, obj);
53319|      0|    }
53320|       |
53321|      0|    buffer = js_array_buffer_constructor1(ctx, JS_UNDEFINED,
53322|      0|                                          len << size_log2);
53323|      0|    if (JS_IsException(buffer))
53324|      0|        goto fail;
53325|      0|    if (typed_array_init(ctx, ret, buffer, 0, len))
53326|      0|        goto fail;
53327|       |
53328|      0|    for(i = 0; i < len; i++) {
53329|      0|        val = JS_GetPropertyUint32(ctx, arr, i);
53330|      0|        if (JS_IsException(val))
53331|      0|            goto fail;
53332|      0|        if (JS_SetPropertyUint32(ctx, ret, i, val) < 0)
53333|      0|            goto fail;
53334|      0|    }
53335|      0|    JS_FreeValue(ctx, arr);
53336|      0|    return ret;
53337|      0| fail:
53338|      0|    JS_FreeValue(ctx, arr);
53339|      0|    JS_FreeValue(ctx, ret);
53340|      0|    return JS_EXCEPTION;
53341|      0|}
53342|       |
53343|       |static JSValue js_typed_array_constructor_ta(JSContext *ctx,
53344|       |                                             JSValueConst new_target,
53345|       |                                             JSValueConst src_obj,
53346|       |                                             int classid)
53347|      0|{
53348|      0|    JSObject *p, *src_buffer;
53349|      0|    JSTypedArray *ta;
53350|      0|    JSValue obj, buffer;
53351|      0|    uint32_t len, i;
53352|      0|    int size_log2;
53353|      0|    JSArrayBuffer *src_abuf, *abuf;
53354|       |
53355|      0|    obj = js_create_from_ctor(ctx, new_target, classid);
53356|      0|    if (JS_IsException(obj))
53357|      0|        return obj;
53358|      0|    p = JS_VALUE_GET_OBJ(src_obj);
53359|      0|    if (typed_array_is_detached(ctx, p)) {
53360|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53361|      0|        goto fail;
53362|      0|    }
53363|      0|    ta = p->u.typed_array;
53364|      0|    len = p->u.array.count;
53365|      0|    src_buffer = ta->buffer;
53366|      0|    src_abuf = src_buffer->u.array_buffer;
53367|      0|    size_log2 = typed_array_size_log2(classid);
53368|      0|    buffer = js_array_buffer_constructor1(ctx, JS_UNDEFINED,
53369|      0|                                          (uint64_t)len << size_log2);
53370|      0|    if (JS_IsException(buffer))
53371|      0|        goto fail;
53372|       |    /* necessary because it could have been detached */
53373|      0|    if (typed_array_is_detached(ctx, p)) {
53374|      0|        JS_FreeValue(ctx, buffer);
53375|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53376|      0|        goto fail;
53377|      0|    }
53378|      0|    abuf = JS_GetOpaque(buffer, JS_CLASS_ARRAY_BUFFER);
53379|      0|    if (typed_array_init(ctx, obj, buffer, 0, len))
53380|      0|        goto fail;
53381|      0|    if (p->class_id == classid) {
53382|       |        /* same type: copy the content */
53383|      0|        memcpy(abuf->data, src_abuf->data + ta->offset, abuf->byte_length);
53384|      0|    } else {
53385|      0|        for(i = 0; i < len; i++) {
53386|      0|            JSValue val;
53387|      0|            val = JS_GetPropertyUint32(ctx, src_obj, i);
53388|      0|            if (JS_IsException(val))
53389|      0|                goto fail;
53390|      0|            if (JS_SetPropertyUint32(ctx, obj, i, val) < 0)
53391|      0|                goto fail;
53392|      0|        }
53393|      0|    }
53394|      0|    return obj;
53395|      0| fail:
53396|      0|    JS_FreeValue(ctx, obj);
53397|      0|    return JS_EXCEPTION;
53398|      0|}
53399|       |
53400|       |static JSValue js_typed_array_constructor(JSContext *ctx,
53401|       |                                          JSValueConst new_target,
53402|       |                                          int argc, JSValueConst *argv,
53403|       |                                          int classid)
53404|      0|{
53405|      0|    JSValue buffer, obj;
53406|      0|    JSArrayBuffer *abuf;
53407|      0|    int size_log2;
53408|      0|    uint64_t len, offset;
53409|       |
53410|      0|    size_log2 = typed_array_size_log2(classid);
53411|      0|    if (JS_VALUE_GET_TAG(argv[0]) != JS_TAG_OBJECT) {
53412|      0|        if (JS_ToIndex(ctx, &len, argv[0]))
53413|      0|            return JS_EXCEPTION;
53414|      0|        buffer = js_array_buffer_constructor1(ctx, JS_UNDEFINED,
53415|      0|                                              len << size_log2);
53416|      0|        if (JS_IsException(buffer))
53417|      0|            return JS_EXCEPTION;
53418|      0|        offset = 0;
53419|      0|    } else {
53420|      0|        JSObject *p = JS_VALUE_GET_OBJ(argv[0]);
53421|      0|        if (p->class_id == JS_CLASS_ARRAY_BUFFER ||
53422|      0|            p->class_id == JS_CLASS_SHARED_ARRAY_BUFFER) {
53423|      0|            abuf = p->u.array_buffer;
53424|      0|            if (JS_ToIndex(ctx, &offset, argv[1]))
53425|      0|                return JS_EXCEPTION;
53426|      0|            if (abuf->detached)
53427|      0|                return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53428|      0|            if ((offset & ((1 << size_log2) - 1)) != 0 ||
53429|      0|                offset > abuf->byte_length)
53430|      0|                return JS_ThrowRangeError(ctx, "invalid offset");
53431|      0|            if (JS_IsUndefined(argv[2])) {
53432|      0|                if ((abuf->byte_length & ((1 << size_log2) - 1)) != 0)
53433|      0|                    goto invalid_length;
53434|      0|                len = (abuf->byte_length - offset) >> size_log2;
53435|      0|            } else {
53436|      0|                if (JS_ToIndex(ctx, &len, argv[2]))
53437|      0|                    return JS_EXCEPTION;
53438|      0|                if (abuf->detached)
53439|      0|                    return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53440|      0|                if ((offset + (len << size_log2)) > abuf->byte_length) {
53441|      0|                invalid_length:
53442|      0|                    return JS_ThrowRangeError(ctx, "invalid length");
53443|      0|                }
53444|      0|            }
53445|      0|            buffer = JS_DupValue(ctx, argv[0]);
53446|      0|        } else {
53447|      0|            if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
53448|      0|                p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
53449|      0|                return js_typed_array_constructor_ta(ctx, new_target, argv[0], classid);
53450|      0|            } else {
53451|      0|                return js_typed_array_constructor_obj(ctx, new_target, argv[0], classid);
53452|      0|            }
53453|      0|        }
53454|      0|    }
53455|       |
53456|      0|    obj = js_create_from_ctor(ctx, new_target, classid);
53457|      0|    if (JS_IsException(obj)) {
53458|      0|        JS_FreeValue(ctx, buffer);
53459|      0|        return JS_EXCEPTION;
53460|      0|    }
53461|      0|    if (typed_array_init(ctx, obj, buffer, offset, len)) {
53462|      0|        JS_FreeValue(ctx, obj);
53463|      0|        return JS_EXCEPTION;
53464|      0|    }
53465|      0|    return obj;
53466|      0|}
53467|       |
53468|       |static void js_typed_array_finalizer(JSRuntime *rt, JSValue val)
53469|      0|{
53470|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
53471|      0|    JSTypedArray *ta = p->u.typed_array;
53472|      0|    if (ta) {
53473|       |        /* during the GC the finalizers are called in an arbitrary
53474|       |           order so the ArrayBuffer finalizer may have been called */
53475|      0|        if (ta->link.next) {
53476|      0|            list_del(&ta->link);
53477|      0|        }
53478|      0|        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));
53479|      0|        js_free_rt(rt, ta);
53480|      0|    }
53481|      0|}
53482|       |
53483|       |static void js_typed_array_mark(JSRuntime *rt, JSValueConst val,
53484|       |                                JS_MarkFunc *mark_func)
53485|      0|{
53486|      0|    JSObject *p = JS_VALUE_GET_OBJ(val);
53487|      0|    JSTypedArray *ta = p->u.typed_array;
53488|      0|    if (ta) {
53489|      0|        JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer), mark_func);
53490|      0|    }
53491|      0|}
53492|       |
53493|       |static JSValue js_dataview_constructor(JSContext *ctx,
53494|       |                                       JSValueConst new_target,
53495|       |                                       int argc, JSValueConst *argv)
53496|      0|{
53497|      0|    JSArrayBuffer *abuf;
53498|      0|    uint64_t offset;
53499|      0|    uint32_t len;
53500|      0|    JSValueConst buffer;
53501|      0|    JSValue obj;
53502|      0|    JSTypedArray *ta;
53503|      0|    JSObject *p;
53504|       |
53505|      0|    buffer = argv[0];
53506|      0|    abuf = js_get_array_buffer(ctx, buffer);
53507|      0|    if (!abuf)
53508|      0|        return JS_EXCEPTION;
53509|      0|    offset = 0;
53510|      0|    if (argc > 1) {
53511|      0|        if (JS_ToIndex(ctx, &offset, argv[1]))
53512|      0|            return JS_EXCEPTION;
53513|      0|    }
53514|      0|    if (abuf->detached)
53515|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53516|      0|    if (offset > abuf->byte_length)
53517|      0|        return JS_ThrowRangeError(ctx, "invalid byteOffset");
53518|      0|    len = abuf->byte_length - offset;
53519|      0|    if (argc > 2 && !JS_IsUndefined(argv[2])) {
53520|      0|        uint64_t l;
53521|      0|        if (JS_ToIndex(ctx, &l, argv[2]))
53522|      0|            return JS_EXCEPTION;
53523|      0|        if (l > len)
53524|      0|            return JS_ThrowRangeError(ctx, "invalid byteLength");
53525|      0|        len = l;
53526|      0|    }
53527|       |
53528|      0|    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_DATAVIEW);
53529|      0|    if (JS_IsException(obj))
53530|      0|        return JS_EXCEPTION;
53531|      0|    if (abuf->detached) {
53532|       |        /* could have been detached in js_create_from_ctor() */
53533|      0|        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53534|      0|        goto fail;
53535|      0|    }
53536|      0|    ta = js_malloc(ctx, sizeof(*ta));
53537|      0|    if (!ta) {
53538|      0|    fail:
53539|      0|        JS_FreeValue(ctx, obj);
53540|      0|        return JS_EXCEPTION;
53541|      0|    }
53542|      0|    p = JS_VALUE_GET_OBJ(obj);
53543|      0|    ta->obj = p;
53544|      0|    ta->buffer = JS_VALUE_GET_OBJ(JS_DupValue(ctx, buffer));
53545|      0|    ta->offset = offset;
53546|      0|    ta->length = len;
53547|      0|    list_add_tail(&ta->link, &abuf->array_list);
53548|      0|    p->u.typed_array = ta;
53549|      0|    return obj;
53550|      0|}
53551|       |
53552|       |static JSValue js_dataview_getValue(JSContext *ctx,
53553|       |                                    JSValueConst this_obj,
53554|       |                                    int argc, JSValueConst *argv, int class_id)
53555|      0|{
53556|      0|    JSTypedArray *ta;
53557|      0|    JSArrayBuffer *abuf;
53558|      0|    BOOL littleEndian, is_swap;
53559|      0|    int size;
53560|      0|    uint8_t *ptr;
53561|      0|    uint32_t v;
53562|      0|    uint64_t pos;
53563|       |
53564|      0|    ta = JS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW);
53565|      0|    if (!ta)
53566|      0|        return JS_EXCEPTION;
53567|      0|    size = 1 << typed_array_size_log2(class_id);
53568|      0|    if (JS_ToIndex(ctx, &pos, argv[0]))
53569|      0|        return JS_EXCEPTION;
53570|      0|    littleEndian = argc > 1 && JS_ToBool(ctx, argv[1]);
53571|      0|    is_swap = littleEndian ^ !is_be();
53572|      0|    abuf = ta->buffer->u.array_buffer;
53573|      0|    if (abuf->detached)
53574|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53575|      0|    if ((pos + size) > ta->length)
53576|      0|        return JS_ThrowRangeError(ctx, "out of bound");
53577|      0|    ptr = abuf->data + ta->offset + pos;
53578|       |
53579|      0|    switch(class_id) {
53580|      0|    case JS_CLASS_INT8_ARRAY:
53581|      0|        return JS_NewInt32(ctx, *(int8_t *)ptr);
53582|      0|    case JS_CLASS_UINT8_ARRAY:
53583|      0|        return JS_NewInt32(ctx, *(uint8_t *)ptr);
53584|      0|    case JS_CLASS_INT16_ARRAY:
53585|      0|        v = get_u16(ptr);
53586|      0|        if (is_swap)
53587|      0|            v = bswap16(v);
53588|      0|        return JS_NewInt32(ctx, (int16_t)v);
53589|      0|    case JS_CLASS_UINT16_ARRAY:
53590|      0|        v = get_u16(ptr);
53591|      0|        if (is_swap)
53592|      0|            v = bswap16(v);
53593|      0|        return JS_NewInt32(ctx, v);
53594|      0|    case JS_CLASS_INT32_ARRAY:
53595|      0|        v = get_u32(ptr);
53596|      0|        if (is_swap)
53597|      0|            v = bswap32(v);
53598|      0|        return JS_NewInt32(ctx, v);
53599|      0|    case JS_CLASS_UINT32_ARRAY:
53600|      0|        v = get_u32(ptr);
53601|      0|        if (is_swap)
53602|      0|            v = bswap32(v);
53603|      0|        return JS_NewUint32(ctx, v);
53604|      0|    case JS_CLASS_BIG_INT64_ARRAY:
53605|      0|        {
53606|      0|            uint64_t v;
53607|      0|            v = get_u64(ptr);
53608|      0|            if (is_swap)
53609|      0|                v = bswap64(v);
53610|      0|            return JS_NewBigInt64(ctx, v);
53611|      0|        }
53612|      0|        break;
53613|      0|    case JS_CLASS_BIG_UINT64_ARRAY:
53614|      0|        {
53615|      0|            uint64_t v;
53616|      0|            v = get_u64(ptr);
53617|      0|            if (is_swap)
53618|      0|                v = bswap64(v);
53619|      0|            return JS_NewBigUint64(ctx, v);
53620|      0|        }
53621|      0|        break;
53622|      0|    case JS_CLASS_FLOAT32_ARRAY:
53623|      0|        {
53624|      0|            union {
53625|      0|                float f;
53626|      0|                uint32_t i;
53627|      0|            } u;
53628|      0|            v = get_u32(ptr);
53629|      0|            if (is_swap)
53630|      0|                v = bswap32(v);
53631|      0|            u.i = v;
53632|      0|            return __JS_NewFloat64(ctx, u.f);
53633|      0|        }
53634|      0|    case JS_CLASS_FLOAT64_ARRAY:
53635|      0|        {
53636|      0|            union {
53637|      0|                double f;
53638|      0|                uint64_t i;
53639|      0|            } u;
53640|      0|            u.i = get_u64(ptr);
53641|      0|            if (is_swap)
53642|      0|                u.i = bswap64(u.i);
53643|      0|            return __JS_NewFloat64(ctx, u.f);
53644|      0|        }
53645|      0|    default:
53646|      0|        abort();
53647|      0|    }
53648|      0|}
53649|       |
53650|       |static JSValue js_dataview_setValue(JSContext *ctx,
53651|       |                                    JSValueConst this_obj,
53652|       |                                    int argc, JSValueConst *argv, int class_id)
53653|      0|{
53654|      0|    JSTypedArray *ta;
53655|      0|    JSArrayBuffer *abuf;
53656|      0|    BOOL littleEndian, is_swap;
53657|      0|    int size;
53658|      0|    uint8_t *ptr;
53659|      0|    uint64_t v64;
53660|      0|    uint32_t v;
53661|      0|    uint64_t pos;
53662|      0|    JSValueConst val;
53663|       |
53664|      0|    ta = JS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW);
53665|      0|    if (!ta)
53666|      0|        return JS_EXCEPTION;
53667|      0|    size = 1 << typed_array_size_log2(class_id);
53668|      0|    if (JS_ToIndex(ctx, &pos, argv[0]))
53669|      0|        return JS_EXCEPTION;
53670|      0|    val = argv[1];
53671|      0|    v = 0; /* avoid warning */
53672|      0|    v64 = 0; /* avoid warning */
53673|      0|    if (class_id <= JS_CLASS_UINT32_ARRAY) {
53674|      0|        if (JS_ToUint32(ctx, &v, val))
53675|      0|            return JS_EXCEPTION;
53676|      0|    } else if (class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
53677|      0|        if (JS_ToBigInt64(ctx, (int64_t *)&v64, val))
53678|      0|            return JS_EXCEPTION;
53679|      0|    } else {
53680|      0|        double d;
53681|      0|        if (JS_ToFloat64(ctx, &d, val))
53682|      0|            return JS_EXCEPTION;
53683|      0|        if (class_id == JS_CLASS_FLOAT32_ARRAY) {
53684|      0|            union {
53685|      0|                float f;
53686|      0|                uint32_t i;
53687|      0|            } u;
53688|      0|            u.f = d;
53689|      0|            v = u.i;
53690|      0|        } else {
53691|      0|            JSFloat64Union u;
53692|      0|            u.d = d;
53693|      0|            v64 = u.u64;
53694|      0|        }
53695|      0|    }
53696|      0|    littleEndian = argc > 2 && JS_ToBool(ctx, argv[2]);
53697|      0|    is_swap = littleEndian ^ !is_be();
53698|      0|    abuf = ta->buffer->u.array_buffer;
53699|      0|    if (abuf->detached)
53700|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53701|      0|    if ((pos + size) > ta->length)
53702|      0|        return JS_ThrowRangeError(ctx, "out of bound");
53703|      0|    ptr = abuf->data + ta->offset + pos;
53704|       |
53705|      0|    switch(class_id) {
53706|      0|    case JS_CLASS_INT8_ARRAY:
53707|      0|    case JS_CLASS_UINT8_ARRAY:
53708|      0|        *ptr = v;
53709|      0|        break;
53710|      0|    case JS_CLASS_INT16_ARRAY:
53711|      0|    case JS_CLASS_UINT16_ARRAY:
53712|      0|        if (is_swap)
53713|      0|            v = bswap16(v);
53714|      0|        put_u16(ptr, v);
53715|      0|        break;
53716|      0|    case JS_CLASS_INT32_ARRAY:
53717|      0|    case JS_CLASS_UINT32_ARRAY:
53718|      0|    case JS_CLASS_FLOAT32_ARRAY:
53719|      0|        if (is_swap)
53720|      0|            v = bswap32(v);
53721|      0|        put_u32(ptr, v);
53722|      0|        break;
53723|      0|    case JS_CLASS_BIG_INT64_ARRAY:
53724|      0|    case JS_CLASS_BIG_UINT64_ARRAY:
53725|      0|    case JS_CLASS_FLOAT64_ARRAY:
53726|      0|        if (is_swap)
53727|      0|            v64 = bswap64(v64);
53728|      0|        put_u64(ptr, v64);
53729|      0|        break;
53730|      0|    default:
53731|      0|        abort();
53732|      0|    }
53733|      0|    return JS_UNDEFINED;
53734|      0|}
53735|       |
53736|       |static const JSCFunctionListEntry js_dataview_proto_funcs[] = {
53737|       |    JS_CGETSET_MAGIC_DEF("buffer", js_typed_array_get_buffer, NULL, 1 ),
53738|       |    JS_CGETSET_MAGIC_DEF("byteLength", js_typed_array_get_byteLength, NULL, 1 ),
53739|       |    JS_CGETSET_MAGIC_DEF("byteOffset", js_typed_array_get_byteOffset, NULL, 1 ),
53740|       |    JS_CFUNC_MAGIC_DEF("getInt8", 1, js_dataview_getValue, JS_CLASS_INT8_ARRAY ),
53741|       |    JS_CFUNC_MAGIC_DEF("getUint8", 1, js_dataview_getValue, JS_CLASS_UINT8_ARRAY ),
53742|       |    JS_CFUNC_MAGIC_DEF("getInt16", 1, js_dataview_getValue, JS_CLASS_INT16_ARRAY ),
53743|       |    JS_CFUNC_MAGIC_DEF("getUint16", 1, js_dataview_getValue, JS_CLASS_UINT16_ARRAY ),
53744|       |    JS_CFUNC_MAGIC_DEF("getInt32", 1, js_dataview_getValue, JS_CLASS_INT32_ARRAY ),
53745|       |    JS_CFUNC_MAGIC_DEF("getUint32", 1, js_dataview_getValue, JS_CLASS_UINT32_ARRAY ),
53746|       |    JS_CFUNC_MAGIC_DEF("getBigInt64", 1, js_dataview_getValue, JS_CLASS_BIG_INT64_ARRAY ),
53747|       |    JS_CFUNC_MAGIC_DEF("getBigUint64", 1, js_dataview_getValue, JS_CLASS_BIG_UINT64_ARRAY ),
53748|       |    JS_CFUNC_MAGIC_DEF("getFloat32", 1, js_dataview_getValue, JS_CLASS_FLOAT32_ARRAY ),
53749|       |    JS_CFUNC_MAGIC_DEF("getFloat64", 1, js_dataview_getValue, JS_CLASS_FLOAT64_ARRAY ),
53750|       |    JS_CFUNC_MAGIC_DEF("setInt8", 2, js_dataview_setValue, JS_CLASS_INT8_ARRAY ),
53751|       |    JS_CFUNC_MAGIC_DEF("setUint8", 2, js_dataview_setValue, JS_CLASS_UINT8_ARRAY ),
53752|       |    JS_CFUNC_MAGIC_DEF("setInt16", 2, js_dataview_setValue, JS_CLASS_INT16_ARRAY ),
53753|       |    JS_CFUNC_MAGIC_DEF("setUint16", 2, js_dataview_setValue, JS_CLASS_UINT16_ARRAY ),
53754|       |    JS_CFUNC_MAGIC_DEF("setInt32", 2, js_dataview_setValue, JS_CLASS_INT32_ARRAY ),
53755|       |    JS_CFUNC_MAGIC_DEF("setUint32", 2, js_dataview_setValue, JS_CLASS_UINT32_ARRAY ),
53756|       |    JS_CFUNC_MAGIC_DEF("setBigInt64", 2, js_dataview_setValue, JS_CLASS_BIG_INT64_ARRAY ),
53757|       |    JS_CFUNC_MAGIC_DEF("setBigUint64", 2, js_dataview_setValue, JS_CLASS_BIG_UINT64_ARRAY ),
53758|       |    JS_CFUNC_MAGIC_DEF("setFloat32", 2, js_dataview_setValue, JS_CLASS_FLOAT32_ARRAY ),
53759|       |    JS_CFUNC_MAGIC_DEF("setFloat64", 2, js_dataview_setValue, JS_CLASS_FLOAT64_ARRAY ),
53760|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "DataView", JS_PROP_CONFIGURABLE ),
53761|       |};
53762|       |
53763|       |/* Atomics */
53764|       |#ifdef CONFIG_ATOMICS
53765|       |
53766|       |typedef enum AtomicsOpEnum {
53767|       |    ATOMICS_OP_ADD,
53768|       |    ATOMICS_OP_AND,
53769|       |    ATOMICS_OP_OR,
53770|       |    ATOMICS_OP_SUB,
53771|       |    ATOMICS_OP_XOR,
53772|       |    ATOMICS_OP_EXCHANGE,
53773|       |    ATOMICS_OP_COMPARE_EXCHANGE,
53774|       |    ATOMICS_OP_LOAD,
53775|       |} AtomicsOpEnum;
53776|       |
53777|       |static void *js_atomics_get_ptr(JSContext *ctx,
53778|       |                                JSArrayBuffer **pabuf,
53779|       |                                int *psize_log2, JSClassID *pclass_id,
53780|       |                                JSValueConst obj, JSValueConst idx_val,
53781|       |                                int is_waitable)
53782|      0|{
53783|      0|    JSObject *p;
53784|      0|    JSTypedArray *ta;
53785|      0|    JSArrayBuffer *abuf;
53786|      0|    void *ptr;
53787|      0|    uint64_t idx;
53788|      0|    BOOL err;
53789|      0|    int size_log2;
53790|       |
53791|      0|    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
53792|      0|        goto fail;
53793|      0|    p = JS_VALUE_GET_OBJ(obj);
53794|      0|    if (is_waitable)
53795|      0|        err = (p->class_id != JS_CLASS_INT32_ARRAY &&
53796|      0|               p->class_id != JS_CLASS_BIG_INT64_ARRAY);
53797|      0|    else
53798|      0|        err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&
53799|      0|                p->class_id <= JS_CLASS_BIG_UINT64_ARRAY);
53800|      0|    if (err) {
53801|      0|    fail:
53802|      0|        JS_ThrowTypeError(ctx, "integer TypedArray expected");
53803|      0|        return NULL;
53804|      0|    }
53805|      0|    ta = p->u.typed_array;
53806|      0|    abuf = ta->buffer->u.array_buffer;
53807|      0|    if (!abuf->shared) {
53808|      0|        if (is_waitable == 2) {
53809|      0|            JS_ThrowTypeError(ctx, "not a SharedArrayBuffer TypedArray");
53810|      0|            return NULL;
53811|      0|        }
53812|      0|        if (abuf->detached) {
53813|      0|            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53814|      0|            return NULL;
53815|      0|        }
53816|      0|    }
53817|      0|    if (JS_ToIndex(ctx, &idx, idx_val)) {
53818|      0|        return NULL;
53819|      0|    }
53820|       |    /* if the array buffer is detached, p->u.array.count = 0 */
53821|      0|    if (idx >= p->u.array.count) {
53822|      0|        JS_ThrowRangeError(ctx, "out-of-bound access");
53823|      0|        return NULL;
53824|      0|    }
53825|      0|    size_log2 = typed_array_size_log2(p->class_id);
53826|      0|    ptr = p->u.array.u.uint8_ptr + ((uintptr_t)idx << size_log2);
53827|      0|    if (pabuf)
53828|      0|        *pabuf = abuf;
53829|      0|    if (psize_log2)
53830|      0|        *psize_log2 = size_log2;
53831|      0|    if (pclass_id)
53832|      0|        *pclass_id = p->class_id;
53833|      0|    return ptr;
53834|      0|}
53835|       |
53836|       |static JSValue js_atomics_op(JSContext *ctx,
53837|       |                             JSValueConst this_obj,
53838|       |                             int argc, JSValueConst *argv, int op)
53839|      0|{
53840|      0|    int size_log2;
53841|      0|    uint64_t v, a, rep_val;
53842|      0|    void *ptr;
53843|      0|    JSValue ret;
53844|      0|    JSClassID class_id;
53845|      0|    JSArrayBuffer *abuf;
53846|       |
53847|      0|    ptr = js_atomics_get_ptr(ctx, &abuf, &size_log2, &class_id,
53848|      0|                             argv[0], argv[1], 0);
53849|      0|    if (!ptr)
53850|      0|        return JS_EXCEPTION;
53851|      0|    rep_val = 0;
53852|      0|    if (op == ATOMICS_OP_LOAD) {
53853|      0|        v = 0;
53854|      0|    } else {
53855|      0|        if (size_log2 == 3) {
53856|      0|            int64_t v64;
53857|      0|            if (JS_ToBigInt64(ctx, &v64, argv[2]))
53858|      0|                return JS_EXCEPTION;
53859|      0|            v = v64;
53860|      0|            if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
53861|      0|                if (JS_ToBigInt64(ctx, &v64, argv[3]))
53862|      0|                    return JS_EXCEPTION;
53863|      0|                rep_val = v64;
53864|      0|            }
53865|      0|        } else {
53866|      0|                uint32_t v32;
53867|      0|                if (JS_ToUint32(ctx, &v32, argv[2]))
53868|      0|                    return JS_EXCEPTION;
53869|      0|                v = v32;
53870|      0|                if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
53871|      0|                    if (JS_ToUint32(ctx, &v32, argv[3]))
53872|      0|                        return JS_EXCEPTION;
53873|      0|                    rep_val = v32;
53874|      0|                }
53875|      0|        }
53876|      0|        if (abuf->detached)
53877|      0|            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
53878|      0|   }
53879|       |
53880|      0|   switch(op | (size_log2 << 3)) {
53881|       |
53882|      0|#define OP(op_name, func_name)                          \
53883|      0|    case ATOMICS_OP_ ## op_name | (0 << 3):             \
53884|      0|       a = func_name((_Atomic(uint8_t) *)ptr, v);       \
53885|      0|       break;                                           \
53886|      0|    case ATOMICS_OP_ ## op_name | (1 << 3):             \
53887|      0|        a = func_name((_Atomic(uint16_t) *)ptr, v);     \
53888|      0|        break;                                          \
53889|      0|    case ATOMICS_OP_ ## op_name | (2 << 3):             \
53890|      0|        a = func_name((_Atomic(uint32_t) *)ptr, v);     \
53891|      0|        break;                                          \
53892|      0|    case ATOMICS_OP_ ## op_name | (3 << 3):             \
53893|      0|        a = func_name((_Atomic(uint64_t) *)ptr, v);     \
53894|      0|        break;
53895|       |
53896|      0|        OP(ADD, atomic_fetch_add)
53897|      0|        OP(AND, atomic_fetch_and)
53898|      0|        OP(OR, atomic_fetch_or)
53899|      0|        OP(SUB, atomic_fetch_sub)
53900|      0|        OP(XOR, atomic_fetch_xor)
53901|      0|        OP(EXCHANGE, atomic_exchange)
53902|      0|#undef OP
53903|       |
53904|      0|    case ATOMICS_OP_LOAD | (0 << 3):
53905|      0|        a = atomic_load((_Atomic(uint8_t) *)ptr);
53906|      0|        break;
53907|      0|    case ATOMICS_OP_LOAD | (1 << 3):
53908|      0|        a = atomic_load((_Atomic(uint16_t) *)ptr);
53909|      0|        break;
53910|      0|    case ATOMICS_OP_LOAD | (2 << 3):
53911|      0|        a = atomic_load((_Atomic(uint32_t) *)ptr);
53912|      0|        break;
53913|      0|    case ATOMICS_OP_LOAD | (3 << 3):
53914|      0|        a = atomic_load((_Atomic(uint64_t) *)ptr);
53915|      0|        break;
53916|       |
53917|      0|    case ATOMICS_OP_COMPARE_EXCHANGE | (0 << 3):
53918|      0|        {
53919|      0|            uint8_t v1 = v;
53920|      0|            atomic_compare_exchange_strong((_Atomic(uint8_t) *)ptr, &v1, rep_val);
53921|      0|            a = v1;
53922|      0|        }
53923|      0|        break;
53924|      0|    case ATOMICS_OP_COMPARE_EXCHANGE | (1 << 3):
53925|      0|        {
53926|      0|            uint16_t v1 = v;
53927|      0|            atomic_compare_exchange_strong((_Atomic(uint16_t) *)ptr, &v1, rep_val);
53928|      0|            a = v1;
53929|      0|        }
53930|      0|        break;
53931|      0|    case ATOMICS_OP_COMPARE_EXCHANGE | (2 << 3):
53932|      0|        {
53933|      0|            uint32_t v1 = v;
53934|      0|            atomic_compare_exchange_strong((_Atomic(uint32_t) *)ptr, &v1, rep_val);
53935|      0|            a = v1;
53936|      0|        }
53937|      0|        break;
53938|      0|    case ATOMICS_OP_COMPARE_EXCHANGE | (3 << 3):
53939|      0|        {
53940|      0|            uint64_t v1 = v;
53941|      0|            atomic_compare_exchange_strong((_Atomic(uint64_t) *)ptr, &v1, rep_val);
53942|      0|            a = v1;
53943|      0|        }
53944|      0|        break;
53945|      0|    default:
53946|      0|        abort();
53947|      0|    }
53948|       |
53949|      0|    switch(class_id) {
53950|      0|    case JS_CLASS_INT8_ARRAY:
53951|      0|        a = (int8_t)a;
53952|      0|        goto done;
53953|      0|    case JS_CLASS_UINT8_ARRAY:
53954|      0|        a = (uint8_t)a;
53955|      0|        goto done;
53956|      0|    case JS_CLASS_INT16_ARRAY:
53957|      0|        a = (int16_t)a;
53958|      0|        goto done;
53959|      0|    case JS_CLASS_UINT16_ARRAY:
53960|      0|        a = (uint16_t)a;
53961|      0|        goto done;
53962|      0|    case JS_CLASS_INT32_ARRAY:
53963|      0|    done:
53964|      0|        ret = JS_NewInt32(ctx, a);
53965|      0|        break;
53966|      0|    case JS_CLASS_UINT32_ARRAY:
53967|      0|        ret = JS_NewUint32(ctx, a);
53968|      0|        break;
53969|      0|    case JS_CLASS_BIG_INT64_ARRAY:
53970|      0|        ret = JS_NewBigInt64(ctx, a);
53971|      0|        break;
53972|      0|    case JS_CLASS_BIG_UINT64_ARRAY:
53973|      0|        ret = JS_NewBigUint64(ctx, a);
53974|      0|        break;
53975|      0|    default:
53976|      0|        abort();
53977|      0|    }
53978|      0|    return ret;
53979|      0|}
53980|       |
53981|       |static JSValue js_atomics_store(JSContext *ctx,
53982|       |                                JSValueConst this_obj,
53983|       |                                int argc, JSValueConst *argv)
53984|      0|{
53985|      0|    int size_log2;
53986|      0|    void *ptr;
53987|      0|    JSValue ret;
53988|      0|    JSArrayBuffer *abuf;
53989|       |
53990|      0|    ptr = js_atomics_get_ptr(ctx, &abuf, &size_log2, NULL,
53991|      0|                             argv[0], argv[1], 0);
53992|      0|    if (!ptr)
53993|      0|        return JS_EXCEPTION;
53994|      0|    if (size_log2 == 3) {
53995|      0|        int64_t v64;
53996|      0|        ret = JS_ToBigIntFree(ctx, JS_DupValue(ctx, argv[2]));
53997|      0|        if (JS_IsException(ret))
53998|      0|            return ret;
53999|      0|        if (JS_ToBigInt64(ctx, &v64, ret)) {
54000|      0|            JS_FreeValue(ctx, ret);
54001|      0|            return JS_EXCEPTION;
54002|      0|        }
54003|      0|        if (abuf->detached)
54004|      0|            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
54005|      0|        atomic_store((_Atomic(uint64_t) *)ptr, v64);
54006|      0|    } else {
54007|      0|        uint32_t v;
54008|       |        /* XXX: spec, would be simpler to return the written value */
54009|      0|        ret = JS_ToIntegerFree(ctx, JS_DupValue(ctx, argv[2]));
54010|      0|        if (JS_IsException(ret))
54011|      0|            return ret;
54012|      0|        if (JS_ToUint32(ctx, &v, ret)) {
54013|      0|            JS_FreeValue(ctx, ret);
54014|      0|            return JS_EXCEPTION;
54015|      0|        }
54016|      0|        if (abuf->detached)
54017|      0|            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
54018|      0|        switch(size_log2) {
54019|      0|        case 0:
54020|      0|            atomic_store((_Atomic(uint8_t) *)ptr, v);
54021|      0|            break;
54022|      0|        case 1:
54023|      0|            atomic_store((_Atomic(uint16_t) *)ptr, v);
54024|      0|            break;
54025|      0|        case 2:
54026|      0|            atomic_store((_Atomic(uint32_t) *)ptr, v);
54027|      0|            break;
54028|      0|        default:
54029|      0|            abort();
54030|      0|        }
54031|      0|    }
54032|      0|    return ret;
54033|      0|}
54034|       |
54035|       |static JSValue js_atomics_isLockFree(JSContext *ctx,
54036|       |                                     JSValueConst this_obj,
54037|       |                                     int argc, JSValueConst *argv)
54038|      0|{
54039|      0|    int v, ret;
54040|      0|    if (JS_ToInt32Sat(ctx, &v, argv[0]))
54041|      0|        return JS_EXCEPTION;
54042|      0|    ret = (v == 1 || v == 2 || v == 4 || v == 8);
54043|      0|    return JS_NewBool(ctx, ret);
54044|      0|}
54045|       |
54046|       |typedef struct JSAtomicsWaiter {
54047|       |    struct list_head link;
54048|       |    BOOL linked;
54049|       |    pthread_cond_t cond;
54050|       |    int32_t *ptr;
54051|       |} JSAtomicsWaiter;
54052|       |
54053|       |static pthread_mutex_t js_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
54054|       |static struct list_head js_atomics_waiter_list =
54055|       |    LIST_HEAD_INIT(js_atomics_waiter_list);
54056|       |
54057|       |static JSValue js_atomics_wait(JSContext *ctx,
54058|       |                               JSValueConst this_obj,
54059|       |                               int argc, JSValueConst *argv)
54060|      0|{
54061|      0|    int64_t v;
54062|      0|    int32_t v32;
54063|      0|    void *ptr;
54064|      0|    int64_t timeout;
54065|      0|    struct timespec ts;
54066|      0|    JSAtomicsWaiter waiter_s, *waiter;
54067|      0|    int ret, size_log2, res;
54068|      0|    double d;
54069|       |
54070|      0|    ptr = js_atomics_get_ptr(ctx, NULL, &size_log2, NULL,
54071|      0|                             argv[0], argv[1], 2);
54072|      0|    if (!ptr)
54073|      0|        return JS_EXCEPTION;
54074|      0|    if (size_log2 == 3) {
54075|      0|        if (JS_ToBigInt64(ctx, &v, argv[2]))
54076|      0|            return JS_EXCEPTION;
54077|      0|    } else {
54078|      0|        if (JS_ToInt32(ctx, &v32, argv[2]))
54079|      0|            return JS_EXCEPTION;
54080|      0|        v = v32;
54081|      0|    }
54082|      0|    if (JS_ToFloat64(ctx, &d, argv[3]))
54083|      0|        return JS_EXCEPTION;
54084|       |    /* must use INT64_MAX + 1 because INT64_MAX cannot be exactly represented as a double */
54085|      0|    if (isnan(d) || d >= 0x1p63)
54086|      0|        timeout = INT64_MAX;
54087|      0|    else if (d < 0)
54088|      0|        timeout = 0;
54089|      0|    else
54090|      0|        timeout = (int64_t)d;
54091|      0|    if (!ctx->rt->can_block)
54092|      0|        return JS_ThrowTypeError(ctx, "cannot block in this thread");
54093|       |
54094|       |    /* XXX: inefficient if large number of waiters, should hash on
54095|       |       'ptr' value */
54096|       |    /* XXX: use Linux futexes when available ? */
54097|      0|    pthread_mutex_lock(&js_atomics_mutex);
54098|      0|    if (size_log2 == 3) {
54099|      0|        res = *(int64_t *)ptr != v;
54100|      0|    } else {
54101|      0|        res = *(int32_t *)ptr != v;
54102|      0|    }
54103|      0|    if (res) {
54104|      0|        pthread_mutex_unlock(&js_atomics_mutex);
54105|      0|        return JS_AtomToString(ctx, JS_ATOM_not_equal);
54106|      0|    }
54107|       |
54108|      0|    waiter = &waiter_s;
54109|      0|    waiter->ptr = ptr;
54110|      0|    pthread_cond_init(&waiter->cond, NULL);
54111|      0|    waiter->linked = TRUE;
54112|      0|    list_add_tail(&waiter->link, &js_atomics_waiter_list);
54113|       |
54114|      0|    if (timeout == INT64_MAX) {
54115|      0|        pthread_cond_wait(&waiter->cond, &js_atomics_mutex);
54116|      0|        ret = 0;
54117|      0|    } else {
54118|       |        /* XXX: use clock monotonic */
54119|      0|        clock_gettime(CLOCK_REALTIME, &ts);
54120|      0|        ts.tv_sec += timeout / 1000;
54121|      0|        ts.tv_nsec += (timeout % 1000) * 1000000;
54122|      0|        if (ts.tv_nsec >= 1000000000) {
54123|      0|            ts.tv_nsec -= 1000000000;
54124|      0|            ts.tv_sec++;
54125|      0|        }
54126|      0|        ret = pthread_cond_timedwait(&waiter->cond, &js_atomics_mutex,
54127|      0|                                     &ts);
54128|      0|    }
54129|      0|    if (waiter->linked)
54130|      0|        list_del(&waiter->link);
54131|      0|    pthread_mutex_unlock(&js_atomics_mutex);
54132|      0|    pthread_cond_destroy(&waiter->cond);
54133|      0|    if (ret == ETIMEDOUT) {
54134|      0|        return JS_AtomToString(ctx, JS_ATOM_timed_out);
54135|      0|    } else {
54136|      0|        return JS_AtomToString(ctx, JS_ATOM_ok);
54137|      0|    }
54138|      0|}
54139|       |
54140|       |static JSValue js_atomics_notify(JSContext *ctx,
54141|       |                                 JSValueConst this_obj,
54142|       |                                 int argc, JSValueConst *argv)
54143|      0|{
54144|      0|    struct list_head *el, *el1, waiter_list;
54145|      0|    int32_t count, n;
54146|      0|    void *ptr;
54147|      0|    JSAtomicsWaiter *waiter;
54148|      0|    JSArrayBuffer *abuf;
54149|       |
54150|      0|    ptr = js_atomics_get_ptr(ctx, &abuf, NULL, NULL, argv[0], argv[1], 1);
54151|      0|    if (!ptr)
54152|      0|        return JS_EXCEPTION;
54153|       |
54154|      0|    if (JS_IsUndefined(argv[2])) {
54155|      0|        count = INT32_MAX;
54156|      0|    } else {
54157|      0|        if (JS_ToInt32Clamp(ctx, &count, argv[2], 0, INT32_MAX, 0))
54158|      0|            return JS_EXCEPTION;
54159|      0|    }
54160|      0|    if (abuf->detached)
54161|      0|        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
54162|       |
54163|      0|    n = 0;
54164|      0|    if (abuf->shared && count > 0) {
54165|      0|        pthread_mutex_lock(&js_atomics_mutex);
54166|      0|        init_list_head(&waiter_list);
54167|      0|        list_for_each_safe(el, el1, &js_atomics_waiter_list) {
54168|      0|            waiter = list_entry(el, JSAtomicsWaiter, link);
54169|      0|            if (waiter->ptr == ptr) {
54170|      0|                list_del(&waiter->link);
54171|      0|                waiter->linked = FALSE;
54172|      0|                list_add_tail(&waiter->link, &waiter_list);
54173|      0|                n++;
54174|      0|                if (n >= count)
54175|      0|                    break;
54176|      0|            }
54177|      0|        }
54178|      0|        list_for_each(el, &waiter_list) {
54179|      0|            waiter = list_entry(el, JSAtomicsWaiter, link);
54180|      0|            pthread_cond_signal(&waiter->cond);
54181|      0|        }
54182|      0|        pthread_mutex_unlock(&js_atomics_mutex);
54183|      0|    }
54184|      0|    return JS_NewInt32(ctx, n);
54185|      0|}
54186|       |
54187|       |static const JSCFunctionListEntry js_atomics_funcs[] = {
54188|       |    JS_CFUNC_MAGIC_DEF("add", 3, js_atomics_op, ATOMICS_OP_ADD ),
54189|       |    JS_CFUNC_MAGIC_DEF("and", 3, js_atomics_op, ATOMICS_OP_AND ),
54190|       |    JS_CFUNC_MAGIC_DEF("or", 3, js_atomics_op, ATOMICS_OP_OR ),
54191|       |    JS_CFUNC_MAGIC_DEF("sub", 3, js_atomics_op, ATOMICS_OP_SUB ),
54192|       |    JS_CFUNC_MAGIC_DEF("xor", 3, js_atomics_op, ATOMICS_OP_XOR ),
54193|       |    JS_CFUNC_MAGIC_DEF("exchange", 3, js_atomics_op, ATOMICS_OP_EXCHANGE ),
54194|       |    JS_CFUNC_MAGIC_DEF("compareExchange", 4, js_atomics_op, ATOMICS_OP_COMPARE_EXCHANGE ),
54195|       |    JS_CFUNC_MAGIC_DEF("load", 2, js_atomics_op, ATOMICS_OP_LOAD ),
54196|       |    JS_CFUNC_DEF("store", 3, js_atomics_store ),
54197|       |    JS_CFUNC_DEF("isLockFree", 1, js_atomics_isLockFree ),
54198|       |    JS_CFUNC_DEF("wait", 4, js_atomics_wait ),
54199|       |    JS_CFUNC_DEF("notify", 3, js_atomics_notify ),
54200|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Atomics", JS_PROP_CONFIGURABLE ),
54201|       |};
54202|       |
54203|       |static const JSCFunctionListEntry js_atomics_obj[] = {
54204|       |    JS_OBJECT_DEF("Atomics", js_atomics_funcs, countof(js_atomics_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
54205|       |};
54206|       |
54207|       |void JS_AddIntrinsicAtomics(JSContext *ctx)
54208|  17.7k|{
54209|       |    /* add Atomics as autoinit object */
54210|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_atomics_obj, countof(js_atomics_obj));
54211|  17.7k|}
54212|       |
54213|       |#endif /* CONFIG_ATOMICS */
54214|       |
54215|       |void JS_AddIntrinsicTypedArrays(JSContext *ctx)
54216|  17.7k|{
54217|  17.7k|    JSValue typed_array_base_proto, typed_array_base_func;
54218|  17.7k|    JSValueConst array_buffer_func, shared_array_buffer_func;
54219|  17.7k|    int i;
54220|       |
54221|  17.7k|    ctx->class_proto[JS_CLASS_ARRAY_BUFFER] = JS_NewObject(ctx);
54222|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY_BUFFER],
54223|  17.7k|                               js_array_buffer_proto_funcs,
54224|  17.7k|                               countof(js_array_buffer_proto_funcs));
54225|       |
54226|  17.7k|    array_buffer_func = JS_NewGlobalCConstructorOnly(ctx, "ArrayBuffer",
54227|  17.7k|                                                 js_array_buffer_constructor, 1,
54228|  17.7k|                                                 ctx->class_proto[JS_CLASS_ARRAY_BUFFER]);
54229|  17.7k|    JS_SetPropertyFunctionList(ctx, array_buffer_func,
54230|  17.7k|                               js_array_buffer_funcs,
54231|  17.7k|                               countof(js_array_buffer_funcs));
54232|       |
54233|  17.7k|    ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER] = JS_NewObject(ctx);
54234|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER],
54235|  17.7k|                               js_shared_array_buffer_proto_funcs,
54236|  17.7k|                               countof(js_shared_array_buffer_proto_funcs));
54237|       |
54238|  17.7k|    shared_array_buffer_func = JS_NewGlobalCConstructorOnly(ctx, "SharedArrayBuffer",
54239|  17.7k|                                                 js_shared_array_buffer_constructor, 1,
54240|  17.7k|                                                 ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER]);
54241|  17.7k|    JS_SetPropertyFunctionList(ctx, shared_array_buffer_func,
54242|  17.7k|                               js_shared_array_buffer_funcs,
54243|  17.7k|                               countof(js_shared_array_buffer_funcs));
54244|       |
54245|  17.7k|    typed_array_base_proto = JS_NewObject(ctx);
54246|  17.7k|    JS_SetPropertyFunctionList(ctx, typed_array_base_proto,
54247|  17.7k|                               js_typed_array_base_proto_funcs,
54248|  17.7k|                               countof(js_typed_array_base_proto_funcs));
54249|       |
54250|       |    /* TypedArray.prototype.toString must be the same object as Array.prototype.toString */
54251|  17.7k|    JSValue obj = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_ARRAY], JS_ATOM_toString);
54252|       |    /* XXX: should use alias method in JSCFunctionListEntry */ //@@@
54253|  17.7k|    JS_DefinePropertyValue(ctx, typed_array_base_proto, JS_ATOM_toString, obj,
54254|  17.7k|                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
54255|       |
54256|  17.7k|    typed_array_base_func = JS_NewCFunction(ctx, js_typed_array_base_constructor,
54257|  17.7k|                                            "TypedArray", 0);
54258|  17.7k|    JS_SetPropertyFunctionList(ctx, typed_array_base_func,
54259|  17.7k|                               js_typed_array_base_funcs,
54260|  17.7k|                               countof(js_typed_array_base_funcs));
54261|  17.7k|    JS_SetConstructor(ctx, typed_array_base_func, typed_array_base_proto);
54262|       |
54263|       |    /* Used to squelch a -Wcast-function-type warning. */
54264|  17.7k|    JSCFunctionType ft = { .generic_magic = js_typed_array_constructor };
54265|   213k|    for(i = JS_CLASS_UINT8C_ARRAY; i < JS_CLASS_UINT8C_ARRAY + JS_TYPED_ARRAY_COUNT; i++) {
54266|   195k|        JSValue func_obj;
54267|   195k|        char buf[ATOM_GET_STR_BUF_SIZE];
54268|   195k|        const char *name;
54269|       |
54270|   195k|        ctx->class_proto[i] = JS_NewObjectProto(ctx, typed_array_base_proto);
54271|   195k|        JS_DefinePropertyValueStr(ctx, ctx->class_proto[i],
54272|   195k|                                  "BYTES_PER_ELEMENT",
54273|   195k|                                  JS_NewInt32(ctx, 1 << typed_array_size_log2(i)),
54274|   195k|                                  0);
54275|   195k|        name = JS_AtomGetStr(ctx, buf, sizeof(buf),
54276|   195k|                             JS_ATOM_Uint8ClampedArray + i - JS_CLASS_UINT8C_ARRAY);
54277|   195k|        func_obj = JS_NewCFunction3(ctx, ft.generic,
54278|   195k|                                    name, 3, JS_CFUNC_constructor_magic, i,
54279|   195k|                                    typed_array_base_func);
54280|   195k|        JS_NewGlobalCConstructor2(ctx, func_obj, name, ctx->class_proto[i]);
54281|   195k|        JS_DefinePropertyValueStr(ctx, func_obj,
54282|   195k|                                  "BYTES_PER_ELEMENT",
54283|   195k|                                  JS_NewInt32(ctx, 1 << typed_array_size_log2(i)),
54284|   195k|                                  0);
54285|   195k|    }
54286|  17.7k|    JS_FreeValue(ctx, typed_array_base_proto);
54287|  17.7k|    JS_FreeValue(ctx, typed_array_base_func);
54288|       |
54289|       |    /* DataView */
54290|  17.7k|    ctx->class_proto[JS_CLASS_DATAVIEW] = JS_NewObject(ctx);
54291|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATAVIEW],
54292|  17.7k|                               js_dataview_proto_funcs,
54293|  17.7k|                               countof(js_dataview_proto_funcs));
54294|  17.7k|    JS_NewGlobalCConstructorOnly(ctx, "DataView",
54295|  17.7k|                                 js_dataview_constructor, 1,
54296|  17.7k|                                 ctx->class_proto[JS_CLASS_DATAVIEW]);
54297|       |    /* Atomics */
54298|  17.7k|#ifdef CONFIG_ATOMICS
54299|  17.7k|    JS_AddIntrinsicAtomics(ctx);
54300|  17.7k|#endif
54301|  17.7k|}
54302|       |
54303|       |/* WeakRef */
54304|       |
54305|       |typedef struct JSWeakRefData {
54306|       |    JSWeakRefHeader weakref_header;
54307|       |    JSValue target;
54308|       |} JSWeakRefData;
54309|       |
54310|       |static void js_weakref_finalizer(JSRuntime *rt, JSValue val)
54311|      0|{
54312|      0|    JSWeakRefData *wrd = JS_GetOpaque(val, JS_CLASS_WEAK_REF);
54313|      0|    if (!wrd)
54314|      0|        return;
54315|      0|    js_weakref_free(rt, wrd->target);
54316|      0|    list_del(&wrd->weakref_header.link);
54317|      0|    js_free_rt(rt, wrd);
54318|      0|}
54319|       |
54320|       |static void weakref_delete_weakref(JSRuntime *rt, JSWeakRefHeader *wh)
54321|      0|{
54322|      0|    JSWeakRefData *wrd = container_of(wh, JSWeakRefData, weakref_header);
54323|       |
54324|      0|    if (!js_weakref_is_live(wrd->target)) {
54325|      0|        js_weakref_free(rt, wrd->target);
54326|      0|        wrd->target = JS_UNDEFINED;
54327|      0|    }
54328|      0|}
54329|       |
54330|       |static JSValue js_weakref_constructor(JSContext *ctx, JSValueConst new_target,
54331|       |                                      int argc, JSValueConst *argv)
54332|      0|{
54333|      0|    JSValueConst arg;
54334|      0|    JSValue obj;
54335|       |
54336|      0|    if (JS_IsUndefined(new_target))
54337|      0|        return JS_ThrowTypeError(ctx, "constructor requires 'new'");
54338|      0|    arg = argv[0];
54339|      0|    if (!js_weakref_is_target(arg))
54340|      0|        return JS_ThrowTypeError(ctx, "invalid target");
54341|      0|    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_WEAK_REF);
54342|      0|    if (JS_IsException(obj))
54343|      0|        return JS_EXCEPTION;
54344|      0|    JSWeakRefData *wrd = js_mallocz(ctx, sizeof(*wrd));
54345|      0|    if (!wrd) {
54346|      0|        JS_FreeValue(ctx, obj);
54347|      0|        return JS_EXCEPTION;
54348|      0|    }
54349|      0|    wrd->target = js_weakref_new(ctx, arg);
54350|      0|    wrd->weakref_header.weakref_type = JS_WEAKREF_TYPE_WEAKREF;
54351|      0|    list_add_tail(&wrd->weakref_header.link, &ctx->rt->weakref_list);
54352|      0|    JS_SetOpaque(obj, wrd);
54353|      0|    return obj;
54354|      0|}
54355|       |
54356|       |static JSValue js_weakref_deref(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
54357|      0|{
54358|      0|    JSWeakRefData *wrd = JS_GetOpaque2(ctx, this_val, JS_CLASS_WEAK_REF);
54359|      0|    if (!wrd)
54360|      0|        return JS_EXCEPTION;
54361|      0|    if (js_weakref_is_live(wrd->target)) 
54362|      0|        return JS_DupValue(ctx, wrd->target);
54363|      0|    else
54364|      0|        return JS_UNDEFINED;
54365|      0|}
54366|       |
54367|       |static const JSCFunctionListEntry js_weakref_proto_funcs[] = {
54368|       |    JS_CFUNC_DEF("deref", 0, js_weakref_deref ),
54369|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakRef", JS_PROP_CONFIGURABLE ),
54370|       |};
54371|       |
54372|       |static const JSClassShortDef js_weakref_class_def[] = {
54373|       |    { JS_ATOM_WeakRef, js_weakref_finalizer, NULL }, /* JS_CLASS_WEAK_REF */
54374|       |};
54375|       |
54376|       |typedef struct JSFinRecEntry {
54377|       |    struct list_head link;
54378|       |    JSValue target;
54379|       |    JSValue held_val;
54380|       |    JSValue token;
54381|       |} JSFinRecEntry;
54382|       |
54383|       |typedef struct JSFinalizationRegistryData {
54384|       |    JSWeakRefHeader weakref_header;
54385|       |    struct list_head entries; /* list of JSFinRecEntry.link */
54386|       |    JSContext *ctx;
54387|       |    JSValue cb;
54388|       |} JSFinalizationRegistryData;
54389|       |
54390|       |static void js_finrec_finalizer(JSRuntime *rt, JSValue val)
54391|      0|{
54392|      0|    JSFinalizationRegistryData *frd = JS_GetOpaque(val, JS_CLASS_FINALIZATION_REGISTRY);
54393|      0|    if (frd) {
54394|      0|        struct list_head *el, *el1;
54395|      0|        list_for_each_safe(el, el1, &frd->entries) {
54396|      0|            JSFinRecEntry *fre = list_entry(el, JSFinRecEntry, link);
54397|      0|            js_weakref_free(rt, fre->target);
54398|      0|            js_weakref_free(rt, fre->token);
54399|      0|            JS_FreeValueRT(rt, fre->held_val);
54400|      0|            js_free_rt(rt, fre);
54401|      0|        }
54402|      0|        JS_FreeValueRT(rt, frd->cb);
54403|      0|        list_del(&frd->weakref_header.link);
54404|      0|        js_free_rt(rt, frd);
54405|      0|    }
54406|      0|}
54407|       |
54408|       |static void js_finrec_mark(JSRuntime *rt, JSValueConst val,
54409|       |                           JS_MarkFunc *mark_func)
54410|      0|{
54411|      0|    JSFinalizationRegistryData *frd = JS_GetOpaque(val, JS_CLASS_FINALIZATION_REGISTRY);
54412|      0|    struct list_head *el;
54413|      0|    if (frd) {
54414|      0|        list_for_each(el, &frd->entries) {
54415|      0|            JSFinRecEntry *fre = list_entry(el, JSFinRecEntry, link);
54416|      0|            JS_MarkValue(rt, fre->held_val, mark_func);
54417|      0|        }
54418|      0|        JS_MarkValue(rt, frd->cb, mark_func);
54419|      0|    }
54420|      0|}
54421|       |
54422|       |static JSValue js_finrec_job(JSContext *ctx, int argc, JSValueConst *argv)
54423|      0|{
54424|      0|    return JS_Call(ctx, argv[0], JS_UNDEFINED, 1, &argv[1]);
54425|      0|}
54426|       |
54427|       |static void finrec_delete_weakref(JSRuntime *rt, JSWeakRefHeader *wh)
54428|      0|{
54429|      0|    JSFinalizationRegistryData *frd = container_of(wh, JSFinalizationRegistryData, weakref_header);
54430|      0|    struct list_head *el, *el1;
54431|       |
54432|      0|    list_for_each_safe(el, el1, &frd->entries) {
54433|      0|        JSFinRecEntry *fre = list_entry(el, JSFinRecEntry, link);
54434|       |
54435|      0|        if (!js_weakref_is_live(fre->token)) {
54436|      0|            js_weakref_free(rt, fre->token);
54437|      0|            fre->token = JS_UNDEFINED;
54438|      0|        }
54439|       |
54440|      0|        if (!js_weakref_is_live(fre->target)) {
54441|      0|            JSValueConst args[2];
54442|      0|            args[0] = frd->cb;
54443|      0|            args[1] = fre->held_val;
54444|      0|            JS_EnqueueJob(frd->ctx, js_finrec_job, 2, args);
54445|       |                
54446|      0|            js_weakref_free(rt, fre->target);
54447|      0|            js_weakref_free(rt, fre->token);
54448|      0|            JS_FreeValueRT(rt, fre->held_val);
54449|      0|            list_del(&fre->link);
54450|      0|            js_free_rt(rt, fre);
54451|      0|        }
54452|      0|    }
54453|      0|}
54454|       |
54455|       |static JSValue js_finrec_constructor(JSContext *ctx, JSValueConst new_target,
54456|       |                                     int argc, JSValueConst *argv)
54457|      0|{
54458|      0|    JSValueConst cb;
54459|      0|    JSValue obj;
54460|      0|    JSFinalizationRegistryData *frd;
54461|       |    
54462|      0|    if (JS_IsUndefined(new_target))
54463|      0|        return JS_ThrowTypeError(ctx, "constructor requires 'new'");
54464|      0|    cb = argv[0];
54465|      0|    if (!JS_IsFunction(ctx, cb))
54466|      0|        return JS_ThrowTypeError(ctx, "argument must be a function");
54467|       |
54468|      0|    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_FINALIZATION_REGISTRY);
54469|      0|    if (JS_IsException(obj))
54470|      0|        return JS_EXCEPTION;
54471|      0|    frd = js_mallocz(ctx, sizeof(*frd));
54472|      0|    if (!frd) {
54473|      0|        JS_FreeValue(ctx, obj);
54474|      0|        return JS_EXCEPTION;
54475|      0|    }
54476|      0|    frd->weakref_header.weakref_type = JS_WEAKREF_TYPE_FINREC;
54477|      0|    list_add_tail(&frd->weakref_header.link, &ctx->rt->weakref_list);
54478|      0|    init_list_head(&frd->entries);
54479|      0|    frd->ctx = ctx; /* XXX: JS_DupContext() ? */
54480|      0|    frd->cb = JS_DupValue(ctx, cb);
54481|      0|    JS_SetOpaque(obj, frd);
54482|      0|    return obj;
54483|      0|}
54484|       |
54485|       |static JSValue js_finrec_register(JSContext *ctx, JSValueConst this_val,
54486|       |                                  int argc, JSValueConst *argv)
54487|      0|{
54488|      0|    JSValueConst target, held_val, token;
54489|      0|    JSFinalizationRegistryData *frd;
54490|      0|    JSFinRecEntry *fre;
54491|       |
54492|      0|    frd = JS_GetOpaque2(ctx, this_val, JS_CLASS_FINALIZATION_REGISTRY);
54493|      0|    if (!frd)
54494|      0|        return JS_EXCEPTION;
54495|      0|    target = argv[0];
54496|      0|    held_val = argv[1];
54497|      0|    token = argc > 2 ? argv[2] : JS_UNDEFINED;
54498|       |
54499|      0|    if (!js_weakref_is_target(target))
54500|      0|        return JS_ThrowTypeError(ctx, "invalid target");
54501|      0|    if (js_same_value(ctx, target, held_val))
54502|      0|        return JS_ThrowTypeError(ctx, "held value cannot be the target");
54503|      0|    if (!JS_IsUndefined(token) && !js_weakref_is_target(token))
54504|      0|        return JS_ThrowTypeError(ctx, "invalid unregister token");
54505|      0|    fre = js_malloc(ctx, sizeof(*fre));
54506|      0|    if (!fre)
54507|      0|        return JS_EXCEPTION;
54508|      0|    fre->target = js_weakref_new(ctx, target);
54509|      0|    fre->held_val = JS_DupValue(ctx, held_val);
54510|      0|    fre->token = js_weakref_new(ctx, token);
54511|      0|    list_add_tail(&fre->link, &frd->entries);
54512|      0|    return JS_UNDEFINED;
54513|      0|}
54514|       |
54515|       |static JSValue js_finrec_unregister(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
54516|      0|{
54517|      0|    JSFinalizationRegistryData *frd = JS_GetOpaque2(ctx, this_val, JS_CLASS_FINALIZATION_REGISTRY);
54518|      0|    JSValueConst token;
54519|      0|    BOOL removed;
54520|      0|    struct list_head *el, *el1;
54521|       |
54522|      0|    if (!frd)
54523|      0|        return JS_EXCEPTION;
54524|      0|    token = argv[0];
54525|      0|    if (!js_weakref_is_target(token))
54526|      0|        return JS_ThrowTypeError(ctx, "invalid unregister token");
54527|       |
54528|      0|    removed = FALSE;
54529|      0|    list_for_each_safe(el, el1, &frd->entries) {
54530|      0|        JSFinRecEntry *fre = list_entry(el, JSFinRecEntry, link);
54531|      0|        if (js_weakref_is_live(fre->token) && js_same_value(ctx, fre->token, token)) {
54532|      0|            js_weakref_free(ctx->rt, fre->target);
54533|      0|            js_weakref_free(ctx->rt, fre->token);
54534|      0|            JS_FreeValue(ctx, fre->held_val);
54535|      0|            list_del(&fre->link);
54536|      0|            js_free(ctx, fre);
54537|      0|            removed = TRUE;
54538|      0|        }
54539|      0|    }
54540|      0|    return JS_NewBool(ctx, removed);
54541|      0|}
54542|       |
54543|       |static const JSCFunctionListEntry js_finrec_proto_funcs[] = {
54544|       |    JS_CFUNC_DEF("register", 2, js_finrec_register ),
54545|       |    JS_CFUNC_DEF("unregister", 1, js_finrec_unregister ),
54546|       |    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "FinalizationRegistry", JS_PROP_CONFIGURABLE ),
54547|       |};
54548|       |
54549|       |static const JSClassShortDef js_finrec_class_def[] = {
54550|       |    { JS_ATOM_FinalizationRegistry, js_finrec_finalizer, js_finrec_mark }, /* JS_CLASS_FINALIZATION_REGISTRY */
54551|       |};
54552|       |
54553|       |void JS_AddIntrinsicWeakRef(JSContext *ctx)
54554|  17.7k|{
54555|  17.7k|    JSRuntime *rt = ctx->rt;
54556|       |
54557|       |    /* WeakRef */
54558|  17.7k|    if (!JS_IsRegisteredClass(rt, JS_CLASS_WEAK_REF)) {
54559|  17.7k|        init_class_range(rt, js_weakref_class_def, JS_CLASS_WEAK_REF,
54560|  17.7k|                         countof(js_weakref_class_def));
54561|  17.7k|    }
54562|  17.7k|    ctx->class_proto[JS_CLASS_WEAK_REF] = JS_NewObject(ctx);
54563|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_WEAK_REF],
54564|  17.7k|                               js_weakref_proto_funcs,
54565|  17.7k|                               countof(js_weakref_proto_funcs));
54566|  17.7k|    JS_NewGlobalCConstructor(ctx, "WeakRef", js_weakref_constructor, 1, ctx->class_proto[JS_CLASS_WEAK_REF]);
54567|       |
54568|       |    /* FinalizationRegistry */
54569|  17.7k|    if (!JS_IsRegisteredClass(rt, JS_CLASS_FINALIZATION_REGISTRY)) {
54570|  17.7k|        init_class_range(rt, js_finrec_class_def, JS_CLASS_FINALIZATION_REGISTRY,
54571|  17.7k|                         countof(js_finrec_class_def));
54572|  17.7k|    }
54573|  17.7k|    ctx->class_proto[JS_CLASS_FINALIZATION_REGISTRY] = JS_NewObject(ctx);
54574|  17.7k|    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_FINALIZATION_REGISTRY],
54575|  17.7k|                               js_finrec_proto_funcs,
54576|  17.7k|                               countof(js_finrec_proto_funcs));
54577|  17.7k|    JS_NewGlobalCConstructor(ctx, "FinalizationRegistry", js_finrec_constructor, 1, ctx->class_proto[JS_CLASS_FINALIZATION_REGISTRY]);
54578|  17.7k|}

/home/eugeneriabinin777/quickjs/quickjs.h:
    1|       |/*
    2|       | * QuickJS Javascript Engine
    3|       | *
    4|       | * Copyright (c) 2017-2021 Fabrice Bellard
    5|       | * Copyright (c) 2017-2021 Charlie Gordon
    6|       | *
    7|       | * Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       | * of this software and associated documentation files (the "Software"), to deal
    9|       | * in the Software without restriction, including without limitation the rights
   10|       | * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       | * copies of the Software, and to permit persons to whom the Software is
   12|       | * furnished to do so, subject to the following conditions:
   13|       | *
   14|       | * The above copyright notice and this permission notice shall be included in
   15|       | * all copies or substantial portions of the Software.
   16|       | *
   17|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       | * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       | * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   20|       | * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       | * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       | * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       | * THE SOFTWARE.
   24|       | */
   25|       |#ifndef QUICKJS_H
   26|       |#define QUICKJS_H
   27|       |
   28|       |#include <stdio.h>
   29|       |#include <stdint.h>
   30|       |#include <string.h>
   31|       |
   32|       |#ifdef __cplusplus
   33|       |extern "C" {
   34|       |#endif
   35|       |
   36|       |#if defined(__GNUC__) || defined(__clang__)
   37|       |#define js_likely(x)          __builtin_expect(!!(x), 1)
   38|  65.3M|#define js_unlikely(x)        __builtin_expect(!!(x), 0)
   39|       |#define js_force_inline       inline __attribute__((always_inline))
   40|       |#define __js_printf_like(f, a)   __attribute__((format(printf, f, a)))
   41|       |#else
   42|       |#define js_likely(x)     (x)
   43|       |#define js_unlikely(x)   (x)
   44|       |#define js_force_inline  inline
   45|       |#define __js_printf_like(a, b)
   46|       |#endif
   47|       |
   48|       |#define JS_BOOL int
   49|       |
   50|       |typedef struct JSRuntime JSRuntime;
   51|       |typedef struct JSContext JSContext;
   52|       |typedef struct JSClass JSClass;
   53|       |typedef uint32_t JSClassID;
   54|       |typedef uint32_t JSAtom;
   55|       |
   56|       |#if INTPTR_MAX >= INT64_MAX
   57|       |#define JS_PTR64
   58|       |#define JS_PTR64_DEF(a) a
   59|       |#else
   60|       |#define JS_PTR64_DEF(a)
   61|       |#endif
   62|       |
   63|       |#ifndef JS_PTR64
   64|       |#define JS_NAN_BOXING
   65|       |#endif
   66|       |
   67|       |#if defined(__SIZEOF_INT128__) && (INTPTR_MAX >= INT64_MAX)
   68|   171M|#define JS_LIMB_BITS 64
   69|       |#else
   70|       |#define JS_LIMB_BITS 32
   71|       |#endif
   72|       |
   73|      0|#define JS_SHORT_BIG_INT_BITS JS_LIMB_BITS
   74|       |    
   75|       |enum {
   76|       |    /* all tags with a reference count are negative */
   77|       |    JS_TAG_FIRST       = -9, /* first negative tag */
   78|       |    JS_TAG_BIG_INT     = -9,
   79|       |    JS_TAG_SYMBOL      = -8,
   80|       |    JS_TAG_STRING      = -7,
   81|       |    JS_TAG_STRING_ROPE = -6,
   82|       |    JS_TAG_MODULE      = -3, /* used internally */
   83|       |    JS_TAG_FUNCTION_BYTECODE = -2, /* used internally */
   84|       |    JS_TAG_OBJECT      = -1,
   85|       |
   86|       |    JS_TAG_INT         = 0,
   87|       |    JS_TAG_BOOL        = 1,
   88|       |    JS_TAG_NULL        = 2,
   89|       |    JS_TAG_UNDEFINED   = 3,
   90|       |    JS_TAG_UNINITIALIZED = 4,
   91|       |    JS_TAG_CATCH_OFFSET = 5,
   92|       |    JS_TAG_EXCEPTION   = 6,
   93|       |    JS_TAG_SHORT_BIG_INT = 7,
   94|       |    JS_TAG_FLOAT64     = 8,
   95|       |    /* any larger tag is FLOAT64 if JS_NAN_BOXING */
   96|       |};
   97|       |
   98|       |typedef struct JSRefCountHeader {
   99|       |    int ref_count;
  100|       |} JSRefCountHeader;
  101|       |
  102|  3.87M|#define JS_FLOAT64_NAN NAN
  103|       |
  104|       |#ifdef CONFIG_CHECK_JSVALUE
  105|       |/* JSValue consistency : it is not possible to run the code in this
  106|       |   mode, but it is useful to detect simple reference counting
  107|       |   errors. It would be interesting to modify a static C analyzer to
  108|       |   handle specific annotations (clang has such annotations but only
  109|       |   for objective C) */
  110|       |typedef struct __JSValue *JSValue;
  111|       |typedef const struct __JSValue *JSValueConst;
  112|       |
  113|       |#define JS_VALUE_GET_TAG(v) (int)((uintptr_t)(v) & 0xf)
  114|       |/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */
  115|       |#define JS_VALUE_GET_NORM_TAG(v) JS_VALUE_GET_TAG(v)
  116|       |#define JS_VALUE_GET_INT(v) (int)((intptr_t)(v) >> 4)
  117|       |#define JS_VALUE_GET_BOOL(v) JS_VALUE_GET_INT(v)
  118|       |#define JS_VALUE_GET_FLOAT64(v) (double)JS_VALUE_GET_INT(v)
  119|       |#define JS_VALUE_GET_SHORT_BIG_INT(v) JS_VALUE_GET_INT(v)
  120|       |#define JS_VALUE_GET_PTR(v) (void *)((intptr_t)(v) & ~0xf)
  121|       |
  122|       |#define JS_MKVAL(tag, val) (JSValue)(intptr_t)(((val) << 4) | (tag))
  123|       |#define JS_MKPTR(tag, p) (JSValue)((intptr_t)(p) | (tag))
  124|       |
  125|       |#define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)
  126|       |
  127|       |#define JS_NAN JS_MKVAL(JS_TAG_FLOAT64, 1)
  128|       |
  129|       |static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
  130|       |{
  131|       |    return JS_MKVAL(JS_TAG_FLOAT64, (int)d);
  132|       |}
  133|       |
  134|       |static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
  135|       |{
  136|       |    return 0;
  137|       |}
  138|       |
  139|       |static inline JSValue __JS_NewShortBigInt(JSContext *ctx, int32_t d)
  140|       |{
  141|       |    return JS_MKVAL(JS_TAG_SHORT_BIG_INT, d);
  142|       |}
  143|       |
  144|       |#elif defined(JS_NAN_BOXING)
  145|       |
  146|       |typedef uint64_t JSValue;
  147|       |
  148|       |#define JSValueConst JSValue
  149|       |
  150|       |#define JS_VALUE_GET_TAG(v) (int)((v) >> 32)
  151|       |#define JS_VALUE_GET_INT(v) (int)(v)
  152|       |#define JS_VALUE_GET_BOOL(v) (int)(v)
  153|       |#define JS_VALUE_GET_SHORT_BIG_INT(v) (int)(v)
  154|       |#define JS_VALUE_GET_PTR(v) (void *)(intptr_t)(v)
  155|       |
  156|       |#define JS_MKVAL(tag, val) (((uint64_t)(tag) << 32) | (uint32_t)(val))
  157|       |#define JS_MKPTR(tag, ptr) (((uint64_t)(tag) << 32) | (uintptr_t)(ptr))
  158|       |
  159|       |#define JS_FLOAT64_TAG_ADDEND (0x7ff80000 - JS_TAG_FIRST + 1) /* quiet NaN encoding */
  160|       |
  161|       |static inline double JS_VALUE_GET_FLOAT64(JSValue v)
  162|       |{
  163|       |    union {
  164|       |        JSValue v;
  165|       |        double d;
  166|       |    } u;
  167|       |    u.v = v;
  168|       |    u.v += (uint64_t)JS_FLOAT64_TAG_ADDEND << 32;
  169|       |    return u.d;
  170|       |}
  171|       |
  172|       |#define JS_NAN (0x7ff8000000000000 - ((uint64_t)JS_FLOAT64_TAG_ADDEND << 32))
  173|       |
  174|       |static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
  175|       |{
  176|       |    union {
  177|       |        double d;
  178|       |        uint64_t u64;
  179|       |    } u;
  180|       |    JSValue v;
  181|       |    u.d = d;
  182|       |    /* normalize NaN */
  183|       |    if (js_unlikely((u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000))
  184|       |        v = JS_NAN;
  185|       |    else
  186|       |        v = u.u64 - ((uint64_t)JS_FLOAT64_TAG_ADDEND << 32);
  187|       |    return v;
  188|       |}
  189|       |
  190|       |#define JS_TAG_IS_FLOAT64(tag) ((unsigned)((tag) - JS_TAG_FIRST) >= (JS_TAG_FLOAT64 - JS_TAG_FIRST))
  191|       |
  192|       |/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */
  193|       |static inline int JS_VALUE_GET_NORM_TAG(JSValue v)
  194|       |{
  195|       |    uint32_t tag;
  196|       |    tag = JS_VALUE_GET_TAG(v);
  197|       |    if (JS_TAG_IS_FLOAT64(tag))
  198|       |        return JS_TAG_FLOAT64;
  199|       |    else
  200|       |        return tag;
  201|       |}
  202|       |
  203|       |static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
  204|       |{
  205|       |    uint32_t tag;
  206|       |    tag = JS_VALUE_GET_TAG(v);
  207|       |    return tag == (JS_NAN >> 32);
  208|       |}
  209|       |
  210|       |static inline JSValue __JS_NewShortBigInt(JSContext *ctx, int32_t d)
  211|       |{
  212|       |    return JS_MKVAL(JS_TAG_SHORT_BIG_INT, d);
  213|       |}
  214|       |
  215|       |#else /* !JS_NAN_BOXING */
  216|       |
  217|       |typedef union JSValueUnion {
  218|       |    int32_t int32;
  219|       |    double float64;
  220|       |    void *ptr;
  221|       |#if JS_SHORT_BIG_INT_BITS == 32
  222|       |    int32_t short_big_int;
  223|       |#else
  224|       |    int64_t short_big_int;
  225|       |#endif
  226|       |} JSValueUnion;
  227|       |
  228|       |typedef struct JSValue {
  229|       |    JSValueUnion u;
  230|       |    int64_t tag;
  231|       |} JSValue;
  232|       |
  233|  16.8M|#define JSValueConst JSValue
  234|       |
  235|   540M|#define JS_VALUE_GET_TAG(v) ((int32_t)(v).tag)
  236|       |/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */
  237|  75.1M|#define JS_VALUE_GET_NORM_TAG(v) JS_VALUE_GET_TAG(v)
  238|  53.0M|#define JS_VALUE_GET_INT(v) ((v).u.int32)
  239|  11.6k|#define JS_VALUE_GET_BOOL(v) ((v).u.int32)
  240|  5.78M|#define JS_VALUE_GET_FLOAT64(v) ((v).u.float64)
  241|  9.54M|#define JS_VALUE_GET_SHORT_BIG_INT(v) ((v).u.short_big_int)
  242|   351M|#define JS_VALUE_GET_PTR(v) ((v).u.ptr)
  243|       |
  244|   110M|#define JS_MKVAL(tag, val) (JSValue){ (JSValueUnion){ .int32 = val }, tag }
  245|  92.4M|#define JS_MKPTR(tag, p) (JSValue){ (JSValueUnion){ .ptr = p }, tag }
  246|       |
  247|  13.9M|#define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)
  248|       |
  249|  3.87M|#define JS_NAN (JSValue){ .u.float64 = JS_FLOAT64_NAN, JS_TAG_FLOAT64 }
  250|       |
  251|       |static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
  252|  3.06M|{
  253|  3.06M|    JSValue v;
  254|  3.06M|    v.tag = JS_TAG_FLOAT64;
  255|  3.06M|    v.u.float64 = d;
  256|  3.06M|    return v;
  257|  3.06M|}
  ------------------
  | Unexecuted instantiation: qjs.c:__JS_NewFloat64
  ------------------
  | quickjs.c:__JS_NewFloat64:
  |  252|  3.06M|{
  |  253|  3.06M|    JSValue v;
  |  254|  3.06M|    v.tag = JS_TAG_FLOAT64;
  |  255|  3.06M|    v.u.float64 = d;
  |  256|  3.06M|    return v;
  |  257|  3.06M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:__JS_NewFloat64
  ------------------
  258|       |
  259|       |static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
  260|   659k|{
  261|   659k|    union {
  262|   659k|        double d;
  263|   659k|        uint64_t u64;
  264|   659k|    } u;
  265|   659k|    if (v.tag != JS_TAG_FLOAT64)
  266|   580k|        return 0;
  267|  78.6k|    u.d = v.u.float64;
  268|  78.6k|    return (u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000;
  269|   659k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_VALUE_IS_NAN
  ------------------
  | quickjs.c:JS_VALUE_IS_NAN:
  |  260|   659k|{
  |  261|   659k|    union {
  |  262|   659k|        double d;
  |  263|   659k|        uint64_t u64;
  |  264|   659k|    } u;
  |  265|   659k|    if (v.tag != JS_TAG_FLOAT64)
  |  266|   580k|        return 0;
  |  267|  78.6k|    u.d = v.u.float64;
  |  268|  78.6k|    return (u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000;
  |  269|   659k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_VALUE_IS_NAN
  ------------------
  270|       |
  271|       |static inline JSValue __JS_NewShortBigInt(JSContext *ctx, int64_t d)
  272|  7.79M|{
  273|  7.79M|    JSValue v;
  274|  7.79M|    v.tag = JS_TAG_SHORT_BIG_INT;
  275|  7.79M|    v.u.short_big_int = d;
  276|  7.79M|    return v;
  277|  7.79M|}
  ------------------
  | Unexecuted instantiation: qjs.c:__JS_NewShortBigInt
  ------------------
  | quickjs.c:__JS_NewShortBigInt:
  |  272|  7.79M|{
  |  273|  7.79M|    JSValue v;
  |  274|  7.79M|    v.tag = JS_TAG_SHORT_BIG_INT;
  |  275|  7.79M|    v.u.short_big_int = d;
  |  276|  7.79M|    return v;
  |  277|  7.79M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:__JS_NewShortBigInt
  ------------------
  278|       |
  279|       |#endif /* !JS_NAN_BOXING */
  280|       |
  281|       |#define JS_VALUE_IS_BOTH_INT(v1, v2) ((JS_VALUE_GET_TAG(v1) | JS_VALUE_GET_TAG(v2)) == 0)
  282|  4.17M|#define JS_VALUE_IS_BOTH_FLOAT(v1, v2) (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(v1)) && JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(v2)))
  283|       |
  284|   227M|#define JS_VALUE_HAS_REF_COUNT(v) ((unsigned)JS_VALUE_GET_TAG(v) >= (unsigned)JS_TAG_FIRST)
  285|       |
  286|       |/* special values */
  287|  5.13M|#define JS_NULL      JS_MKVAL(JS_TAG_NULL, 0)
  288|  56.3M|#define JS_UNDEFINED JS_MKVAL(JS_TAG_UNDEFINED, 0)
  289|  4.90M|#define JS_FALSE     JS_MKVAL(JS_TAG_BOOL, 0)
  290|  2.15M|#define JS_TRUE      JS_MKVAL(JS_TAG_BOOL, 1)
  291|   245k|#define JS_EXCEPTION JS_MKVAL(JS_TAG_EXCEPTION, 0)
  292|  47.6k|#define JS_UNINITIALIZED JS_MKVAL(JS_TAG_UNINITIALIZED, 0)
  293|       |
  294|       |/* flags for object properties */
  295|  32.0M|#define JS_PROP_CONFIGURABLE  (1 << 0)
  296|  28.1M|#define JS_PROP_WRITABLE      (1 << 1)
  297|   111M|#define JS_PROP_ENUMERABLE    (1 << 2)
  298|  23.6M|#define JS_PROP_C_W_E         (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)
  299|   392k|#define JS_PROP_LENGTH        (1 << 3) /* used internally in Arrays */
  300|   109M|#define JS_PROP_TMASK         (3 << 4) /* mask for NORMAL, GETSET, VARREF, AUTOINIT */
  301|   217k|#define JS_PROP_NORMAL         (0 << 4)
  302|  29.0M|#define JS_PROP_GETSET         (1 << 4)
  303|  19.5M|#define JS_PROP_VARREF         (2 << 4) /* used internally */
  304|  25.7M|#define JS_PROP_AUTOINIT       (3 << 4) /* used internally */
  305|       |
  306|       |/* flags for JS_DefineProperty */
  307|  1.26M|#define JS_PROP_HAS_SHIFT        8
  308|  13.4M|#define JS_PROP_HAS_CONFIGURABLE (1 << 8)
  309|  13.0M|#define JS_PROP_HAS_WRITABLE     (1 << 9)
  310|  13.4M|#define JS_PROP_HAS_ENUMERABLE   (1 << 10)
  311|  28.9M|#define JS_PROP_HAS_GET          (1 << 11)
  312|  28.9M|#define JS_PROP_HAS_SET          (1 << 12)
  313|  25.4M|#define JS_PROP_HAS_VALUE        (1 << 13)
  314|       |
  315|       |/* throw an exception if false would be returned
  316|       |   (JS_DefineProperty/JS_SetProperty) */
  317|  3.52M|#define JS_PROP_THROW            (1 << 14)
  318|       |/* throw an exception if false would be returned in strict mode
  319|       |   (JS_SetProperty) */
  320|  5.00M|#define JS_PROP_THROW_STRICT     (1 << 15)
  321|       |
  322|      0|#define JS_PROP_NO_ADD           (1 << 16) /* internal use */
  323|   802k|#define JS_PROP_NO_EXOTIC        (1 << 17) /* internal use */
  324|       |
  325|       |#ifndef JS_DEFAULT_STACK_SIZE
  326|  17.7k|#define JS_DEFAULT_STACK_SIZE (1024 * 1024)
  327|       |#endif
  328|       |
  329|       |/* JS_Eval() flags */
  330|   101k|#define JS_EVAL_TYPE_GLOBAL   (0 << 0) /* global code (default) */
  331|   263k|#define JS_EVAL_TYPE_MODULE   (1 << 0) /* module code */
  332|   312k|#define JS_EVAL_TYPE_DIRECT   (2 << 0) /* direct call (internal use) */
  333|   121k|#define JS_EVAL_TYPE_INDIRECT (3 << 0) /* indirect call (internal use) */
  334|  53.3k|#define JS_EVAL_TYPE_MASK     (3 << 0)
  335|       |
  336|  17.7k|#define JS_EVAL_FLAG_STRICT   (1 << 3) /* force 'strict' mode */
  337|       |/* compile but do not run. The result is an object with a
  338|       |   JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed
  339|       |   with JS_EvalFunction(). */
  340|  10.1k|#define JS_EVAL_FLAG_COMPILE_ONLY (1 << 5)
  341|       |/* don't include the stack frames before this eval in the Error() backtraces */
  342|  17.7k|#define JS_EVAL_FLAG_BACKTRACE_BARRIER (1 << 6)
  343|       |/* allow top-level await in normal script. JS_Eval() returns a
  344|       |   promise. Only allowed with JS_EVAL_TYPE_GLOBAL */
  345|  16.8k|#define JS_EVAL_FLAG_ASYNC (1 << 7)
  346|       |
  347|       |typedef JSValue JSCFunction(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
  348|       |typedef JSValue JSCFunctionMagic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);
  349|       |typedef JSValue JSCFunctionData(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic, JSValue *func_data);
  350|       |
  351|       |typedef struct JSMallocState {
  352|       |    size_t malloc_count;
  353|       |    size_t malloc_size;
  354|       |    size_t malloc_limit;
  355|       |    void *opaque; /* user opaque */
  356|       |} JSMallocState;
  357|       |
  358|       |typedef struct JSMallocFunctions {
  359|       |    void *(*js_malloc)(JSMallocState *s, size_t size);
  360|       |    void (*js_free)(JSMallocState *s, void *ptr);
  361|       |    void *(*js_realloc)(JSMallocState *s, void *ptr, size_t size);
  362|       |    size_t (*js_malloc_usable_size)(const void *ptr);
  363|       |} JSMallocFunctions;
  364|       |
  365|       |typedef struct JSGCObjectHeader JSGCObjectHeader;
  366|       |
  367|       |JSRuntime *JS_NewRuntime(void);
  368|       |/* info lifetime must exceed that of rt */
  369|       |void JS_SetRuntimeInfo(JSRuntime *rt, const char *info);
  370|       |void JS_SetMemoryLimit(JSRuntime *rt, size_t limit);
  371|       |void JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold);
  372|       |/* use 0 to disable maximum stack size check */
  373|       |void JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size);
  374|       |/* should be called when changing thread to update the stack top value
  375|       |   used to check stack overflow. */
  376|       |void JS_UpdateStackTop(JSRuntime *rt);
  377|       |JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque);
  378|       |void JS_FreeRuntime(JSRuntime *rt);
  379|       |void *JS_GetRuntimeOpaque(JSRuntime *rt);
  380|       |void JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque);
  381|       |typedef void JS_MarkFunc(JSRuntime *rt, JSGCObjectHeader *gp);
  382|       |void JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
  383|       |void JS_RunGC(JSRuntime *rt);
  384|       |JS_BOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj);
  385|       |
  386|       |JSContext *JS_NewContext(JSRuntime *rt);
  387|       |void JS_FreeContext(JSContext *s);
  388|       |JSContext *JS_DupContext(JSContext *ctx);
  389|       |void *JS_GetContextOpaque(JSContext *ctx);
  390|       |void JS_SetContextOpaque(JSContext *ctx, void *opaque);
  391|       |JSRuntime *JS_GetRuntime(JSContext *ctx);
  392|       |void JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj);
  393|       |JSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id);
  394|       |
  395|       |/* the following functions are used to select the intrinsic object to
  396|       |   save memory */
  397|       |JSContext *JS_NewContextRaw(JSRuntime *rt);
  398|       |void JS_AddIntrinsicBaseObjects(JSContext *ctx);
  399|       |void JS_AddIntrinsicDate(JSContext *ctx);
  400|       |void JS_AddIntrinsicEval(JSContext *ctx);
  401|       |void JS_AddIntrinsicStringNormalize(JSContext *ctx);
  402|       |void JS_AddIntrinsicRegExpCompiler(JSContext *ctx);
  403|       |void JS_AddIntrinsicRegExp(JSContext *ctx);
  404|       |void JS_AddIntrinsicJSON(JSContext *ctx);
  405|       |void JS_AddIntrinsicProxy(JSContext *ctx);
  406|       |void JS_AddIntrinsicMapSet(JSContext *ctx);
  407|       |void JS_AddIntrinsicTypedArrays(JSContext *ctx);
  408|       |void JS_AddIntrinsicPromise(JSContext *ctx);
  409|       |void JS_AddIntrinsicWeakRef(JSContext *ctx);
  410|       |
  411|       |JSValue js_string_codePointRange(JSContext *ctx, JSValueConst this_val,
  412|       |                                 int argc, JSValueConst *argv);
  413|       |
  414|       |void *js_malloc_rt(JSRuntime *rt, size_t size);
  415|       |void js_free_rt(JSRuntime *rt, void *ptr);
  416|       |void *js_realloc_rt(JSRuntime *rt, void *ptr, size_t size);
  417|       |size_t js_malloc_usable_size_rt(JSRuntime *rt, const void *ptr);
  418|       |void *js_mallocz_rt(JSRuntime *rt, size_t size);
  419|       |
  420|       |void *js_malloc(JSContext *ctx, size_t size);
  421|       |void js_free(JSContext *ctx, void *ptr);
  422|       |void *js_realloc(JSContext *ctx, void *ptr, size_t size);
  423|       |size_t js_malloc_usable_size(JSContext *ctx, const void *ptr);
  424|       |void *js_realloc2(JSContext *ctx, void *ptr, size_t size, size_t *pslack);
  425|       |void *js_mallocz(JSContext *ctx, size_t size);
  426|       |char *js_strdup(JSContext *ctx, const char *str);
  427|       |char *js_strndup(JSContext *ctx, const char *s, size_t n);
  428|       |
  429|       |typedef struct JSMemoryUsage {
  430|       |    int64_t malloc_size, malloc_limit, memory_used_size;
  431|       |    int64_t malloc_count;
  432|       |    int64_t memory_used_count;
  433|       |    int64_t atom_count, atom_size;
  434|       |    int64_t str_count, str_size;
  435|       |    int64_t obj_count, obj_size;
  436|       |    int64_t prop_count, prop_size;
  437|       |    int64_t shape_count, shape_size;
  438|       |    int64_t js_func_count, js_func_size, js_func_code_size;
  439|       |    int64_t js_func_pc2line_count, js_func_pc2line_size;
  440|       |    int64_t c_func_count, array_count;
  441|       |    int64_t fast_array_count, fast_array_elements;
  442|       |    int64_t binary_object_count, binary_object_size;
  443|       |} JSMemoryUsage;
  444|       |
  445|       |void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s);
  446|       |void JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt);
  447|       |
  448|       |/* atom support */
  449|   167M|#define JS_ATOM_NULL 0
  450|       |
  451|       |JSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len);
  452|       |JSAtom JS_NewAtom(JSContext *ctx, const char *str);
  453|       |JSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n);
  454|       |JSAtom JS_DupAtom(JSContext *ctx, JSAtom v);
  455|       |void JS_FreeAtom(JSContext *ctx, JSAtom v);
  456|       |void JS_FreeAtomRT(JSRuntime *rt, JSAtom v);
  457|       |JSValue JS_AtomToValue(JSContext *ctx, JSAtom atom);
  458|       |JSValue JS_AtomToString(JSContext *ctx, JSAtom atom);
  459|       |const char *JS_AtomToCString(JSContext *ctx, JSAtom atom);
  460|       |JSAtom JS_ValueToAtom(JSContext *ctx, JSValueConst val);
  461|       |
  462|       |/* object class support */
  463|       |
  464|       |typedef struct JSPropertyEnum {
  465|       |    JS_BOOL is_enumerable;
  466|       |    JSAtom atom;
  467|       |} JSPropertyEnum;
  468|       |
  469|       |typedef struct JSPropertyDescriptor {
  470|       |    int flags;
  471|       |    JSValue value;
  472|       |    JSValue getter;
  473|       |    JSValue setter;
  474|       |} JSPropertyDescriptor;
  475|       |
  476|       |typedef struct JSClassExoticMethods {
  477|       |    /* Return -1 if exception (can only happen in case of Proxy object),
  478|       |       FALSE if the property does not exists, TRUE if it exists. If 1 is
  479|       |       returned, the property descriptor 'desc' is filled if != NULL. */
  480|       |    int (*get_own_property)(JSContext *ctx, JSPropertyDescriptor *desc,
  481|       |                             JSValueConst obj, JSAtom prop);
  482|       |    /* '*ptab' should hold the '*plen' property keys. Return 0 if OK,
  483|       |       -1 if exception. The 'is_enumerable' field is ignored.
  484|       |    */
  485|       |    int (*get_own_property_names)(JSContext *ctx, JSPropertyEnum **ptab,
  486|       |                                  uint32_t *plen,
  487|       |                                  JSValueConst obj);
  488|       |    /* return < 0 if exception, or TRUE/FALSE */
  489|       |    int (*delete_property)(JSContext *ctx, JSValueConst obj, JSAtom prop);
  490|       |    /* return < 0 if exception or TRUE/FALSE */
  491|       |    int (*define_own_property)(JSContext *ctx, JSValueConst this_obj,
  492|       |                               JSAtom prop, JSValueConst val,
  493|       |                               JSValueConst getter, JSValueConst setter,
  494|       |                               int flags);
  495|       |    /* The following methods can be emulated with the previous ones,
  496|       |       so they are usually not needed */
  497|       |    /* return < 0 if exception or TRUE/FALSE */
  498|       |    int (*has_property)(JSContext *ctx, JSValueConst obj, JSAtom atom);
  499|       |    JSValue (*get_property)(JSContext *ctx, JSValueConst obj, JSAtom atom,
  500|       |                            JSValueConst receiver);
  501|       |    /* return < 0 if exception or TRUE/FALSE */
  502|       |    int (*set_property)(JSContext *ctx, JSValueConst obj, JSAtom atom,
  503|       |                        JSValueConst value, JSValueConst receiver, int flags);
  504|       |} JSClassExoticMethods;
  505|       |
  506|       |typedef void JSClassFinalizer(JSRuntime *rt, JSValue val);
  507|       |typedef void JSClassGCMark(JSRuntime *rt, JSValueConst val,
  508|       |                           JS_MarkFunc *mark_func);
  509|      2|#define JS_CALL_FLAG_CONSTRUCTOR (1 << 0)
  510|       |typedef JSValue JSClassCall(JSContext *ctx, JSValueConst func_obj,
  511|       |                            JSValueConst this_val, int argc, JSValueConst *argv,
  512|       |                            int flags);
  513|       |
  514|       |typedef struct JSClassDef {
  515|       |    const char *class_name;
  516|       |    JSClassFinalizer *finalizer;
  517|       |    JSClassGCMark *gc_mark;
  518|       |    /* if call != NULL, the object is a function. If (flags &
  519|       |       JS_CALL_FLAG_CONSTRUCTOR) != 0, the function is called as a
  520|       |       constructor. In this case, 'this_val' is new.target. A
  521|       |       constructor call only happens if the object constructor bit is
  522|       |       set (see JS_SetConstructorBit()). */
  523|       |    JSClassCall *call;
  524|       |    /* XXX: suppress this indirection ? It is here only to save memory
  525|       |       because only a few classes need these methods */
  526|       |    JSClassExoticMethods *exotic;
  527|       |} JSClassDef;
  528|       |
  529|      0|#define JS_INVALID_CLASS_ID 0
  530|       |JSClassID JS_NewClassID(JSClassID *pclass_id);
  531|       |/* Returns the class ID if `v` is an object, otherwise returns JS_INVALID_CLASS_ID. */
  532|       |JSClassID JS_GetClassID(JSValue v);
  533|       |int JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def);
  534|       |int JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);
  535|       |
  536|       |/* value handling */
  537|       |
  538|       |static js_force_inline JSValue JS_NewBool(JSContext *ctx, JS_BOOL val)
  539|  11.1M|{
  540|  11.1M|    return JS_MKVAL(JS_TAG_BOOL, (val != 0));
  541|  11.1M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewBool
  ------------------
  | quickjs.c:JS_NewBool:
  |  539|  11.1M|{
  |  540|  11.1M|    return JS_MKVAL(JS_TAG_BOOL, (val != 0));
  |  541|  11.1M|}
  ------------------
  | quickjs-libc.c:JS_NewBool:
  |  539|    367|{
  |  540|    367|    return JS_MKVAL(JS_TAG_BOOL, (val != 0));
  |  541|    367|}
  ------------------
  542|       |
  543|       |static js_force_inline JSValue JS_NewInt32(JSContext *ctx, int32_t val)
  544|  29.1M|{
  545|  29.1M|    return JS_MKVAL(JS_TAG_INT, val);
  546|  29.1M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewInt32
  ------------------
  | quickjs.c:JS_NewInt32:
  |  544|  29.1M|{
  |  545|  29.1M|    return JS_MKVAL(JS_TAG_INT, val);
  |  546|  29.1M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_NewInt32
  ------------------
  547|       |
  548|       |static js_force_inline JSValue JS_NewCatchOffset(JSContext *ctx, int32_t val)
  549|  7.47k|{
  550|  7.47k|    return JS_MKVAL(JS_TAG_CATCH_OFFSET, val);
  551|  7.47k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewCatchOffset
  ------------------
  | quickjs.c:JS_NewCatchOffset:
  |  549|  7.47k|{
  |  550|  7.47k|    return JS_MKVAL(JS_TAG_CATCH_OFFSET, val);
  |  551|  7.47k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_NewCatchOffset
  ------------------
  552|       |
  553|       |static js_force_inline JSValue JS_NewInt64(JSContext *ctx, int64_t val)
  554|   158k|{
  555|   158k|    JSValue v;
  556|   158k|    if (val == (int32_t)val) {
  557|   119k|        v = JS_NewInt32(ctx, val);
  558|   119k|    } else {
  559|  38.3k|        v = __JS_NewFloat64(ctx, val);
  560|  38.3k|    }
  561|   158k|    return v;
  562|   158k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewInt64
  ------------------
  | quickjs.c:JS_NewInt64:
  |  554|   158k|{
  |  555|   158k|    JSValue v;
  |  556|   158k|    if (val == (int32_t)val) {
  |  557|   119k|        v = JS_NewInt32(ctx, val);
  |  558|   119k|    } else {
  |  559|  38.3k|        v = __JS_NewFloat64(ctx, val);
  |  560|  38.3k|    }
  |  561|   158k|    return v;
  |  562|   158k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_NewInt64
  ------------------
  563|       |
  564|       |static js_force_inline JSValue JS_NewUint32(JSContext *ctx, uint32_t val)
  565|  9.68M|{
  566|  9.68M|    JSValue v;
  567|  9.68M|    if (val <= 0x7fffffff) {
  568|  9.68M|        v = JS_NewInt32(ctx, val);
  569|  9.68M|    } else {
  570|  6.76k|        v = __JS_NewFloat64(ctx, val);
  571|  6.76k|    }
  572|  9.68M|    return v;
  573|  9.68M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewUint32
  ------------------
  | quickjs.c:JS_NewUint32:
  |  565|  9.68M|{
  |  566|  9.68M|    JSValue v;
  |  567|  9.68M|    if (val <= 0x7fffffff) {
  |  568|  9.68M|        v = JS_NewInt32(ctx, val);
  |  569|  9.68M|    } else {
  |  570|  6.76k|        v = __JS_NewFloat64(ctx, val);
  |  571|  6.76k|    }
  |  572|  9.68M|    return v;
  |  573|  9.68M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_NewUint32
  ------------------
  574|       |
  575|       |JSValue JS_NewBigInt64(JSContext *ctx, int64_t v);
  576|       |JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v);
  577|       |
  578|       |static js_force_inline JSValue JS_NewFloat64(JSContext *ctx, double d)
  579|   928k|{
  580|   928k|    int32_t val;
  581|   928k|    union {
  582|   928k|        double d;
  583|   928k|        uint64_t u;
  584|   928k|    } u, t;
  585|   928k|    if (d >= INT32_MIN && d <= INT32_MAX) {
  586|   766k|        u.d = d;
  587|   766k|        val = (int32_t)d;
  588|   766k|        t.d = val;
  589|       |        /* -0 cannot be represented as integer, so we compare the bit
  590|       |           representation */
  591|   766k|        if (u.u == t.u)
  592|   731k|            return JS_MKVAL(JS_TAG_INT, val);
  593|   766k|    }
  594|   197k|    return __JS_NewFloat64(ctx, d);
  595|   928k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewFloat64
  ------------------
  | quickjs.c:JS_NewFloat64:
  |  579|   928k|{
  |  580|   928k|    int32_t val;
  |  581|   928k|    union {
  |  582|   928k|        double d;
  |  583|   928k|        uint64_t u;
  |  584|   928k|    } u, t;
  |  585|   928k|    if (d >= INT32_MIN && d <= INT32_MAX) {
  |  586|   766k|        u.d = d;
  |  587|   766k|        val = (int32_t)d;
  |  588|   766k|        t.d = val;
  |  589|       |        /* -0 cannot be represented as integer, so we compare the bit
  |  590|       |           representation */
  |  591|   766k|        if (u.u == t.u)
  |  592|   731k|            return JS_MKVAL(JS_TAG_INT, val);
  |  593|   766k|    }
  |  594|   197k|    return __JS_NewFloat64(ctx, d);
  |  595|   928k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_NewFloat64
  ------------------
  596|       |
  597|       |static inline JS_BOOL JS_IsNumber(JSValueConst v)
  598|      0|{
  599|      0|    int tag = JS_VALUE_GET_TAG(v);
  600|      0|    return tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag);
  601|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsNumber
  ------------------
  | Unexecuted instantiation: quickjs.c:JS_IsNumber
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsNumber
  ------------------
  602|       |
  603|       |static inline JS_BOOL JS_IsBigInt(JSContext *ctx, JSValueConst v)
  604|      0|{
  605|      0|    int tag = JS_VALUE_GET_TAG(v);
  606|      0|    return tag == JS_TAG_BIG_INT || tag == JS_TAG_SHORT_BIG_INT;
  607|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsBigInt
  ------------------
  | Unexecuted instantiation: quickjs.c:JS_IsBigInt
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsBigInt
  ------------------
  608|       |
  609|       |static inline JS_BOOL JS_IsBool(JSValueConst v)
  610|      0|{
  611|      0|    return JS_VALUE_GET_TAG(v) == JS_TAG_BOOL;
  612|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsBool
  ------------------
  | Unexecuted instantiation: quickjs.c:JS_IsBool
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsBool
  ------------------
  613|       |
  614|       |static inline JS_BOOL JS_IsNull(JSValueConst v)
  615|  20.0M|{
  616|  20.0M|    return JS_VALUE_GET_TAG(v) == JS_TAG_NULL;
  617|  20.0M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsNull
  ------------------
  | quickjs.c:JS_IsNull:
  |  615|  20.0M|{
  |  616|  20.0M|    return JS_VALUE_GET_TAG(v) == JS_TAG_NULL;
  |  617|  20.0M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsNull
  ------------------
  618|       |
  619|       |static inline JS_BOOL JS_IsUndefined(JSValueConst v)
  620|  15.9M|{
  621|  15.9M|    return JS_VALUE_GET_TAG(v) == JS_TAG_UNDEFINED;
  622|  15.9M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsUndefined
  ------------------
  | quickjs.c:JS_IsUndefined:
  |  620|  15.9M|{
  |  621|  15.9M|    return JS_VALUE_GET_TAG(v) == JS_TAG_UNDEFINED;
  |  622|  15.9M|}
  ------------------
  | quickjs-libc.c:JS_IsUndefined:
  |  620|  14.2k|{
  |  621|  14.2k|    return JS_VALUE_GET_TAG(v) == JS_TAG_UNDEFINED;
  |  622|  14.2k|}
  ------------------
  623|       |
  624|       |static inline JS_BOOL JS_IsException(JSValueConst v)
  625|  64.8M|{
  626|  64.8M|    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_EXCEPTION);
  627|  64.8M|}
  ------------------
  | qjs.c:JS_IsException:
  |  625|  18.3k|{
  |  626|  18.3k|    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_EXCEPTION);
  |  627|  18.3k|}
  ------------------
  | quickjs.c:JS_IsException:
  |  625|  64.8M|{
  |  626|  64.8M|    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_EXCEPTION);
  |  627|  64.8M|}
  ------------------
  | quickjs-libc.c:JS_IsException:
  |  625|    367|{
  |  626|    367|    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_EXCEPTION);
  |  627|    367|}
  ------------------
  628|       |
  629|       |static inline JS_BOOL JS_IsUninitialized(JSValueConst v)
  630|   424k|{
  631|   424k|    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_UNINITIALIZED);
  632|   424k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsUninitialized
  ------------------
  | quickjs.c:JS_IsUninitialized:
  |  630|   424k|{
  |  631|   424k|    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_UNINITIALIZED);
  |  632|   424k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsUninitialized
  ------------------
  633|       |
  634|       |static inline JS_BOOL JS_IsString(JSValueConst v)
  635|  3.14M|{
  636|  3.14M|    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING ||
  637|  3.14M|        JS_VALUE_GET_TAG(v) == JS_TAG_STRING_ROPE;
  638|  3.14M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsString
  ------------------
  | quickjs.c:JS_IsString:
  |  635|  3.14M|{
  |  636|  3.14M|    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING ||
  |  637|  3.14M|        JS_VALUE_GET_TAG(v) == JS_TAG_STRING_ROPE;
  |  638|  3.14M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsString
  ------------------
  639|       |
  640|       |static inline JS_BOOL JS_IsSymbol(JSValueConst v)
  641|      0|{
  642|      0|    return JS_VALUE_GET_TAG(v) == JS_TAG_SYMBOL;
  643|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsSymbol
  ------------------
  | Unexecuted instantiation: quickjs.c:JS_IsSymbol
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsSymbol
  ------------------
  644|       |
  645|       |static inline JS_BOOL JS_IsObject(JSValueConst v)
  646|   902k|{
  647|   902k|    return JS_VALUE_GET_TAG(v) == JS_TAG_OBJECT;
  648|   902k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_IsObject
  ------------------
  | quickjs.c:JS_IsObject:
  |  646|   902k|{
  |  647|   902k|    return JS_VALUE_GET_TAG(v) == JS_TAG_OBJECT;
  |  648|   902k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_IsObject
  ------------------
  649|       |
  650|       |JSValue JS_Throw(JSContext *ctx, JSValue obj);
  651|       |JSValue JS_GetException(JSContext *ctx);
  652|       |JS_BOOL JS_HasException(JSContext *ctx);
  653|       |JS_BOOL JS_IsError(JSContext *ctx, JSValueConst val);
  654|       |void JS_SetUncatchableError(JSContext *ctx, JSValueConst val, JS_BOOL flag);
  655|       |void JS_ResetUncatchableError(JSContext *ctx);
  656|       |JSValue JS_NewError(JSContext *ctx);
  657|       |JSValue __js_printf_like(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...);
  658|       |JSValue __js_printf_like(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...);
  659|       |JSValue __js_printf_like(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...);
  660|       |JSValue __js_printf_like(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...);
  661|       |JSValue __js_printf_like(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
  662|       |JSValue JS_ThrowOutOfMemory(JSContext *ctx);
  663|       |
  664|       |void __JS_FreeValue(JSContext *ctx, JSValue v);
  665|       |static inline void JS_FreeValue(JSContext *ctx, JSValue v)
  666|  94.9M|{
  667|  94.9M|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  668|  57.7M|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  669|  57.7M|        if (--p->ref_count <= 0) {
  670|  18.0M|            __JS_FreeValue(ctx, v);
  671|  18.0M|        }
  672|  57.7M|    }
  673|  94.9M|}
  ------------------
  | qjs.c:JS_FreeValue:
  |  666|  17.4k|{
  |  667|  17.4k|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  |  668|  1.21k|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  |  669|  1.21k|        if (--p->ref_count <= 0) {
  |  670|    874|            __JS_FreeValue(ctx, v);
  |  671|    874|        }
  |  672|  1.21k|    }
  |  673|  17.4k|}
  ------------------
  | quickjs.c:JS_FreeValue:
  |  666|  94.8M|{
  |  667|  94.8M|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  |  668|  57.6M|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  |  669|  57.6M|        if (--p->ref_count <= 0) {
  |  670|  17.9M|            __JS_FreeValue(ctx, v);
  |  671|  17.9M|        }
  |  672|  57.6M|    }
  |  673|  94.8M|}
  ------------------
  | quickjs-libc.c:JS_FreeValue:
  |  666|  46.3k|{
  |  667|  46.3k|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  |  668|  46.3k|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  |  669|  46.3k|        if (--p->ref_count <= 0) {
  |  670|  13.9k|            __JS_FreeValue(ctx, v);
  |  671|  13.9k|        }
  |  672|  46.3k|    }
  |  673|  46.3k|}
  ------------------
  674|       |void __JS_FreeValueRT(JSRuntime *rt, JSValue v);
  675|       |static inline void JS_FreeValueRT(JSRuntime *rt, JSValue v)
  676|  28.8M|{
  677|  28.8M|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  678|  19.9M|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  679|  19.9M|        if (--p->ref_count <= 0) {
  680|  5.48M|            __JS_FreeValueRT(rt, v);
  681|  5.48M|        }
  682|  19.9M|    }
  683|  28.8M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_FreeValueRT
  ------------------
  | quickjs.c:JS_FreeValueRT:
  |  676|  28.8M|{
  |  677|  28.8M|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  |  678|  19.9M|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  |  679|  19.9M|        if (--p->ref_count <= 0) {
  |  680|  5.48M|            __JS_FreeValueRT(rt, v);
  |  681|  5.48M|        }
  |  682|  19.9M|    }
  |  683|  28.8M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_FreeValueRT
  ------------------
  684|       |
  685|       |static inline JSValue JS_DupValue(JSContext *ctx, JSValueConst v)
  686|  71.6M|{
  687|  71.6M|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  688|  55.1M|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  689|  55.1M|        p->ref_count++;
  690|  55.1M|    }
  691|  71.6M|    return (JSValue)v;
  692|  71.6M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_DupValue
  ------------------
  | quickjs.c:JS_DupValue:
  |  686|  71.6M|{
  |  687|  71.6M|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  |  688|  55.1M|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  |  689|  55.1M|        p->ref_count++;
  |  690|  55.1M|    }
  |  691|  71.6M|    return (JSValue)v;
  |  692|  71.6M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_DupValue
  ------------------
  693|       |
  694|       |static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
  695|  20.4k|{
  696|  20.4k|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  697|  11.6k|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  698|  11.6k|        p->ref_count++;
  699|  11.6k|    }
  700|  20.4k|    return (JSValue)v;
  701|  20.4k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_DupValueRT
  ------------------
  | quickjs.c:JS_DupValueRT:
  |  695|  20.4k|{
  |  696|  20.4k|    if (JS_VALUE_HAS_REF_COUNT(v)) {
  |  697|  11.6k|        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
  |  698|  11.6k|        p->ref_count++;
  |  699|  11.6k|    }
  |  700|  20.4k|    return (JSValue)v;
  |  701|  20.4k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_DupValueRT
  ------------------
  702|       |
  703|       |JS_BOOL JS_StrictEq(JSContext *ctx, JSValueConst op1, JSValueConst op2);
  704|       |JS_BOOL JS_SameValue(JSContext *ctx, JSValueConst op1, JSValueConst op2);
  705|       |JS_BOOL JS_SameValueZero(JSContext *ctx, JSValueConst op1, JSValueConst op2);
  706|       |
  707|       |int JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */
  708|       |int JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val);
  709|       |static inline int JS_ToUint32(JSContext *ctx, uint32_t *pres, JSValueConst val)
  710|  2.75M|{
  711|  2.75M|    return JS_ToInt32(ctx, (int32_t*)pres, val);
  712|  2.75M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_ToUint32
  ------------------
  | quickjs.c:JS_ToUint32:
  |  710|  2.75M|{
  |  711|  2.75M|    return JS_ToInt32(ctx, (int32_t*)pres, val);
  |  712|  2.75M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_ToUint32
  ------------------
  713|       |int JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val);
  714|       |int JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val);
  715|       |int JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val);
  716|       |/* return an exception if 'val' is a Number */
  717|       |int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val);
  718|       |/* same as JS_ToInt64() but allow BigInt */
  719|       |int JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val);
  720|       |
  721|       |JSValue JS_NewStringLen(JSContext *ctx, const char *str1, size_t len1);
  722|       |static inline JSValue JS_NewString(JSContext *ctx, const char *str)
  723|   281k|{
  724|   281k|    return JS_NewStringLen(ctx, str, strlen(str));
  725|   281k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewString
  ------------------
  | quickjs.c:JS_NewString:
  |  723|   262k|{
  |  724|   262k|    return JS_NewStringLen(ctx, str, strlen(str));
  |  725|   262k|}
  ------------------
  | quickjs-libc.c:JS_NewString:
  |  723|  18.1k|{
  |  724|  18.1k|    return JS_NewStringLen(ctx, str, strlen(str));
  |  725|  18.1k|}
  ------------------
  726|       |JSValue JS_NewAtomString(JSContext *ctx, const char *str);
  727|       |JSValue JS_ToString(JSContext *ctx, JSValueConst val);
  728|       |JSValue JS_ToPropertyKey(JSContext *ctx, JSValueConst val);
  729|       |const char *JS_ToCStringLen2(JSContext *ctx, size_t *plen, JSValueConst val1, JS_BOOL cesu8);
  730|       |static inline const char *JS_ToCStringLen(JSContext *ctx, size_t *plen, JSValueConst val1)
  731|  2.22M|{
  732|  2.22M|    return JS_ToCStringLen2(ctx, plen, val1, 0);
  733|  2.22M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_ToCStringLen
  ------------------
  | quickjs.c:JS_ToCStringLen:
  |  731|  2.19M|{
  |  732|  2.19M|    return JS_ToCStringLen2(ctx, plen, val1, 0);
  |  733|  2.19M|}
  ------------------
  | quickjs-libc.c:JS_ToCStringLen:
  |  731|  28.2k|{
  |  732|  28.2k|    return JS_ToCStringLen2(ctx, plen, val1, 0);
  |  733|  28.2k|}
  ------------------
  734|       |static inline const char *JS_ToCString(JSContext *ctx, JSValueConst val1)
  735|   318k|{
  736|   318k|    return JS_ToCStringLen2(ctx, NULL, val1, 0);
  737|   318k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_ToCString
  ------------------
  | quickjs.c:JS_ToCString:
  |  735|   289k|{
  |  736|   289k|    return JS_ToCStringLen2(ctx, NULL, val1, 0);
  |  737|   289k|}
  ------------------
  | quickjs-libc.c:JS_ToCString:
  |  735|  28.5k|{
  |  736|  28.5k|    return JS_ToCStringLen2(ctx, NULL, val1, 0);
  |  737|  28.5k|}
  ------------------
  738|       |void JS_FreeCString(JSContext *ctx, const char *ptr);
  739|       |
  740|       |JSValue JS_NewObjectProtoClass(JSContext *ctx, JSValueConst proto, JSClassID class_id);
  741|       |JSValue JS_NewObjectClass(JSContext *ctx, int class_id);
  742|       |JSValue JS_NewObjectProto(JSContext *ctx, JSValueConst proto);
  743|       |JSValue JS_NewObject(JSContext *ctx);
  744|       |
  745|       |JS_BOOL JS_IsFunction(JSContext* ctx, JSValueConst val);
  746|       |JS_BOOL JS_IsConstructor(JSContext* ctx, JSValueConst val);
  747|       |JS_BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, JS_BOOL val);
  748|       |
  749|       |JSValue JS_NewArray(JSContext *ctx);
  750|       |int JS_IsArray(JSContext *ctx, JSValueConst val);
  751|       |
  752|       |JSValue JS_NewDate(JSContext *ctx, double epoch_ms);
  753|       |
  754|       |JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
  755|       |                               JSAtom prop, JSValueConst receiver,
  756|       |                               JS_BOOL throw_ref_error);
  757|       |static js_force_inline JSValue JS_GetProperty(JSContext *ctx, JSValueConst this_obj,
  758|       |                                              JSAtom prop)
  759|  17.6M|{
  760|  17.6M|    return JS_GetPropertyInternal(ctx, this_obj, prop, this_obj, 0);
  761|  17.6M|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_GetProperty
  ------------------
  | quickjs.c:JS_GetProperty:
  |  759|  17.6M|{
  |  760|  17.6M|    return JS_GetPropertyInternal(ctx, this_obj, prop, this_obj, 0);
  |  761|  17.6M|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_GetProperty
  ------------------
  762|       |JSValue JS_GetPropertyStr(JSContext *ctx, JSValueConst this_obj,
  763|       |                          const char *prop);
  764|       |JSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
  765|       |                             uint32_t idx);
  766|       |
  767|       |int JS_SetPropertyInternal(JSContext *ctx, JSValueConst obj,
  768|       |                           JSAtom prop, JSValue val, JSValueConst this_obj,
  769|       |                           int flags);
  770|       |static inline int JS_SetProperty(JSContext *ctx, JSValueConst this_obj,
  771|       |                                 JSAtom prop, JSValue val)
  772|      0|{
  773|      0|    return JS_SetPropertyInternal(ctx, this_obj, prop, val, this_obj, JS_PROP_THROW);
  774|      0|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_SetProperty
  ------------------
  | Unexecuted instantiation: quickjs.c:JS_SetProperty
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_SetProperty
  ------------------
  775|       |int JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
  776|       |                         uint32_t idx, JSValue val);
  777|       |int JS_SetPropertyInt64(JSContext *ctx, JSValueConst this_obj,
  778|       |                        int64_t idx, JSValue val);
  779|       |int JS_SetPropertyStr(JSContext *ctx, JSValueConst this_obj,
  780|       |                      const char *prop, JSValue val);
  781|       |int JS_HasProperty(JSContext *ctx, JSValueConst this_obj, JSAtom prop);
  782|       |int JS_IsExtensible(JSContext *ctx, JSValueConst obj);
  783|       |int JS_PreventExtensions(JSContext *ctx, JSValueConst obj);
  784|       |int JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags);
  785|       |int JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val);
  786|       |JSValue JS_GetPrototype(JSContext *ctx, JSValueConst val);
  787|       |
  788|  6.41M|#define JS_GPN_STRING_MASK  (1 << 0)
  789|  17.7k|#define JS_GPN_SYMBOL_MASK  (1 << 1)
  790|       |#define JS_GPN_PRIVATE_MASK (1 << 2)
  791|       |/* only include the enumerable properties */
  792|  89.4M|#define JS_GPN_ENUM_ONLY    (1 << 4)
  793|       |/* set theJSPropertyEnum.is_enumerable field */
  794|  1.87M|#define JS_GPN_SET_ENUM     (1 << 5)
  795|       |
  796|       |int JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,
  797|       |                           uint32_t *plen, JSValueConst obj, int flags);
  798|       |int JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,
  799|       |                      JSValueConst obj, JSAtom prop);
  800|       |
  801|       |JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
  802|       |                int argc, JSValueConst *argv);
  803|       |JSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,
  804|       |                  int argc, JSValueConst *argv);
  805|       |JSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,
  806|       |                           int argc, JSValueConst *argv);
  807|       |JSValue JS_CallConstructor2(JSContext *ctx, JSValueConst func_obj,
  808|       |                            JSValueConst new_target,
  809|       |                            int argc, JSValueConst *argv);
  810|       |JS_BOOL JS_DetectModule(const char *input, size_t input_len);
  811|       |/* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
  812|       |JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
  813|       |                const char *filename, int eval_flags);
  814|       |/* same as JS_Eval() but with an explicit 'this_obj' parameter */
  815|       |JSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,
  816|       |                    const char *input, size_t input_len,
  817|       |                    const char *filename, int eval_flags);
  818|       |JSValue JS_GetGlobalObject(JSContext *ctx);
  819|       |int JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj);
  820|       |int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
  821|       |                      JSAtom prop, JSValueConst val,
  822|       |                      JSValueConst getter, JSValueConst setter, int flags);
  823|       |int JS_DefinePropertyValue(JSContext *ctx, JSValueConst this_obj,
  824|       |                           JSAtom prop, JSValue val, int flags);
  825|       |int JS_DefinePropertyValueUint32(JSContext *ctx, JSValueConst this_obj,
  826|       |                                 uint32_t idx, JSValue val, int flags);
  827|       |int JS_DefinePropertyValueStr(JSContext *ctx, JSValueConst this_obj,
  828|       |                              const char *prop, JSValue val, int flags);
  829|       |int JS_DefinePropertyGetSet(JSContext *ctx, JSValueConst this_obj,
  830|       |                            JSAtom prop, JSValue getter, JSValue setter,
  831|       |                            int flags);
  832|       |void JS_SetOpaque(JSValue obj, void *opaque);
  833|       |void *JS_GetOpaque(JSValueConst obj, JSClassID class_id);
  834|       |void *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id);
  835|       |void *JS_GetAnyOpaque(JSValueConst obj, JSClassID *class_id);
  836|       |
  837|       |/* 'buf' must be zero terminated i.e. buf[buf_len] = '\0'. */
  838|       |JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
  839|       |                     const char *filename);
  840|      0|#define JS_PARSE_JSON_EXT (1 << 0) /* allow extended JSON */
  841|       |JSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,
  842|       |                      const char *filename, int flags);
  843|       |JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
  844|       |                         JSValueConst replacer, JSValueConst space0);
  845|       |
  846|       |typedef void JSFreeArrayBufferDataFunc(JSRuntime *rt, void *opaque, void *ptr);
  847|       |JSValue JS_NewArrayBuffer(JSContext *ctx, uint8_t *buf, size_t len,
  848|       |                          JSFreeArrayBufferDataFunc *free_func, void *opaque,
  849|       |                          JS_BOOL is_shared);
  850|       |JSValue JS_NewArrayBufferCopy(JSContext *ctx, const uint8_t *buf, size_t len);
  851|       |void JS_DetachArrayBuffer(JSContext *ctx, JSValueConst obj);
  852|       |uint8_t *JS_GetArrayBuffer(JSContext *ctx, size_t *psize, JSValueConst obj);
  853|       |
  854|       |typedef enum JSTypedArrayEnum {
  855|       |    JS_TYPED_ARRAY_UINT8C = 0,
  856|       |    JS_TYPED_ARRAY_INT8,
  857|       |    JS_TYPED_ARRAY_UINT8,
  858|       |    JS_TYPED_ARRAY_INT16,
  859|       |    JS_TYPED_ARRAY_UINT16,
  860|       |    JS_TYPED_ARRAY_INT32,
  861|       |    JS_TYPED_ARRAY_UINT32,
  862|       |    JS_TYPED_ARRAY_BIG_INT64,
  863|       |    JS_TYPED_ARRAY_BIG_UINT64,
  864|       |    JS_TYPED_ARRAY_FLOAT32,
  865|       |    JS_TYPED_ARRAY_FLOAT64,
  866|       |} JSTypedArrayEnum;
  867|       |
  868|       |JSValue JS_NewTypedArray(JSContext *ctx, int argc, JSValueConst *argv,
  869|       |                         JSTypedArrayEnum array_type);
  870|       |JSValue JS_GetTypedArrayBuffer(JSContext *ctx, JSValueConst obj,
  871|       |                               size_t *pbyte_offset,
  872|       |                               size_t *pbyte_length,
  873|       |                               size_t *pbytes_per_element);
  874|       |typedef struct {
  875|       |    void *(*sab_alloc)(void *opaque, size_t size);
  876|       |    void (*sab_free)(void *opaque, void *ptr);
  877|       |    void (*sab_dup)(void *opaque, void *ptr);
  878|       |    void *sab_opaque;
  879|       |} JSSharedArrayBufferFunctions;
  880|       |void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
  881|       |                                      const JSSharedArrayBufferFunctions *sf);
  882|       |
  883|       |typedef enum JSPromiseStateEnum {
  884|       |    JS_PROMISE_PENDING,
  885|       |    JS_PROMISE_FULFILLED,
  886|       |    JS_PROMISE_REJECTED,
  887|       |} JSPromiseStateEnum;
  888|       |
  889|       |JSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs);
  890|       |JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise);
  891|       |JSValue JS_PromiseResult(JSContext *ctx, JSValue promise);
  892|       |
  893|       |/* is_handled = TRUE means that the rejection is handled */
  894|       |typedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,
  895|       |                                           JSValueConst reason,
  896|       |                                           JS_BOOL is_handled, void *opaque);
  897|       |void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
  898|       |
  899|       |/* return != 0 if the JS code needs to be interrupted */
  900|       |typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
  901|       |void JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque);
  902|       |/* if can_block is TRUE, Atomics.wait() can be used */
  903|       |void JS_SetCanBlock(JSRuntime *rt, JS_BOOL can_block);
  904|       |/* select which debug info is stripped from the compiled code */
  905|   154k|#define JS_STRIP_SOURCE (1 << 0) /* strip source code */
  906|   308k|#define JS_STRIP_DEBUG  (1 << 1) /* strip all debug info including source code */
  907|       |void JS_SetStripInfo(JSRuntime *rt, int flags);
  908|       |int JS_GetStripInfo(JSRuntime *rt);
  909|       |
  910|       |/* set the [IsHTMLDDA] internal slot */
  911|       |void JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj);
  912|       |
  913|       |typedef struct JSModuleDef JSModuleDef;
  914|       |
  915|       |/* return the module specifier (allocated with js_malloc()) or NULL if
  916|       |   exception */
  917|       |typedef char *JSModuleNormalizeFunc(JSContext *ctx,
  918|       |                                    const char *module_base_name,
  919|       |                                    const char *module_name, void *opaque);
  920|       |typedef JSModuleDef *JSModuleLoaderFunc(JSContext *ctx,
  921|       |                                        const char *module_name, void *opaque);
  922|       |
  923|       |/* module_normalize = NULL is allowed and invokes the default module
  924|       |   filename normalizer */
  925|       |void JS_SetModuleLoaderFunc(JSRuntime *rt,
  926|       |                            JSModuleNormalizeFunc *module_normalize,
  927|       |                            JSModuleLoaderFunc *module_loader, void *opaque);
  928|       |/* return the import.meta object of a module */
  929|       |JSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m);
  930|       |JSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m);
  931|       |JSValue JS_GetModuleNamespace(JSContext *ctx, JSModuleDef *m);
  932|       |
  933|       |/* JS Job support */
  934|       |
  935|       |typedef JSValue JSJobFunc(JSContext *ctx, int argc, JSValueConst *argv);
  936|       |int JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func, int argc, JSValueConst *argv);
  937|       |
  938|       |JS_BOOL JS_IsJobPending(JSRuntime *rt);
  939|       |int JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx);
  940|       |
  941|       |/* Object Writer/Reader (currently only used to handle precompiled code) */
  942|      0|#define JS_WRITE_OBJ_BYTECODE  (1 << 0) /* allow function/module */
  943|       |#define JS_WRITE_OBJ_BSWAP     (1 << 1) /* byte swapped output */
  944|      0|#define JS_WRITE_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */
  945|      0|#define JS_WRITE_OBJ_REFERENCE (1 << 3) /* allow object references to
  946|       |                                           encode arbitrary object
  947|       |                                           graph */
  948|       |uint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,
  949|       |                        int flags);
  950|       |uint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,
  951|       |                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len);
  952|       |
  953|      0|#define JS_READ_OBJ_BYTECODE  (1 << 0) /* allow function/module */
  954|      0|#define JS_READ_OBJ_ROM_DATA  (1 << 1) /* avoid duplicating 'buf' data */
  955|      0|#define JS_READ_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */
  956|      0|#define JS_READ_OBJ_REFERENCE (1 << 3) /* allow object references */
  957|       |JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
  958|       |                      int flags);
  959|       |/* instantiate and evaluate a bytecode function. Only used when
  960|       |   reading a script or module with JS_ReadObject() */
  961|       |JSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj);
  962|       |/* load the dependencies of the module 'obj'. Useful when JS_ReadObject()
  963|       |   returns a module. */
  964|       |int JS_ResolveModule(JSContext *ctx, JSValueConst obj);
  965|       |
  966|       |/* only exported for os.Worker() */
  967|       |JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
  968|       |/* only exported for os.Worker() */
  969|       |JSValue JS_LoadModule(JSContext *ctx, const char *basename,
  970|       |                      const char *filename);
  971|       |
  972|       |/* C function definition */
  973|       |typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
  974|       |    JS_CFUNC_generic,
  975|       |    JS_CFUNC_generic_magic,
  976|       |    JS_CFUNC_constructor,
  977|       |    JS_CFUNC_constructor_magic,
  978|       |    JS_CFUNC_constructor_or_func,
  979|       |    JS_CFUNC_constructor_or_func_magic,
  980|       |    JS_CFUNC_f_f,
  981|       |    JS_CFUNC_f_f_f,
  982|       |    JS_CFUNC_getter,
  983|       |    JS_CFUNC_setter,
  984|       |    JS_CFUNC_getter_magic,
  985|       |    JS_CFUNC_setter_magic,
  986|       |    JS_CFUNC_iterator_next,
  987|       |} JSCFunctionEnum;
  988|       |
  989|       |typedef union JSCFunctionType {
  990|       |    JSCFunction *generic;
  991|       |    JSValue (*generic_magic)(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);
  992|       |    JSCFunction *constructor;
  993|       |    JSValue (*constructor_magic)(JSContext *ctx, JSValueConst new_target, int argc, JSValueConst *argv, int magic);
  994|       |    JSCFunction *constructor_or_func;
  995|       |    double (*f_f)(double);
  996|       |    double (*f_f_f)(double, double);
  997|       |    JSValue (*getter)(JSContext *ctx, JSValueConst this_val);
  998|       |    JSValue (*setter)(JSContext *ctx, JSValueConst this_val, JSValueConst val);
  999|       |    JSValue (*getter_magic)(JSContext *ctx, JSValueConst this_val, int magic);
 1000|       |    JSValue (*setter_magic)(JSContext *ctx, JSValueConst this_val, JSValueConst val, int magic);
 1001|       |    JSValue (*iterator_next)(JSContext *ctx, JSValueConst this_val,
 1002|       |                             int argc, JSValueConst *argv, int *pdone, int magic);
 1003|       |} JSCFunctionType;
 1004|       |
 1005|       |JSValue JS_NewCFunction2(JSContext *ctx, JSCFunction *func,
 1006|       |                         const char *name,
 1007|       |                         int length, JSCFunctionEnum cproto, int magic);
 1008|       |JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
 1009|       |                            int length, int magic, int data_len,
 1010|       |                            JSValueConst *data);
 1011|       |
 1012|       |static inline JSValue JS_NewCFunction(JSContext *ctx, JSCFunction *func, const char *name,
 1013|       |                                      int length)
 1014|   124k|{
 1015|   124k|    return JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_generic, 0);
 1016|   124k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewCFunction
  ------------------
  | quickjs.c:JS_NewCFunction:
  | 1014|  53.3k|{
  | 1015|  53.3k|    return JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_generic, 0);
  | 1016|  53.3k|}
  ------------------
  | quickjs-libc.c:JS_NewCFunction:
  | 1014|  71.0k|{
  | 1015|  71.0k|    return JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_generic, 0);
  | 1016|  71.0k|}
  ------------------
 1017|       |
 1018|       |static inline JSValue JS_NewCFunctionMagic(JSContext *ctx, JSCFunctionMagic *func,
 1019|       |                                           const char *name,
 1020|       |                                           int length, JSCFunctionEnum cproto, int magic)
 1021|   124k|{
 1022|   124k|    return JS_NewCFunction2(ctx, (JSCFunction *)func, name, length, cproto, magic);
 1023|   124k|}
  ------------------
  | Unexecuted instantiation: qjs.c:JS_NewCFunctionMagic
  ------------------
  | quickjs.c:JS_NewCFunctionMagic:
  | 1021|   124k|{
  | 1022|   124k|    return JS_NewCFunction2(ctx, (JSCFunction *)func, name, length, cproto, magic);
  | 1023|   124k|}
  ------------------
  | Unexecuted instantiation: quickjs-libc.c:JS_NewCFunctionMagic
  ------------------
 1024|       |void JS_SetConstructor(JSContext *ctx, JSValueConst func_obj,
 1025|       |                       JSValueConst proto);
 1026|       |
 1027|       |/* C property definition */
 1028|       |
 1029|       |typedef struct JSCFunctionListEntry {
 1030|       |    const char *name;
 1031|       |    uint8_t prop_flags;
 1032|       |    uint8_t def_type;
 1033|       |    int16_t magic;
 1034|       |    union {
 1035|       |        struct {
 1036|       |            uint8_t length; /* XXX: should move outside union */
 1037|       |            uint8_t cproto; /* XXX: should move outside union */
 1038|       |            JSCFunctionType cfunc;
 1039|       |        } func;
 1040|       |        struct {
 1041|       |            JSCFunctionType get;
 1042|       |            JSCFunctionType set;
 1043|       |        } getset;
 1044|       |        struct {
 1045|       |            const char *name;
 1046|       |            int base;
 1047|       |        } alias;
 1048|       |        struct {
 1049|       |            const struct JSCFunctionListEntry *tab;
 1050|       |            int len;
 1051|       |        } prop_list;
 1052|       |        const char *str;
 1053|       |        int32_t i32;
 1054|       |        int64_t i64;
 1055|       |        double f64;
 1056|       |    } u;
 1057|       |} JSCFunctionListEntry;
 1058|       |
 1059|  6.11M|#define JS_DEF_CFUNC          0
 1060|   266k|#define JS_DEF_CGETSET        1
 1061|  1.22M|#define JS_DEF_CGETSET_MAGIC  2
 1062|   444k|#define JS_DEF_PROP_STRING    3
 1063|  17.7k|#define JS_DEF_PROP_INT32     4
 1064|      0|#define JS_DEF_PROP_INT64     5
 1065|   177k|#define JS_DEF_PROP_DOUBLE    6
 1066|  17.7k|#define JS_DEF_PROP_UNDEFINED 7
 1067|   515k|#define JS_DEF_OBJECT         8
 1068|   177k|#define JS_DEF_ALIAS          9
 1069|       |
 1070|       |/* Note: c++ does not like nested designators */
 1071|       |#define JS_CFUNC_DEF(name, length, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_generic, { .generic = func1 } } } }
 1072|       |#define JS_CFUNC_MAGIC_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_generic_magic, { .generic_magic = func1 } } } }
 1073|       |#define JS_CFUNC_SPECIAL_DEF(name, length, cproto, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_ ## cproto, { .cproto = func1 } } } }
 1074|       |#define JS_ITERATOR_NEXT_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_iterator_next, { .iterator_next = func1 } } } }
 1075|       |#define JS_CGETSET_DEF(name, fgetter, fsetter) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET, 0, .u = { .getset = { .get = { .getter = fgetter }, .set = { .setter = fsetter } } } }
 1076|       |#define JS_CGETSET_MAGIC_DEF(name, fgetter, fsetter, magic) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET_MAGIC, magic, .u = { .getset = { .get = { .getter_magic = fgetter }, .set = { .setter_magic = fsetter } } } }
 1077|       |#define JS_PROP_STRING_DEF(name, cstr, prop_flags) { name, prop_flags, JS_DEF_PROP_STRING, 0, .u = { .str = cstr } }
 1078|       |#define JS_PROP_INT32_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT32, 0, .u = { .i32 = val } }
 1079|       |#define JS_PROP_INT64_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT64, 0, .u = { .i64 = val } }
 1080|       |#define JS_PROP_DOUBLE_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_DOUBLE, 0, .u = { .f64 = val } }
 1081|       |#define JS_PROP_UNDEFINED_DEF(name, prop_flags) { name, prop_flags, JS_DEF_PROP_UNDEFINED, 0, .u = { .i32 = 0 } }
 1082|       |#define JS_OBJECT_DEF(name, tab, len, prop_flags) { name, prop_flags, JS_DEF_OBJECT, 0, .u = { .prop_list = { tab, len } } }
 1083|       |#define JS_ALIAS_DEF(name, from) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, -1 } } }
 1084|       |#define JS_ALIAS_BASE_DEF(name, from, base) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, base } } }
 1085|       |
 1086|       |void JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,
 1087|       |                                const JSCFunctionListEntry *tab,
 1088|       |                                int len);
 1089|       |
 1090|       |/* C module definition */
 1091|       |
 1092|       |typedef int JSModuleInitFunc(JSContext *ctx, JSModuleDef *m);
 1093|       |
 1094|       |JSModuleDef *JS_NewCModule(JSContext *ctx, const char *name_str,
 1095|       |                           JSModuleInitFunc *func);
 1096|       |/* can only be called before the module is instantiated */
 1097|       |int JS_AddModuleExport(JSContext *ctx, JSModuleDef *m, const char *name_str);
 1098|       |int JS_AddModuleExportList(JSContext *ctx, JSModuleDef *m,
 1099|       |                           const JSCFunctionListEntry *tab, int len);
 1100|       |/* can only be called after the module is instantiated */
 1101|       |int JS_SetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name,
 1102|       |                       JSValue val);
 1103|       |int JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,
 1104|       |                           const JSCFunctionListEntry *tab, int len);
 1105|       |
 1106|       |#undef js_unlikely
 1107|       |#undef js_force_inline
 1108|       |
 1109|       |#ifdef __cplusplus
 1110|       |} /* extern "C" { */
 1111|       |#endif
 1112|       |
 1113|       |#endif /* QUICKJS_H */

